--- Problem 1 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the operations team needs to coordinate the berthing of four different types of ships to minimize the total waiting time. Each type of ship has a unique number of arrivals: Type 1 has 652 arrivals, Type 2 has 1,948 arrivals, Type 3 has 586 arrivals, and Type 4 has 1,056 arrivals. The total berthing cycle time for all types is fixed at 80 hours, ensuring synchronization with other port activities. However, each type’s berthing time must be carefully allocated—no less than 15 hours to allow for safe docking and no more than 80 hours to prevent excessive waiting for other types. The core challenge is to distribute the limited cycle time among the types such that the total waiting time—calculated as the sum of each type’s arrival count multiplied by its non-berthing time (cycle time minus berthing time)—is minimized. The question is: *What is the optimal berthing time allocation for each type to achieve the least total waiting time while adhering to the cycle and boundary constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - \( t_i \): Continuous variable representing the berthing time (in hours) allocated to type \( i \) (\( i = 1, 2, 3, 4 \)).  
     Bounds: \( 15 \leq t_i \leq 80 \).  

   **2. Parameters:**  
   - \( \text{arrival_coeffs} = [652, 1948, 586, 1056] \): Arrival coefficients for each type.  
   - \( \text{cycle_time} = 80 \): Total fixed cycle time (hours).  
   - \( \text{lb_time} = 15 \), \( \text{ub_time} = 80 \): Lower/upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize the total waiting time:  
   \[
   \text{Minimize: } \sum_{i=1}^{4} \text{arrival_coeffs}[i] \times (\text{cycle_time} - t_i).
   \]  

   **4. Constraints:**  
   - **Total cycle time:** The sum of berthing times must equal the cycle time:  
     \[
     \sum_{i=1}^{4} t_i = 80.
     \]  
   - **Variable bounds:** \( 15 \leq t_i \leq 80 \) for all \( i \).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_types = 4
lb_time = 15          # Lower bound for berthing time
ub_time = 80          # Upper bound for berthing time
cycle_time = 80       # Total cycle time (set equal to ub_time)
arrival_coeffs = [652, 1948, 586, 1056] # Arrival coefficients per type
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_coeffs) != num_types:
    print("Error: arrival_coeffs length mismatch with num_types")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_coeffs length"
    # raise ValueError("arrival_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_types}-Type Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_types) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_types, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for type i is proportional to arrival * non-berthing_time = arrival * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_types)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_types)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_types)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_types):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 236770.00
------------------------------
Optimal berthing times (hours):
  t1: 15.00, t2: 35.00, t3: 15.00, t4: 15.00


```

================================================================================



--- Problem 2 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
At a busy port, a team of 11 dockworkers is responsible for unloading incoming containers from both small and large ships. The port has dedicated berths for each ship type: small ship berths require 2 dockworkers each and can handle up to 25 containers per hour, while large ship berths need 1 dockworker and process a maximum of 12 containers hourly. On this particular shift, 159 containers from small ships and 45 containers from large ships are expected to arrive. The challenge is to allocate dockworkers to open the right mix of small and large ship berths to maximize the total number of containers processed, ensuring no berth exceeds its hourly capacity and no more containers are processed than actually arrive. The core question is: *How many small and large ship berths should be opened to clear as many containers as possible within these constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y_small`: Integer, number of small ship berths to open.  
     - `y_large`: Integer, number of large ship berths to open.  
     - `z_small`: Continuous, number of containers from small ships processed (≤ arrivals and capacity).  
     - `z_large`: Continuous, number of containers from large ships processed (≤ arrivals and capacity).  

   - **2. Parameters:**  
     - `total_dockworkers = 11` (available dockworkers).  
     - `dockworkers_per_small_berth = 2`, `dockworkers_per_large_berth = 1` (staffing needs).  
     - `capacity_small_berth = 25`, `capacity_large_berth = 12` (hourly throughput).  
     - `arriving_small_containers = 159`, `arriving_large_containers = 45` (demand).  

   - **3. Objective Function:**  
     Maximize total containers processed:  
     `Maximize: z_small + z_large`.  

   - **4. Constraints:**  
     - Dockworker limit: `2*y_small + 1*y_large ≤ 11`.  
     - Capacity limits:  
       `z_small ≤ 25*y_small`, `z_large ≤ 12*y_large`.  
     - Arrival limits:  
       `z_small ≤ 159`, `z_large ≤ 45`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_dockworkers = 11
dockworkers_per_small_berth = 2
dockworkers_per_large_berth = 1
capacity_small_berth = 25 # containers per hour
capacity_large_berth = 12 # containers per hour
arriving_small_containers = 159
arriving_large_containers = 45
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTH_ALLOC", env=env)

    # --- Decision Variables ---
    # y_small: number of small ship berths to open
    y_small = m.addVar(vtype=GRB.INTEGER, lb=0, name="y_small")
    # y_large: number of large ship berths to open
    y_large = m.addVar(vtype=GRB.INTEGER, lb=0, name="y_large")
    # z_small: number of containers from small ships processed
    z_small = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="z_small")
    # z_large: number of containers from large ships processed
    z_large = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="z_large")

    # --- Objective Function: Maximize total containers processed ---
    m.setObjective(z_small + z_large, GRB.MAXIMIZE)

    # --- Constraints ---
    # Dockworker availability constraint
    # Ensure dockworker counts are positive before adding constraint
    if dockworkers_per_small_berth > 0 and dockworkers_per_large_berth > 0:
        m.addConstr(dockworkers_per_small_berth * y_small + dockworkers_per_large_berth * y_large <= total_dockworkers, "DockworkerLimit")
    elif dockworkers_per_small_berth > 0:
         m.addConstr(dockworkers_per_small_berth * y_small <= total_dockworkers, "DockworkerLimit")
    elif dockworkers_per_large_berth > 0:
         m.addConstr(dockworkers_per_large_berth * y_large <= total_dockworkers, "DockworkerLimit")

    # Processed containers cannot exceed capacity
    m.addConstr(z_small <= capacity_small_berth * y_small, "SmallCapacity")
    m.addConstr(z_large <= capacity_large_berth * y_large, "LargeCapacity")

    # Processed containers cannot exceed arrivals
    m.addConstr(z_small <= arriving_small_containers, "SmallArrivals")
    m.addConstr(z_large <= arriving_large_containers, "LargeArrivals")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['y_small_sol'] = y_small.X # Not needed for output
        # results_dict['y_large_sol'] = y_large.X # Not needed for output
        # results_dict['z_small_sol'] = z_small.X # Not needed for output
        # results_dict['z_large_sol'] = z_large.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Objective is total containers, potentially float if z variables are float
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# --- Supplemental Code Block ---
if m.Status == GRB.OPTIMAL:
    print(f"Number of small ship berths to open: {y_small.X}")
    print(f"Number of large ship berths to open: {y_large.X}")
    print(f"Containers processed from small ships: {z_small.X}")
    print(f"Containers processed from large ships: {z_large.X}")
```
Answer:
Optimal objective value: 137.00
Number of small ship berths to open: 5.0
Number of large ship berths to open: 1.0
Containers processed from small ships: 125.0
Containers processed from large ships: 12.0


```

================================================================================



--- Problem 3 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
A port operator is tasked with scheduling workers across three distinct shifts to meet fluctuating demand while minimizing labor costs. The shifts begin at 6 AM, 2 PM, and 10 PM, each requiring a minimum number of workers to ensure smooth operations: 7 workers for the morning shift, 5 for the afternoon, and 9 for the overnight shift. Each worker assigned to a shift incurs a fixed cost of $254 per day. The challenge is to determine the exact number of workers to start at each shift time, ensuring all coverage requirements are met without exceeding necessary expenditures. The core question is: *What is the most cost-effective way to staff these shifts while fully meeting operational demands?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( x_s \) represent the number of workers assigned to shift \( s \), where \( s \in \{1, 2, 3\} \) (corresponding to 6 AM, 2 PM, and 10 PM shifts). Each \( x_s \) is a non-negative integer.  
   - **2. Parameters:**  
     - \( \text{requirements} = \{1: 7, 2: 5, 3: 9\} \): Minimum workers needed per shift.  
     - \( \text{cost_per_worker_shift} = 254 \): Fixed cost per worker per shift.  
   - **3. Objective Function:**  
     - Minimize the total daily staffing cost:  
       \[ \text{Minimize: } 254x_1 + 254x_2 + 254x_3. \]  
   - **4. Constraints:**  
     - Coverage constraints (minimum workers per shift):  
       \[ x_1 \geq 7, \quad x_2 \geq 5, \quad x_3 \geq 9. \]  
     - Non-negativity and integrality: \( x_s \geq 0 \) and integer for all \( s \).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
requirements = {1: 7, 2: 5, 3: 9}
shift_starts = {1: '6am', 2: '2pm', 3: '10pm'} # Using the generated structure
cost_per_worker_shift = 254
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m31 = gp.Model("PORT_SCHEDULING_IP", env=env)

    # --- Decision Variables ---
    # Integer: Number of workers starting each shift
    x = m31.addVars(shift_starts.keys(), vtype=GRB.INTEGER, name="workers_start_shift", lb=0)

    # --- Objective Function ---
    # Minimize total daily staffing cost
    m31.setObjective(gp.quicksum(x[s] * cost_per_worker_shift for s in shift_starts.keys()), sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Coverage constraints for each requirement period (assuming 1-to-1 mapping)
    for shift_id, req in requirements.items():
         if shift_id in x: # Check if variable exists for this shift
             m31.addConstr(x[shift_id] >= req, name=f"cover_shift{shift_id}")

    # --- Optimization ---
    m31.optimize()

    # --- Store results ---
    results_dict['status'] = m31.status
    if m31.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m31.ObjVal
        # results_dict['x_sol'] = m31.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m31.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Ensure obj_val_print is a number before formatting
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}") # Original example didn't show decimals, but objval can be float
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m31.status == GRB.INFEASIBLE:
        print("No optimal solution found.") # Matches example's else case
    elif m31.status == GRB.TIME_LIMIT:
        print("No optimal solution found.") # Matches example's else case
    else:
        print("No optimal solution found.") # Matches example's else case


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the number of workers for each shift
if m31.status == GRB.OPTIMAL:
    for shift_id in shift_starts.keys():
        print(f"Number of workers for {shift_starts[shift_id]} shift: {x[shift_id].X}")
```
Answer:
Optimal objective value: 5334.00
Number of workers for 6am shift: 7.0
Number of workers for 2pm shift: 5.0
Number of workers for 10pm shift: 9.0


```

================================================================================



--- Problem 4 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
In a busy port, a critical logistics challenge arises at a major container terminal where ships arrive and depart. During peak hours, a steady stream of 1,668 containers per hour needs to be unloaded from the main dock (node A) and transported to the storage area (node B). The available paths include a direct link from A to B (segment AB) and an alternative route via the secondary dock (node C) (segments AC and CB). However, each segment has strict capacity limits: AB can handle 1,140 containers/hour, AC accommodates 1,403, and CB is capped at 975. The primary goal is to distribute the container flow efficiently to avoid congestion, particularly on the direct AB link, which is prone to bottlenecks. The optimization task is to determine the ideal flow allocation across these routes while minimizing any overflow—excess containers beyond capacity—on AB, ensuring smooth operations and adherence to infrastructure limits.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `f_AB`: Flow of containers from A to B (containers/hr).  
     - `f_AC`: Flow of containers from A to C (containers/hr).  
     - `f_CB`: Flow of containers from C to B (containers/hr).  
     - `overflow_AB`: Excess containers beyond AB’s capacity (containers/hr).  

   - **2. Parameters:**  
     - `total_flow_originating_A = 1668` (containers/hr).  
     - Segment capacities: `AB = 1140`, `AC = 1403`, `CB = 975` (containers/hr).  

   - **3. Objective Function:**  
     Minimize the overflow on AB:  
     \[ \text{Minimize: } \text{overflow\_AB} \]  

   - **4. Constraints:**  
     - **Flow conservation at A:** The total flow out of A must equal the originating demand:  
       \[ f_{AB} + f_{AC} = 1668 \]  
     - **Flow balance at C:** All containers entering C must exit toward B:  
       \[ f_{AC} = f_{CB} \]  
     - **AB capacity with overflow:** The flow on AB cannot exceed its capacity plus overflow:  
       \[ f_{AB} \leq 1140 + \text{overflow\_AB} \]  
     - **AC and CB capacity limits:**  
       \[ f_{AC} \leq 1403, \quad f_{CB} \leq 975 \]  
     - **Non-negativity:** All flows and overflow must be ≥ 0.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_flow_originating_A = 1668 # containers/hr
capacity = {'AB': 1140, 'AC': 1403, 'CB': 975} # Dict segment: capacity (containers/hr)
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m33 = gp.Model("CONTAINER_FLOW_LP", env=env)

    # --- Decision Variables ---
    # Flows on each segment
    f_AB = m33.addVar(name="flow_A_B", lb=0)
    f_AC = m33.addVar(name="flow_A_C", lb=0)
    f_CB = m33.addVar(name="flow_C_B", lb=0)
    # Overflow variable for the congested link AB
    overflow_AB = m33.addVar(name="overflow_A_B", lb=0)

    # --- Objective Function ---
    # Minimize the overflow on segment A->B
    m33.setObjective(overflow_AB, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Total flow conservation leaving node A
    m33.addConstr(f_AB + f_AC == total_flow_originating_A, name="flow_out_A")

    # Constraint 2: Flow conservation at node C
    m33.addConstr(f_AC == f_CB, name="flow_at_C")

    # Constraint 3: Calculate overflow for A->B link
    # overflow = max(0, f_AB - capacity_AB)
    cap_ab = capacity.get('AB', 0) # Get capacity safely
    m33.addConstr(f_AB <= cap_ab + overflow_AB, name="overflow_calc")

    # Constraint 4: Capacity constraint for A->C link
    cap_ac = capacity.get('AC', 0)
    m33.addConstr(f_AC <= cap_ac, name="capacity_AC")

    # Constraint 5: Capacity constraint for C->B link
    cap_cb = capacity.get('CB', 0)
    m33.addConstr(f_CB <= cap_cb, name="capacity_CB")

    # --- Optimization ---
    m33.optimize()

    # --- Store results ---
    results_dict['status'] = m33.status
    if m33.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m33.ObjVal # = overflow_AB.X
        results_dict['f_AB_sol'] = f_AB.X
        results_dict['f_AC_sol'] = f_AC.X
        results_dict['f_CB_sol'] = f_CB.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 33: Container Flow Rerouting (LP) ---") # Original problem number
    if m33.status == GRB.OPTIMAL:
        overflow_sol = results_dict.get('obj_val', 'N/A')
        f_ab_sol = results_dict.get('f_AB_sol', 'N/A')
        f_ac_sol = results_dict.get('f_AC_sol', 'N/A')
        f_cb_sol = results_dict.get('f_CB_sol', 'N/A')
        cap_ab_print = capacity.get('AB', 'N/A')
        cap_ac_print = capacity.get('AC', 'N/A')
        cap_cb_print = capacity.get('CB', 'N/A')

        print(f"Optimization Status: Optimal")
        # Format numerical output
        print(f"Minimum Overflow on A->B: {float(overflow_sol):.1f} containers/hr")
        print("Optimal Flow Distribution:")
        print(f"  Flow A -> B: {float(f_ab_sol):.1f} (Capacity: {cap_ab_print})")
        print(f"  Flow A -> C: {float(f_ac_sol):.1f} (Capacity: {cap_ac_print})")
        print(f"  Flow C -> B: {float(f_cb_sol):.1f} (Capacity: {cap_cb_print})")
        # Check total flow matches original
        total_flow_out = float(f_ab_sol) + float(f_ac_sol) if isinstance(f_ab_sol, (int, float)) and isinstance(f_ac_sol, (int, float)) else 'N/A'
        print(f"Total Flow from A: {total_flow_out:.1f} (Initial: {total_flow_originating_A})")

    elif m33.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible. Check capacities vs total flow.")
         print(f"Total Flow: {total_flow_originating_A}, Capacity AC+CB path: {capacity.get('AC', 0) + capacity.get('CB', 0)}?") # Simple check example
    else:
        print(f"Optimization Status: {m33.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 33: Container Flow Rerouting (LP) ---
Optimization Status: Optimal
Minimum Overflow on A->B: 0.0 containers/hr
Optimal Flow Distribution:
  Flow A -> B: 693.0 (Capacity: 1140)
  Flow A -> C: 975.0 (Capacity: 1403)
  Flow C -> B: 975.0 (Capacity: 975)
Total Flow from A: 1668.0 (Initial: 1668)


```

================================================================================



--- Problem 5 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy logistics hub, nine delivery trucks arrive at staggered times, each requiring a depot for unloading and processing. The hub has four depots available, and the challenge is to assign each truck to a depot while minimizing the total waiting time—the time each truck spends idle before its processing begins. The trucks arrive at specific hours (Truck 1 at hour 3, Truck 2 at hour 7, etc.), and each has a distinct processing duration (Truck 1 takes 5 hours, Truck 2 takes 8 hours, etc.). The hub authority must ensure that no two trucks assigned to the same depot overlap in their processing windows. The core question is: *How can the trucks be scheduled across the depots to minimize the cumulative waiting time while respecting arrival times and processing constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary variable indicating whether Truck *i* is assigned to Depot *j*.  
     - `start_time(i)`: Continuous variable representing the time Truck *i* begins processing.  
     - `completion_time(i)`: Continuous variable representing the time Truck *i* finishes processing.  
     - `precedes(i, k, j)`: Binary variable indicating whether Truck *i* is processed before Truck *k* at Depot *j*.  

   - **2. Parameters:**  
     - `trucks = [1, 2, ..., 9]`: List of trucks.  
     - `depots = [1, 2, 3, 4]`: List of depots.  
     - `arrival_times[i]`: Time Truck *i* arrives (e.g., Truck 1 arrives at hour 3).  
     - `processing_times[i]`: Duration Truck *i* occupies a depot (e.g., Truck 1 takes 5 hours).  
     - `H = 200`: A large constant ("Big M") for logical constraints.  

   - **3. Objective Function:**  
     Minimize the total waiting time:  
     \[
     \text{Minimize: } \sum_{i \in \text{trucks}} (\text{start_time}(i) - \text{arrival_times}[i]).
     \]  

   - **4. Constraints:**  
     - **Assignment:** Each truck is assigned to exactly one depot:  
       \[
       \sum_{j \in \text{depots}} \text{assign}(i, j) = 1 \quad \forall i \in \text{trucks}.
       \]  
     - **Arrival Time:** Processing cannot start before arrival:  
       \[
       \text{start_time}(i) \geq \text{arrival_times}[i] \quad \forall i \in \text{trucks}.
       \]  
     - **Completion Time:** Processing duration is fixed:  
       \[
       \text{completion_time}(i) = \text{start_time}(i) + \text{processing_times}[i] \quad \forall i \in \text{trucks}.
       \]  
     - **Non-Overlapping:** For each depot, if two trucks *i* and *k* are assigned, one must precede the other:  
       \[
       \text{If } \text{precedes}(i, k, j) = 1, \text{ then } \text{start_time}(k) \geq \text{completion_time}(i).
       \]  
       \[
       \text{If } \text{precedes}(i, k, j) = 0, \text{ then } \text{start_time}(i) \geq \text{completion_time}(k).
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7, 8, 9]
depots = [1, 2, 3, 4]
arrival_times = {1: 3, 2: 7, 3: 11, 4: 13, 5: 16, 6: 18, 7: 19, 8: 20, 9: 24}
processing_times = {1: 5, 2: 8, 3: 8, 4: 10, 5: 6, 6: 6, 7: 8, 8: 8, 9: 9}
H = 200 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_17_LARGE_WAIT")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")
        # Print best objective if available on timeout etc.
        if m.SolCount > 0 and abs(m.ObjVal) < GRB.INFINITY :
             print(f"{m.ObjVal:.4f}")
        elif m.status != GRB.INFEASIBLE and m.status != GRB.UNBOUNDED:
             print("No feasible solution found.")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the assignment of trucks to depots and their start and completion times
if m.status == GRB.OPTIMAL:
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}, Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
139.0000
Truck 1 is assigned to Depot 1, Start Time: 3.0000, Completion Time: 8.0000
Truck 2 is assigned to Depot 1, Start Time: 8.0000, Completion Time: 16.0000
Truck 3 is assigned to Depot 1, Start Time: 36.0000, Completion Time: 44.0000
Truck 4 is assigned to Depot 1, Start Time: 61.0000, Completion Time: 71.0000
Truck 5 is assigned to Depot 1, Start Time: 16.0000, Completion Time: 22.0000
Truck 6 is assigned to Depot 1, Start Time: 22.0000, Completion Time: 28.0000
Truck 7 is assigned to Depot 1, Start Time: 44.0000, Completion Time: 52.0000
Truck 8 is assigned to Depot 1, Start Time: 28.0000, Completion Time: 36.0000
Truck 9 is assigned to Depot 1, Start Time: 52.0000, Completion Time: 61.0000


```

================================================================================



--- Problem 6 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy port, five distinct berths—Berth_A to Berth_E—face fluctuating ship arrivals and berth availability. Berth_A has 146 available slots but requires 164 to meet demand, while Berth_B has 71 slots against a demand of 59. Similarly, Berth_C (164 supply, 141 demand), Berth_D (109 supply, 111 demand), and Berth_E (54 supply, 43 demand) exhibit imbalances. Moving ships between berths incurs costs: for instance, relocating a ship from Berth_C to Berth_A costs $5, whereas Berth_E to Berth_D costs $3. The challenge is to strategically redistribute ships—either by retaining them in their original berths or transferring them—to satisfy all berth demands while minimizing the total relocation cost. The core question: *What is the most cost-effective ship allocation plan that ensures no berth faces a shortage?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `stay[b]`: Continuous, non-negative number of ships remaining in berth `b` (for each berth in `berths`).  
     - `move[(i, j)]`: Continuous, non-negative number of ships moved from berth `i` to berth `j` (for each valid `(i, j)` pair in `move_costs`).  
   - **2. Parameters:**  
     - `supply[b]`: Initial ship count in berth `b` (e.g., `supply['Berth_A'] = 146`).  
     - `demand[b]`: Required ships in berth `b` (e.g., `demand['Berth_A'] = 164`).  
     - `move_costs[(i, j)]`: Cost per ship moved from `i` to `j` (e.g., `move_costs[('Berth_C', 'Berth_A')] = 5`).  
   - **3. Objective Function:**  
     Minimize total relocation cost:  
     `Minimize: sum(move[(i, j)] * move_costs[(i, j)] for all (i, j) in move_costs)`.  
   - **4. Constraints:**  
     - **Supply balance:** For each berth `b`, ships staying or leaving must equal supply:  
       `stay[b] + sum(move[(b, j)] for all j ≠ b) = supply[b]`.  
     - **Demand satisfaction:** For each berth `b`, ships staying or arriving must meet demand:  
       `stay[b] + sum(move[(i, b)] for all i ≠ b) >= demand[b]`.  
     - **Non-negativity:** `stay[b] >= 0`, `move[(i, j)] >= 0`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
berths = ['Berth_A', 'Berth_B', 'Berth_C', 'Berth_D', 'Berth_E']
supply = {'Berth_A': 146, 'Berth_B': 71, 'Berth_C': 164, 'Berth_D': 109, 'Berth_E': 54}
demand = {'Berth_A': 164, 'Berth_B': 59, 'Berth_C': 141, 'Berth_D': 111, 'Berth_E': 43}
move_costs = {('Berth_A', 'Berth_B'): 8, ('Berth_A', 'Berth_C'): 7, ('Berth_A', 'Berth_D'): 10, ('Berth_A', 'Berth_E'): 12, ('Berth_B', 'Berth_A'): 13, ('Berth_B', 'Berth_C'): 8, ('Berth_B', 'Berth_D'): 5, ('Berth_B', 'Berth_E'): 15, ('Berth_C', 'Berth_A'): 5, ('Berth_C', 'Berth_B'): 15, ('Berth_C', 'Berth_D'): 11, ('Berth_C', 'Berth_E'): 14, ('Berth_D', 'Berth_A'): 6, ('Berth_D', 'Berth_B'): 6, ('Berth_D', 'Berth_C'): 15, ('Berth_D', 'Berth_E'): 5, ('Berth_E', 'Berth_A'): 5, ('Berth_E', 'Berth_B'): 13, ('Berth_E', 'Berth_C'): 3, ('Berth_E', 'Berth_D'): 3} # Dict (from, to): cost
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m29 = gp.Model("SHIP_ALLOCATION_LP", env=env)

    # --- Decision Variables ---
    # Number of ships moving between berths (use actual keys from move_costs)
    move_keys = list(move_costs.keys())
    move = m29.addVars(move_keys, name="move", lb=0)
    # Number of ships staying in their berths
    stay = m29.addVars(berths, name="stay", lb=0)

    # --- Objective Function ---
    # Minimize total cost of moving ships
    m29.setObjective(gp.quicksum(move[i, j] * move_costs[i, j] for i, j in move_keys), sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Ship source constraints (Ships in berth must either stay or move out)
    for b in berths:
        # Sum outgoing moves using .get() for safety, although all keys should exist
        outgoing_moves = gp.quicksum(move.get((b, other_b), 0) for other_b in berths if b != other_b and (b, other_b) in move)
        m29.addConstr(stay[b] + outgoing_moves == supply[b], name=f"supply_{b}")

    # Demand satisfaction constraints (Ships available in berth = stayed + moved in)
    for b in berths:
        # Sum incoming moves using .get()
        incoming_moves = gp.quicksum(move.get((other_b, b), 0) for other_b in berths if b != other_b and (other_b, b) in move)
        m29.addConstr(stay[b] + incoming_moves >= demand[b], name=f"demand_{b}")

    # --- Optimization ---
    m29.optimize()

    # --- Store results ---
    results_dict['status'] = m29.status
    if m29.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m29.ObjVal
        results_dict['stay_sol'] = m29.getAttr('X', stay)
        results_dict['move_sol'] = m29.getAttr('X', move)


    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- SHIP_ALLOCATION: Port Berth Allocation (LP) ---")
    if m29.status == GRB.OPTIMAL:
        stay_sol = results_dict.get('stay_sol', {})
        move_sol = results_dict.get('move_sol', {})
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Minimum Ship Moving Cost: ${obj_val_print:.2f}")
        print("Ship Allocation:")
        for b in berths:
             print(f"  Stay in {b}: {stay_sol.get(b, 0):.1f}")

        total_moved = 0
        for (i, j), cost in move_costs.items():
            moved_val = move_sol.get((i,j), 0)
            if moved_val > 1e-4: # Print only if non-negligible move
                 print(f"  Move {i} -> {j}: {moved_val:.1f} (Cost/ship: ${cost})")
                 total_moved += moved_val
        print(f"  Total Ships Moved: {total_moved:.1f}")


        print("\nBerth Fulfillment:")
        total_supply_check = sum(supply.values())
        total_demand_check = sum(demand.values())
        total_final_ships = 0
        for b in berths:
            stayed = stay_sol.get(b, 0)
            moved_in = sum(move_sol.get((other_b, b), 0) for other_b in berths if b != other_b)
            final_ships = stayed + moved_in
            total_final_ships += final_ships
            print(f"  Berth {b}: Has {final_ships:.1f} ships (Need: {demand.get(b, 'N/A')}, Supply: {supply.get(b, 'N/A')})")
        print(f"Total Ships Accounted For: {total_final_ships:.1f} (Initial Total Supply: {total_supply_check})")


    elif m29.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible.")
         # Calculate totals directly from input params for this message
         print(f"Total Supply Available: {sum(supply.values())}")
         print(f"Total Demand Required: {sum(demand.values())}")
         print("(Check if total supply >= total demand and if movement allows meeting local demand)")
    elif m29.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m29.ObjVal is not None and abs(m29.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m29.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m29.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- SHIP_ALLOCATION: Port Berth Allocation (LP) ---
Optimization Status: Optimal
Minimum Ship Moving Cost: $96.00
Ship Allocation:
  Stay in Berth_A: 146.0
  Stay in Berth_B: 71.0
  Stay in Berth_C: 146.0
  Stay in Berth_D: 109.0
  Stay in Berth_E: 52.0
  Move Berth_C -> Berth_A: 18.0 (Cost/ship: $5)
  Move Berth_E -> Berth_D: 2.0 (Cost/ship: $3)
  Total Ships Moved: 20.0

Berth Fulfillment:
  Berth Berth_A: Has 164.0 ships (Need: 164, Supply: 146)
  Berth Berth_B: Has 71.0 ships (Need: 59, Supply: 71)
  Berth Berth_C: Has 146.0 ships (Need: 141, Supply: 164)
  Berth Berth_D: Has 111.0 ships (Need: 111, Supply: 109)
  Berth Berth_E: Has 52.0 ships (Need: 43, Supply: 54)
Total Ships Accounted For: 544.0 (Initial Total Supply: 544)


```

================================================================================



--- Problem 7 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
A maritime port with six berths is experiencing recurring incidents that reduce the capacity of main berthing slots, causing significant delays for ships. Port management must dynamically divert ships to alternative berthing slots during these incidents to minimize total delay while adhering to operational constraints. Each berth has distinct characteristics: normal and reduced main slot capacities (e.g., Berth 1: 4987 TEU/h normal, 3394 TEU/h reduced), alternative slot capacities (e.g., 1683 TEU/h for Berth 1), and arrival rates that fluctuate across 10 time periods (each 0.5 hours long). Diversion ratios are limited to discrete options (10%, 30%, 50%, 70%), and transitions between consecutive periods cannot exceed a 20% change to ensure smooth traffic flow. The system-wide diversion ratio must stay between 30% and 70% to balance load. The challenge is to assign optimal diversion ratios for each berth and time period, minimizing total delay—comprising queue delays on the main slot (if flow exceeds reduced capacity) and extra handling time on alternative slots—while respecting all feasibility and smoothness constraints.

**Modeling Process:**
- **1. Decision Variables:**  
     - Binary variable \( y(i,t,k) \): 1 if berth \( i \) at time \( t \) uses diversion option \( k \) (where \( k \in \{0,1,2,3\} \) for 10%, 30%, 50%, 70%), else 0.  
     - Continuous variable \( \text{total\_diversion} \): Average diversion ratio across all berths and periods.  

   - **2. Parameters:**  
     - \( \text{arrival\_rates}[i][t] \): Ships arriving at berth \( i \) in period \( t \) (e.g., 3884 TEU/h for Berth 1, Period 1).  
     - \( \text{capacities\_main\_normal}[i] \), \( \text{capacities\_main\_reduced}[i] \), \( \text{capacities\_alt}[i] \): Slot capacities.  
     - \( \text{alt\_slot\_extra\_times}[i] \): Additional time (hours) for alternative slots (e.g., 0.258h for Berth 1).  
     - \( \text{MAX\_DIVERSION\_CHANGE} = 0.2 \), \( \text{MIN\_TOTAL\_DIVERSION} = 0.3 \), \( \text{MAX\_TOTAL\_DIVERSION} = 0.7 \).  

   - **3. Objective Function:**  
     Minimize total delay:  
     \[
     \text{Minimize: } \sum_{i,t,k} y(i,t,k) \cdot \text{berth\_period\_option\_delays}[i][t][k].
     \]  

   - **4. Constraints:**  
     - **Feasibility:** Only feasible diversion options (where alternative slot flow ≤ capacity) are allowed.  
     - **Single Option Selection:** \( \sum_k y(i,t,k) = 1 \) for each berth \( i \) and period \( t \).  
     - **Smooth Transitions:** \( y(i,t-1,k_1) + y(i,t,k_2) \leq 1 \) if \( |\text{diversion\_options}[k_1] - \text{diversion\_options}[k_2]| > 0.2 \).  
     - **Total Diversion Bounds:** \( 0.3 \leq \text{total\_diversion} \leq 0.7 \).  

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 6
NUM_TIME_PERIODS = 10
TIME_PERIOD_LENGTH = 0.5  # h
MAX_DIVERSION_CHANGE = 0.2  # Maximum allowed change in diversion ratio
MIN_TOTAL_DIVERSION = 0.3  # Minimum total diversion ratio
MAX_TOTAL_DIVERSION = 0.7  # Maximum total diversion ratio
capacities_main_normal = [4987, 3174, 5990, 3614, 5766, 5246]  # TEU/h
capacities_main_reduced = [3394, 1457, 3081, 1131, 3568, 2467]  # TEU/h
capacities_alt = [1683, 1218, 1848, 1766, 1264, 1858]  # TEU/h
arrival_rates = [[3884, 2949, 4882, 4506, 2306, 3532, 4167, 2833, 2262, 4165], [2206, 3067, 4260, 4780, 4898, 4759, 2074, 2134, 2831, 4674], [4300, 2005, 2478, 2965, 4122, 4962, 3391, 4927, 3797, 3454], [2028, 4400, 4019, 3397, 3732, 3803, 4469, 3764, 3094, 3581], [2750, 3135, 4845, 4770, 2028, 4657, 2451, 4129, 4074, 4831], [3623, 2659, 2436, 3448, 4173, 3156, 4139, 4815, 4047, 4923]]  # TEU/h
incident_durations = [0.8326703440614345, 1.4617873677944153, 0.6030606933813922, 1.339037026599832, 0.5013731935781438, 1.8207976150236094]  # h
alt_slot_extra_times = [0.2583519028183169, 0.3303223276701727, 0.20758553674517016, 0.23554839828535662, 0.2286519556131429, 0.22955118259588708]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Slot Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Slot Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_slot_extra_times[i]

            # 3. Calculate Main Slot Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")
total_diversion = m.addVar(name="TotalDiversion")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

        # Add smooth transition constraints between periods
        if t > 0:
            for k1 in range(num_options):
                for k2 in range(num_options):
                    if abs(diversion_options[k1] - diversion_options[k2]) > MAX_DIVERSION_CHANGE:
                        m.addConstr(y[i,t-1,k1] + y[i,t,k2] <= 1,
                                  name="SmoothTransition_Berth{0}_Period{1}_Options{2}{3}".format(i,t,k1,k2))

# Calculate total diversion ratio
m.addConstr(total_diversion == gp.quicksum(
    y[i,t,k] * diversion_options[k]
    for i in range(NUM_BERTHS)
    for t in range(NUM_TIME_PERIODS)
    for k in range(num_options)
    if berth_period_option_feasible[i][t][k]
) / (NUM_BERTHS * NUM_TIME_PERIODS),
name="TotalDiversionRatio")

# Add total diversion ratio constraints
m.addConstr(total_diversion >= MIN_TOTAL_DIVERSION, name="MinTotalDiversion")
m.addConstr(total_diversion <= MAX_TOTAL_DIVERSION, name="MaxTotalDiversion")

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    print(f"Total Diversion Ratio: {0:.1f}%".format(total_diversion.X * 100))
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:
Total Diversion Ratio: 0.0%

Berth 1:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 1 (30%)

Berth 2:
  Period 1 (0.0-0.5h): Option 2 (50%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 2 (50%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 0 (10%)

Berth 3:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 2 (50%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 1 (30%)

Berth 4:
  Period 1 (0.0-0.5h): Option 2 (50%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 2 (50%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 2 (50%)
  Period 10 (4.5-5.0h): Option 1 (30%)

Berth 5:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 0 (10%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 0 (10%)

Berth 6:
  Period 1 (0.0-0.5h): Option 2 (50%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 2 (50%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 2 (50%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 1 (30%)



================================================================================



--- Problem 8 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
**
A port operator faces the challenge of dynamically pricing berthing fees during different traffic periods to maximize revenue while respecting the port's capacity limits. The port experiences two distinct periods: "off-peak" with a base demand of 966 ships per hour and "peak" with a significantly higher base demand of 2893 ships per hour. The operator can adjust berthing fees up to a maximum of $6 per ship, with demand sensitivity (alpha) set at 38 ships per hour for every dollar increase in berthing fee. The port's capacity is fixed at 1638 ships per hour, meaning the number of ships that can be berthed cannot exceed this limit regardless of demand.  

The core question is: What berthing fees should be set during off-peak and peak periods to maximize total revenue, ensuring that the resulting number of ships does not exceed capacity and that demand responds linearly to price changes? The operator must balance higher berthing fees (which reduce demand but increase revenue per ship) against lower berthing fees (which attract more ships but may not fully utilize capacity).
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `fee[p]`: Berthing fee (in $) for period `p` (where `p` is either "off" or "peak"). Bounded between 0 and `max_fee` ($6).  
- `demand[p]`: Resulting demand (ships/hr) for period `p`, calculated as `base_demand[p] - alpha * fee[p]`.  
- `flow[p]`: Actual number of ships (ships/hr) for period `p`, constrained by both demand and capacity.  

**2. Parameters:**  
- `capacity = 1638`: Maximum flow capacity (ships/hr).  
- `base_demand = {'off': 966, 'peak': 2893}`: Base demand (ships/hr) when berthing fees are $0.  
- `alpha = 38`: Demand sensitivity (ships/hr per $1 fee increase).  
- `max_fee = 6`: Upper bound on berthing fee ($).  

**3. Objective Function:**  
Maximize total revenue:  
`Maximize: sum(flow[p] * fee[p] for p in periods)`  

**4. Constraints:**  
- Demand calculation for each period `p`:  
  `demand[p] == base_demand[p] - alpha * fee[p]`  
- Flow cannot exceed capacity:  
  `flow[p] <= capacity`  
- Flow cannot exceed demand:  
  `flow[p] <= demand[p]`  
- Non-negativity:  
  `fee[p], demand[p], flow[p] >= 0`  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 1638; base_demand = {'off': 966, 'peak': 2893}; alpha = 38; max_fee = 6; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berthing_Fee_Pricing_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berthing Fee Pricing (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of DYNAMIC_BERTHING_FEE_PRICING
```
Answer:
--- Problem 18: Dynamic Berthing Fee Pricing (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $14256.00
  Period: Off
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 738.0 ships/hr (Base: 966)
    Actual Flow (min(Demand, Capacity)): 738.0 ships/hr (Capacity: 1638)
    Revenue this period: $4428.00
  Period: Peak
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 2665.0 ships/hr (Base: 2893)
    Actual Flow (min(Demand, Capacity)): 1638.0 ships/hr (Capacity: 1638)
    Revenue this period: $9828.00
Total ships processed: 2376.0



================================================================================


--- Problem 9 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
At a busy port, the operations manager needs to decide on the most efficient method for handling container ships. The decision is between implementing a *dedicated berth* (where each ship has a fixed time slot and a specific berth, free from conflicts) or a *flexible berth* (where ships can dock at any available berth, but this often causes delays). The dedicated berth incurs a fixed cost of $68 per hour for infrastructure and operational adjustments. In contrast, the flexible berth avoids this cost but introduces an estimated penalty of $147 per hour due to accumulated delays for ships, reflecting lost time, fuel, and operational inefficiency. The challenge is clear: **Which berth management method minimizes the total cost while balancing efficiency and operational smoothness?**
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y_dedicated`: Binary variable where `y_dedicated = 1` if the dedicated berth is selected, and `0` if the flexible berth is chosen.  
   - **2. Parameters:**  
     - `cost_dedicated_berth = 68` ($/hr): Fixed cost of operating the dedicated berth.  
     - `cost_flexible_delay = 147` ($/hr): Penalty cost associated with delays under the flexible berth.  
   - **3. Objective Function:**  
     Minimize the total cost:  
     \[
     \text{Total Cost} = y\_dedicated \times 68 + (1 - y\_dedicated) \times 147
     \]  
   - **4. Constraints:**  
     None (the model is an unconstrained binary optimization).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cost_dedicated_berth = 68 # Proxy cost/hr
cost_flexible_delay = 147 # Proxy penalty/hr
# --- End Parameters ---

GUROBI_TIME_LIMIT = 5

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m36 = gp.Model("SHIP_BERTH_DECISION_IP", env=env)

    # --- Decision Variables ---
    # Binary: y_dedicated = 1 if dedicated berth is chosen, 0 otherwise
    y_dedicated = m36.addVar(vtype=GRB.BINARY, name="use_dedicated_berth")

    # --- Objective Function ---
    # Minimize total cost = cost of chosen berth
    m36.setObjective(y_dedicated * cost_dedicated_berth + (1 - y_dedicated) * cost_flexible_delay, sense=GRB.MINIMIZE)

    # --- Constraints: None ---

    # --- Optimization ---
    m36.optimize()

    # --- Store results ---
    results_dict['status'] = m36.status
    if m36.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m36.ObjVal
        results_dict['y_dedicated_sol'] = y_dedicated.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 36: Port Ship Berth Decision (IP) ---") # Original problem number
    if m36.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        use_dedicated = results_dict.get('y_dedicated_sol', 0) > 0.5

        print(f"Optimization Status: Optimal")
        print(f"Optimal Decision: {'Use Dedicated Berth' if use_dedicated else 'Use Flexible Berth'}")
        print(f"  Cost of Dedicated Berth: ${float(cost_dedicated_berth):.2f}")
        print(f"  Estimated Cost of Flexible Berth (due to delay): ${float(cost_flexible_delay):.2f}")
        print(f"Minimum Estimated Cost: ${float(obj_val_print):.2f}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m36.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 36: Port Ship Berth Decision (IP) ---
Optimization Status: Optimal
Optimal Decision: Use Dedicated Berth
  Cost of Dedicated Berth: $68.00
  Estimated Cost of Flexible Berth (due to delay): $147.00
Minimum Estimated Cost: $68.00


```

================================================================================



--- Problem 10 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port terminal is tasked with efficiently scheduling a set of nine ships for berthing. Each ship has a specific length and a unique cargo type, and the berths have a strict length capacity of 91 units. The challenge is compounded by an additional operational rule: no berth can contain ships of more than two distinct cargo types. The ships vary significantly in length, from a short 3-unit ship to longer ones like 79 and 75 units. The cargo types are diverse, including labels like 'L', 'K', 'C', 'T', 'B', 'I', 'O', and 'Z'. The terminal manager must determine the minimal number of berths required to accommodate all ships while respecting both length limits and cargo type diversity constraints. The core question is: *What is the most efficient way to schedule these ships into the fewest possible berths without exceeding capacity or violating cargo type rules?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `x[i, j]` indicates whether ship `i` is assigned to berth `j`.  
   - Binary variable `y[j]` indicates whether berth `j` is used.  
   - Binary variable `z[c, j]` indicates whether cargo type `c` is present in berth `j`.  

   **2. Parameters:**  
   - `ships`: Lengths of ships `[50, 79, 62, 3, 48, 69, 15, 75, 67]`.  
   - `cargo_types`: Cargo type labels for ships `['L', 'K', 'C', 'T', 'B', 'I', 'T', 'O', 'Z']`.  
   - `capacity`: Maximum length per berth (91).  
   - `num_ships`: Total ships (9).  
   - `num_berths`: Maximum possible berths (9, one per ship).  

   **3. Objective Function:**  
   Minimize the total number of berths used:  
   \[
   \text{Minimize: } \sum_{j} y[j]
   \]  

   **4. Constraints:**  
   - **Ship Assignment:** Each ship must be assigned to exactly one berth:  
     \[
     \sum_{j} x[i, j] = 1 \quad \forall i
     \]  
   - **Berth Capacity:** The total length in a berth cannot exceed its capacity:  
     \[
     \sum_{i} (\text{ships}[i] \cdot x[i, j]) \leq \text{capacity} \cdot y[j] \quad \forall j
     \]  
   - **Cargo Type Linking:** If a ship of cargo type `c` is in berth `j`, `z[c, j]` must be 1:  
     \[
     x[i, j] \leq z[\text{cargo_types}[i], j] \quad \forall i, j
     \]  
   - **Cargo Type Limit:** Each used berth can have at most two distinct cargo types:  
     \[
     \sum_{c} z[c, j] \leq 2 \cdot y[j] \quad \forall j
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
ships = [50, 79, 62, 3, 48, 69, 15, 75, 67]      # Lengths of ships
cargo_types = ['L', 'K', 'C', 'T', 'B', 'I', 'T', 'O', 'Z']    # Cargo types of ships
capacity = 91         # Berth capacity
num_ships = 9       # len(ships) - derived correctly below
num_berths = num_ships      # Maximum berths (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(ships) != len(cargo_types) or len(ships) != num_ships:
    print("Error: Data inconsistency (ships/cargo_types/num_ships length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_cargo_types_list = sorted(list(set(cargo_types))) # Get unique cargo types deterministically
ship_indices_by_cargo_type = {cargo_type: [i for i, c in enumerate(cargo_types) if c == cargo_type] for cargo_type in unique_cargo_types_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Cargo-Type-Constrained Berth Scheduling", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")  # x[i,j] -> ship i in berth j
        y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")              # y[j] -> whether berth j is used
        # z[c,j] -> whether cargo type c is PRESENT in berth j (Use unique_cargo_types_list for keys)
        z = model.addVars(unique_cargo_types_list, num_berths, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of berths used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each ship must be assigned to exactly one berth ---
        for i in range(num_ships):
            model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

        # --- Constraint 2: Berth capacity constraint ---
        for j in range(num_berths):
            model.addConstr(gp.quicksum(ships[i] * x[i, j] for i in range(num_ships)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

        # --- Constraint 3: Cargo type constraint (at most 2 *different* cargo types per berth) ---

        # Part 3a: Link x (ship in berth) and z (cargo type in berth).
        for j in range(num_berths):
            for cargo_type in unique_cargo_types_list:
                indices_of_this_cargo_type = ship_indices_by_cargo_type.get(cargo_type, []) # Use .get for safety

                if not indices_of_this_cargo_type:
                    # If no ships of this cargo type exist, z[cargo_type, j] must be 0.
                    model.addConstr(z[cargo_type, j] == 0, name=f"NoShips_{cargo_type}_Berth_{j}")
                    continue

                # If any ship 'i' of this 'cargo_type' is placed in berth 'j' (x[i,j]=1),
                # then the presence indicator for that 'cargo_type' in berth 'j' (z[cargo_type,j]) must be 1.
                for i in indices_of_this_cargo_type:
                    model.addConstr(x[i, j] <= z[cargo_type, j], name=f"Link_x{i}_z{cargo_type}_Berth{j}")

                # Ensure z[cargo_type, j] is 0 if no ships of that cargo type are in the berth.
                # This helps tighten the formulation.
                model.addConstr(z[cargo_type, j] <= gp.quicksum(x[i, j] for i in indices_of_this_cargo_type), name=f"Link_z{cargo_type}_SumX_Berth{j}")


        # Part 3b: Limit the number of distinct cargo types (sum of z[c,j] for berth j) to 2 for USED berths.
        for j in range(num_berths):
            # sum(z[c,j] for c in unique_cargo_types_list) gives the count of distinct cargo types in berth j.
            # This sum must be <= 2 *IF* the berth is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2CargoTypes_Berth_{j}")

        # --- Solve ---
        print("Solving CCBP instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of berths used: {optimal_berths}")
    print("-" * 30)

    berth_details = []
    printed_berth_count = 0
    for j_sol in range(num_berths): # Iterate through all potential berth indices
        try:
             # Check if this berth was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_berth_count += 1
                 assigned_ships_indices = [i for i in range(num_ships) if x[i, j_sol].X > 0.5]
                 assigned_ships_lengths = [ships[i] for i in assigned_ships_indices]
                 assigned_ships_cargo_types = [cargo_types[i] for i in assigned_ships_indices]
                 distinct_cargo_types_in_berth = sorted(list(set(assigned_ships_cargo_types))) # Sort for consistent output
                 berth_load = sum(assigned_ships_lengths)

                 print(f"Berth {printed_berth_count} (Internal Index {j_sol}):")
                 print(f"  Ships (indices): {assigned_ships_indices}")
                 # print(f"  Ships (lengths): {assigned_ships_lengths}") # Optional details
                 # print(f"  Ships (cargo types):  {assigned_ships_cargo_types}") # Optional details
                 print(f"  Distinct Cargo Types: {distinct_cargo_types_in_berth} (Count: {len(distinct_cargo_types_in_berth)})")
                 print(f"  Total length:    {berth_load} / {capacity}")
                 print("-" * 10)

                 berth_data = {
                     'berth_index_internal': j_sol,
                     'berth_index_printed': printed_berth_count,
                     'ship_indices': assigned_ships_indices,
                     'distinct_cargo_types': distinct_cargo_types_in_berth,
                     'load': berth_load
                 }
                 berth_details.append(berth_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for berth index {j_sol}: {e_print}")


    results_dict['berth_details'] = berth_details # Store details

    # Final sanity check
    if printed_berth_count != optimal_berths:
         print(f"Warning: Number of printed used berths ({printed_berth_count}) does not match objective value ({optimal_berths}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# The provided code already prints the necessary outputs, so no additional print statements are needed.
```
Answer:
Solving CCBP instance...
------------------------------

Optimal solution found.
Optimal number of berths used: 7
------------------------------
Berth 1 (Internal Index 0):
  Ships (indices): [3, 5]
  Distinct Cargo Types: ['I', 'T'] (Count: 2)
  Total length:    72 / 91
----------
Berth 2 (Internal Index 1):
  Ships (indices): [7]
  Distinct Cargo Types: ['O'] (Count: 1)
  Total length:    75 / 91
----------
Berth 3 (Internal Index 3):
  Ships (indices): [2]
  Distinct Cargo Types: ['C'] (Count: 1)
  Total length:    62 / 91
----------
Berth 4 (Internal Index 4):
  Ships (indices): [0]
  Distinct Cargo Types: ['L'] (Count: 1)
  Total length:    50 / 91
----------
Berth 5 (Internal Index 5):
  Ships (indices): [8]
  Distinct Cargo Types: ['Z'] (Count: 1)
  Total length:    67 / 91
----------
Berth 6 (Internal Index 6):
  Ships (indices): [4, 6]
  Distinct Cargo Types: ['B', 'T'] (Count: 2)
  Total length:    63 / 91
----------
Berth 7 (Internal Index 8):
  Ships (indices): [1]
  Distinct Cargo Types: ['K'] (Count: 1)
  Total length:    79 / 91
----------


```

================================================================================



--- Problem 11 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port is experiencing a temporary reduction in the capacity of its main berth due to maintenance, reducing its handling capacity from 5,142 containers per hour (cont/h) to just 1,864 cont/h. An alternative berth with a fixed capacity of 1,281 cont/h is available, but it adds an extra handling time of approximately 9 minutes (0.1507 hours) per container. The port management must decide how to divert containers between the main and alternative berths to minimize total delay during the maintenance, which is expected to last 1.078 hours.  

   The decision involves selecting from four predefined diversion strategies: diverting 10%, 30%, 50%, or 70% of the total arriving containers (2,815 cont/h) to the alternative berth. Each strategy must respect the alternative berth's capacity—diverting more containers than it can handle is infeasible and incurs a prohibitively large penalty delay. For the main berth, if the remaining containers exceed its reduced capacity, a queue forms, and delays are calculated based on how long it takes to clear the backlog once the maintenance ends and normal capacity resumes.  

   The challenge is to identify the diversion ratio that balances container handling between the two berths, avoiding infeasible overloading while minimizing the combined delay from both the alternative berth's extra handling time and the main berth's queuing effects.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `y[k]` for each diversion option `k` (where `k` ranges over indices 0 to 3, representing 10%, 30%, 50%, and 70% diversion ratios). `y[k] = 1` if the option is selected, else `0`.  

   **2. Parameters:**  
   - `capacity_main_normal = 5,142` cont/h (main berth’s normal capacity).  
   - `capacity_main_reduced = 1,864` cont/h (main berth’s reduced capacity during the maintenance).  
   - `capacity_alt = 1,281` cont/h (alternative berth’s fixed capacity).  
   - `arrival_rate_total = 2,815` cont/h (total container demand).  
   - `maintenance_duration = 1.078` hours (duration of the maintenance).  
   - `alt_berth_extra_time = 0.1507` hours (additional handling time on the alternative berth).  
   - `diversion_options = [0.1, 0.3, 0.5, 0.7]` (available diversion ratios).  
   - `option_delays[k]` (precomputed total delay for each feasible option `k`).  
   - `option_feasible[k]` (indicates whether option `k` respects the alternative berth’s capacity).  

   **3. Objective Function:**  
   Minimize the total delay:  
   `Minimize: sum(y[k] * option_delays[k] for all feasible k)`  

   **4. Constraints:**  
   - **Single selection:** Exactly one feasible diversion option must be chosen:  
     `sum(y[k] for all feasible k) = 1`.  
   - **Infeasibility exclusion:** Infeasible options (where diverted containers exceed `capacity_alt`) are forced to 0:  
     `y[k] = 0` for all infeasible `k`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
capacity_main_normal = 5142 # cont/h
capacity_main_reduced = 1864 # cont/h
capacity_alt = 1281 # cont/h
arrival_rate_total = 2815 # cont/h
maintenance_duration = 1.0779761852327703 # h
alt_berth_extra_time = 0.1507210334708749 # h
diversion_options = [0.1, 0.3, 0.5, 0.7] # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option ---
option_delays = {}
option_feasible = {}

for k in range(num_options):
    p_k = diversion_options[k]
    flow_alt_k = arrival_rate_total * p_k
    flow_main_k = arrival_rate_total * (1 - p_k)

    # 1. Check Alternative Berth Capacity Feasibility
    if flow_alt_k > capacity_alt + EPSILON:
        option_feasible[k] = False
        option_delays[k] = LARGE_DELAY
        continue

    option_feasible[k] = True

    # 2. Calculate Alternative Berth Delay
    delay_alt_k = flow_alt_k * maintenance_duration * alt_berth_extra_time

    # 3. Calculate Main Berth Queue Delay
    delay_queue_main_k = 0
    max_queue_main_k = 0

    if flow_main_k > capacity_main_reduced + EPSILON:
        max_queue_main_k = (flow_main_k - capacity_main_reduced) * maintenance_duration
        if flow_main_k >= capacity_main_normal - EPSILON:
            delay_queue_main_k = LARGE_DELAY
        else:
            dissipation_rate_k = capacity_main_normal - flow_main_k
            if dissipation_rate_k < EPSILON:
                 delay_queue_main_k = LARGE_DELAY
            else:
                 dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                 total_influence_time_k = maintenance_duration + dissipation_time_main_k
                 delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

    # 4. Calculate Total Delay for this option
    total_delay_k = delay_alt_k + delay_queue_main_k
    option_delays[k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("Berth_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
feasible_indices = [k for k in range(num_options) if option_feasible[k]]
if not feasible_indices:
     exit()

m.addConstr(gp.quicksum(y[k] for k in feasible_indices) == 1, name="SelectOneFeasibleOption")

for k in range(num_options):
    if not option_feasible[k]:
        m.addConstr(y[k] == 0, name="ForbidInfeasibleOption_{0}".format(k))

# --- Objective Function ---
m.setObjective(gp.quicksum(y[k] * option_delays[k] for k in feasible_indices), GRB.MINIMIZE)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    chosen_option_index = -1
    chosen_diversion_ratio = -1.0
    for k in range(num_options):
        if k in feasible_indices and y[k].X > 0.5:
            chosen_option_index = k
            chosen_diversion_ratio = diversion_options[k]
            break

    if chosen_option_index != -1:
         print("Optimal Diversion Option: Index {0}, Ratio {1:.0f}%".format(chosen_option_index, chosen_diversion_ratio*100))
```
Answer:
Optimal Diversion Option: Index 1, Ratio 30%



================================================================================



--- Problem 12 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A major port is experiencing a temporary reduction in the number of available berths due to an ongoing maintenance incident, forcing some ships to divert to a nearby private terminal. The port’s normal capacity is 5,746 ship arrivals per hour, but during the incident, it drops to 2,497 ship arrivals per hour. The initial demand on the port is 4,765 ship arrivals per hour, while the private terminal initially attracts 471 ship arrivals per hour. The private terminal has a fixed capacity of 2,937 ship arrivals per hour and imposes an additional handling time of 0.087 hours per ship due to congestion.

To manage congestion, port authorities consider dynamic pricing, adjusting the fee from the normal price of $5.31 down to $0 in $1 increments. Lowering the fee is expected to attract more ships from the port at a rate of 140 additional ships per dollar reduction. However, diverting too much traffic could overwhelm the private terminal or leave the port underutilized. The goal is to determine the optimal fee that minimizes the total system delay—accounting for both port queueing delays and private terminal congestion—over a 2.02-hour incident duration.

The critical question is: **What fee (from $0 to $5) should be set to minimize the total delay across both the port and the private terminal during the incident?**

---

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable \( y_p \) for each fee option \( p \) (where \( p \in \{0, 1, 2, 3, 4, 5\} \)), indicating whether fee \( p \) is selected.  

   **2. Parameters:**  
   - \( C_{\text{port\_norm}} = 5,746 \): Port capacity (normal).  
   - \( C_{\text{port\_red}} = 2,497 \): Reduced port capacity during incident.  
   - \( \lambda_{\text{demand\_port}} = 4,765 \): Initial port demand.  
   - \( C_{\text{terminal}} = 2,937 \): Private terminal capacity.  
   - \( T_{\text{extra\_terminal}} = 0.087 \): Additional delay per ship on private terminal (hours).  
   - \( \lambda_{\text{terminal\_initial}} = 471 \): Initial private terminal demand.  
   - \( T_{\text{inc}} = 2.02 \): Incident duration (hours).  
   - \( \text{Flow\_increase\_per\_dollar} = 140.41 \): Additional private terminal demand per $1 fee reduction.  

   **3. Objective Function:**  
   Minimize the total system delay:  
   \[
   \text{Minimize: } \sum_{p} y_p \cdot \text{delay}_p
   \]  
   where \( \text{delay}_p \) is the total delay (port + private terminal) for fee \( p \).  

   **4. Constraints:**  
   - **Single fee selection:** Exactly one fee must be chosen:  
     \[
     \sum_{p} y_p = 1
     \]  
   - **Binary variables:** \( y_p \in \{0, 1\} \) for all \( p \).  

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
C_port_norm = 5746.291543250304
C_port_red = 2497.435045258106
lambda_demand_port_initial = 4764.5954931783945
C_terminal = 2937.2078593852093
T_extra_terminal_h = 0.0869532004178431
Fee_norm = 5.306070331289873
lambda_terminal_initial = 471.3765554663
T_inc_h = 2.0213678298008064
Flow_increase_per_dollar = 140.41385996604401
Fee_options = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]

Lambda_total = lambda_demand_port_initial + lambda_terminal_initial

# --- Calculate total delay for each fee option ---
option_delays = {}
print("--- System Delay Calculation per Fee Option ---")

for p in Fee_options:
    fee_decrease = Fee_norm - p
    flow_increase_expected = fee_decrease * Flow_increase_per_dollar
    lambda_terminal_expected = lambda_terminal_initial + flow_increase_expected

    # Effective terminal flow considering capacity
    lambda_terminal_effective = min(lambda_terminal_expected, C_terminal)

    # Remaining flow on port
    lambda_port = Lambda_total - lambda_terminal_effective

    # Calculate delays
    # Terminal delay (extra travel time only)
    delay_terminal = lambda_terminal_effective * T_inc_h * T_extra_terminal_h

    # Port queueing delay
    delay_port = 0
    q_max = 0
    t_diss = float('nan')
    if lambda_port > C_port_red:
        q_max = (lambda_port - C_port_red) * T_inc_h
        dissipation_rate = C_port_norm - lambda_port
        if dissipation_rate > 1e-6:
            t_diss = q_max / dissipation_rate
            delay_port = 0.5 * q_max * (T_inc_h + t_diss)
        else:
            delay_port = float('inf') # Queue doesn't dissipate naturally
    else:
         delay_port = 0 # No queue forms

    total_delay = delay_port + delay_terminal if delay_port != float('inf') else float('inf')
    option_delays[p] = total_delay

    print(f" Fee=${p:.2f}: TerminalFlow={lambda_terminal_effective:.0f}, PortFlow={lambda_port:.0f} -> PortDelay={delay_port:.2f}, TerminalDelay={delay_terminal:.2f} => Total={total_delay:.2f}")

# --- Gurobi Model (Select best fee) ---
model = gp.Model("DynamicPricingIncident")

# --- Decision Variables ---
y = model.addVars(Fee_options, vtype=GRB.BINARY, name="ChooseFee")

# --- Constraints ---
model.addConstr(gp.quicksum(y[p] for p in Fee_options) == 1, name="SelectOneFee")

# --- Objective Function ---
# Minimize total system delay. Handle infinite delay case (e.g., assign large penalty).
objective = gp.LinExpr()
for p in Fee_options:
    cost = option_delays[p]
    if cost == float('inf'):
        cost = 1e12 # Assign large finite cost for infeasible/non-dissipating scenarios
    objective += y[p] * cost

model.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    chosen_fee = -1.0
    for p in Fee_options:
        if y[p].X > 0.9:
            chosen_fee = p
            break

    if chosen_fee >= 0:
         print(f"Optimal Fee: ${chosen_fee:.2f}")
         # Handle displaying infinite delay if that was the "optimal" outcome
         min_delay_val = model.objVal
         if min_delay_val >= 1e11: # Check if the large penalty was chosen
              print(f" Minimum Total System Delay: Infinite (or very large due to non-dissipating queues)")
         else:
              print(f" Minimum Total System Delay: {model.objVal:.2f} ship-hours")
    else:
         print("Error: No fee selected.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- System Delay Calculation per Fee Option ---
 Fee=$0.00: TerminalFlow=1216, PortFlow=4020 -> PortDelay=5850.75, TerminalDelay=213.80 => Total=6064.55
 Fee=$1.00: TerminalFlow=1076, PortFlow=4160 -> PortDelay=6956.12, TerminalDelay=189.12 => Total=7145.25
 Fee=$2.00: TerminalFlow=936, PortFlow=4300 -> PortDelay=8276.19, TerminalDelay=164.44 => Total=8440.64
 Fee=$3.00: TerminalFlow=795, PortFlow=4441 -> PortDelay=9880.22, TerminalDelay=139.76 => Total=10019.99
 Fee=$4.00: TerminalFlow=655, PortFlow=4581 -> PortDelay=11870.88, TerminalDelay=115.08 => Total=11985.96
 Fee=$5.00: TerminalFlow=514, PortFlow=4722 -> PortDelay=14407.11, TerminalDelay=90.40 => Total=14497.51
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 6 columns and 6 nonzeros
Model fingerprint: 0xee1338a9
Variable types: 0 continuous, 6 integer (6 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [6e+03, 1e+04]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 6064.5488047
Presolve removed 1 rows and 6 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 1: 6064.55 

Optimal solution found (tolerance 1.00e-04)
Best objective 6.064548804657e+03, best bound 6.064548804657e+03, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Fee: $0.00
 Minimum Total System Delay: 6064.55 ship-hours



================================================================================



--- Problem 13 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port is faced with the challenge of maximizing its daily revenue by strategically selecting which ships to service within a limited time horizon. The port has four ships (numbered 0 to 3) vying for attention, each with distinct service times and associated revenues. Ship 0 requires 8 hours of service and generates $22,000 in revenue, while Ship 1 takes 33 hours and brings in $54,000. Ship 2 needs 11 hours for $34,000, and Ship 3 demands 39 hours but promises a hefty $89,000 in return. The port operates for a maximum of 164 hours in a day, and the ships must be serviced in a fixed sequence (0, 1, 2, 3). The manager must decide which ships to accept and schedule their start and completion times to ensure the total service time does not exceed the available time window while maximizing the total revenue. The core question is: Which combination of ships should the port service to achieve the highest possible revenue without exceeding the 164-hour limit?
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `x[i]`: Binary variable indicating whether ship `i` is served (1) or not (0), for `i` in {0, 1, 2, 3}.
   - `s[i]`: Continuous variable representing the start time of ship `i` (if served).
   - `C[i]`: Continuous variable representing the completion time of ship `i` (if served).

**2. Parameters:**
   - `service_times[i]`: Service time for ship `i` (8, 33, 11, 39 hours for ships 0 to 3, respectively).
   - `revenues[i]`: Revenue generated by serving ship `i` ($22,000, $54,000, $34,000, $89,000 for ships 0 to 3, respectively).
   - `time_horizon`: Maximum available time for servicing ships (164 hours).
   - `M`: A large constant (256) used to enforce constraints when ships are not served.

**3. Objective Function:**
   - Maximize the total revenue:  
     `Maximize: sum(revenues[i] * x[i] for all i)`.

**4. Constraints:**
   - **Time Limit:** If a ship `i` is served, its completion time must not exceed the time horizon:  
     `C[i] <= time_horizon + M * (1 - x[i])` for all `i`.
   - **Start and Completion Time Definition:**  
     - If `x[i] = 0`, force `s[i] = 0` and `C[i] = 0`:  
       `s[i] <= M * x[i]` and `C[i] <= M * x[i]` for all `i`.
     - If `x[i] = 1`, ensure `C[i] = s[i] + service_times[i]`:  
       `C[i] >= s[i] + service_times[i] - M * (1 - x[i])` and  
       `C[i] <= s[i] + service_times[i] + M * (1 - x[i])` for all `i`.
   - **Sequencing:** Ships must be serviced in the fixed sequence 0, 1, 2, 3. If ship `i` is served, its start time must be after the completion time of the previous ship `i-1`:  
     `s[i] >= C[i-1] - M * (1 - x[i])` for `i` in {1, 2, 3}.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3]
service_times = {0: 8, 1: 33, 2: 11, 3: 39} # Dict ship: time
revenues = {0: 22000, 1: 54000, 2: 34000, 3: 89000}     # Dict ship: revenue
time_horizon = 164 # hours
M = 256 # Big M
# --- End Parameters ---

GUROBI_TIME_LIMIT = 60

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_SCHEDULING", env=env)

    # --- Basic Input Validation ---
    if not ships:
        raise ValueError("Empty ships list")

    # --- Decision Variables ---
    # x[i] = 1 if ship i is served, 0 otherwise
    x = m.addVars(ships, vtype=GRB.BINARY, name="x")
    # C[i] = completion time of ship i (if served)
    C = m.addVars(ships, vtype=GRB.CONTINUOUS, lb=0, name="C")
    # s[i] = start time of ship i (if served)
    s = m.addVars(ships, vtype=GRB.CONTINUOUS, lb=0, name="s")

    # --- Objective Function: Maximize total revenue ---
    m.setObjective(gp.quicksum(revenues.get(i, 0) * x[i] for i in ships), GRB.MAXIMIZE)

    # --- Constraints ---
    # Completion time within horizon if served (Relax if not served using Big-M)
    m.addConstrs((C[i] <= time_horizon + M * (1 - x[i]) for i in ships), "TimeLimit")

    # Start and Completion time definition & relationship (only if x[i]=1)
    # If x[i]=0, force s[i]=0 and C[i]=0
    m.addConstrs((s[i] <= M * x[i] for i in ships), "StartZero")
    m.addConstrs((C[i] <= M * x[i] for i in ships), "CompletionZero")
    # If x[i]=1, ensure C[i] >= s[i] + service_time[i]
    m.addConstrs((C[i] >= s[i] + service_times.get(i, 0) - M * (1 - x[i]) for i in ships), "CompletionDefLower")
    # If x[i]=1, ensure C[i] <= s[i] + service_time[i] (optional, prevents C[i] being arbitrarily large)
    m.addConstrs((C[i] <= s[i] + service_times.get(i, 0) + M * (1 - x[i]) for i in ships), "CompletionDefUpper")

    # Sequencing constraint (assuming fixed sequence 0, 1, 2...)
    # Ship i can only start after ship i-1 is completed, *if both are served*
    # Original model assumes fixed sequence, implement that.
    if ships: # Check list not empty
        # s[0] >= 0 (handled by lb=0)
        # C[0] definition handled above
        for i in range(1, len(ships)):
            # If x[i]=1, then s[i] >= C[i-1]. Use Big-M.
            # s[i] must be >= C[i-1] if x[i]=1.
            # s[i] >= C[i-1] - M*(1-x[i])
            # This forces s[i] >= C[i-1] if x[i]=1. If x[i]=0, s[i]>=C[i-1]-M (redundant).
            m.addConstr(s[i] >= C[i-1] - M * (1 - x[i]), f"Seq_{i}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output
        # results_dict['C_sol'] = m.getAttr('X', C) # Not needed for output
        # results_dict['s_sol'] = m.getAttr('X', s) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible") # Matches example
    elif m.Status == GRB.TIME_LIMIT:
         print(f"Optimization ended with status {m.Status}") # Matches example's generic else
    else: # Other statuses
        print(f"Optimization ended with status {m.Status}") # Matches example's generic else

except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the decision variables and start/completion times
if m.Status == GRB.OPTIMAL:
    obj_val_print = results_dict.get('obj_val', 'N/A')
    if isinstance(obj_val_print, (int, float)):
        print(f"Optimal objective value: {obj_val_print:.2f}")
    
    # Print which ships are served
    for i in ships:
        if x[i].X > 0.5:
            print(f"Ship {i} is served, Start Time: {s[i].X:.2f}, Completion Time: {C[i].X:.2f}")
        else:
            print(f"Ship {i} is not served")
```
Answer:
Optimal objective value: 199000.00
Optimal objective value: 199000.00
Ship 0 is served, Start Time: 0.00, Completion Time: 8.00
Ship 1 is served, Start Time: 8.00, Completion Time: 41.00
Ship 2 is served, Start Time: 41.00, Completion Time: 52.00
Ship 3 is served, Start Time: 52.00, Completion Time: 91.00


```

================================================================================



--- Problem 14 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy container terminal is facing a critical resource allocation challenge. With an average of **70 containers arriving per hour** and each of its **7 available cranes** capable of handling **17 containers per hour**, the terminal management must carefully balance operational costs and service efficiency. The terminal incurs a **$20 hourly cost per crane** but faces a **$57 penalty** if crane utilization exceeds **76%**—a threshold indicating potential delays in container handling. The challenge: *Determine the optimal number of cranes to deploy that minimizes total costs (operational costs + penalties) while meeting fluctuating demand*.  

   The penalty is triggered when the crane count falls below a calculated safety margin. Here, even the minimum viable team (1 crane) results in severe overutilization (411.8% vs. the 76% threshold), forcing acceptance of the penalty. The model navigates this trade-off, revealing whether it’s cheaper to operate more cranes or pay for occasional delays.
**

**Modeling Process:**
**
- **Decision Variables:**  
     - `x`: Integer number of cranes (1 to 7).  
     - `z`: Binary flag (1 if penalty applies, else 0).  
   - **Parameters:**  
     - `arrival_rate = 70`, `service_rate_per_cranes = 17`, `max_cranes = 7`.  
     - `cost_per_cranes = 20`, `penalty_high_wait = 57`, `utilization_threshold = 0.76`.  
     - `M = 1000` (large constant for constraint logic).  
   - **Objective Function:**  
     Minimize total cost: `Cranes Cost (x * 20) + Penalty Cost (z * 57)`.  
   - **Constraints:**  
     - If `x` ≥ `min_cranes_no_penalty` (calculated as 6), penalty is avoided (`z=0`).  
     - If `x` ≤ 5, penalty applies (`z=1`).  
     - `x` is bounded between 1 and 7 cranes.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
max_cranes = 7; arrival_rate = 70; service_rate_per_cranes = 17
cost_per_cranes = 20; penalty_high_wait = 57; utilization_threshold = 0.76
M = 1000
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    # Pre-calculate penalty cutoff inside try block
    min_cranes_no_penalty = 0
    penalty_cutoff_cranes = -1 # Default if penalty never applies or calculation fails
    if service_rate_per_cranes > 1e-6 and utilization_threshold > 1e-6:
         min_cranes_no_penalty_float = arrival_rate / (service_rate_per_cranes * utilization_threshold)
         min_cranes_no_penalty = math.ceil(min_cranes_no_penalty_float)
         penalty_cutoff_cranes = min_cranes_no_penalty - 1
    elif arrival_rate <= 1e-6: # No arrivals, no penalty needed
         min_cranes_no_penalty = 1 # Or 0 if allowed? Assume 1 crane min
         penalty_cutoff_cranes = -1
    else: # Service rate is zero with positive arrivals, always penalty?
          # This logic implies infinite utilization, penalty always applies if threshold < infinity
          # Let's assume penalty applies for any crane count in this case
          min_cranes_no_penalty = float('inf')
          penalty_cutoff_cranes = max_cranes # Penalty applies up to max cranes

    # Ensure cutoff is not negative if min_cranes_no_penalty is 0 or 1
    penalty_cutoff_cranes = max(-1, penalty_cutoff_cranes)

    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m15 = gp.Model("Container_Terminal_Cranes_IP", env=env)
    # Vars
    x = m15.addVar(vtype=GRB.INTEGER, name="num_cranes", lb=1, ub=max_cranes)
    z = m15.addVar(vtype=GRB.BINARY, name="penalty_applies")
    # Objective
    m15.setObjective(x * cost_per_cranes + z * penalty_high_wait, sense=GRB.MINIMIZE)
    # Constraints
    # Only add constraints if min_cranes_no_penalty is finite
    if min_cranes_no_penalty != float('inf'):
         m15.addConstr(x >= min_cranes_no_penalty - M * z, name="force_z0_if_x_high")
         m15.addConstr(x <= penalty_cutoff_cranes + M * (1 - z), name="force_z1_if_x_low")
    else: # If min_cranes is infinite, penalty always applies (z=1)
         m15.addConstr(z == 1, name="force_z1_always")

    # Optimize
    m15.optimize()
    # Store results
    results_dict['status'] = m15.status
    if m15.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m15.objVal; results_dict['x_opt'] = x.X; results_dict['z_opt'] = z.X
    # Output Results
    print("--- Problem 15: Container Terminal Cranes (IP) ---")
    if m15.status == GRB.OPTIMAL:
        num_cranes_opt = int(round(results_dict.get('x_opt', 0)))
        rho_opt = arrival_rate / (num_cranes_opt * service_rate_per_cranes) if num_cranes_opt * service_rate_per_cranes > 1e-6 else float('inf')
        penalty_applied = results_dict.get('z_opt', 0) > 0.5
        cranes_cost_opt = num_cranes_opt * cost_per_cranes
        penalty_cost_opt = penalty_high_wait if penalty_applied else 0
        print(f"Optimization Status: Optimal")
        print(f"Optimal number of cranes: {num_cranes_opt} / {max_cranes}")
        print(f"  Resulting Utilization (rho): {rho_opt:.3f} (Threshold for penalty: > {utilization_threshold})")
        print(f"  Cranes Cost: ${cranes_cost_opt:.2f}/hr")
        print(f"  High Wait Penalty Applied (z=1): {'Yes' if penalty_applied else 'No'} (${penalty_cost_opt}.00)")
        print(f"Minimum Total Cost: ${m15.objVal:.2f}/hr")
    else: print(f"Optimization Status: {m15.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of CONTAINER_TERMINAL
```
Answer:
--- Problem 15: Container Terminal Cranes (IP) ---
Optimization Status: Optimal
Optimal number of cranes: 1 / 7
  Resulting Utilization (rho): 4.118 (Threshold for penalty: > 0.76)
  Cranes Cost: $20.00/hr
  High Wait Penalty Applied (z=1): Yes ($57.00)
Minimum Total Cost: $77.00/hr



================================================================================



--- Problem 15 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port is managed by a three-phase ship berthing system, where each phase controls the flow of ships from a specific direction. The port managers face a critical challenge: minimizing the total delay experienced by ships across all phases while adhering to strict timing constraints. Each phase has a unique traffic flow coefficient (2225, 1687, and 1260 ships per hour, respectively), reflecting the volume of ships that would be delayed if the berthing timing is suboptimal. The green time for each phase must be between 15 and 53 minutes, and the total cycle time—the sum of all green times—must exactly match the upper bound of 53 minutes. The core question is: *How should the 53-minute cycle be allocated among the three phases to minimize the cumulative delay caused by waiting times?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Let \( t_i \) represent the green time (in minutes) allocated to phase \( i \), where \( i \in \{1, 2, 3\} \). Each \( t_i \) is a continuous variable bounded between 15 and 53 minutes.  
   - **2. Parameters:**  
     - \( \text{flow_coeffs} = [2225, 1687, 1260] \): Traffic flow coefficients for each phase.  
     - \( \text{cycle_time} = 53 \): Total cycle time (fixed).  
     - \( \text{lb_time} = 15 \), \( \text{ub_time} = 53 \): Lower and upper bounds for green times.  
   - **3. Objective Function:**  
     Minimize the total delay:  
     \[
     \text{Minimize: } \sum_{i=1}^{3} \text{flow_coeffs}[i] \times (\text{cycle_time} - t_i)
     \]  
   - **4. Constraints:**  
     - The sum of green times equals the cycle time:  
       \[
       t_1 + t_2 + t_3 = 53
       \]  
     - Bounds on green times:  
       \[
       15 \leq t_i \leq 53 \quad \text{for all } i.
       \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 3
lb_time = 15          # Lower bound for green time
ub_time = 53          # Upper bound for green time
cycle_time = 53   # Total cycle time (set equal to ub_time)
flow_coeffs = [2225, 1687, 1260] # Traffic flow coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for phase i is proportional to flow * red_time = flow * (cycle_time - green_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of green times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal green times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total delay: 178736.00
------------------------------
Optimal green times (minutes):
  t1: 23.00, t2: 15.00, t3: 15.00


```

================================================================================



--- Problem 16 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
A maritime port is tasked with efficiently scheduling 18 uniquely colored containers into berths for unloading, each with a strict weight limit of 89 units. The containers vary significantly in weight—from a mere 1-unit container to an 88-unit heavyweight—and are labeled with 12 distinct colors (e.g., 'Q', 'Y', 'G'). The challenge is twofold: minimize the number of berths used while ensuring no berth contains containers of more than two different colors. This constraint reflects real-world sorting policies, where mixed-color batches complicate downstream processing. For instance, a berth might hold three containers (weights 43, 23, 19) as long as their colors ('Y', 'Y', 'G') span no more than two distinct hues. The puzzle: *What is the smallest number of berths needed to schedule all containers without violating weight or color diversity limits?*

**Modeling Process:**
**1. Decision Variables:**  
   - Binary variable `x[i,j]` = 1 if container *i* is assigned to berth *j*, else 0.  
   - Binary variable `y[j]` = 1 if berth *j* is used, else 0.  
   - Binary variable `z[c,j]` = 1 if color *c* is present in berth *j*, else 0.  

   **2. Parameters:**  
   - `containers`: List of weights (e.g., [85, 43, ..., 83]).  
   - `colors`: List mapping each container to a color (e.g., ['Q', 'Y', ..., 'Z']).  
   - `capacity`: Maximum berth weight (89).  
   - `unique_colors_list`: Sorted list of distinct colors (e.g., ['F', 'G', ..., 'Z']).  

   **3. Objective Function:**  
   Minimize the total berths used:  
   `Minimize: sum(y[j] for all j)`  

   **4. Constraints:**  
   - Each container in exactly one berth:  
     `For each container i: sum(x[i,j] for all j) = 1`.  
   - Berth weight limit:  
     `For each berth j: sum(containers[i] * x[i,j] for all i) <= capacity * y[j]`.  
   - Color-berth linking:  
     `If container i of color c is in berth j (x[i,j]=1), then z[c,j]=1`.  
     `z[c,j] <= sum(x[i,j] for all i of color c)`.  
   - Color diversity:  
     `For each berth j: sum(z[c,j] for all c) <= 2 * y[j]`.  

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
containers = [85, 43, 23, 19, 56, 17, 34, 47, 74, 34, 50, 1, 88, 79, 36, 78, 14, 83]      # Weights of containers
colors = ['Q', 'Y', 'Y', 'G', 'R', 'F', 'P', 'S', 'J', 'R', 'G', 'L', 'U', 'I', 'Q', 'U', 'M', 'Z']    # Colors of containers
capacity = 89         # Berth capacity
num_containers = 18       # len(containers) - derived correctly below
num_berths = num_containers      # Maximum berths (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(containers) != len(colors) or len(containers) != num_containers:
    print("Error: Data inconsistency (containers/colors/num_containers length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_colors_list = sorted(list(set(colors))) # Get unique colors deterministically
container_indices_by_color = {color: [i for i, c in enumerate(colors) if c == color] for color in unique_colors_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Color-Constrained Berth Scheduling", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_containers, num_berths, vtype=GRB.BINARY, name="x")  # x[i,j] -> container i in berth j
        y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")              # y[j] -> whether berth j is used
        # z[c,j] -> whether color c is PRESENT in berth j (Use unique_colors_list for keys)
        z = model.addVars(unique_colors_list, num_berths, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of berths used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each container must be assigned to exactly one berth ---
        for i in range(num_containers):
            model.addConstr(x.sum(i, '*') == 1, name=f"Container_{i}_Assignment")

        # --- Constraint 2: Berth capacity constraint ---
        for j in range(num_berths):
            model.addConstr(gp.quicksum(containers[i] * x[i, j] for i in range(num_containers)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

        # --- Constraint 3: Color constraint (at most 2 *different* colors per berth) ---

        # Part 3a: Link x (container in berth) and z (color in berth).
        for j in range(num_berths):
            for color in unique_colors_list:
                indices_of_this_color = container_indices_by_color.get(color, []) # Use .get for safety

                if not indices_of_this_color:
                    # If no containers of this color exist, z[color, j] must be 0.
                    model.addConstr(z[color, j] == 0, name=f"NoContainers_{color}_Berth_{j}")
                    continue

                # If any container 'i' of this 'color' is placed in berth 'j' (x[i,j]=1),
                # then the presence indicator for that 'color' in berth 'j' (z[color,j]) must be 1.
                for i in indices_of_this_color:
                    model.addConstr(x[i, j] <= z[color, j], name=f"Link_x{i}_z{color}_Berth{j}")

                # Ensure z[color, j] is 0 if no containers of that color are in the berth.
                # This helps tighten the formulation.
                model.addConstr(z[color, j] <= gp.quicksum(x[i, j] for i in indices_of_this_color), name=f"Link_z{color}_SumX_Berth{j}")


        # Part 3b: Limit the number of distinct colors (sum of z[c,j] for berth j) to 2 for USED berths.
        for j in range(num_berths):
            # sum(z[c,j] for c in unique_colors_list) gives the count of distinct colors in berth j.
            # This sum must be <= 2 *IF* the berth is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Colors_Berth_{j}")

        # --- Solve ---
        print("Solving CCBP instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of berths used: {optimal_berths}")
    print("-" * 30)

    berth_details = []
    printed_berth_count = 0
    for j_sol in range(num_berths): # Iterate through all potential berth indices
        try:
             # Check if this berth was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_berth_count += 1
                 assigned_containers_indices = [i for i in range(num_containers) if x[i, j_sol].X > 0.5]
                 assigned_containers_weights = [containers[i] for i in assigned_containers_indices]
                 assigned_containers_colors = [colors[i] for i in assigned_containers_indices]
                 distinct_colors_in_berth = sorted(list(set(assigned_containers_colors))) # Sort for consistent output
                 berth_load = sum(assigned_containers_weights)

                 print(f"Berth {printed_berth_count} (Internal Index {j_sol}):")
                 print(f"  Containers (indices): {assigned_containers_indices}")
                 # print(f"  Containers (weights): {assigned_containers_weights}") # Optional details
                 # print(f"  Containers (colors):  {assigned_containers_colors}") # Optional details
                 print(f"  Distinct Colors: {distinct_colors_in_berth} (Count: {len(distinct_colors_in_berth)})")
                 print(f"  Total weight:    {berth_load} / {capacity}")
                 print("-" * 10)

                 berth_data = {
                     'berth_index_internal': j_sol,
                     'berth_index_printed': printed_berth_count,
                     'container_indices': assigned_containers_indices,
                     'distinct_colors': distinct_colors_in_berth,
                     'load': berth_load
                 }
                 berth_details.append(berth_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for berth index {j_sol}: {e_print}")


    results_dict['berth_details'] = berth_details # Store details

    # Final sanity check
    if printed_berth_count != optimal_berths:
         print(f"Warning: Number of printed used berths ({printed_berth_count}) does not match objective value ({optimal_berths}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# The provided code already prints the key outputs, including the optimal number of berths used and detailed information for each berth.
# No additional print statements are necessary.
```
Answer:
Solving CCBP instance...
------------------------------

Optimal solution found.
Optimal number of berths used: 11
------------------------------
Berth 1 (Internal Index 0):
  Containers (indices): [0]
  Distinct Colors: ['Q'] (Count: 1)
  Total weight:    85 / 89
----------
Berth 2 (Internal Index 1):
  Containers (indices): [13]
  Distinct Colors: ['I'] (Count: 1)
  Total weight:    79 / 89
----------
Berth 3 (Internal Index 4):
  Containers (indices): [7]
  Distinct Colors: ['S'] (Count: 1)
  Total weight:    47 / 89
----------
Berth 4 (Internal Index 5):
  Containers (indices): [10, 14]
  Distinct Colors: ['G', 'Q'] (Count: 2)
  Total weight:    86 / 89
----------
Berth 5 (Internal Index 6):
  Containers (indices): [11, 15]
  Distinct Colors: ['L', 'U'] (Count: 2)
  Total weight:    79 / 89
----------
Berth 6 (Internal Index 8):
  Containers (indices): [4, 5]
  Distinct Colors: ['F', 'R'] (Count: 2)
  Total weight:    73 / 89
----------
Berth 7 (Internal Index 9):
  Containers (indices): [8, 16]
  Distinct Colors: ['J', 'M'] (Count: 2)
  Total weight:    88 / 89
----------
Berth 8 (Internal Index 10):
  Containers (indices): [12]
  Distinct Colors: ['U'] (Count: 1)
  Total weight:    88 / 89
----------
Berth 9 (Internal Index 12):
  Containers (indices): [17]
  Distinct Colors: ['Z'] (Count: 1)
  Total weight:    83 / 89
----------
Berth 10 (Internal Index 14):
  Containers (indices): [1, 2, 3]
  Distinct Colors: ['G', 'Y'] (Count: 2)
  Total weight:    85 / 89
----------
Berth 11 (Internal Index 16):
  Containers (indices): [6, 9]
  Distinct Colors: ['P', 'R'] (Count: 2)
  Total weight:    68 / 89
----------


```

================================================================================



--- Problem 17 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port traffic management system faces a critical decision during an incident: how to divert ships to minimize total delay. The main channel’s capacity drops sharply during the incident, while an alternative route offers limited additional capacity but adds extra travel time. Port traffic managers must choose from four pre-defined diversion ratios (10%, 30%, 50%, or 70%) to balance flow between the congested main channel and the slower alternative.  

The main channel operates at 4,907 ships per hour (ships/h) under normal conditions but plummets to 1,736 ships/h during the 1.617-hour incident. The alternative route can handle 1,552 ships/h but imposes an additional 0.167 hours per ship. With a total arrival rate of 3,358 ships/h, the challenge is to allocate traffic optimally: divert too little, and queues on the main channel grow excessively; divert too much, and the alternative route becomes overwhelmed. The goal is to select the diversion ratio that minimizes the combined delay from queuing and the added travel time on the alternative route.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Binary variable `y[k]` for each diversion option `k` (0.1, 0.3, 0.5, 0.7), where `y[k] = 1` if the option is chosen, else `0`.  
   - **2. Parameters:**  
     - `capacity_main_normal = 4907`, `capacity_main_reduced = 1736`, `capacity_alt = 1552` (ships/h).  
     - `arrival_rate_total = 3358` (ships/h), `incident_duration = 1.617` (h), `alt_route_extra_time = 0.167` (h).  
     - Precomputed `option_delays[k]`: Total delay (ship-hours) for each feasible diversion ratio.  
   - **3. Objective Function:**  
     Minimize total delay: `sum(y[k] * option_delays[k] for all feasible k)`.  
   - **4. Constraints:**  
     - Exactly one feasible diversion option must be selected: `sum(y[k] for feasible k) = 1`.  
     - Infeasible options (where alternative route capacity is exceeded) are forced to 0.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
capacity_main_normal = 4907 # ships/h
capacity_main_reduced = 1736 # ships/h
capacity_alt = 1552 # ships/h
arrival_rate_total = 3358 # ships/h
incident_duration = 1.6174803240064022 # h
alt_route_extra_time = 0.1665966380465123 # h
diversion_options = [0.1, 0.3, 0.5, 0.7] # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option ---
option_delays = {}
option_feasible = {}

for k in range(num_options):
    p_k = diversion_options[k]
    flow_alt_k = arrival_rate_total * p_k
    flow_main_k = arrival_rate_total * (1 - p_k)

    # 1. Check Alternative Route Capacity Feasibility
    if flow_alt_k > capacity_alt + EPSILON:
        option_feasible[k] = False
        option_delays[k] = LARGE_DELAY
        continue

    option_feasible[k] = True

    # 2. Calculate Alternative Route Delay
    delay_alt_k = flow_alt_k * incident_duration * alt_route_extra_time

    # 3. Calculate Main Route Queue Delay
    delay_queue_main_k = 0
    max_queue_main_k = 0

    if flow_main_k > capacity_main_reduced + EPSILON:
        max_queue_main_k = (flow_main_k - capacity_main_reduced) * incident_duration
        if flow_main_k >= capacity_main_normal - EPSILON:
            delay_queue_main_k = LARGE_DELAY
        else:
            dissipation_rate_k = capacity_main_normal - flow_main_k
            if dissipation_rate_k < EPSILON:
                 delay_queue_main_k = LARGE_DELAY
            else:
                 dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                 total_influence_time_k = incident_duration + dissipation_time_main_k
                 delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

    # 4. Calculate Total Delay for this option
    total_delay_k = delay_alt_k + delay_queue_main_k
    option_delays[k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("Port_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
feasible_indices = [k for k in range(num_options) if option_feasible[k]]
if not feasible_indices:
     exit()

m.addConstr(gp.quicksum(y[k] for k in feasible_indices) == 1, name="SelectOneFeasibleOption")

for k in range(num_options):
    if not option_feasible[k]:
        m.addConstr(y[k] == 0, name="ForbidInfeasibleOption_{0}".format(k))

# --- Objective Function ---
m.setObjective(gp.quicksum(y[k] * option_delays[k] for k in feasible_indices), GRB.MINIMIZE)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    chosen_option_index = -1
    chosen_diversion_ratio = -1.0
    for k in range(num_options):
        if k in feasible_indices and y[k].X > 0.5:
            chosen_option_index = k
            chosen_diversion_ratio = diversion_options[k]
            break

    if chosen_option_index != -1:
         print("Optimal Diversion Option: Index {0}, Ratio {1:.0f}%".format(chosen_option_index, chosen_diversion_ratio*100))
```
Answer:
Optimal Diversion Option: Index 1, Ratio 30%



================================================================================



--- Problem 18 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
A port terminal must optimize the berthing schedule for ships arriving from two different directions: North-South (NS) and East-West (EW). The terminal experiences an hourly demand of **714.54 ships from the NS approach** and **527.50 ships from the EW approach**. Each approach has a **saturation flow rate of 1,356.14 ships per hour per berth**, with **1.87 berths** available, translating to a total approach capacity of **2,538.37 ships per hour** (assuming full utilization).

The berthing schedule operates in a **two-phase cycle**, with each phase incurring a **lost time of 4.03 hours** due to clearance intervals and startup delays. The **minimum allowable cycle length is 76.65 hours**, while the **maximum is 105.27 hours**, ensuring reasonable ship wait times. Additionally, each phase must grant a **minimum green time of 18.87 hours** to allow safe berthing.

The challenge is to **maximize the terminal’s total throughput**—the sum of ships served per hour—while respecting these constraints. The optimization must carefully balance green time allocation between the NS and EW phases, ensuring neither direction is starved of capacity while adhering to the cycle length limits.

**Key Question:** *What is the optimal cycle length and green time split between the NS and EW phases to maximize the terminal’s total throughput, given the competing demands and operational constraints?*  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- **Cycle Length (C):** Total duration of the berthing cycle (hours), bounded between *C_min* and *C_max*.  
- **Green Time (g_NS, g_EW):** Active green time allocated to the NS and EW phases (hours), each ≥ *g_min_time*.  
- **Effective Green Ratios (λ_g_NS, λ_g_EW):** Fraction of the cycle dedicated to green time for each phase (λ = g/C).  
- **Capacities (Cap_NS, Cap_EW):** Hourly throughput for each approach (ships/hour), calculated as *S_fog_approach_h × λ_g*.  

**2. Parameters:**  
- **λ_NS_h = 714.54**, **λ_EW_h = 527.50**: Hourly ship demand for NS/EW.  
- **S_fog_lane_h = 1,356.14**, **N_lanes = 1.87**: Saturation flow rate and berth count.  
- **L_lost_time_per_phase = 4.03**: Lost time per phase (hours).  
- **C_min = 76.65**, **C_max = 105.27**: Cycle length bounds (hours).  
- **g_min_time = 18.87**: Minimum green time per phase (hours).  

**3. Objective Function:**  
Maximize total throughput:  
\[
\text{Maximize: } \text{Cap_NS} + \text{Cap_EW}  
\]  
where:  
\[
\text{Cap_NS} = S_{\text{fog\_approach\_h}} \times \lambda_{g\_NS}, \quad \text{Cap_EW} = S_{\text{fog\_approach\_h}} \times \lambda_{g\_EW}  
\]  

**4. Constraints:**  
- **Cycle Composition:** Total cycle equals green times plus lost times:  
  \[
  C = g_{\text{NS}} + g_{\text{EW}} + 2 \times L_{\text{lost\_time\_per\_phase}}  
  \]  
- **Effective Green Ratios:** Non-linear coupling of green time and cycle length:  
  \[
  \lambda_{g\_NS} \times C = g_{\text{NS}}, \quad \lambda_{g\_EW} \times C = g_{\text{EW}}  
  \]  
- **Capacity Definitions:** Throughput is proportional to green ratio.  
- **Bounds:**  
  \[
  C \in [C_{\text{min}}, C_{\text{max}}], \quad g_{\text{NS}}, g_{\text{EW}} \geq g_{\text{min\_time}}  
  \]  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
lambda_NS_h = 714.5390008657997  # ships/h
lambda_EW_h = 527.5034256803266  # ships/h
S_fog_lane_h = 1356.1383565656686  # ships/h/berth
N_lanes = 1.872076735368779
L_lost_time_per_phase = 4.029827870169466  # h
C_min = 76.64706403269997  # h
C_max = 105.27300914093217  # h
g_min_time = 18.871768503670022  # h

S_fog_approach_h = N_lanes * S_fog_lane_h

# --- Gurobi Model ---
model = gp.Model("BerthingSchedule")

# --- Decision Variables ---
C = model.addVar(name="CycleLength", lb=C_min, ub=C_max)
g_NS = model.addVar(name="Green_NS", lb=g_min_time) # Actual green time NS
g_EW = model.addVar(name="Green_EW", lb=g_min_time) # Actual green time EW

# --- Intermediate Variables ---
# Effective green ratios (lambda = g/C)
lambda_g_NS = model.addVar(name="lambda_g_NS", lb=0.0, ub=1.0) # g_NS / C
lambda_g_EW = model.addVar(name="lambda_g_EW", lb=0.0, ub=1.0) # g_EW / C
# Capacities
Cap_NS = model.addVar(name="Capacity_NS", lb=0.0)
Cap_EW = model.addVar(name="Capacity_EW", lb=0.0)

# --- Constraints ---
# 1. Cycle length composition (2 phases)
model.addConstr(C == g_NS + g_EW + 2 * L_lost_time_per_phase, name="CycleComposition")

# 2. Calculate effective green ratios (non-linear: lambda = g/C)
# lambda * C = g
model.addQConstr(lambda_g_NS * C == g_NS, name="CalcLambdaNS")
model.addQConstr(lambda_g_EW * C == g_EW, name="CalcLambdaEW")

# 3. Calculate approach capacities
# Cap = S * lambda_g
model.addConstr(Cap_NS == S_fog_approach_h * lambda_g_NS, name="CalcCapacityNS")
model.addConstr(Cap_EW == S_fog_approach_h * lambda_g_EW, name="CalcCapacityEW")

# --- Objective Function ---
# Maximize total throughput (sum of capacities)
model.setObjective(Cap_NS + Cap_EW, GRB.MAXIMIZE)

# --- Optimize ---
# Needs NonConvex capabilities due to quadratic constraints (g = lambda * C)
model.Params.NonConvex = 2
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL or model.status == GRB.SUBOPTIMAL:
    print(f"Optimization Status: {model.status}")
    print(f"Optimal Cycle Length (C): {C.X:.2f} h")
    print(f"Optimal Green Time NS (g_NS): {g_NS.X:.2f} h")
    print(f"Optimal Green Time EW (g_EW): {g_EW.X:.2f} h")
    print(f"  Total Green = {g_NS.X+g_EW.X:.2f}h, Lost Time = {2*L_lost_time_per_phase:.1f}h, Sum = {g_NS.X+g_EW.X+2*L_lost_time_per_phase:.2f}h (matches C)")
    print(f"Resulting Capacity NS: {Cap_NS.X:.2f} ships/h (Demand={lambda_NS_h})")
    print(f"Resulting Capacity EW: {Cap_EW.X:.2f} ships/h (Demand={lambda_EW_h})")
    print(f"Maximized Total Throughput: {model.objVal:.2f} ships/h")
    # Check if demand constraints were implicitly met
    if Cap_NS.X < lambda_NS_h: print("  Warning: NS Demand exceeds capacity.")
    if Cap_EW.X < lambda_EW_h: print("  Warning: EW Demand exceeds capacity.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
    model.computeIIS()
    model.write("model_iis.ilp")
    print("IIS written to model_iis.ilp")
elif model.status == GRB.INF_OR_UNBD:
     print("Optimization Status: Infeasible or Unbounded")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 3 rows, 7 columns and 7 nonzeros
Model fingerprint: 0xd4dbbba8
Model has 2 quadratic constraints
Coefficient statistics:
  Matrix range     [1e+00, 3e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [1e+00, 1e+02]
  RHS range        [8e+00, 8e+00]
Presolve removed 2 rows and 2 columns

Continuous model is non-convex -- solving as a MIP

Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolved: 9 rows, 6 columns, 27 nonzeros
Presolved model has 2 bilinear constraint(s)
Variable types: 6 continuous, 0 integer (0 binary)
Found heuristic solution: objective 2344.4260224

Root relaxation: objective 2.629182e+03, 3 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0 2629.18174    0    2 2344.42602 2629.18174  12.1%     -    0s
     0     0 2535.57464    0    2 2344.42602 2535.57464  8.15%     -    0s
     0     2 2535.57464    0    2 2344.42602 2535.57464  8.15%     -    0s

Explored 61 nodes (42 simplex iterations) in 0.02 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 2344.43 

Optimal solution found (tolerance 1.00e-04)
Best objective 2.344426022395e+03, best bound 2.344426022395e+03, gap 0.0000%

--- Optimization Results ---
Optimization Status: 2
Optimal Cycle Length (C): 105.27 h
Optimal Green Time NS (g_NS): 48.61 h
Optimal Green Time EW (g_EW): 48.61 h
  Total Green = 97.21h, Lost Time = 8.1h, Sum = 105.27h (matches C)
Resulting Capacity NS: 1172.21 ships/h (Demand=714.5390008657997)
Resulting Capacity EW: 1172.21 ships/h (Demand=527.5034256803266)
Maximized Total Throughput: 2344.43 ships/h



================================================================================



--- Problem 19 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port operates across three key berths: A, B, and C. Berth A currently has a surplus of 82 containers, while B faces a deficit of 35 containers, and C is short by 16 containers. To rebalance the system, the port must transport containers from A to B and C using a fleet of 4 cranes, each with a capacity of 25 containers. The logistics team faces a critical challenge: minimize the total transportation cost while ensuring all deficits are met. The cost to dispatch a crane to B is \$184, and to C is \$115. The goal is to determine how many cranes to send to each berth and how many containers to load onto them, ensuring no crane exceeds its capacity, the total number of cranes used does not exceed the fleet size, and the surplus at A is not exceeded. The central question is: What is the most cost-effective way to redistribute containers to eliminate the deficits at B and C?
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n_B`: Integer, number of cranes sent to B (0 ≤ `n_B` ≤ 4).  
     - `n_C`: Integer, number of cranes sent to C (0 ≤ `n_C` ≤ 4).  
     - `x_AB`: Integer, number of containers transported from A to B (≥ 0).  
     - `x_AC`: Integer, number of containers transported from A to C (≥ 0).  

   - **2. Parameters:**  
     - Surplus at A: 82 containers.  
     - Deficit at B: 35 containers.  
     - Deficit at C: 16 containers.  
     - Crane capacity: 25 containers.  
     - Fleet size: 4 cranes.  
     - Cost to B: \$184 per crane.  
     - Cost to C: \$115 per crane.  

   - **3. Objective Function:**  
     Minimize total cost: `184 * n_B + 115 * n_C`.  

   - **4. Constraints:**  
     - Total cranes used: `n_B + n_C ≤ 4`.  
     - Crane capacity (if capacity > 0):  
       - `x_AB ≤ 25 * n_B`.  
       - `x_AC ≤ 25 * n_C`.  
     - Supply limit at A: `x_AB + x_AC ≤ 82`.  
     - Demand fulfillment:  
       - `x_AB ≥ 35` (meet deficit at B).  
       - `x_AC ≥ 16` (meet deficit at C).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
surplus_A = 82
deficit_B = 35
deficit_C = 16
crane_capacity = 25
num_cranes = 4
cost_AB = 184
cost_AC = 115
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("CONTAINER_REDISTRIBUTION_COST", env=env)

    # --- Decision Variables ---
    # n_B: number of cranes going to B
    n_B = m.addVar(vtype=GRB.INTEGER, lb=0, ub=num_cranes, name="n_B")
    # n_C: number of cranes going to C
    n_C = m.addVar(vtype=GRB.INTEGER, lb=0, ub=num_cranes, name="n_C")
    # x_AB: number of containers transported from A to B
    x_AB = m.addVar(vtype=GRB.INTEGER, lb=0, name="x_AB")
    # x_AC: number of containers transported from A to C
    x_AC = m.addVar(vtype=GRB.INTEGER, lb=0, name="x_AC")

    # --- Objective Function: Minimize transportation cost ---
    m.setObjective(cost_AB * n_B + cost_AC * n_C, GRB.MINIMIZE)

    # --- Constraints ---
    # Total number of cranes used
    m.addConstr(n_B + n_C <= num_cranes, "TotalCranes")

    # Transported amount cannot exceed crane capacity
    # Handle crane_capacity = 0 case
    if crane_capacity > 0:
        m.addConstr(x_AB <= crane_capacity * n_B, "CapacityB")
        m.addConstr(x_AC <= crane_capacity * n_C, "CapacityC")
    else:
        # If capacity is 0, cannot transport containers
        m.addConstr(x_AB == 0, "CapacityB_Zero")
        m.addConstr(x_AC == 0, "CapacityC_Zero")

    # Transported amount cannot exceed surplus at A
    m.addConstr(x_AB + x_AC <= surplus_A, "SupplyA")

    # Transported amount must meet deficit (Original didn't require this, but realistic)
    # Making this optional based on original snippet focusing only on cost.
    # However, without a demand constraint, solution might be trivial (move 0 containers).
    # Let's assume the goal IS to meet demand if possible, while minimizing crane cost.
    # Add constraints to meet demand:
    m.addConstr(x_AB >= deficit_B, "MeetDemandB")
    m.addConstr(x_AC >= deficit_C, "MeetDemandC")
    # Note: The original snippet had these as upper bounds (<= deficit).
    # If the goal is just to minimize cost *given* fixed moves, the model changes.
    # Reverting to original snippet's logic (less realistic but matches code):
    # m.addConstr(x_AB <= deficit_B, "DemandB_Limit") # Limit containers moved
    # m.addConstr(x_AC <= deficit_C, "DemandC_Limit") # Limit containers moved
    # **Correction:** The goal is likely to meet demand *while* minimizing cost.
    # The model should try to fulfill demand. Keeping the >= constraints.

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_B_sol'] = n_B.X # Not needed for output
        # results_dict['n_C_sol'] = n_C.X
        # results_dict['x_AB_sol'] = x_AB.X
        # results_dict['x_AC_sol'] = x_AC.X

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
         print("Model is infeasible") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print missing outputs
if m.Status == GRB.OPTIMAL:
    print(f"Number of cranes sent to B: {n_B.X}")
    print(f"Number of cranes sent to C: {n_C.X}")
    print(f"Containers transported from A to B: {x_AB.X}")
    print(f"Containers transported from A to C: {x_AC.X}")
```
Answer:
Optimal objective value: 483.00
Number of cranes sent to B: 2.0
Number of cranes sent to C: 1.0
Containers transported from A to B: 35.0
Containers transported from A to C: 16.0


```

================================================================================



--- Problem 20 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently loading a fleet of 17 trucks onto four available loading docks (Dock_A, Dock_B, Dock_C, and Dock_D). Each truck has a specific weight and occupies a certain amount of space, both of which vary across the fleet. For instance, Truck 0 weighs 2.5 units and takes up 2.3 space units, while Truck 10 is lighter at 1.0 weight units but occupies only 0.9 space units. The docks themselves have strict limitations: Dock_A can hold up to 3.8 space units and 5.7 weight units, while Dock_B, the most spacious, allows 4.4 space units and 7.2 weight units. The challenge is to assign as many trucks as possible to the docks without exceeding these capacity constraints, ensuring that no truck is split across multiple docks. The logistics company must determine the optimal loading configuration to maximize the number of trucks transported while adhering to these physical and operational limits.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable \(x(i, d)\) for each truck \(i\) and dock \(d\), where \(x(i, d) = 1\) if truck \(i\) is assigned to dock \(d\), and \(0\) otherwise.  
   - **2. Parameters:**  
     - \(weights(i)\): Weight of truck \(i\) (e.g., \(weights(0) = 2.5\)).  
     - \(spaces(i)\): Space occupied by truck \(i\) (e.g., \(spaces(0) = 2.3\)).  
     - \(dock\_capacity(d)\): Maximum space capacity for dock \(d\) (e.g., \(dock\_capacity('Dock\_A') = 3.8\)).  
     - \(dock\_weight\_limit(d)\): Maximum weight capacity for dock \(d\) (e.g., \(dock\_weight\_limit('Dock\_B') = 7.2\)).  
   - **3. Objective Function:**  
     - Maximize the total number of trucks loaded:  
       \[
       \text{Maximize: } \sum_{i \in \text{trucks}} \sum_{d \in \text{docks}} x(i, d)
       \]  
   - **4. Constraints:**  
     - **Truck Assignment:** Each truck can be assigned to at most one dock:  
       \[
       \sum_{d \in \text{docks}} x(i, d) \leq 1 \quad \forall i \in \text{trucks}
       \]  
     - **Dock Space:** Total space used on each dock must not exceed its capacity:  
       \[
       \sum_{i \in \text{trucks}} spaces(i) \cdot x(i, d) \leq dock\_capacity(d) \quad \forall d \in \text{docks}
       \]  
     - **Dock Weight:** Total weight on each dock must not exceed its limit:  
       \[
       \sum_{i \in \text{trucks}} weights(i) \cdot x(i, d) \leq dock\_weight\_limit(d) \quad \forall d \in \text{docks}
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] # List of truck indices
weights = {0: 2.5, 1: 1.2, 2: 1.8, 3: 3.4, 4: 1.3, 5: 2.2, 6: 1.4, 7: 3.3, 8: 3.1, 9: 3.5, 10: 1.0, 11: 1.3, 12: 2.3, 13: 2.1, 14: 3.5, 15: 3.7, 16: 1.7}   # Dict: truck -> weight
spaces = {0: 2.3, 1: 1.1, 2: 1.1, 3: 2.3, 4: 1.2, 5: 2.3, 6: 1.1, 7: 2.4, 8: 1.9, 9: 1.9, 10: 0.9, 11: 1.1, 12: 1.9, 13: 2.4, 14: 2.0, 15: 2.1, 16: 1.1}     # Dict: truck -> space units
docks = ['Dock_A', 'Dock_B', 'Dock_C', 'Dock_D']       # List of dock names
dock_capacity = {'Dock_A': 3.8, 'Dock_B': 4.4, 'Dock_C': 4.4, 'Dock_D': 3.2} # Dict: dock -> space capacity
dock_weight_limit = {'Dock_A': 5.7, 'Dock_B': 7.2, 'Dock_C': 5.7, 'Dock_D': 4.2} # Dict: dock -> weight capacity
# --- End Parameters ---

GUROBI_TIME_LIMIT = 45

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("TRUCK_LOADING", env=env)

    # --- Basic Input Validation ---
    if not trucks or not docks:
        raise ValueError("Empty trucks or docks list")

    # --- Decision Variables ---
    # x[i, d] = 1 if truck i is loaded onto dock d
    load_keys = [(i, d) for i in trucks for d in docks]
    x = m.addVars(load_keys, vtype=GRB.BINARY, name="x")

    # --- Objective Function: Maximize the number of trucks loaded ---
    m.setObjective(gp.quicksum(x[i, d] for i, d in load_keys), GRB.MAXIMIZE)

    # --- Constraints ---
    # Each truck can be assigned to at most one dock
    m.addConstrs((gp.quicksum(x[i, d] for d in docks) <= 1 for i in trucks), "TruckAssignment")

    # Dock capacity constraints
    for d in docks:
        dock_space_cap = dock_capacity.get(d, 0)
        dock_weight_cap = dock_weight_limit.get(d, 0)

        # Space constraint
        m.addConstr(gp.quicksum(spaces.get(i, 0) * x[i, d] for i in trucks) <= dock_space_cap, f"Dock_{d}_Space")
        # Weight constraint
        m.addConstr(gp.quicksum(weights.get(i, 0) * x[i, d] for i in trucks) <= dock_weight_cap, f"Dock_{d}_Weight")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Objective value is the number of trucks, should be integer-like
        if isinstance(obj_val_print, (int, float)):
             # Use round() before int() for safety with potential float results
             print(f"Optimal objective value: {int(round(obj_val_print))}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the assignment of trucks to docks
if m.Status == GRB.OPTIMAL:
    for d in docks:
        assigned_trucks = [i for i in trucks if x[i, d].X > 0.5]
        if assigned_trucks:
            print(f"Trucks assigned to {d}: {assigned_trucks}")
```
Answer:
Optimal objective value: 11
Trucks assigned to Dock_A: [8, 12]
Trucks assigned to Dock_B: [9, 14]
Trucks assigned to Dock_C: [1, 6, 11, 16]
Trucks assigned to Dock_D: [2, 4, 10]


```

================================================================================



--- Problem 21 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
At a busy port, the operations team is tasked with scheduling the berthing times for four different ships to minimize the total waiting time. Each ship has a specific number of containers that need to be loaded or unloaded: Ship 1 handles 1,315 containers, Ship 2 handles 855 containers, Ship 3 handles 1,081 containers, and Ship 4 handles 374 containers. The berthing times for each ship must be allocated within strict bounds—no less than 18 minutes and no more than 95 minutes—while ensuring the total berthing cycle time (the sum of all berthing times) matches the fixed upper limit of 95 minutes. The core challenge is to distribute these berthing times strategically, minimizing the cumulative waiting time experienced by all ships, where the waiting time for each ship is proportional to its container load multiplied by its non-berthing time (the cycle time minus its berthing time). The question at hand: *What is the optimal allocation of berthing times across the four ships to minimize total waiting time while adhering to the cycle time constraint?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - \( t_i \): Continuous variable representing the berthing time (in minutes) allocated to ship \( i \), where \( i \in \{1, 2, 3, 4\} \).  
     - Bounds: \( 18 \leq t_i \leq 95 \) for each ship.  

   - **2. Parameters:**  
     - \( \text{container_loads} = [1315, 855, 1081, 374] \): Container loads for each ship.  
     - \( \text{cycle_time} = 95 \): Total fixed cycle time (minutes).  
     - \( \text{lb_time} = 18 \), \( \text{ub_time} = 95 \): Lower/upper bounds for berthing times.  

   - **3. Objective Function:**  
     Minimize total waiting time:  
     \[
     \text{Minimize: } \sum_{i=1}^{4} \text{container_loads}[i-1] \times (\text{cycle_time} - t_i)
     \]  

   - **4. Constraints:**  
     - **Cycle time constraint:** The sum of berthing times must equal the total cycle time:  
       \[
       t_1 + t_2 + t_3 + t_4 = 95
       \]  
     - **Variable bounds:** \( t_i \geq 18 \) and \( t_i \leq 95 \) for all \( i \).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_ships = 4
lb_time = 18          # Lower bound for berthing time
ub_time = 95          # Upper bound for berthing time
cycle_time = 95   # Total cycle time (set equal to ub_time)
container_loads = [1315, 855, 1081, 374] # Container loads per ship
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(container_loads) != num_ships:
    print("Error: container_loads length mismatch with num_ships")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: container_loads length"
    # raise ValueError("container_loads length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_ships}-Ship Berthing Scheduling", env=env)

        # --- Decision variables (dynamic based on num_ships) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_ships, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for ship i is proportional to container_load * non-berthing_time = container_load * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(container_loads[i] * (cycle_time - t_vars[i]) for i in range(num_ships)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_ships)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_ships)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_ships):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
Optimal total waiting time: 248880.00
------------------------------
Optimal berthing times (minutes):
  t1: 41.00, t2: 18.00, t3: 18.00, t4: 18.00



================================================================================



--- Problem 22 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling two delivery trucks (Truck 1 and Truck 2) to a single loading dock while adhering to strict operational constraints. Truck 1 arrives at 3 hours and requires 5 hours for unloading, while Truck 2 arrives at 8 hours and needs 8 hours of processing. The hub must also accommodate a critical maintenance window from hour 13 to hour 18, during which the loading dock is unavailable. The goal is to sequence the trucks' loading times to minimize the total completion time (makespan) while ensuring neither truck overlaps with maintenance or violates arrival time constraints. The challenge lies in determining whether to schedule both trucks before maintenance, after maintenance, or split them around the maintenance window to achieve the shortest possible makespan.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary variable (1 if truck *i* is assigned to loading dock *j*, else 0).  
   - `start_time[i]`: Continuous variable for the start time of truck *i*.  
   - `completion_time[i]`: Continuous variable for the completion time of truck *i*.  
   - `precedes[i, k, j]`: Binary variable (1 if truck *i* is scheduled before truck *k* on loading dock *j*, else 0).  
   - `makespan`: Continuous variable representing the total completion time.  
   - `b[i]`: Binary variable (1 if truck *i* is scheduled before maintenance, else 0).  

   **2. Parameters:**  
   - `trucks = [1, 2]`, `docks = [1]`.  
   - Arrival times: `{1: 3, 2: 8}`.  
   - Processing times: `{1: 5, 2: 8}`.  
   - Maintenance window: `maint_start = 13`, `maint_end = 18`.  
   - Big M: `H = 100`.  

   **3. Objective Function:**  
   Minimize `makespan`.  

   **4. Constraints:**  
   - Each truck is assigned to the loading dock: `assign[i, 1] = 1` for all *i*.  
   - Start time cannot precede arrival: `start_time[i] >= arrival_times[i]`.  
   - Completion time calculation: `completion_time[i] = start_time[i] + processing_times[i]`.  
   - Non-overlapping trucks: For *i < k*, enforce `start_time[k] >= completion_time[i]` if `precedes[i, k, 1] = 1`, else `start_time[i] >= completion_time[k]`.  
   - Maintenance disjunction:  
     - If `b[i] = 1`, truck *i* must finish by `maint_start`: `completion_time[i] <= maint_start + H * b[i]`.  
     - If `b[i] = 0`, truck *i* must start after `maint_end`: `start_time[i] >= maint_end - H * (1 - b[i])`.  
   - Makespan definition: `makespan >= completion_time[i]` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2]
docks = [1] # Should be [1]
arrival_times = {1: 3, 2: 8}
processing_times = {1: 5, 2: 8}
maint_start = 13
maint_end = 18
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("LOADING_DOCK_PROBLEM_6_MAINTENANCE")

    if not trucks or not docks or len(docks)!=1: raise ValueError("Invalid trucks/docks")
    the_dock = docks[0]

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    b = m.addVars(trucks, vtype=GRB.BINARY, name="maint_choice") # For disjunction

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_dock] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (using Indicators)
    j = the_dock
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j])) # Link precedence if both assigned (always true here)

    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. Maintenance window constraint
    for i in trucks:
         m.addConstr(completion_time[i] <= maint_start + H * b[i], name=f"maint_before_{i}")
         m.addConstr(start_time[i] >= maint_end - H * (1 - b[i]), name=f"maint_after_{i}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal makespan: {results_dict['obj_val']:.4f}")
    for i in trucks:
        print(f"Truck {i} start time: {start_time[i].x:.4f}, completion time: {completion_time[i].x:.4f}")
        if b[i].x > 0.5:
            print(f"Truck {i} is scheduled before maintenance.")
        else:
            print(f"Truck {i} is scheduled after maintenance.")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
26.0000
Optimal makespan: 26.0000
Truck 1 start time: 3.0000, completion time: 8.0000
Truck 1 is scheduled after maintenance.
Truck 2 start time: 18.0000, completion time: 26.0000
Truck 2 is scheduled before maintenance.


```

================================================================================



--- Problem 23 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy container terminal is facing the challenge of efficiently allocating 92 incoming trucks to its three available loading docks (Docks A, B, and C). Each dock has limited remaining capacity: Dock A can accommodate 19 more trucks, Dock B has 38 empty slots, and Dock C offers 35 available spaces. The terminal incurs varying costs to direct trucks to each dock—$3 per truck for Dock A, $4 for Dock B, and a steeper $12 for Dock C, reflecting higher operational expenses or distance. The terminal manager must assign all arriving trucks to these docks without exceeding any dock's remaining capacity while minimizing the total direction cost. The core question is: *How should the trucks be distributed across the three docks to achieve the lowest possible total cost?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( n_i \) represent the number of trucks assigned to dock \( i \) (where \( i \in \{A, B, C\} \)). Each \( n_i \) is a non-negative integer.  
   - **2. Parameters:**  
     - \( \text{empty_slots}_i \): Available slots per dock (19, 38, 35 for Docks A, B, C).  
     - \( \text{direction_cost}_i \): Cost per truck directed to dock \( i \) (3, 4, 12).  
     - \( \text{arriving_trucks} = 92 \): Total trucks to assign.  
   - **3. Objective Function:**  
     - Minimize the total direction cost:  
       \[ \text{Minimize: } 3n_A + 4n_B + 12n_C \]  
   - **4. Constraints:**  
     - **Total trucks assigned:** \( n_A + n_B + n_C = 92 \).  
     - **Dock capacity limits:**  
       - \( n_A \leq 19 \),  
       - \( n_B \leq 38 \),  
       - \( n_C \leq 35 \).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
docks = ['A', 'B', 'C']
capacity = {'A': 78, 'B': 76, 'C': 120} # For context
empty_slots = {'A': 19, 'B': 38, 'C': 35}
arriving_trucks = 92
direction_cost = {'A': 3, 'B': 4, 'C': 12} # Cost per truck directed to dock i
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("TRUCK_DOCK_DIRECTION", env=env)

    # --- Input Validation ---
    if not docks: raise ValueError("Empty docks list")
    if arriving_trucks < 0: raise ValueError("Arriving trucks cannot be negative")
    if sum(empty_slots.get(i, 0) for i in docks) < arriving_trucks:
        # This case should be prevented by generator, but double-check
        print("Warning: Total empty slots less than arriving trucks, likely infeasible.")
        # raise ValueError("Total empty slots less than arriving trucks")

    # --- Decision Variables ---
    # n[i]: number of trucks assigned to dock i
    n = m.addVars(docks, vtype=GRB.INTEGER, lb=0, name="n")

    # --- Objective Function: Minimize total direction cost ---
    m.setObjective(gp.quicksum(direction_cost.get(i, 0) * n[i] for i in docks), GRB.MINIMIZE)

    # --- Constraints ---
    # Total number of assigned trucks must equal arriving trucks
    m.addConstr(gp.quicksum(n[i] for i in docks) == arriving_trucks, "TotalTrucks")

    # Number of assigned trucks cannot exceed empty slots on each dock
    m.addConstrs((n[i] <= empty_slots.get(i, 0) for i in docks), "DockCapacity")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_sol'] = m.getAttr('X', n) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible. Not enough total capacity for arriving trucks.") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the number of trucks assigned to each dock
if m.Status == GRB.OPTIMAL:
    for i in docks:
        print(f"Number of trucks assigned to Dock {i}: {n[i].X}")
```
Answer:
Optimal objective value: 629.00
Number of trucks assigned to Dock A: 19.0
Number of trucks assigned to Dock B: 38.0
Number of trucks assigned to Dock C: 35.0


```

================================================================================



--- Problem 24 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port with four berths is experiencing recurring maintenance activities, each reducing the capacity of the main berth while increasing congestion. Port managers must dynamically divert ships to alternative berths during these maintenance periods to minimize total delay. Each berth has distinct characteristics: normal and reduced main berth capacities (e.g., Berth 1 handles 4,388 ship/h normally but drops to 1,672 ship/h during maintenance), alternative berth capacities (e.g., 1,982 ship/h for Berth 1), and maintenance durations (e.g., 1.31 hours for Berth 1). Ships diverted to alternative berths face extra handling times (e.g., 0.29 hours for Berth 1). Over six 30-minute time periods, arrival rates fluctuate (e.g., Berth 1 sees 4,303 ship/h in Period 1). Managers can choose from four diversion ratios (10%, 30%, 50%, or 70%) per berth and period, but must ensure alternative flows do not exceed capacities. The challenge is to determine the optimal diversion strategy for each berth and time period to minimize the cumulative delay—balancing queue delays on the main berth against extra handling times on alternatives—while respecting feasibility constraints.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Binary variable \( y(i,t,k) \) equals 1 if diversion option \( k \) (e.g., 10%, 30%) is selected for berth \( i \) in time period \( t \), else 0.  
   - **2. Parameters:**  
     - \( \text{arrival_rates}[i][t] \): Ships arriving at berth \( i \) in period \( t \) (e.g., 4,303 ship/h for Berth 1, Period 1).  
     - \( \text{capacities_main_normal}[i], \text{capacities_main_reduced}[i] \): Main berth capacities under normal/maintenance conditions.  
     - \( \text{capacities_alt}[i] \): Alternative berth capacity (e.g., 1,982 ship/h for Berth 1).  
     - \( \text{alt_berth_extra_times}[i] \): Additional handling time for alternative berths (e.g., 0.29 hours for Berth 1).  
     - \( \text{diversion_options}[k] \): Available diversion ratios (0.1, 0.3, 0.5, 0.7).  
   - **3. Objective Function:**  
     Minimize total delay:  
     \[
     \sum_{i,t,k} y(i,t,k) \cdot \left( \text{delay_alt}_k + \text{delay_queue_main}_k \right),
     \]  
     where delays are precomputed based on flow-capacity mismatches and dissipation rates.  
   - **4. Constraints:**  
     - **Feasibility:** For each berth \( i \) and period \( t \), exactly one feasible diversion option \( k \) must be selected (if any exist).  
     - **Infeasibility:** \( y(i,t,k) = 0 \) if the option \( k \) violates alternative berth capacity.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 4
NUM_TIME_PERIODS = 6
TIME_PERIOD_LENGTH = 0.5  # h
capacities_main_normal = [4388, 5670, 4391, 5196]  # ship/h
capacities_main_reduced = [1672, 3800, 2070, 2529]  # ship/h
capacities_alt = [1982, 1692, 1303, 914]  # ship/h
arrival_rates = [[4303, 2027, 4980, 3271, 4647, 4755], [2396, 4446, 4823, 2369, 4564, 3016], [4619, 2796, 3760, 3706, 3781, 3171], [3145, 4089, 3983, 3619, 3050, 3378]]  # ship/h
maintenance_durations = [1.305755418324112, 1.41117982280426, 1.8544505966972231, 1.0446863976562668]  # h
alt_berth_extra_times = [0.2857991317091115, 0.31056727229795167, 0.12335614394101237, 0.08909836002306849]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:

Berth 1:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 2 (50%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)

Berth 2:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)

Berth 3:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)

Berth 4:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)



================================================================================



--- Problem 25 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
A port is tasked with efficiently scheduling 10 ships for berthing at a set of standardized docks. Each dock has a fixed width of 7 units and length of 29 units, and the goal is to minimize the number of docks used while ensuring no ships overlap and all fit within their assigned dock’s boundaries. The ships vary significantly in size—some are long and narrow (e.g., 2x28), while others are compact (e.g., 3x4) or wide but short (e.g., 7x25). The challenge is to arrange these ships spatially within the docks to avoid wasted space, a common pain point in port operations where inefficient berthing leads to higher operational costs and delayed schedules. The central question: *What is the smallest number of docks required to berth all ships without violating placement rules, and where should each ship be positioned within those docks?*

**Modeling Process:**
**
**1. Decision Variables:**  
    - Binary `x[i, j]`: 1 if ship *i* is assigned to dock *j*, else 0.  
    - Binary `y[j]`: 1 if dock *j* is used, else 0.  
    - Continuous `px[i, j]`, `py[i, j]`: Bottom-left coordinates of ship *i* in dock *j*.  
    - Auxiliary binary variables (`left`, `right`, `below`, `above`) enforce non-overlapping for ship pairs in the same dock.  

    **2. Parameters:**  
    - `ships`: List of ship dimensions (e.g., (7,25) for ship 0).  
    - `dock_size`: (7, 29) for width and length.  
    - `num_ships = 10`, `num_docks = 10` (worst-case upper bound).  

    **3. Objective Function:**  
    Minimize total docks used:  
    `Minimize: sum(y[j] for all j)`  

    **4. Constraints:**  
    - **Assignment:** Each ship *i* must be in exactly one dock:  
      `sum(x[i, j] for all j) = 1` for all *i*.  
    - **Dock Boundaries:** Ship *i*’s right/top edges must not exceed dock dimensions if placed in dock *j*:  
      `px[i, j] + width_i ≤ 7` and `py[i, j] + length_i ≤ 29` (enforced via Big-M when `x[i, j] = 1`).  
    - **Non-Overlapping:** For any two ships (*i*, *k*) in the same dock *j*, at least one of the four relative positioning conditions must hold (left/right/below/above).  
    - **Dock Activation:** If any ship *i* is in dock *j*, `y[j]` must be 1: `x[i, j] ≤ y[j]` for all *i*, *j*.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum

# --- Data Definition ---
ships = [(7, 25), (4, 9), (4, 15), (2, 28), (3, 6), (5, 8), (3, 4), (5, 29), (2, 27), (4, 5)]  # (width, length) of ships
dock_size = (7, 29)  # (width, length) of each dock
num_ships = 10  # len(ships)
# Maximum docks needed (worst case: one ship per dock)
# Can sometimes be reduced with lower bounds, but num_ships is safe
num_docks = num_ships
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {}  # Define if not passed

results_dict['status'] = None  # Default status

# Big-M values (using dock dimensions is common and valid)
M_w = dock_size[0]
M_h = dock_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Dock Scheduling", env=env)

# --- Decision Variables ---
# x[i,j]: ship i assigned to dock j
x = model.addVars(num_ships, num_docks, vtype=GRB.BINARY, name="x")
# y[j]: dock j is used
y = model.addVars(num_docks, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of ship i if in dock j
px = model.addVars(num_ships, num_docks, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_ships, num_docks, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of ships *within the same dock*
left  = model.addVars(num_ships, num_ships, num_docks, vtype=GRB.BINARY, name="left")
right = model.addVars(num_ships, num_ships, num_docks, vtype=GRB.BINARY, name="right")
below = model.addVars(num_ships, num_ships, num_docks, vtype=GRB.BINARY, name="below")
above = model.addVars(num_ships, num_ships, num_docks, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of docks used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)  # Same as quicksum(y[j] for j in range(num_docks))

# --- Constraints ---

# 1. Each ship must be assigned to exactly one dock
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Ship placement constraints within dock boundaries (Big-M formulation)
for j in range(num_docks):
    for i in range(num_ships):
        ship_w, ship_l = ships[i]  # Get dimensions for ship i

        # Position variables must be 0 if ship i is not in dock j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Ship's right edge <= dock width IF ship is placed in dock (x[i,j]=1)
        model.addConstr(px[i, j] + ship_w <= dock_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Ship's top edge <= dock length IF ship is placed in dock (x[i,j]=1)
        model.addConstr(py[i, j] + ship_l <= dock_size[1] + M_h * (1 - x[i, j]), name=f"Length_Limit_{i}_{j}")

# 3. Non-overlapping constraints for ships within the same dock
for j in range(num_docks):
    for i in range(num_ships):
        for k in range(i + 1, num_ships):  # Iterate over distinct pairs (i < k)
            ship_i_w, ship_i_l = ships[i]
            ship_k_w, ship_k_l = ships[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => ship i is to the left of ship k
            model.addConstr(px[i, j] + ship_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => ship i is to the right of ship k (k is left of i)
            model.addConstr(px[k, j] + ship_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => ship i is below ship k
            model.addConstr(py[i, j] + ship_i_l <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => ship i is above ship k (k is below i)
            model.addConstr(py[k, j] + ship_k_l <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH ship i and ship k are in dock j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link ship assignment to dock usage: If any ship i is in dock j, then dock j must be used (y[j]=1)
#    This can be done per ship or aggregated. Per ship is often tighter.
for j in range(num_docks):
    for i in range(num_ships):
        model.addConstr(x[i, j] <= y[j], name=f"Ship_Dock_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_ships * y[j], name=f"Dock_Activation_{j}")


# --- Solve ---
print("Solving 2D Dock Scheduling instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1  # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2  # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of docks used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    dock_details = []  # Store details for potential use by caller if needed
    for j_sol in range(num_docks):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Dock {j_sol + 1} (Used):")
            ships_in_dock_info = []
            for i_sol in range(num_ships):
                if x[i_sol, j_sol].X > 0.5:
                    ship_data = {
                        "id": i_sol,
                        "dims": ships[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    ships_in_dock_info.append(ship_data)
                    print(f"  Ship {ship_data['id']} {ship_data['dims']} at {ship_data['pos']}")
            dock_details.append({'dock_index': j_sol, 'ships': ships_in_dock_info})
            print("-" * 10)
    results_dict['dock_details'] = dock_details  # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
    print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
    print("\nOptimization stopped due to time limit.")
    if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
    else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 2D Dock Scheduling instance...
Gurobi Error code 10010: Model too large for size-limited license; visit https://gurobi.com/unrestricted for more information

Optimization finished with status: -1. No optimal solution found.


```

================================================================================



--- Problem 26 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A sudden storm has disrupted the operations at a major port, forcing the port authorities to reroute incoming ships to alternative berths. The situation demands a strategic decision to minimize the total delay experienced by affected ships. Two alternative berths are available: Berth 1, with a base capacity of 2,363 ships per hour and an additional handling time of 0.138 hours per ship, and Berth 2, with a base capacity of 3,019 ships per hour and an extra 0.187 hours per ship. A signal boost can increase these capacities by 18.06%, but deploying it comes with logistical trade-offs.

Additionally, some ships (534.6 ships/h) may be allowed to use local waterways, bypassing the need for rerouting entirely. The storm is expected to last 2.725 hours, and the total affected demand is 3,667.5 ships per hour. The challenge is to select the best rerouting strategy—balancing capacity, delays, and signal boost usage—to minimize the cumulative delay across all rerouted ships.

The core question is: **Which rerouting strategy—whether enforcing full rerouting, allowing local traffic, or applying signal boosts—achieves the smallest total delay in ship-hours?**

---

**Modeling Process:**
**
1. Decision Variables:**  
- Binary variable `y(s)` for each strategy `s` (1 to 4), where `y(s) = 1` if strategy `s` is selected, else `0`.  

**2. Parameters:**  
- `T_event_h = 2.725`: Duration of the storm (hours).  
- `Lambda_affected = 3667.5`: Total affected demand (ships/h).  
- `Lambda_local_allowed = 534.6`: Ships permitted on local waterways (ships/h).  
- `C1_base = 2363`, `C2_base = 3019`: Base capacities of Berths 1 and 2 (ships/h).  
- `T_extra1_h = 0.138`, `T_extra2_h = 0.187`: Additional handling times for Berths 1 and 2 (hours).  
- `Signal_boost_factor = 1.1806`: Capacity multiplier if signal boost is applied.  

**3. Objective Function:**  
Minimize the total rerouting delay:  
```
Minimize: sum(y(s) * delay(s) for all strategies s)
```
where `delay(s)` is the precomputed delay for strategy `s` (in ship-h).  

**4. Constraints:**  
- **Single Strategy Selection:** Exactly one strategy must be chosen:  
  `sum(y(s) for all s) = 1`.  

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
T_event_h = 2.725212654684718
Lambda_affected = 3667.4683062762792
Lambda_local_allowed = 534.6011790238073

# Alt Berth 1
C1_base = 2363.075298483715
T_extra1_h = 0.13804649101937236
# Alt Berth 2
C2_base = 3019.1596090106295
T_extra2_h = 0.1872699036555608

Signal_boost_factor = 1.1806110195342125

# Define Strategies
strategies_def = {
    1: ("Force All Reroute, No Boost", False, False),
    2: ("Force All Reroute, Boost", False, True),
    3: ("Allow Local, No Boost", True, False),
    4: ("Allow Local, Boost", True, True),
}
strategy_ids = list(strategies_def.keys())

# --- Calculate delay for each strategy ---
strategy_delays = {}
print("--- Total Delay Calculation per Strategy ---")

for s_id in strategy_ids:
    desc, local_allowed, signal_boost = strategies_def[s_id]

    lambda_reroute = Lambda_affected
    if local_allowed:
        lambda_reroute = Lambda_affected - Lambda_local_allowed

    C1 = C1_base * Signal_boost_factor if signal_boost else C1_base
    C2 = C2_base * Signal_boost_factor if signal_boost else C2_base
    Total_Alt_Cap = C1 + C2

    total_delay_s = 0
    flow1 = 0
    flow2 = 0
    unserved = 0

    print(f" Strategy {s_id} ({desc}):")
    print(f"  Rerouted Demand = {lambda_reroute:.0f} ships/h")
    print(f"  Alt1 Cap = {C1:.0f}, Alt2 Cap = {C2:.0f}, Total Alt Cap = {Total_Alt_Cap:.0f}")

    if lambda_reroute > Total_Alt_Cap:
        print("  Warning: Rerouted demand exceeds total alternative capacity!")
        total_delay_s = float('inf')
        unserved = lambda_reroute - Total_Alt_Cap
        flow1 = C1
        flow2 = C2
    else:
        flow1 = min(lambda_reroute, C1)
        flow2 = min(lambda_reroute - flow1, C2)
        unserved = lambda_reroute - flow1 - flow2

        delay1 = flow1 * T_extra1_h
        delay2 = flow2 * T_extra2_h
        total_delay_s = (delay1 + delay2) * T_event_h

    strategy_delays[s_id] = total_delay_s
    print(f"  Flow Alt1 = {flow1:.0f}, Flow Alt2 = {flow2:.0f}, Unserved = {unserved:.0f}")
    print(f"  Estimated Total Rerouting Delay = {total_delay_s:.2f} ship-h")
    if local_allowed: print(f"  (Ignoring delay for {Lambda_local_allowed} ships/h local traffic)")

# --- Gurobi Model ---
model = gp.Model("StormReroutingStrategy")

# --- Decision Variables ---
y = model.addVars(strategy_ids, vtype=GRB.BINARY, name="ChooseStrategy")

# --- Constraints ---
model.addConstr(gp.quicksum(y[s] for s in strategy_ids) == 1, name="SelectOneStrategy")

# --- Objective Function ---
objective = gp.LinExpr()
for s_id in strategy_ids:
    delay = strategy_delays[s_id]
    if delay == float('inf'):
        delay = 1e12
    objective += y[s_id] * delay
model.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    chosen_strategy_id = -1
    for s_id in strategy_ids:
        if y[s_id].X > 0.9:
            chosen_strategy_id = s_id
            break

    if chosen_strategy_id != -1:
         desc, _, _ = strategies_def[chosen_strategy_id]
         print(f"Optimal Strategy: ID {chosen_strategy_id} ({desc})")
         min_delay_val = model.objVal
         if min_delay_val >= 1e11:
              print(f" Minimum Total Delay: Infeasible / Extremely Large (Demand exceeds capacity)")
         else:
              print(f" Minimum Total Rerouting Delay: {model.objVal:.2f} ship-hours")
    else:
         print("Error: No strategy selected.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- Total Delay Calculation per Strategy ---
 Strategy 1 (Force All Reroute, No Boost):
  Rerouted Demand = 3667 ships/h
  Alt1 Cap = 2363, Alt2 Cap = 3019, Total Alt Cap = 5382
  Flow Alt1 = 2363, Flow Alt2 = 1304, Unserved = 0
  Estimated Total Rerouting Delay = 1554.70 ship-h
 Strategy 2 (Force All Reroute, Boost):
  Rerouted Demand = 3667 ships/h
  Alt1 Cap = 2790, Alt2 Cap = 3564, Total Alt Cap = 6354
  Flow Alt1 = 2790, Flow Alt2 = 878, Unserved = 0
  Estimated Total Rerouting Delay = 1497.45 ship-h
 Strategy 3 (Allow Local, No Boost):
  Rerouted Demand = 3133 ships/h
  Alt1 Cap = 2363, Alt2 Cap = 3019, Total Alt Cap = 5382
  Flow Alt1 = 2363, Flow Alt2 = 770, Unserved = 0
  Estimated Total Rerouting Delay = 1281.87 ship-h
  (Ignoring delay for 534.6011790238073 ships/h local traffic)
 Strategy 4 (Allow Local, Boost):
  Rerouted Demand = 3133 ships/h
  Alt1 Cap = 2790, Alt2 Cap = 3564, Total Alt Cap = 6354
  Flow Alt1 = 2790, Flow Alt2 = 343, Unserved = 0
  Estimated Total Rerouting Delay = 1224.61 ship-h
  (Ignoring delay for 534.6011790238073 ships/h local traffic)
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 4 columns and 4 nonzeros
Model fingerprint: 0xe09d6dfa
Variable types: 0 continuous, 4 integer (4 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [1e+03, 2e+03]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 1554.7005879
Presolve removed 1 rows and 4 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 2: 1224.61 1554.7 

Optimal solution found (tolerance 1.00e-04)
Best objective 1.224614280161e+03, best bound 1.224614280161e+03, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Strategy: ID 4 (Allow Local, Boost)
 Minimum Total Rerouting Delay: 1224.61 ship-hours



================================================================================



--- Problem 27 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy container terminal is tasked with maximizing revenue while efficiently using limited space and adhering to strict operational constraints. The terminal has a total capacity of 82 TEUs (Twenty-foot Equivalent Units), where each 20-foot container consumes 1 TEU and each 40-foot container requires 2 TEUs. Additionally, the terminal can handle no more than 89 containers in total.

On this particular day, 33 20-foot containers and 46 40-foot containers are waiting to be loaded, each contributing differently to the terminal’s profitability: 20-foot containers generate $64 in profit, while 40-foot containers yield a significantly higher $448 each. The terminal manager must decide how many 20-foot and 40-foot containers to load to maximize total profit without exceeding the terminal’s TEU or container limits.

The core question is: *What is the optimal combination of 20-foot and 40-foot containers to load onto the terminal to achieve the highest possible profit while respecting all capacity constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x_20ft`: Integer, representing the number of 20-foot containers loaded (≥ 0).  
     - `x_40ft`: Integer, representing the number of 40-foot containers loaded (≥ 0).  

   - **2. Parameters:**  
     - `teu_capacity = 82`: Total TEU capacity of the terminal.  
     - `teu_per_20ft = 1`: TEUs consumed per 20-foot container.  
     - `teu_per_40ft = 2`: TEUs consumed per 40-foot container.  
     - `max_containers = 89`: Maximum total containers allowed.  
     - `profit_per_20ft = 64`: Profit ($) per 20-foot container loaded.  
     - `profit_per_40ft = 448`: Profit ($) per 40-foot container loaded.  
     - `waiting_20ft = 33`: Available 20-foot containers waiting to be loaded.  
     - `waiting_40ft = 46`: Available 40-foot containers waiting to be loaded.  

   - **3. Objective Function:**  
     Maximize total profit:  
     `Maximize: (profit_per_20ft * x_20ft) + (profit_per_40ft * x_40ft)`  

   - **4. Constraints:**  
     - TEU capacity: `(1 * x_20ft) + (2 * x_40ft) ≤ 82`  
     - Total container limit: `x_20ft + x_40ft ≤ 89`  
     - 20-foot container availability: `x_20ft ≤ 33`  
     - 40-foot container availability: `x_40ft ≤ 46`  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
teu_capacity = 82; teu_per_20ft = 1; teu_per_40ft = 2
max_containers = 89; profit_per_20ft = 64; profit_per_40ft = 448
waiting_20ft = 33; waiting_40ft = 46
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m7 = gp.Model("Container_Terminal_IP", env=env)
    # Vars
    x_20ft = m7.addVar(vtype=GRB.INTEGER, name="num_20ft_loaded", lb=0)
    x_40ft = m7.addVar(vtype=GRB.INTEGER, name="num_40ft_loaded", lb=0)
    # Objective
    m7.setObjective(profit_per_20ft * x_20ft + profit_per_40ft * x_40ft, sense=GRB.MAXIMIZE)
    # Constraints
    m7.addConstr(teu_per_20ft * x_20ft + teu_per_40ft * x_40ft <= teu_capacity, "teu_capacity")
    m7.addConstr(x_20ft + x_40ft <= max_containers, "total_container_limit")
    m7.addConstr(x_20ft <= waiting_20ft, "20ft_availability")
    m7.addConstr(x_40ft <= waiting_40ft, "40ft_availability")
    # Optimize
    m7.optimize()
    # Store results
    results_dict['status'] = m7.status
    if m7.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m7.objVal; results_dict['x_20ft_opt'] = x_20ft.X; results_dict['x_40ft_opt'] = x_40ft.X
    # Output Results
    print("--- Problem 7: Container Terminal (20ft vs. 40ft) (IP) ---")
    if m7.status == GRB.OPTIMAL:
        x20 = results_dict.get('x_20ft_opt', 0); x40 = results_dict.get('x_40ft_opt', 0)
        print(f"Optimization Status: Optimal"); print(f"Optimal number of 20-foot containers to load: {int(round(x20))}")
        print(f"Optimal number of 40-foot containers to load: {int(round(x40))}"); print(f"Total TEU used: {teu_per_20ft * x20 + teu_per_40ft * x40:.1f} / {teu_capacity}")
        print(f"Total containers loaded: {int(round(x20 + x40))} / {max_containers}"); print(f"Maximum total profit: ${m7.objVal:.2f}")
    else: print(f"Optimization Status: {m7.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of CONTAINER_TERMINAL
```
Answer:
--- Problem 7: Container Terminal (20ft vs. 40ft) (IP) ---
Optimization Status: Optimal
Optimal number of 20-foot containers to load: 0
Optimal number of 40-foot containers to load: 41
Total TEU used: 82.0 / 82
Total containers loaded: 41 / 89
Maximum total profit: $18368.00



================================================================================



--- Problem 28 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy port terminal faces the challenge of efficiently scheduling nine incoming trucks (labeled 1 through 9) to a single depot, minimizing the total time required to service all vehicles. Each truck arrives at a specific time: Truck 1 at hour 3, Truck 2 at hour 4, and so on, with the latest arrival being Truck 9 at hour 23. The base processing time for each truck varies—for instance, Truck 1 requires 7 hours, while Truck 3 needs only 3 hours. However, Trucks 7 and 9 demand additional security checks, adding 1.2 hours to their processing times. The terminal must sequence the trucks such that no two vehicles occupy the depot simultaneously, respecting their arrival times and processing durations. The core question is: *What is the optimal schedule that ensures all trucks are serviced in the shortest possible total time (makespan)?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable indicating whether truck *i* is assigned to depot *j*.  
   - `start_time(i)`: Continuous variable representing the time truck *i* begins service.  
   - `completion_time(i)`: Continuous variable representing the time truck *i* finishes service.  
   - `precedes(i, k, j)`: Binary variable indicating if truck *i* is scheduled before truck *k* on depot *j*.  
   - `makespan`: Continuous variable representing the total time to complete all jobs.  

   **2. Parameters:**  
   - `trucks`: [1, 2, ..., 9] (list of trucks).  
   - `depots`: [1] (single depot).  
   - `arrival_times`: {1: 3, 2: 4, ..., 9: 23} (truck arrival times).  
   - `base_processing_times`: {1: 7, 2: 6, ..., 9: 4} (base service times).  
   - `type_X_trucks`: [7, 9] (trucks requiring extra security time).  
   - `security_check_time`: 1.2 hours (additional time for security checks).  
   - `H`: 100 (large constant for constraints).  

   **3. Objective Function:**  
   Minimize `makespan` (total completion time of the last truck).  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to the depot exactly once.  
     - `sum(assign(i, j) for j in depots) = 1` for all trucks *i*.  
   - **Arrival Time:** Trucks cannot start before their arrival time.  
     - `start_time(i) >= arrival_times[i]` for all trucks *i*.  
   - **Completion Time:** Service duration includes processing and security time (if applicable).  
     - `completion_time(i) = start_time(i) + processing_times[i]` for all trucks *i*.  
   - **Non-Overlapping:** Trucks on the same depot must not overlap.  
     - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
     - If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.  
   - **Makespan Definition:** The total time is the maximum completion time across all trucks.  
     - `makespan >= completion_time(i)` for all trucks *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7, 8, 9]
depots = [1]
arrival_times = {1: 3, 2: 4, 3: 6, 4: 8, 5: 11, 6: 15, 7: 17, 8: 18, 9: 23}
base_processing_times = {1: 7, 2: 6, 3: 3, 4: 3, 5: 8, 6: 8, 7: 3, 8: 5, 9: 4}
type_X_trucks = [9, 7] # Trucks needing security check
security_check_time = 1.2
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Data Prep ---
    processing_times = {}
    for i in trucks:
        if i in type_X_trucks:
            processing_times[i] = base_processing_times.get(i, 0) + security_check_time
        else:
            processing_times[i] = base_processing_times.get(i, 0)

    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_38_SECURITY_CHECK")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (using effective processing time)
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the start and completion times for each truck
if m.status == GRB.OPTIMAL:
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
52.4000
Truck 1 - Start Time: 3.0000, Completion Time: 10.0000
Truck 2 - Start Time: 21.0000, Completion Time: 27.0000
Truck 3 - Start Time: 10.0000, Completion Time: 13.0000
Truck 4 - Start Time: 27.0000, Completion Time: 30.0000
Truck 5 - Start Time: 13.0000, Completion Time: 21.0000
Truck 6 - Start Time: 30.0000, Completion Time: 38.0000
Truck 7 - Start Time: 38.0000, Completion Time: 42.2000
Truck 8 - Start Time: 42.2000, Completion Time: 47.2000
Truck 9 - Start Time: 47.2000, Completion Time: 52.4000


```

================================================================================



--- Problem 29 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A busy trucking depot operates with a mix of loading docks for different types of trucks to ensure efficient service. The depot has 5 docks for small trucks and 2 docks for large trucks, each with distinct service rates: small truck docks can handle 13 trucks per hour, while large truck docks serve 6 trucks per hour. The depot remains open for 9 hours daily, during which trucks arrive at steady rates—43 small trucks and 46 large trucks per hour. The challenge lies in determining the maximum number of trucks the depot can serve without exceeding its dock capacities or the actual demand. The goal is to optimize the allocation of service resources to maximize the total number of trucks served, balancing between the constraints of dock availability, service rates, and incoming truck demand. The core question is: *What is the optimal number of small and large trucks the depot can serve in a 9-hour day, given these operational constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `served_small`: Number of small trucks served (continuous, ≥ 0).
   - `served_large`: Number of large trucks served (continuous, ≥ 0).

**2. Parameters:**
   - `num_small_docks = 5`: Number of small truck docks available.
   - `num_large_docks = 2`: Number of large truck docks available.
   - `service_rate_small = 13`: Small trucks served per dock per hour.
   - `service_rate_large = 6`: Large trucks served per dock per hour.
   - `arrival_rate_small = 43`: Small trucks arriving per hour.
   - `arrival_rate_large = 46`: Large trucks arriving per hour.
   - `hours_open = 9`: Operating hours per day.

**3. Objective Function:**
   - Maximize the total number of trucks served:  
     `Maximize: served_small + served_large`.

**4. Constraints:**
   - **Small truck capacity constraint:**  
     `served_small ≤ num_small_docks * service_rate_small * hours_open`.
   - **Large truck capacity constraint:**  
     `served_large ≤ num_large_docks * service_rate_large * hours_open`.
   - **Small truck demand constraint:**  
     `served_small ≤ arrival_rate_small * hours_open`.
   - **Large truck demand constraint:**  
     `served_large ≤ arrival_rate_large * hours_open`.

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
num_small_docks = 5; num_large_docks = 2
service_rate_small = 13; service_rate_large = 6
arrival_rate_small = 43; arrival_rate_large = 46; hours_open = 9
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m5 = gp.Model("Trucking_Depot_Dock_Allocation_LP", env=env)
    # Vars
    served_small = m5.addVar(name="served_small_trucks", lb=0)
    served_large = m5.addVar(name="served_large_trucks", lb=0)
    # Objective
    m5.setObjective(served_small + served_large, sense=GRB.MAXIMIZE)
    # Constraints
    m5.addConstr(served_small <= num_small_docks * service_rate_small * hours_open, "small_capacity")
    m5.addConstr(served_large <= num_large_docks * service_rate_large * hours_open, "large_capacity")
    m5.addConstr(served_small <= arrival_rate_small * hours_open, "small_demand")
    m5.addConstr(served_large <= arrival_rate_large * hours_open, "large_demand")
    # Optimize
    m5.optimize()
    # Store results
    results_dict['status'] = m5.status
    if m5.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m5.objVal
        results_dict['served_small_opt'] = served_small.X; results_dict['served_large_opt'] = served_large.X
    # Output Results
    print("--- Problem 5: Trucking Depot Dock Allocation (LP) ---")
    if m5.status == GRB.OPTIMAL:
        ss = results_dict.get('served_small_opt', 0); sl = results_dict.get('served_large_opt', 0)
        demand_s = arrival_rate_small * hours_open; demand_l = arrival_rate_large * hours_open
        cap_s = num_small_docks * service_rate_small * hours_open; cap_l = num_large_docks * service_rate_large * hours_open
        print(f"Optimization Status: Optimal")
        print(f"Maximum small trucks served in {hours_open} hours: {ss:.0f} (Demand: {demand_s}, Capacity: {cap_s})")
        print(f"Maximum large trucks served in {hours_open} hours: {sl:.0f} (Demand: {demand_l}, Capacity: {cap_l})")
        print(f"Total trucks served: {m5.objVal:.0f}")
    else: print(f"Optimization Status: {m5.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of TRUCKING_DEPOT
```
Answer:
--- Problem 5: Trucking Depot Dock Allocation (LP) ---
Optimization Status: Optimal
Maximum small trucks served in 9 hours: 387 (Demand: 387, Capacity: 585)
Maximum large trucks served in 9 hours: 108 (Demand: 414, Capacity: 108)
Total trucks served: 495



================================================================================



--- Problem 30 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A fleet of 13 electric trucks, labeled Truck_1 through Truck_13, requires overnight charging at a depot equipped with two chargers: Chgr_1 (54.4 kW) and Chgr_2 (36.8 kW). Each truck has a specific charging need, ranging from 33 kWh (Truck_1) to 95 kWh (Truck_10 and Truck_13). The charging time for each truck depends on the charger's power output—higher-power chargers complete the job faster. For instance, Truck_1 takes 36.4 minutes on Chgr_1 but 53.8 minutes on Chgr_2. The depot manager faces a critical scheduling challenge: assign each truck to a charger such that the last truck finishes charging as early as possible. This minimizes downtime and ensures the fleet is ready for morning operations. The goal is to balance the load between the two chargers, accounting for their differing speeds, to achieve the shortest possible total charging schedule.
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `assign[t, c]`: Binary variable (0 or 1) indicating whether truck `t` is assigned to charger `c`.
   - `charger_makespan[c]`: Continuous variable representing the total time charger `c` is in use (sum of charging times for trucks assigned to it).
   - `makespan`: Continuous variable representing the overall completion time (maximum of the two charger makespans).

**2. Parameters:**
   - `trucks`: List of 13 trucks (Truck_1 to Truck_13).
   - `chargers`: List of 2 chargers (Chgr_1, Chgr_2).
   - `charge_needs_kwh[t]`: Charging requirement (kWh) for each truck `t`.
   - `charger_power_kw[c]`: Power output (kW) of charger `c`.
   - `charging_time_min[t, c]`: Time (minutes) to charge truck `t` on charger `c`, calculated as `(charge_needs_kwh[t] / charger_power_kw[c]) * 60`.

**3. Objective Function:**
   - Minimize `makespan` (the time when the last truck finishes charging).

**4. Constraints:**
   - Each truck must be assigned to exactly one charger:  
     `sum(assign[t, c] for c in chargers) = 1` for all `t` in `trucks`.
   - The makespan for each charger is the sum of charging times for its assigned trucks:  
     `charger_makespan[c] = sum(assign[t, c] * charging_time_min[t, c] for t in trucks)` for all `c` in `chargers`.
   - The overall makespan is the maximum of the individual charger makespans:  
     `makespan >= charger_makespan[c]` for all `c` in `chargers`.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = ['Truck_1', 'Truck_2', 'Truck_3', 'Truck_4', 'Truck_5', 'Truck_6', 'Truck_7', 'Truck_8', 'Truck_9', 'Truck_10', 'Truck_11', 'Truck_12', 'Truck_13']
charge_needs_kwh = {'Truck_1': 33, 'Truck_2': 54, 'Truck_3': 54, 'Truck_4': 57, 'Truck_5': 34, 'Truck_6': 59, 'Truck_7': 62, 'Truck_8': 70, 'Truck_9': 62, 'Truck_10': 95, 'Truck_11': 64, 'Truck_12': 66, 'Truck_13': 95}
chargers = ['Chgr_1', 'Chgr_2']
charger_power_kw = {'Chgr_1': 54.4, 'Chgr_2': 36.8}
# Calculated charging times (truck, charger): time_in_minutes
charging_time_min = {('Truck_1', 'Chgr_1'): 36.39705882352941, ('Truck_1', 'Chgr_2'): 53.80434782608696, ('Truck_2', 'Chgr_1'): 59.55882352941177, ('Truck_2', 'Chgr_2'): 88.04347826086956, ('Truck_3', 'Chgr_1'): 59.55882352941177, ('Truck_3', 'Chgr_2'): 88.04347826086956, ('Truck_4', 'Chgr_1'): 62.867647058823536, ('Truck_4', 'Chgr_2'): 92.93478260869566, ('Truck_5', 'Chgr_1'): 37.5, ('Truck_5', 'Chgr_2'): 55.434782608695656, ('Truck_6', 'Chgr_1'): 65.0735294117647, ('Truck_6', 'Chgr_2'): 96.19565217391305, ('Truck_7', 'Chgr_1'): 68.38235294117646, ('Truck_7', 'Chgr_2'): 101.08695652173914, ('Truck_8', 'Chgr_1'): 77.20588235294119, ('Truck_8', 'Chgr_2'): 114.13043478260872, ('Truck_9', 'Chgr_1'): 68.38235294117646, ('Truck_9', 'Chgr_2'): 101.08695652173914, ('Truck_10', 'Chgr_1'): 104.77941176470588, ('Truck_10', 'Chgr_2'): 154.8913043478261, ('Truck_11', 'Chgr_1'): 70.58823529411765, ('Truck_11', 'Chgr_2'): 104.34782608695653, ('Truck_12', 'Chgr_1'): 72.79411764705883, ('Truck_12', 'Chgr_2'): 107.60869565217392, ('Truck_13', 'Chgr_1'): 104.77941176470588, ('Truck_13', 'Chgr_2'): 154.8913043478261}
# --- End Parameters ---

GUROBI_TIME_LIMIT = 45

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m35 = gp.Model("ELECTRIC_TRUCK_CHARGING_MIP", env=env)

    # --- Basic Input Validation ---
    if not trucks or not chargers: raise ValueError("Empty trucks or chargers list")
    # Check if any charging time is infinite (due to zero power)
    if any(t == float('inf') for t in charging_time_min.values()):
         print("Warning: Some charger has zero power, potentially infeasible.")

    # --- Decision Variables ---
    # Binary: assign[t, c]=1 if truck t assigned to charger c
    assign_keys = [(t, c) for t in trucks for c in chargers if charging_time_min.get((t,c), float('inf')) != float('inf')]
    if not assign_keys: raise ValueError("No possible assignments due to zero power chargers?")
    assign = m35.addVars(assign_keys, vtype=GRB.BINARY, name="assign")
    # Continuous: Makespan for each charger
    charger_makespan = m35.addVars(chargers, name="charger_makespan", lb=0)
    # Continuous: Overall makespan (objective)
    makespan = m35.addVar(name="overall_makespan", lb=0)

    # --- Objective Function ---
    # Minimize the overall makespan (time last truck finishes charging)
    m35.setObjective(makespan, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Assignment constraint: Each truck assigned to exactly one charger
    # Sum only over possible assignments (assign_keys) for each truck
    for t in trucks:
        m35.addConstr(gp.quicksum(assign[t_key, c_key] for t_key, c_key in assign_keys if t_key == t) == 1, name=f"assign_truck_{t}")

    # Makespan calculation constraints:
    # 1. Calculate makespan for each charger (sum of charging times of assigned trucks)
    for c in chargers:
        # Sum only over possible assignments involving charger c
        m35.addConstr(charger_makespan[c] == gp.quicksum(assign[t_key, c_key] * charging_time_min.get((t_key, c_key), 0)
                                                        for t_key, c_key in assign_keys if c_key == c), name=f"makespan_charger_{c}")

    # 2. Overall makespan is the maximum of individual charger makespans
    for c in chargers:
        m35.addConstr(makespan >= charger_makespan[c], name=f"overall_makespan_ge_charger_{c}")

    # --- Optimization ---
    m35.optimize()

    # --- Store results ---
    results_dict['status'] = m35.status
    if m35.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m35.ObjVal # = makespan.X
        results_dict['charger_makespan_sol'] = m35.getAttr('X', charger_makespan)
        results_dict['assign_sol'] = m35.getAttr('X', assign)

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 35: Electric Truck Charging Schedule (MIP) ---") # Original problem number
    if m35.status == GRB.OPTIMAL:
        makespan_sol = results_dict.get('obj_val', 'N/A')
        charger_mk_sol = results_dict.get('charger_makespan_sol', {})
        assign_sol = results_dict.get('assign_sol', {})

        print(f"Optimization Status: Optimal")
        if isinstance(makespan_sol, (int, float)):
             print(f"Minimum Makespan (Time until all trucks charged): {makespan_sol:.1f} minutes")
        else:
             print(f"Minimum Makespan (Time until all trucks charged): {makespan_sol}")

        print("Assignments and Charger Makespans:")
        assignments_dict = {} # Track assignments for final print
        for c in chargers:
            trucks_on_charger = []
            charger_mk_print = charger_mk_sol.get(c, 'N/A')
            # Iterate through solution dictionary `assign_sol`
            for (t_key, c_key), assigned_val in assign_sol.items():
                if c_key == c and assigned_val > 0.5:
                    charge_time_print = charging_time_min.get((t_key, c_key), '?')
                    trucks_on_charger.append(f"{t_key} ({float(charge_time_print):.0f} min)")
                    assignments_dict[t_key] = c_key # Store assignment

            # Format charger makespan value
            if isinstance(charger_mk_print, (int, float)):
                 charger_mk_str = f"{charger_mk_print:.1f} min"
            else:
                 charger_mk_str = f"{charger_mk_print}"
            print(f"  Charger {c}: Assigned Trucks: {', '.join(trucks_on_charger)}. Charger Makespan: {charger_mk_str}")

        print("Truck Assignments:")
        for t in trucks: print(f"  Truck {t} -> Charger {assignments_dict.get(t, 'Unassigned')}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m35.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 35: Electric Truck Charging Schedule (MIP) ---
Optimization Status: Optimal
Minimum Makespan (Time until all trucks charged): 529.9 minutes
Assignments and Charger Makespans:
  Charger Chgr_1: Assigned Trucks: Truck_1 (36 min), Truck_2 (60 min), Truck_3 (60 min), Truck_4 (63 min), Truck_6 (65 min), Truck_7 (68 min), Truck_10 (105 min), Truck_12 (73 min). Charger Makespan: 529.4 min
  Charger Chgr_2: Assigned Trucks: Truck_5 (55 min), Truck_8 (114 min), Truck_9 (101 min), Truck_11 (104 min), Truck_13 (155 min). Charger Makespan: 529.9 min
Truck Assignments:
  Truck Truck_1 -> Charger Chgr_1
  Truck Truck_2 -> Charger Chgr_1
  Truck Truck_3 -> Charger Chgr_1
  Truck Truck_4 -> Charger Chgr_1
  Truck Truck_5 -> Charger Chgr_2
  Truck Truck_6 -> Charger Chgr_1
  Truck Truck_7 -> Charger Chgr_1
  Truck Truck_8 -> Charger Chgr_2
  Truck Truck_9 -> Charger Chgr_2
  Truck Truck_10 -> Charger Chgr_1
  Truck Truck_11 -> Charger Chgr_2
  Truck Truck_12 -> Charger Chgr_1
  Truck Truck_13 -> Charger Chgr_2


```

================================================================================



--- Problem 31 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling six incoming trucks across three available depots to maximize operational throughput. Each truck arrives at a specific time: Truck 1 at 6 hours, Truck 2 at 7, Truck 3 at 15, Truck 4 at 21, Truck 5 at 25, and Truck 6 at 32. The processing times vary—Truck 1 requires 10 hours, Truck 2 takes 5, Truck 3 needs 12, Truck 4 demands 11, Truck 5 uses 7, and Truck 6 also requires 10 hours. The hub operates within a strict 43-hour horizon, meaning all truck servicing must conclude by this deadline.  

   The core challenge is to assign each truck to exactly one depot while ensuring no two trucks at the same depot overlap in their servicing times. The goal is to maximize the total processing time of all assigned trucks, effectively optimizing depot utilization. This requires carefully sequencing truck start times to respect arrival times, processing durations, and the hard horizon constraint.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable indicating whether truck *i* is assigned to depot *j*.  
   - `start_time(i)`: Continuous variable representing the start time of truck *i*.  
   - `completion_time(i)`: Continuous variable representing the completion time of truck *i*.  
   - `precedes(i, k, j)`: Binary variable indicating whether truck *i* is serviced before truck *k* at depot *j*.  

   **2. Parameters:**  
   - `trucks = [1, 2, 3, 4, 5, 6]`: List of trucks.  
   - `depots = [1, 2, 3]`: List of depots.  
   - `arrival_times`: Dictionary of truck arrival times (e.g., `{1: 6, 2: 7, ...}`).  
   - `processing_times`: Dictionary of truck processing times (e.g., `{1: 10, 2: 5, ...}`).  
   - `horizon = 43`: Maximum allowable completion time.  
   - `H = 100`: A large constant (Big-M) for logical constraints.  

   **3. Objective Function:**  
   Maximize the total processing time of assigned trucks:  
   `Maximize: sum(processing_times[i] * assign(i, j) for all i, j)`  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot:  
     `sum(assign(i, j) for all j) = 1` for each truck *i*.  
   - **Arrival Time:** A truck cannot start before its arrival time:  
     `start_time(i) >= arrival_times[i]` for each truck *i*.  
   - **Completion Time:** Completion time is the sum of start time and processing time:  
     `completion_time(i) = start_time(i) + processing_times[i]` for each truck *i*.  
   - **Non-Overlapping:** For any two trucks assigned to the same depot, one must precede the other:  
     `precedes(i, k, j) + precedes(k, i, j) >= assign(i, j) + assign(k, j) - 1` for all *i < k* and depot *j*.  
     Logical constraints ensure sequencing:  
     If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
   - **Horizon Limit:** All trucks must finish by the horizon:  
     `completion_time(i) <= horizon` for each truck *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
depots = [1, 2, 3]
arrival_times = {1: 6, 2: 7, 3: 15, 4: 21, 5: 25, 6: 32}
processing_times = {1: 10, 2: 5, 3: 12, 4: 11, 5: 7, 6: 10}
horizon = 43
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_MAX_OCCUPATION")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")
    # Optional: use_truck[i]=1 if truck i is served (if not all trucks must be served)
    # For this model, assume assign.sum == 1 implies truck is served

    # --- Objective Function ---
    # Maximize total processing time of assigned trucks
    m.setObjective(gp.quicksum(processing_times.get(i, 0) * assign.sum(i, '*') for i in trucks), GRB.MAXIMIZE)

    # --- Constraints ---
    # 1. Assignment (Each truck assigned to at most one depot)
    # Original model used == 1, assuming all trucks must try to be berthed
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")

    # 5. Horizon Constraint
    m.addConstrs((completion_time[i] <= horizon for i in trucks), name="horizon_limit")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        obj = m.getObjective()
        results_dict['obj_val'] = obj.getValue()

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.2f}") # Total processing time
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.2f}, Completion Time: {completion_time[i].x:.2f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
55.00
Optimal Solution Found:
Truck 1 is assigned to Depot 3
Start Time: 6.00, Completion Time: 16.00
Truck 2 is assigned to Depot 3
Start Time: 16.00, Completion Time: 21.00
Truck 3 is assigned to Depot 3
Start Time: 21.00, Completion Time: 33.00
Truck 4 is assigned to Depot 2
Start Time: 21.00, Completion Time: 32.00
Truck 5 is assigned to Depot 3
Start Time: 33.00, Completion Time: 40.00
Truck 6 is assigned to Depot 2
Start Time: 33.00, Completion Time: 43.00


```

================================================================================



--- Problem 32 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
At a busy port, the harbor master is tasked with optimizing the allocation of crane usage time for two major container ships, Ship A and Ship B. The total available crane operation time in a cycle is 70 minutes, during which each ship must account for not only the active crane time but also the necessary transition times—5 minutes of setup and 3 minutes of cooldown, totaling 8 minutes of "lost time" per ship. The minimum crane operation time for either ship is set to 23 minutes to ensure efficient loading and unloading processes.

Ship A handles an arrival flow of 693 containers per hour against a saturation capacity of 2097, while Ship B sees 660 containers arriving against a saturation capacity of 1795. The goal is to allocate crane operation times in a way that maximizes the *weighted sum* of crane operation durations, where the weights reflect the urgency of each ship—specifically, the ratio of arrival flow to saturation capacity. This ensures that the ship with higher congestion pressure receives proportionally more crane operation time, improving overall port efficiency.

The core question is: *How should the available crane operation time be split between Ship A and Ship B to maximize the weighted crane operation time while adhering to the cycle time and minimum operation constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `c_a`: Continuous variable representing the crane operation time (minutes) allocated to Ship A.  
- `c_b`: Continuous variable representing the crane operation time (minutes) allocated to Ship B.  

**2. Parameters:**  
- `cycle_time = 70`: Total duration (minutes) of the crane operation cycle.  
- `lost_time_per_ship = 8`: Sum of setup (5m) and cooldown (3m) times per ship.  
- `min_operation = 23`: Minimum crane operation time (minutes) for either ship.  
- `sat_capacity_a = 2097`, `arr_flow_a = 693`: Saturation and arrival flows (containers/hour) for Ship A.  
- `sat_capacity_b = 1795`, `arr_flow_b = 660`: Saturation and arrival flows (containers/hour) for Ship B.  
- Weights:  
  - `weight_a = arr_flow_a / sat_capacity_a` (≈0.3305).  
  - `weight_b = arr_flow_b / sat_capacity_b` (≈0.3677).  

**3. Objective Function:**  
Maximize the weighted sum of crane operation times:  
`Maximize: weight_a * c_a + weight_b * c_b`.  

**4. Constraints:**  
- **Cycle time constraint:** Total phase times (operation + lost time) must equal the cycle time:  
  `c_a + lost_time_per_ship + c_b + lost_time_per_ship = cycle_time`.  
- **Minimum operation time:**  
  `c_a ≥ min_operation`, `c_b ≥ min_operation`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cycle_time = 70
setup_time = 5
cooldown_time = 3
min_operation = 23
sat_capacity_a = 2097
arr_flow_a = 693
sat_capacity_b = 1795
arr_flow_b = 660
lost_time_per_ship = 8 # setup + cooldown
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("CRANE_OPERATION_TIMING", env=env)

    # --- Decision Variables ---
    # c_a: crane operation time for Ship A (minutes)
    c_a = m.addVar(lb=min_operation, vtype=GRB.CONTINUOUS, name="c_a")
    # c_b: crane operation time for Ship B (minutes)
    c_b = m.addVar(lb=min_operation, vtype=GRB.CONTINUOUS, name="c_b")

    # --- Objective Function: Maximize weighted crane operation times ---
    # Weight by flow/saturation ratio (degree of saturation)
    # Avoid division by zero
    weight_a = arr_flow_a / sat_capacity_a if sat_capacity_a > 1e-6 else 0
    weight_b = arr_flow_b / sat_capacity_b if sat_capacity_b > 1e-6 else 0
    m.setObjective(weight_a * c_a + weight_b * c_b, GRB.MAXIMIZE)

    # --- Constraints ---
    # Cycle time constraint: sum of phase times must equal cycle time
    # Phase time = operation + lost_time_per_ship
    m.addConstr(c_a + lost_time_per_ship + c_b + lost_time_per_ship == cycle_time, "CycleTimeConstraint")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['c_a_sol'] = c_a.X # Not needed for output
        # results_dict['c_b_sol'] = c_b.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Format objective value (weighted crane operation time sum)
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show more decimals for weighted sum
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the decision variables
if m.Status == GRB.OPTIMAL:
    print(f"Optimal objective value: {obj_val_print:.4f}")
    print(f"Crane operation time for Ship A: {c_a.X:.4f} minutes")
    print(f"Crane operation time for Ship B: {c_b.X:.4f} minutes")
```
Answer:
Optimal objective value: 18.9992
Optimal objective value: 18.9992
Crane operation time for Ship A: 23.0000 minutes
Crane operation time for Ship B: 31.0000 minutes


```

================================================================================



--- Problem 33 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy logistics hub, a critical scheduling challenge arises: efficiently managing the arrival and departure of a fleet of eight delivery trucks at a single available loading dock while adhering to strict operational rules. Each truck arrives at the hub at a specific time (e.g., Truck 1 arrives at 4.8 hours, Truck 2 at 8.9 hours, etc.), and each requires a fixed processing time for unloading and loading (ranging from 4 to 7 hours). The dock must handle these trucks without overlaps, ensuring that no two vehicles occupy the same space simultaneously. Additionally, to avoid logistical conflicts, the start times of any two trucks must be separated by at least 0.9 hours, even if their processing windows don’t directly clash. The hub manager’s goal is to sequence the trucks in a way that minimizes the total time required to service all vehicles (the *makespan*), ensuring the dock is freed up as quickly as possible for future operations. The core question is: **What is the optimal schedule for managing these trucks to achieve the shortest possible completion time while respecting arrival times, processing durations, and minimum start-time gaps?**

---

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to dock *j*, else 0).  
   - `start_time(i)`: Continuous variable for the time truck *i* begins service.  
   - `completion_time(i)`: Continuous variable for the time truck *i* finishes service.  
   - `precedes(i, k, j)`: Binary variable (1 if truck *i* is scheduled before truck *k* on dock *j*, else 0).  
   - `z_start_sep(i, k)`: Binary variable enforcing the minimum start-time gap between trucks *i* and *k*.  
   - `makespan`: Continuous variable representing the total time to complete all jobs.  

   **2. Parameters:**  
   - `trucks`: [1, 2, ..., 8] (list of trucks).  
   - `docks`: [1] (single dock).  
   - `arrival_times`: {1: 4.8, 2: 8.9, ..., 8: 28.5} (hours).  
   - `processing_times`: {1: 6, 2: 5, ..., 8: 6} (hours).  
   - `min_start_gap`: 0.9 hours (minimum separation between start times).  
   - `H`: 100 (large constant for linearizing constraints).  

   **3. Objective Function:**  
   Minimize `makespan` (the latest completion time among all trucks).  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to the single dock:  
     `sum(assign(i, j) for j in docks) = 1` for all trucks *i*.  
   - **Arrival Time:** Trucks cannot start before arrival:  
     `start_time(i) >= arrival_times[i]` for all *i*.  
   - **Completion Time:** `completion_time(i) = start_time(i) + processing_times[i]`.  
   - **Non-Overlapping:** For trucks *i* and *k* on the same dock, one must precede the other:  
     If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
   - **Start-Time Separation:** For any two trucks *i* and *k*, enforce a minimum gap:  
     `start_time(i) >= start_time(k) + min_start_gap - H*(1 - z_start_sep(i, k))`  
     `start_time(k) >= start_time(i) + min_start_gap - H*z_start_sep(i, k)`.  
   - **Makespan Definition:** `makespan >= completion_time(i)` for all *i*.  

---

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7, 8]
docks = [1]
arrival_times = {1: 4.8, 2: 8.9, 3: 10.9, 4: 15.5, 5: 19.6, 6: 24.2, 7: 25.8, 8: 28.5}
processing_times = {1: 6, 2: 5, 3: 7, 4: 6, 5: 6, 6: 5, 7: 4, 8: 6}
min_start_gap = 0.9
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DOCKING_PROBLEM_48_START_GAP")

    if not trucks or not docks: raise ValueError("Empty trucks or docks")

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    # Binary var for start separation disjunction
    z_start_sep = m.addVars([(i, k) for i in trucks for k in trucks if i < k],
                            vtype=GRB.BINARY, name="z_start_sep")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in docks:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. Global Start Time Separation Constraint using Big-M
    for i in trucks:
        for k in trucks:
            if i < k:
                 m.addConstr(start_time[i] >= start_time[k] + min_start_gap - H * (1-z_start_sep[i,k]), name=f"start_gap1_{i}_{k}")
                 m.addConstr(start_time[k] >= start_time[i] + min_start_gap - H * z_start_sep[i,k], name=f"start_gap2_{i}_{k}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")
        if m.SolCount > 0 and abs(m.ObjVal) < GRB.INFINITY :
             print(f"{m.ObjVal:.4f}")
        elif m.status != GRB.INFEASIBLE and m.status != GRB.UNBOUNDED:
             print("No feasible solution found.")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Schedule:")
    for i in trucks:
        print(f"Truck {i}: Start Time = {start_time[i].x:.4f}, Completion Time = {completion_time[i].x:.4f}")
    print(f"Total Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
49.8000
Optimal Schedule:
Truck 1: Start Time = 4.8000, Completion Time = 10.8000
Truck 2: Start Time = 10.8000, Completion Time = 15.8000
Truck 3: Start Time = 15.8000, Completion Time = 22.8000
Truck 4: Start Time = 32.8000, Completion Time = 38.8000
Truck 5: Start Time = 22.8000, Completion Time = 28.8000
Truck 6: Start Time = 38.8000, Completion Time = 43.8000
Truck 7: Start Time = 28.8000, Completion Time = 32.8000
Truck 8: Start Time = 43.8000, Completion Time = 49.8000
Total Makespan: 49.8000


```

================================================================================



--- Problem 34 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A busy port with three distinct berths—Berth_A, Berth_B, and Berth_C—faces the challenge of efficiently loading and unloading cargo during a limited time window. Berth_A contains 97 containers, Berth_B holds 378, and Berth_C has 68. The port has two cranes, Crane 1 and Crane 2, each capable of handling up to 25 containers per minute. Over a critical 23-minute loading/unloading window, the total capacity for each crane is capped at 575 containers. The port manager must determine how to allocate the flow of containers from each berth to the cranes to maximize the total number of containers loaded or unloaded without exceeding berth supplies or crane capacities. The core question is: *What is the optimal distribution of containers from each berth to the cranes to load or unload as many containers as possible within the given constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `f[i, j]`: The number of containers flowing from berth `i` (where `i` is in `['Berth_A', 'Berth_B', 'Berth_C']`) to crane `j` (where `j` is in `[1, 2]`). This is a continuous variable with a lower bound of 0.  
   - **2. Parameters:**  
     - `berth_containers[i]`: The number of containers initially in berth `i` (e.g., `berth_containers['Berth_A'] = 97`).  
     - `total_crane_capacity[j]`: The maximum number of containers crane `j` can handle over the time period (e.g., `total_crane_capacity[1] = 575`).  
     - `time_period`: The loading/unloading duration (23 minutes).  
   - **3. Objective Function:**  
     - Maximize the total number of containers loaded or unloaded:  
       `Maximize: sum(f[i, j] for all i, j)`  
   - **4. Constraints:**  
     - **Berth Supply:** The total flow out of each berth cannot exceed its container count:  
       `sum(f[i, j] for j in cranes) <= berth_containers[i] for each i in berths`  
     - **Crane Capacity:** The total flow into each crane cannot exceed its capacity:  
       `sum(f[i, j] for i in berths) <= total_crane_capacity[j] for each j in cranes`  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
berths = ['Berth_A', 'Berth_B', 'Berth_C']
cranes = [1, 2]
berth_containers = {'Berth_A': 97, 'Berth_B': 378, 'Berth_C': 68} # Dict berth: count
crane_capacity_rate = 25 # containers per minute per crane
time_period = 23 # minutes
total_crane_capacity = {1: 575, 2: 575} # Dict crane: capacity over period
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_CRANE_SCHEDULING", env=env)

    # --- Basic Input Validation ---
    if not berths or not cranes:
        raise ValueError("Empty berths or cranes list")

    # --- Decision Variables ---
    # f[i, j]: Number of containers flowing from berth i to crane j within the time period
    flow_keys = [(i, j) for i in berths for j in cranes]
    f = m.addVars(flow_keys, vtype=GRB.CONTINUOUS, lb=0, name="flow")

    # --- Objective Function: Maximize total containers loaded or unloaded ---
    m.setObjective(gp.quicksum(f[i, j] for i, j in flow_keys), GRB.MAXIMIZE)

    # --- Constraints ---
    # Flow out of a berth cannot exceed the number of containers in it
    m.addConstrs((gp.quicksum(f[i, j] for j in cranes) <= berth_containers.get(i, 0) for i in berths), "BerthSupply")

    # Flow into a crane cannot exceed its capacity over the period
    m.addConstrs((gp.quicksum(f[i, j] for i in berths) <= total_crane_capacity.get(j, 0) for j in cranes), "CraneCapacity")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['f_sol'] = m.getAttr('X', f) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Objective is total containers, potentially float
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code to print the flow of containers from each berth to each crane
if m.Status == GRB.OPTIMAL:
    for i in berths:
        for j in cranes:
            print(f"Containers from {i} to Crane {j}: {f[i, j].X:.2f}")
```
Answer:
Optimal objective value: 543.00
Containers from Berth_A to Crane 1: 97.00
Containers from Berth_A to Crane 2: 0.00
Containers from Berth_B to Crane 1: 0.00
Containers from Berth_B to Crane 2: 378.00
Containers from Berth_C to Crane 1: 68.00
Containers from Berth_C to Crane 2: 0.00


```

================================================================================



--- Problem 35 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
A logistics company is tasked with efficiently loading five rectangular cargo containers onto standardized trucks to minimize transportation costs. Each truck has a fixed width of 23 units and a length of 66 units. The containers vary in size: one measures 9x60, another 14x12, a third 21x24, a fourth 4x39, and the last 6x28. The challenge is to arrange these containers on the fewest possible trucks without overlaps while respecting the truck dimensions. The company must determine not only how many trucks are needed but also the exact placement of each container within its assigned truck—specifying the bottom-left corner coordinates to ensure no container extends beyond the truck boundaries or overlaps with others. The goal is to find the most space-efficient configuration, reducing both material waste and transportation expenses.

**Modeling Process:**
- **1. Decision Variables:**  
     - Binary variable `x[i, j]`: 1 if container `i` is assigned to truck `j`, else 0.  
     - Binary variable `y[j]`: 1 if truck `j` is used, else 0.  
     - Continuous variables `px[i, j]` and `py[i, j]`: Represent the bottom-left x and y coordinates of container `i` in truck `j`.  
     - Auxiliary binary variables (`left`, `right`, `below`, `above`): Enforce non-overlapping constraints between pairs of containers in the same truck.  

   - **2. Parameters:**  
     - `containers`: List of container dimensions [(9, 60), (14, 12), (21, 24), (4, 39), (6, 28)].  
     - `truck_size`: (23, 66).  
     - `num_trucks`: Upper bound of 5 (one per container).  
     - Big-M values `M_w = 23`, `M_h = 66` to relax constraints when containers are not in the same truck.  

   - **3. Objective Function:**  
     Minimize the total number of trucks used:  
     \[
     \text{Minimize: } \sum_{j} y[j]
     \]  

   - **4. Constraints:**  
     - **Assignment:** Each container must be placed in exactly one truck.  
       \[
       \sum_{j} x[i, j] = 1 \quad \forall i
       \]  
     - **Truck Boundaries:** Containers must fit within their assigned truck.  
       \[
       px[i, j] + w_i \leq 23 + M_w (1 - x[i, j]) \quad \forall i, j
       \]  
       \[
       py[i, j] + h_i \leq 66 + M_h (1 - x[i, j]) \quad \forall i, j
       \]  
     - **Non-Overlapping:** For containers in the same truck, enforce relative positioning (left/right/below/above).  
       \[
       \text{left}[i, k, j] + \text{right}[i, k, j] + \text{below}[i, k, j] + \text{above}[i, k, j] \geq x[i, j] + x[k, j] - 1 \quad \forall i < k, j
       \]  
     - **Truck Activation:** A truck is used if any container is assigned to it.  
       \[
       x[i, j] \leq y[j] \quad \forall i, j
       \]  

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
containers = [(9, 60), (14, 12), (21, 24), (4, 39), (6, 28)]  # (width, height) of containers
truck_size = (23, 66)  # (width, length) of each truck
num_containers = 5 # len(containers)
# Maximum trucks needed (worst case: one container per truck)
# Can sometimes be reduced with lower bounds, but num_containers is safe
num_trucks = num_containers
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using truck dimensions is common and valid)
M_w = truck_size[0]
M_h = truck_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Truck Loading", env=env)

# --- Decision Variables ---
# x[i,j]: container i assigned to truck j
x = model.addVars(num_containers, num_trucks, vtype=GRB.BINARY, name="x")
# y[j]: truck j is used
y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of container i if in truck j
px = model.addVars(num_containers, num_trucks, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_containers, num_trucks, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of containers *within the same truck*
left  = model.addVars(num_containers, num_containers, num_trucks, vtype=GRB.BINARY, name="left")
right = model.addVars(num_containers, num_containers, num_trucks, vtype=GRB.BINARY, name="right")
below = model.addVars(num_containers, num_containers, num_trucks, vtype=GRB.BINARY, name="below")
above = model.addVars(num_containers, num_containers, num_trucks, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of trucks used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_trucks))

# --- Constraints ---

# 1. Each container must be assigned to exactly one truck
for i in range(num_containers):
    model.addConstr(x.sum(i, '*') == 1, name=f"Container_{i}_Assignment")

# 2. Container placement constraints within truck boundaries (Big-M formulation)
for j in range(num_trucks):
    for i in range(num_containers):
        container_w, container_h = containers[i] # Get dimensions for container i

        # Position variables must be 0 if container i is not in truck j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Container's right edge <= truck width IF container is placed in truck (x[i,j]=1)
        model.addConstr(px[i, j] + container_w <= truck_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Container's top edge <= truck length IF container is placed in truck (x[i,j]=1)
        model.addConstr(py[i, j] + container_h <= truck_size[1] + M_h * (1 - x[i, j]), name=f"Length_Limit_{i}_{j}")

# 3. Non-overlapping constraints for containers within the same truck
for j in range(num_trucks):
    for i in range(num_containers):
        for k in range(i + 1, num_containers): # Iterate over distinct pairs (i < k)
            container_i_w, container_i_h = containers[i]
            container_k_w, container_k_h = containers[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => container i is to the left of container k
            model.addConstr(px[i, j] + container_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => container i is to the right of container k (k is left of i)
            model.addConstr(px[k, j] + container_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => container i is below container k
            model.addConstr(py[i, j] + container_i_h <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => container i is above container k (k is below i)
            model.addConstr(py[k, j] + container_k_h <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH container i and container k are in truck j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link container assignment to truck usage: If any container i is in truck j, then truck j must be used (y[j]=1)
#    This can be done per container or aggregated. Per container is often tighter.
for j in range(num_trucks):
    for i in range(num_containers):
        model.addConstr(x[i, j] <= y[j], name=f"Container_Truck_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_containers * y[j], name=f"Truck_Activation_{j}")


# --- Solve ---
print("Solving 2D Truck Loading instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of trucks used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    truck_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_trucks):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Truck {j_sol + 1} (Used):")
            containers_in_truck_info = []
            for i_sol in range(num_containers):
                if x[i_sol, j_sol].X > 0.5:
                    container_data = {
                        "id": i_sol,
                        "dims": containers[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    containers_in_truck_info.append(container_data)
                    print(f"  Container {container_data['id']} {container_data['dims']} at {container_data['pos']}")
            truck_details.append({'truck_index': j_sol, 'containers': containers_in_truck_info})
            print("-" * 10)
    results_dict['truck_details'] = truck_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 2D Truck Loading instance...

Optimal number of trucks used: 2
------------------------------
Truck 1 (Used):
  Container 1 (14, 12) at (6.0, 0.0)
  Container 2 (21, 24) at (0.0, 28.0)
  Container 4 (6, 28) at (0.0, 0.0)
----------
Truck 4 (Used):
  Container 0 (9, 60) at (4.0, 0.0)
  Container 3 (4, 39) at (0.0, 0.0)
----------


```

================================================================================



--- Problem 36 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy inland logistics hub faces the challenge of efficiently managing incoming trucks to minimize the number of depots used while respecting arrival times and processing durations. Nine trucks, labeled 1 through 9, arrive at staggered times: Truck 1 at time 1, Truck 2 at time 4, and so on, with the last arrival (Truck 9) at time 23. Each truck requires a specific processing time—ranging from 5 to 8 hours—to unload cargo or refuel. The hub has five potential depots, but activating each incurs operational costs. The goal is to assign trucks to depots such that no two trucks occupy the same depot simultaneously, all trucks are serviced, and the total number of active depots is minimized. The central question: *What is the smallest number of depots needed to accommodate all trucks without delays or overlaps?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary (1 if truck *i* is assigned to depot *j*; 0 otherwise).  
   - `start_time(i)`: Continuous, ≥0 (when truck *i* begins service).  
   - `completion_time(i)`: Continuous, ≥0 (when truck *i* finishes, derived as `start_time(i) + processing_times[i]`).  
   - `precedes(i, k, j)`: Binary (1 if truck *i* is scheduled before truck *k* on depot *j*; 0 otherwise).  
   - `depot_used(j)`: Binary (1 if depot *j* is used; 0 otherwise).  

   **2. Parameters:**  
   - `arrival_times[i]`: Time truck *i* arrives (e.g., Truck 1: 1, Truck 2: 4).  
   - `processing_times[i]`: Duration for truck *i* (e.g., Truck 1: 6, Truck 3: 5).  
   - `H=100`: A large constant ("Big M") for precedence constraints.  

   **3. Objective Function:**  
   Minimize the total depots used:  
   `Minimize: sum(depot_used[j] for all depots j)`.  

   **4. Constraints:**  
   - **Assignment:** Each truck assigned to exactly one depot:  
     `sum(assign[i, j] for all j) = 1` for all trucks *i*.  
   - **Arrival Time:** Trucks cannot start before arrival:  
     `start_time[i] ≥ arrival_times[i]` for all *i*.  
   - **Completion Time:** Linked to start time:  
     `completion_time[i] = start_time[i] + processing_times[i]` for all *i*.  
   - **Non-Overlapping:** For each depot *j*, if trucks *i* and *k* are assigned, enforce precedence:  
     `precedes[i, k, j] + precedes[k, i, j] ≥ assign[i, j] + assign[k, j] - 1`,  
     `precedes[i, k, j] + precedes[k, i, j] ≤ 1`,  
     and indicator constraints to ensure temporal separation.  
   - **Depot Activation:** A depot is marked used if any truck is assigned:  
     `assign[i, j] ≤ depot_used[j]` for all *i, j*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7, 8, 9]
depots = [1, 2, 3, 4, 5]
arrival_times = {1: 1, 2: 4, 3: 8, 4: 9, 5: 13, 6: 14, 7: 16, 8: 20, 9: 23}
processing_times = {1: 6, 2: 6, 3: 5, 4: 5, 5: 6, 6: 6, 7: 8, 8: 8, 9: 7}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_52_MIN_DEPOTS")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")
    depot_used = m.addVars(depots, vtype=GRB.BINARY, name="DepotUsed") # Objective var

    # --- Objective Function ---
    m.setObjective(gp.quicksum(depot_used[j] for j in depots), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")

    # 5. Link DepotUsed to assignments
    m.addConstrs((assign[i, j] <= depot_used[j] for i in trucks for j in depots), name="link_used_depot")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is number of depots, should be integer
             print(f"{int(round(obj_val_print))}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    # Print the number of depots used
    print(f"Number of depots used: {int(round(results_dict['obj_val']))}")

    # Print the assignment of trucks to depots
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
    
    # Print the start and completion times for each truck
    for i in trucks:
        print(f"Truck {i} starts at time {start_time[i].x:.2f} and completes at time {completion_time[i].x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
1
Number of depots used: 1
Truck 1 is assigned to Depot 5
Truck 2 is assigned to Depot 5
Truck 3 is assigned to Depot 5
Truck 4 is assigned to Depot 5
Truck 5 is assigned to Depot 5
Truck 6 is assigned to Depot 5
Truck 7 is assigned to Depot 5
Truck 8 is assigned to Depot 5
Truck 9 is assigned to Depot 5
Truck 1 starts at time 74.00 and completes at time 80.00
Truck 2 starts at time 68.00 and completes at time 74.00
Truck 3 starts at time 63.00 and completes at time 68.00
Truck 4 starts at time 58.00 and completes at time 63.00
Truck 5 starts at time 52.00 and completes at time 58.00
Truck 6 starts at time 46.00 and completes at time 52.00
Truck 7 starts at time 38.00 and completes at time 46.00
Truck 8 starts at time 30.00 and completes at time 38.00
Truck 9 starts at time 23.00 and completes at time 30.00


```

================================================================================



--- Problem 37 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port is divided into three berths, each experiencing varying ship arrival rates and potential incidents that reduce the berthing capacity. Port managers must decide how to divert ships during incidents to minimize total delay. Each berth has distinct characteristics: normal and reduced capacities for the main berth, an alternative berth with its own capacity, and specific arrival rates of ships. Incidents last for different durations on each berth, and diverting ships to the alternative berth incurs additional waiting time. The challenge is to determine the optimal proportion of ships to divert (from predefined options: 10%, 30%, 50%, or 70%) for each berth, balancing the trade-off between queue delays on the main berth and the extra time taken by diverted ships. The goal is to minimize the total delay across all berths while respecting capacity constraints on both main and alternative berths.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable \( y[i][k] \): Indicates whether diversion option \( k \) (where \( k \) corresponds to 10%, 30%, 50%, or 70%) is selected for berth \( i \).  
   - **2. Parameters:**  
     - \( \text{capacities\_main\_normal}[i] \): Normal capacity of the main berth for berth \( i \) (ships/hour).  
     - \( \text{capacities\_main\_reduced}[i] \): Reduced capacity of the main berth during an incident for berth \( i \) (ships/hour).  
     - \( \text{capacities\_alt}[i] \): Capacity of the alternative berth for berth \( i \) (ships/hour).  
     - \( \text{arrival\_rates}[i] \): Ship arrival rate for berth \( i \) (ships/hour).  
     - \( \text{incident\_durations}[i] \): Duration of the incident for berth \( i \) (hours).  
     - \( \text{alt\_berth\_extra\_times}[i] \): Additional waiting time for diverted ships on berth \( i \) (hours).  
     - \( \text{diversion\_options} \): Available diversion ratios (0.1, 0.3, 0.5, 0.7).  
   - **3. Objective Function:**  
     - Minimize the total delay:  
       \[
       \text{Minimize: } \sum_{i=1}^{3} \sum_{k=1}^{4} y[i][k] \cdot \text{berth\_option\_delays}[i][k]
       \]  
   - **4. Constraints:**  
     - Exactly one feasible diversion option must be selected for each berth:  
       \[
       \sum_{k \in \text{feasible\_indices}[i]} y[i][k] = 1 \quad \forall i
       \]  
     - Infeasible diversion options (those exceeding alternative berth capacity) are forbidden:  
       \[
       y[i][k] = 0 \quad \text{if } \text{berth\_option\_feasible}[i][k] = \text{False}
       \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 3
capacities_main_normal = [3912, 3441, 5324]  # ships/hour
capacities_main_reduced = [1369, 1564, 2556]  # ships/hour
capacities_alt = [1432, 1508, 1481]  # ships/hour
arrival_rates = [2164, 2812, 2132]  # ships/hour
incident_durations = [1.9172898900195445, 0.504499814551342, 1.0080972368724483]  # hours
alt_berth_extra_times = [0.1917007724090523, 0.266413817420223, 0.3180440998307011]  # hours
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option and Berth ---
berth_option_delays = {}
berth_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_option_delays[i] = {}
    berth_option_feasible[i] = {}

    for k in range(num_options):
        p_k = diversion_options[k]
        flow_alt_k = arrival_rates[i] * p_k
        flow_main_k = arrival_rates[i] * (1 - p_k)

        # 1. Check Alternative Berth Capacity Feasibility
        if flow_alt_k > capacities_alt[i] + EPSILON:
            berth_option_feasible[i][k] = False
            berth_option_delays[i][k] = LARGE_DELAY
            continue

        berth_option_feasible[i][k] = True

        # 2. Calculate Alternative Berth Delay
        delay_alt_k = flow_alt_k * incident_durations[i] * alt_berth_extra_times[i]

        # 3. Calculate Main Berth Queue Delay
        delay_queue_main_k = 0
        max_queue_main_k = 0

        if flow_main_k > capacities_main_reduced[i] + EPSILON:
            max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * incident_durations[i]
            if flow_main_k >= capacities_main_normal[i] - EPSILON:
                delay_queue_main_k = LARGE_DELAY
            else:
                dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                if dissipation_rate_k < EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                    total_influence_time_k = incident_durations[i] + dissipation_time_main_k
                    delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

        # 4. Calculate Total Delay for this option
        total_delay_k = delay_alt_k + delay_queue_main_k
        berth_option_delays[i][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    feasible_indices = [k for k in range(num_options) if berth_option_feasible[i][k]]
    if not feasible_indices:
        exit()

    m.addConstr(gp.quicksum(y[i,k] for k in feasible_indices) == 1, name="SelectOneFeasibleOption_Berth{0}".format(i))

    for k in range(num_options):
        if not berth_option_feasible[i][k]:
            m.addConstr(y[i,k] == 0, name="ForbidInfeasibleOption_Berth{0}_Option{1}".format(i,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,k] * berth_option_delays[i][k]
        for i in range(NUM_BERTHS)
        for k in range(num_options)
        if berth_option_feasible[i][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Diversion Strategy:")
    for i in range(NUM_BERTHS):
        for k in range(num_options):
            if y[i,k].X > 0.5:
                print("Berth {0}: Option {1} ({2:.0f}%)".format(
                    i+1, k, diversion_options[k]*100
                ))
                break
```
Answer:
Optimal Diversion Strategy:
Berth 1: Option 2 (50%)
Berth 2: Option 1 (30%)
Berth 3: Option 0 (10%)



================================================================================



--- Problem 38 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
A busy port sees heavy traffic from both north-south (NS) and east-west (EW) directions, with arrival rates of **656.09 vessels/hour** and **539.78 vessels/hour**, respectively. The port has approximately **2.01 berths** per direction, each capable of handling **1,460.44 vessels/hour/berth** under normal conditions. Port managers must determine the optimal signal timing to maximize throughput while adhering to operational constraints: a minimum cycle length of **72.11 minutes**, a maximum of **112.43 minutes**, and a minimum green time of **21.76 minutes** per phase. Lost time due to phase transitions totals **7.23 minutes** (3.61 minutes per phase). The challenge is to allocate green times between NS and EW directions such that the combined hourly capacity is maximized without violating cycle length or safety limits.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `C`: Cycle length (minutes), bounded between `C_min` and `C_max`.  
     - `g_NS`, `g_EW`: Green times (minutes) for NS and EW phases, each ≥ `g_min_time`.  
     - `lambda_g_NS`, `lambda_g_EW`: Fraction of cycle allocated to NS/EW green times (unitless, [0, 1]).  
     - `Cap_NS`, `Cap_EW`: Hourly capacities (vessels/hour) for NS and EW directions.  

   - **2. Parameters:**  
     - `lambda_NS_h`, `lambda_EW_h`: Vessel arrival rates (vessels/hour).  
     - `S_fog_lane_h`: Saturation flow rate per berth (vessels/hour/berth).  
     - `N_lanes`: Effective number of berths.  
     - `L_lost_time_per_phase`: Lost time per phase (minutes).  

   - **3. Objective Function:**  
     Maximize total throughput:  
     ```  
     Maximize: Cap_NS + Cap_EW  
     ```  

   - **4. Constraints:**  
     - Cycle composition: `C = g_NS + g_EW + 2 * L_lost_time_per_phase`.  
     - Green time fractions: `lambda_g_NS * C = g_NS`, `lambda_g_EW * C = g_EW`.  
     - Capacity calculations:  
       `Cap_NS = N_lanes * S_fog_lane_h * lambda_g_NS`,  
       `Cap_EW = N_lanes * S_fog_lane_h * lambda_g_EW`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
lambda_NS_h = 656.0870798866727  # vessels/h
lambda_EW_h = 539.7770349789062  # vessels/h
S_fog_lane_h = 1460.4364589161103  # vessels/h/berth
N_lanes = 2.0107477778653746
L_lost_time_per_phase = 3.614515782006933  # min
C_min = 72.10598423088928  # min
C_max = 112.42577473058644  # min
g_min_time = 21.759314114277572  # min

# --- Gurobi Model ---
model = gp.Model("PortSignalTiming")

# Decision Variables
C = model.addVar(name="CycleLength", lb=C_min, ub=C_max)
g_NS = model.addVar(name="Green_NS", lb=g_min_time)
g_EW = model.addVar(name="Green_EW", lb=g_min_time)

# Intermediate Variables
lambda_g_NS = model.addVar(name="lambda_g_NS", lb=0.0, ub=1.0)
lambda_g_EW = model.addVar(name="lambda_g_EW", lb=0.0, ub=1.0)
Cap_NS = model.addVar(name="Capacity_NS", lb=0.0)
Cap_EW = model.addVar(name="Capacity_EW", lb=0.0)

# Constraints
model.addConstr(C == g_NS + g_EW + 2 * L_lost_time_per_phase, name="CycleComposition")
model.addQConstr(lambda_g_NS * C == g_NS, name="CalcLambdaNS")
model.addQConstr(lambda_g_EW * C == g_EW, name="CalcLambdaEW")
model.addConstr(Cap_NS == N_lanes * S_fog_lane_h * lambda_g_NS, name="CalcCapacityNS")
model.addConstr(Cap_EW == N_lanes * S_fog_lane_h * lambda_g_EW, name="CalcCapacityEW")

# Objective
model.setObjective(Cap_NS + Cap_EW, GRB.MAXIMIZE)

# Optimize
model.Params.NonConvex = 2
model.optimize()

# Output
if model.status == GRB.OPTIMAL:
    print("\n--- Port Signal Timing Results ---")
    print(f"Optimal Cycle Length: {C.X:.2f} min")
    print(f"North-South Green Time: {g_NS.X:.2f} min")
    print(f"East-West Green Time: {g_EW.X:.2f} min")
    print(f"North-South Capacity: {Cap_NS.X:.2f} vessels/h")
    print(f"East-West Capacity: {Cap_EW.X:.2f} vessels/h")
    print(f"Total Throughput: {model.objVal:.2f} vessels/h")
else:
    print(f"Model status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 3 rows, 7 columns and 7 nonzeros
Model fingerprint: 0x8931d3c3
Model has 2 quadratic constraints
Coefficient statistics:
  Matrix range     [1e+00, 3e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [1e+00, 1e+02]
  RHS range        [7e+00, 7e+00]
Presolve removed 2 rows and 2 columns

Continuous model is non-convex -- solving as a MIP

Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolved: 9 rows, 6 columns, 27 nonzeros
Presolved model has 2 bilinear constraint(s)
Variable types: 6 continuous, 0 integer (0 binary)
Found heuristic solution: objective 2747.7465374

Root relaxation: objective 3.208389e+03, 3 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0 3208.38922    0    2 2747.74654 3208.38922  16.8%     -    0s
     0     0 3056.15075    0    2 2747.74654 3056.15075  11.2%     -    0s
     0     2 3056.15075    0    2 2747.74654 3056.15075  11.2%     -    0s

Explored 77 nodes (42 simplex iterations) in 0.03 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 2747.75 

Optimal solution found (tolerance 1.00e-04)
Best objective 2.747746537358e+03, best bound 2.747746537358e+03, gap 0.0000%

--- Port Signal Timing Results ---
Optimal Cycle Length: 112.43 min
North-South Green Time: 52.60 min
East-West Green Time: 52.60 min
North-South Capacity: 1373.87 vessels/h
East-West Capacity: 1373.87 vessels/h
Total Throughput: 2747.75 vessels/h



================================================================================



--- Problem 39 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy logistics hub, seven trucks of varying types and schedules arrive at a single depot, each with strict arrival times and processing requirements. The logistics manager faces the challenge of scheduling these vehicles efficiently to minimize the total time (makespan) required to service all trucks, considering setup times between different truck types.  

The trucks are labeled 1 through 7, with arrival times ranging from 2 to 19 hours. Processing times vary from 4 to 6 hours per truck. Truck types are categorized as 'A' or 'C', with a critical setup time of 2.3 hours required when transitioning from an 'A' to a 'B' type (though no 'B' types are present in this instance, the setup logic is embedded in the model). The depot must adhere to strict rules: each truck must be assigned to the depot, cannot start processing before its arrival time, and must complete processing without overlapping with other trucks unless separated by necessary setup times.  

The core question is: **What is the optimal schedule that minimizes the total completion time (makespan) for all trucks, given their arrival times, processing durations, and potential setup delays?**  

---
**

Modeling Process:**
**
**1. Decision Variables:**  
- `assign(i, j)`: Binary variable indicating whether truck `i` is assigned to depot `j`.  
- `start_time(i)`: Continuous variable representing the start time of truck `i`.  
- `completion_time(i)`: Continuous variable representing the completion time of truck `i`.  
- `precedes(i, k, j)`: Binary variable indicating if truck `i` precedes truck `k` on depot `j`.  
- `setup(i, k, j)`: Continuous variable representing the setup time between trucks `i` and `k` on depot `j`.  
- `makespan`: Continuous variable representing the total completion time of all trucks.  

**2. Parameters:**  
- `trucks = [1, 2, 3, 4, 5, 6, 7]`: List of trucks.  
- `depots = [1]`: Single depot available.  
- `arrival_times`: Dictionary mapping trucks to their arrival times (e.g., truck 1 arrives at hour 2).  
- `processing_times`: Dictionary mapping trucks to their processing durations (e.g., truck 1 requires 4 hours).  
- `truck_types`: Dictionary mapping trucks to their types ('A' or 'C').  
- `setup_time_value = 2.3`: Setup time (hours) required for transitioning from type 'A' to 'B' (though unused here).  
- `H = 100`: A large constant for modeling purposes.  

**3. Objective Function:**  
Minimize `makespan` (the latest completion time among all trucks).  

**4. Constraints:**  
- **Assignment:** Each truck must be assigned to the depot:  
  `sum(assign(i, j) for j in depots) = 1` for all `i` in trucks.  
- **Arrival Time:** Trucks cannot start before their arrival time:  
  `start_time(i) >= arrival_times[i]` for all `i` in trucks.  
- **Completion Time:** Completion time is the sum of start time and processing time:  
  `completion_time(i) = start_time(i) + processing_times[i]` for all `i` in trucks.  
- **Non-Overlapping and Setup:**  
  - If truck `i` precedes truck `k` on depot `j`, enforce setup time and sequencing:  
    `start_time(k) >= completion_time(i) + setup(i, k, j)`.  
  - Setup time is zero unless transitioning from 'A' to 'B' (not applicable here).  
  - Precedence constraints ensure no overlaps:  
    `precedes(i, k, j) + precedes(k, i, j) >= assign(i, j) + assign(k, j) - 1` for `i < k`.  
- **Makespan Definition:** The makespan is the maximum completion time:  
  `makespan >= completion_time(i)` for all `i` in trucks.  

---

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7]
depots = [1]
arrival_times = {1: 2, 2: 4, 3: 6, 4: 10, 5: 11, 6: 15, 7: 19}
processing_times = {1: 4, 2: 5, 3: 6, 4: 5, 5: 5, 6: 4, 7: 4}
truck_types = {1: 'C', 2: 'A', 3: 'C', 4: 'A', 5: 'C', 6: 'A', 7: 'A'} # Dict {truck_id: type_str}
setup_time_value = 2.3 # Hours for A -> B setup
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_40_SETUP_MAKESPAN")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")
    setup = m.addVars(trucks, trucks, depots, lb=0.0, vtype=GRB.CONTINUOUS, name="setup")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping and Setup Time Calculation (Copied from Problem 61)
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i == k: continue
                is_setup_needed = 1 if truck_types.get(i) == 'A' and truck_types.get(k) == 'B' else 0
                m.addGenConstrIndicator(precedes[i,k,j], True, setup[i,k,j] >= setup_time_value * is_setup_needed, name=f"setup_lower_{i}_{k}_{j}")
                m.addConstr(setup[i,k,j] <= setup_time_value * precedes[i,k,j], name=f"setup_upper_{i}_{k}_{j}")
                if not is_setup_needed:
                     m.addConstr(setup[i,k,j] == 0, name=f"setup_zero_{i}_{k}_{j}")
                m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i] + setup[i,k,j], name=f"overlap_with_setup_{i}_{k}_{j}")
                if i < k:
                     m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                     m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    print("Optimal Schedule:")
    for i in trucks:
        print(f"Truck {i}: Start Time = {start_time[i].x:.4f}, Completion Time = {completion_time[i].x:.4f}")
    print(f"Total Makespan: {makespan.x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
35.0000
Optimal Schedule:
Truck 1: Start Time = 2.0000, Completion Time = 6.0000
Truck 2: Start Time = 17.0000, Completion Time = 22.0000
Truck 3: Start Time = 6.0000, Completion Time = 12.0000
Truck 4: Start Time = 12.0000, Completion Time = 17.0000
Truck 5: Start Time = 26.0000, Completion Time = 31.0000
Truck 6: Start Time = 22.0000, Completion Time = 26.0000
Truck 7: Start Time = 31.0000, Completion Time = 35.0000
Total Makespan: 35.0000


```

================================================================================



--- Problem 40 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A port manager is tasked with optimizing the berthing schedule for two ships at a busy port to minimize total waiting time. The port operates with a fixed cycle time of 46 hours, divided into two distinct berthing slots. Each slot has a duration that must fall within strict bounds: no less than 18 hours and no more than 46 hours. The impact of waiting time for each ship is characterized by coefficients of 424 and 2380, representing the relative cost of delay for ships waiting during the non-berthing time. The manager's challenge is to allocate the berthing times between the two slots such that the sum of the berthing times equals the total cycle time, while minimizing the cumulative waiting time experienced by all ships. The core question is: What is the optimal distribution of berthing times between the two slots to achieve the lowest possible total waiting time?
**

**Modeling Process:**
**
**1. Decision Variables:**
- `t_vars[i]`: Continuous variable representing the berthing time (in hours) allocated to slot `i`, where `i` ranges from 0 to `num_slots - 1` (i.e., 0 and 1 for the two slots). Each `t_vars[i]` has a lower bound of 18 hours and an upper bound of 46 hours.

**2. Parameters:**
- `num_slots = 2`: Number of berthing slots.
- `lb_time = 18`: Minimum berthing time for any slot (hours).
- `ub_time = 46`: Maximum berthing time for any slot (hours).
- `cycle_time = 46`: Total cycle time (hours), fixed and equal to `ub_time`.
- `wait_coeffs = [424, 2380]`: Waiting time coefficients for slots 0 and 1, respectively.

**3. Objective Function:**
- Minimize the total waiting time, calculated as the sum over all slots of the product of the waiting time coefficient and the non-berthing time (which is `cycle_time - berthing_time` for each slot):
  ```
  Minimize: sum(wait_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_slots))
  ```

**4. Constraints:**
- The sum of berthing times across all slots must equal the total cycle time:
  ```
  sum(t_vars[i] for i in range(num_slots)) == cycle_time
  ```
- Variable bounds:
  ```
  18 <= t_vars[i] <= 46 for all i in range(num_slots)
  ```
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_slots = 2
lb_time = 18          # Lower bound for berthing time
ub_time = 46          # Upper bound for berthing time
cycle_time = 46   # Total cycle time (set equal to ub_time)
wait_coeffs = [424, 2380] # Waiting time coefficients per slot
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(wait_coeffs) != num_slots:
    print("Error: wait_coeffs length mismatch with num_slots")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: wait_coeffs length"
    # raise ValueError("wait_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_slots}-Slot Berthing Schedule", env=env)

        # --- Decision variables (dynamic based on num_slots) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_slots, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for slot i is proportional to wait * non-berthing_time = wait * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(wait_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_slots)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_slots)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_slots)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_slots):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
Optimal total waiting time: 54712.00
------------------------------
Optimal berthing times (hours):
  t1: 18.00, t2: 28.00



================================================================================



--- Problem 41 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A maritime logistics company is tasked with efficiently scheduling two tugboats from a central port to serve a single ship, aiming to minimize total travel distance while respecting tugboat capacity constraints. The port (Node 0) must dispatch the tugboats, each with distinct capacities: the first can carry up to 10 units, while the second can handle up to 29 units. The ship (Node 1) requires 20 units of assistance, making it impossible for the smaller tugboat to service this request alone. The travel distance between the port and the ship is 66 nautical miles, and the return trip covers the same distance. The challenge is to assign routes such that the ship’s demand is met without exceeding tugboat capacities, while ensuring each tugboat starts and ends at the port. The key question is: *What is the most efficient routing plan that minimizes total travel distance while fulfilling all operational constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable \(x_{i,j,k}\): Equals 1 if tugboat \(k\) travels directly from node \(i\) to node \(j\), else 0.  
     - Continuous variable \(u_i\) (for subtour elimination): Represents the sequence of node \(i\) in the route (only relevant for larger problems).  
   - **2. Parameters:**  
     - \(N = 2\): Total nodes (port + ship).  
     - \(K = 2\): Number of tugboats.  
     - \(Q = [10, 29]\): Tugboat capacities.  
     - \(q = [0, 20]\): Demand at nodes (port has 0 demand).  
     - \(d = [[0, 66], [66, 0]]\): Distance matrix.  
   - **3. Objective Function:**  
     Minimize total distance: \(\sum_{k=1}^{K} \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} d_{i,j} \cdot x_{i,j,k}\).  
   - **4. Constraints:**  
     - **Visit Once:** Ship (Node 1) must be visited exactly once.  
     - **Flow Conservation:** Tugboats entering a node must exit it.  
     - **Port Departure/Return:** Each tugboat starts and ends at the port (Node 0).  
     - **Capacity:** Total demand served by a tugboat cannot exceed its capacity.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 2
K = 2
Q = [10, 29.0]
q = [0, 20]
d = [
    [0, 66],
    [66, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("Tugboat Scheduling", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each ship (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Tugboat Departure/Return from Port (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartPort_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnPort_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving Tugboat Scheduling instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for tugboat {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for tugboat {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving Tugboat Scheduling instance...

Optimal solution found!
Total distance: 132.00

Route for tugboat 2 (Capacity: 29.0):
0 -> 1 -> 0
Route Load: 20 / 29.0


```

================================================================================



--- Problem 42 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy trucking depot, a critical scheduling challenge arises: efficiently assigning six delivery trucks (`trucks = [1, 2, 3, 4, 5, 6]`) to a single available loading dock (`docks = [1]`). Each truck arrives at a specific time (`arrival_times = {1: 2, 2: 3, 3: 7, 4: 12, 5: 17, 6: 21}`) and requires a fixed processing duration (`processing_times = {1: 4, 2: 7, 3: 6, 4: 7, 5: 5, 6: 7}`) to unload its cargo. The depot operations are further complicated by two scheduled maintenance windows (`maintenance_windows = [(9, 12), (19, 23)]`), during which the dock cannot be used. The goal is to assign trucks to the dock while respecting arrival times, avoiding overlaps, and ensuring no truck is processed during maintenance. The central question: *What is the minimal total time (makespan) required to complete all operations without violating these constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary (1 if truck `i` is assigned to dock `j`; 0 otherwise).  
   - `start_time[i]`: Continuous (when truck `i` begins processing).  
   - `completion_time[i]`: Continuous (when truck `i` finishes).  
   - `precedes[i, k, j]`: Binary (1 if truck `i` is scheduled before truck `k` on dock `j`).  
   - `maint_choice[i, w]`: Binary (1 if truck `i` avoids maintenance window `w` by finishing before it starts; 0 otherwise).  
   - `makespan`: Continuous (total time to complete all trucks).  

   **2. Parameters:**  
   - `arrival_times[i]`, `processing_times[i]`: Truck-specific data.  
   - `H = 100`: Large constant for linearizing disjunctions.  
   - Maintenance windows: `(9, 12)` and `(19, 23)`.  

   **3. Objective Function:**  
   Minimize `makespan` (latest completion time across all trucks).  

   **4. Constraints:**  
   - Each truck must be assigned to the dock (`assign[i, j] = 1`).  
   - Trucks cannot start before arrival (`start_time[i] >= arrival_times[i]`).  
   - Completion time is start time plus processing time (`completion_time[i] = start_time[i] + processing_times[i]`).  
   - Non-overlapping: If `precedes[i, k, j] = 1`, truck `k` starts after `i` finishes, and vice versa.  
   - Maintenance avoidance: For each window `(m_start, m_end)`, truck `i` must finish before `m_start` or start after `m_end`.  
   - `makespan` is the maximum completion time across all trucks.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
docks = [1] # Should be [1]
arrival_times = {1: 2, 2: 3, 3: 7, 4: 12, 5: 17, 6: 21}
processing_times = {1: 4, 2: 7, 3: 6, 4: 7, 5: 5, 6: 7}
maintenance_windows = [(9, 12), (19, 23)] # List of (start, end) tuples
H = 100 # Big M
max_k = 20 # Not used
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DOCKING_PROBLEM_63_MULTI_MAINT")

    if not trucks or not docks or len(docks)!=1: raise ValueError("Invalid trucks/docks")
    the_dock = docks[0]
    # if not maintenance_windows: raise ValueError("Maintenance windows list is empty") # Allow empty list

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign") # Trivial
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    # Binary variable for each truck and each maintenance window disjunction
    maint_choice = m.addVars(trucks, range(len(maintenance_windows)), vtype=GRB.BINARY, name="maint_choice")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_dock] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (on the single dock) using Indicators
    j = the_dock
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. Maintenance window constraints (multiple windows)
    for i in trucks:
        for w_idx, (m_start, m_end) in enumerate(maintenance_windows):
             # Disjunction: c[i] <= m_start OR s[i] >= m_end
             m.addConstr(completion_time[i] <= m_start + H * maint_choice[i, w_idx], name=f"maint_before_{i}_win{w_idx}")
             m.addConstr(start_time[i] >= m_end - H * (1 - maint_choice[i, w_idx]), name=f"maint_after_{i}_win{w_idx}")


    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal makespan: {results_dict['obj_val']:.4f}")
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
48.0000
Optimal makespan: 48.0000
Truck 1 - Start Time: 5.0000, Completion Time: 9.0000
Truck 2 - Start Time: 12.0000, Completion Time: 19.0000
Truck 3 - Start Time: 23.0000, Completion Time: 29.0000
Truck 4 - Start Time: 36.0000, Completion Time: 43.0000
Truck 5 - Start Time: 43.0000, Completion Time: 48.0000
Truck 6 - Start Time: 29.0000, Completion Time: 36.0000


```

================================================================================



--- Problem 43 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy container terminal is facing the challenge of balancing operational costs against the need to handle a constant stream of arriving ships. With 11 berths available, each capable of processing up to 85 containers per hour, the management must decide how many berths to open to meet the demand of 695 containers per hour while minimizing the total cost. Opening a berth incurs a fixed expense of $43, reflecting staffing and maintenance overhead. The core dilemma is to determine the minimal number of berths to activate—no more, no less—to ensure the total processing capacity meets or exceeds the incoming container volume without unnecessary expenditure. The stakes are high: too few berths risk congestion and delays, while too many inflate costs unnecessarily.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[j]`: Binary variable for each berth `j` (where `j = 0, 1, ..., 10`), where `x[j] = 1` if berth `j` is open, and `0` otherwise.  
   - **2. Parameters:**  
     - `num_berths = 11`: Total available berths.  
     - `containers_arriving = 695`: Containers requiring processing per hour.  
     - `berth_capacity = 85`: Maximum containers a single berth can handle per hour.  
     - `cost_per_berth = 43`: Cost ($) to open and operate one berth.  
   - **3. Objective Function:**  
     - Minimize the total cost: `Minimize: sum(cost_per_berth * x[j] for all j)`.  
   - **4. Constraints:**  
     - **Capacity requirement:** The total capacity of open berths must satisfy demand: `sum(x[j] * berth_capacity for all j) >= 695`.  
     - **Binary variables:** Each `x[j]` must be `0` or `1`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_berths = 11
containers_arriving = 695
berth_capacity = 85
cost_per_berth = 43
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("CONTAINER_TERMINAL_BERTH_OPENING", env=env)

    # --- Decision Variables ---
    # x[j] = 1 if berth j is open, 0 otherwise
    x = m.addVars(num_berths, vtype=GRB.BINARY, name="x")

    # --- Objective Function: Minimize total cost ---
    m.setObjective(gp.quicksum(cost_per_berth * x[j] for j in range(num_berths)), GRB.MINIMIZE)

    # --- Constraints ---
    # Total processing capacity must meet the demand
    m.addConstr(gp.quicksum(x[j] * berth_capacity for j in range(num_berths)) >= containers_arriving, "CapacityConstraint")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status # Note: Status, not status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        results_dict['x_sol'] = m.getAttr('X', x) # Store variable values

    # --- Output Results ---
    print(f"--- CONTAINER_TERMINAL_BERTH_OPENING Results ---")
    if m.Status == GRB.OPTIMAL:
        x_sol = results_dict.get('x_sol', {})
        open_berths = [j for j in range(num_berths) if x_sol.get(j, 0) > 0.5]
        num_open = len(open_berths)
        total_capacity_provided = num_open * berth_capacity

        print(f"Optimization Status: Optimal")
        print(f"Minimum Total Cost: {results_dict.get('obj_val', 'N/A'):.2f}")
        print(f"Number of Berths to Open: {num_open} / {num_berths}")
        # print(f"Indices of Open Berths: {open_berths}") # Optional: list indices
        print(f"Total Capacity Provided: {total_capacity_provided} containers/hr")
        print(f"Containers Arriving (Demand): {containers_arriving} containers/hr")
        print(f"Capacity per Berth: {berth_capacity}, Cost per Berth: {cost_per_berth}")

    elif m.Status == GRB.INFEASIBLE:
        print(f"Optimization Status: Infeasible")
        print(f"Demand ({containers_arriving}) may exceed max possible capacity ({num_berths * berth_capacity}).")
    elif m.Status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m.ObjVal is not None and abs(m.ObjVal) < float('inf'):
              print(f"Best Objective Found: {m.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m.Status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- CONTAINER_TERMINAL_BERTH_OPENING Results ---
Optimization Status: Optimal
Minimum Total Cost: 387.00
Number of Berths to Open: 9 / 11
Total Capacity Provided: 765 containers/hr
Containers Arriving (Demand): 695 containers/hr
Capacity per Berth: 85, Cost per Berth: 43


```

================================================================================



--- Problem 44 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port is tasked with efficiently scheduling the berthing of four ships at a set of standardized docks to minimize the number of docks used. The docks measure 37 units in width and 45 units in length, and the ships vary significantly in size: one is a long, narrow ship (6×31), another a wide but short ship (24×15), a moderately sized ship (7×14), and a very long, flat ship (33×1). The challenge is to arrange all ships into the fewest possible docks without overlaps while respecting the dock boundaries. The goal is not just to fit them but to do so in a way that optimizes spatial utilization, reducing wasted space and operational costs associated with excess dock usage. The critical question: *What is the minimal number of docks required to berth all ships, and where should each ship be placed within those docks?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
    - Binary `x[i, j]`: 1 if ship *i* is assigned to dock *j*, else 0.  
    - Binary `y[j]`: 1 if dock *j* is used, else 0.  
    - Continuous `px[i, j]`, `py[i, j]`: Bottom-left coordinates of ship *i* in dock *j*.  
    - Binary `left[i, k, j]`, `right[i, k, j]`, `below[i, k, j]`, `above[i, k, j]`: 1 if ship *i* is to the left/right/below/above ship *k* in dock *j*.  

    **2. Parameters:**  
    - `ships`: List of ship dimensions [(6,31), (24,15), (7,14), (33,1)].  
    - `dock_size`: (37, 45).  
    - `M_w`, `M_h`: Big-M values (37 and 45, respectively).  

    **3. Objective Function:**  
    Minimize the total docks used:  
    `Minimize: sum(y[j] for all j)`  

    **4. Constraints:**  
    - **Assignment:** Each ship *i* must be in exactly one dock (`sum(x[i, j] for all j == 1`).  
    - **Dock Boundaries:** Ship *i*’s placement in dock *j* must fit within the dock’s dimensions (using Big-M to deactivate constraints if *x[i, j] = 0*).  
    - **Non-Overlapping:** For any two ships (*i*, *k*) in the same dock *j*, enforce at least one spatial relationship (left/right/below/above).  
    - **Dock Activation:** If any ship *i* is in dock *j*, dock *j* must be marked as used (`x[i, j] <= y[j]`).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
ships = [(6, 31), (24, 15), (7, 14), (33, 1)]  # (width, length) of ships
dock_size = (37, 45)  # (width, length) of each dock
num_ships = 4 # len(ships)
# Maximum docks needed (worst case: one ship per dock)
# Can sometimes be reduced with lower bounds, but num_ships is safe
num_docks = num_ships
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using dock dimensions is common and valid)
M_w = dock_size[0]
M_h = dock_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Dock Scheduling", env=env)

# --- Decision Variables ---
# x[i,j]: ship i assigned to dock j
x = model.addVars(num_ships, num_docks, vtype=GRB.BINARY, name="x")
# y[j]: dock j is used
y = model.addVars(num_docks, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of ship i if in dock j
px = model.addVars(num_ships, num_docks, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_ships, num_docks, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of ships *within the same dock*
left  = model.addVars(num_ships, num_ships, num_docks, vtype=GRB.BINARY, name="left")
right = model.addVars(num_ships, num_ships, num_docks, vtype=GRB.BINARY, name="right")
below = model.addVars(num_ships, num_ships, num_docks, vtype=GRB.BINARY, name="below")
above = model.addVars(num_ships, num_ships, num_docks, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of docks used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_docks))

# --- Constraints ---

# 1. Each ship must be assigned to exactly one dock
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Ship placement constraints within dock boundaries (Big-M formulation)
for j in range(num_docks):
    for i in range(num_ships):
        ship_w, ship_l = ships[i] # Get dimensions for ship i

        # Position variables must be 0 if ship i is not in dock j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Ship's right edge <= dock width IF ship is placed in dock (x[i,j]=1)
        model.addConstr(px[i, j] + ship_w <= dock_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Ship's top edge <= dock length IF ship is placed in dock (x[i,j]=1)
        model.addConstr(py[i, j] + ship_l <= dock_size[1] + M_h * (1 - x[i, j]), name=f"Length_Limit_{i}_{j}")

# 3. Non-overlapping constraints for ships within the same dock
for j in range(num_docks):
    for i in range(num_ships):
        for k in range(i + 1, num_ships): # Iterate over distinct pairs (i < k)
            ship_i_w, ship_i_l = ships[i]
            ship_k_w, ship_k_l = ships[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => ship i is to the left of ship k
            model.addConstr(px[i, j] + ship_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => ship i is to the right of ship k (k is left of i)
            model.addConstr(px[k, j] + ship_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => ship i is below ship k
            model.addConstr(py[i, j] + ship_i_l <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => ship i is above ship k (k is below i)
            model.addConstr(py[k, j] + ship_k_l <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH ship i and ship k are in dock j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link ship assignment to dock usage: If any ship i is in dock j, then dock j must be used (y[j]=1)
#    This can be done per ship or aggregated. Per ship is often tighter.
for j in range(num_docks):
    for i in range(num_ships):
        model.addConstr(x[i, j] <= y[j], name=f"Ship_Dock_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_ships * y[j], name=f"Dock_Activation_{j}")


# --- Solve ---
print("Solving 2DDP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of docks used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    dock_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_docks):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Dock {j_sol + 1} (Used):")
            ships_in_dock_info = []
            for i_sol in range(num_ships):
                if x[i_sol, j_sol].X > 0.5:
                    ship_data = {
                        "id": i_sol,
                        "dims": ships[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    ships_in_dock_info.append(ship_data)
                    print(f"  Ship {ship_data['id']} {ship_data['dims']} at {ship_data['pos']}")
            dock_details.append({'dock_index': j_sol, 'ships': ships_in_dock_info})
            print("-" * 10)
    results_dict['dock_details'] = dock_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 2DDP instance...

Optimal number of docks used: 1
------------------------------
Dock 1 (Used):
  Ship 0 (6, 31) at (24.0, 1.0)
  Ship 1 (24, 15) at (0.0, 1.0)
  Ship 2 (7, 14) at (0.0, 16.0)
  Ship 3 (33, 1) at (0.0, 0.0)
----------


```

================================================================================



--- Problem 45 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
At a busy container port, the management team is tasked with efficiently managing ship berthing to minimize wait times while optimizing resource usage. The port has two types of berths: 4 berths capable of handling large cargo ships (which can also accommodate smaller vessels) and 3 berths dedicated exclusively to smaller vessels. Each large cargo berth can process 32 large ships per hour, while small vessel-only berths handle 47 small vessels per hour. On a typical day, 43 large ships and 274 small vessels arrive, demanding prompt processing to avoid congestion. The operational goal is to determine the minimal number of berths to open—balancing staffing costs and infrastructure utilization—while ensuring sufficient capacity to handle all incoming vessels. The key question is: What is the most efficient combination of large cargo and small vessel-only berths to open to meet demand without unnecessary excess capacity?
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `open_large[i]`: Binary variable (0 or 1) indicating whether large cargo berth `i` is opened (1) or closed (0), for `i` in 1 to 4.
   - `open_small[j]`: Binary variable (0 or 1) indicating whether small vessel-only berth `j` is opened (1) or closed (0), for `j` in 1 to 3.

**2. Parameters:**
   - `num_large_berths = 4`: Total available large cargo berths.
   - `num_small_only_berths = 3`: Total available small vessel-only berths.
   - `large_service_rate = 32`: Large ships processed per hour per open large cargo berth.
   - `small_service_rate = 47`: Small vessels processed per hour per open small vessel-only berth (or per open large cargo berth, for small vessels).
   - `arrival_large_ships = 43`: Total large ships requiring processing.
   - `arrival_small_vessels = 274`: Total small vessels requiring processing.

**3. Objective Function:**
   - Minimize the total number of open berths:  
     `Minimize: sum(open_large[i] for all i) + sum(open_small[j] for all j)`.

**4. Constraints:**
   - **Large ship capacity:** The total capacity of open large cargo berths must meet or exceed large ship arrivals:  
     `sum(open_large[i] * large_service_rate for all i) >= arrival_large_ships`.
   - **Small vessel capacity:** The combined capacity of open large cargo berths (for small vessels) and open small vessel-only berths must meet or exceed small vessel arrivals:  
     `sum(open_large[i] * small_service_rate for all i) + sum(open_small[j] * small_service_rate for all j) >= arrival_small_vessels`.
   - **Binary constraints:** All decision variables are binary (0 or 1).

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
num_large_berths = 4; num_small_only_berths = 3
large_service_rate = 32; small_service_rate = 47
arrival_small_vessels = 274; arrival_large_ships = 43
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m8 = gp.Model("Port_Berthing_MIP", env=env)
    # Vars
    open_large = m8.addVars(num_large_berths, vtype=GRB.BINARY, name="open_large_berth")
    open_small = m8.addVars(num_small_only_berths, vtype=GRB.BINARY, name="open_small_only_berth")
    # Objective
    m8.setObjective(gp.quicksum(open_large) + gp.quicksum(open_small), sense=GRB.MINIMIZE)
    # Constraints
    m8.addConstr(gp.quicksum(open_large[i] * large_service_rate for i in range(num_large_berths)) >= arrival_large_ships, "large_capacity")
    m8.addConstr(gp.quicksum(open_large[i] * small_service_rate for i in range(num_large_berths)) + gp.quicksum(open_small[j] * small_service_rate for j in range(num_small_only_berths)) >= arrival_small_vessels, "small_capacity")
    # Optimize
    m8.optimize()
    # Store results
    results_dict['status'] = m8.status
    if m8.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m8.objVal
        results_dict['open_large_opt'] = [open_large[i].X for i in range(num_large_berths)]
        results_dict['open_small_opt'] = [open_small[j].X for j in range(num_small_only_berths)]
    # Output Results
    print("--- Problem 8: Port Berthing (MIP) ---")
    if m8.status == GRB.OPTIMAL:
        ol_opt = results_dict.get('open_large_opt', []); os_opt = results_dict.get('open_small_opt', [])
        num_open_large = sum(v > 0.5 for v in ol_opt); num_open_small_only = sum(v > 0.5 for v in os_opt)
        print(f"Optimization Status: Optimal")
        print(f"Optimal number of large cargo berths to open: {int(num_open_large)} / {num_large_berths}")
        print(f"Optimal number of small vessel-only berths to open: {int(num_open_small_only)} / {num_small_only_berths}")
        print(f"Minimum total open berths: {int(m8.objVal)}")
        large_cap = sum(v * large_service_rate for v in ol_opt)
        small_cap = sum(v * small_service_rate for v in ol_opt) + sum(v * small_service_rate for v in os_opt)
        print(f"Total large ship capacity: {large_cap:.1f} >= {arrival_large_ships}")
        print(f"Total small vessel capacity: {small_cap:.1f} >= {arrival_small_vessels}")
    elif m8.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible")
    else: print(f"Optimization Status: {m8.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_BERTHING
```
Answer:
--- Problem 8: Port Berthing (MIP) ---
Optimization Status: Optimal
Optimal number of large cargo berths to open: 3 / 4
Optimal number of small vessel-only berths to open: 3 / 3
Minimum total open berths: 6
Total large ship capacity: 96.0 >= 43
Total small vessel capacity: 282.0 >= 274



================================================================================



--- Problem 46 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
At a busy port, the harbor master is tasked with balancing the competing demands of two types of cargo ships: container ships and bulk carriers. The port operates on a fixed 90-minute cycle, but not all of this time can be used productively—each phase transition incurs a 5-minute loss, totaling 10 minutes of lost time per cycle. The remaining 80 minutes must be allocated as *effective berthing time* between the two ship types, ensuring smooth operations while adhering to strict service-level constraints.  

The container ships handle a steady stream of 814.33 TEUs (Twenty-foot Equivalent Units) per hour, supported by a saturation flow rate of 1,790.76 TEUs per hour. Meanwhile, the bulk carriers see slightly lighter demand at 652.16 tons per hour, with a saturation flow of 1,637.32 tons per hour. A critical requirement limits the bulk carrier saturation level to no more than 0.932, ensuring minimal delays for these ships. Additionally, safety regulations mandate a minimum of 5 minutes of berthing time for each phase, even during low-traffic periods.  

The core optimization challenge is to maximize the container ship effective berthing time—prioritizing its higher demand—while guaranteeing the bulk carriers receive just enough berthing time to meet their saturation constraint. Striking this balance requires precise mathematical coordination to avoid congestion or inefficient resource allocation.  

**Key Question:** *How should the 80 minutes of effective berthing time be split between container ships and bulk carriers to maximize container ship throughput while ensuring the bulk carrier saturation limit is respected?*  

---
**

Modeling Process:**
**
**1. Decision Variables:**  
- `b_cont`: Effective berthing time allocated to the container ships (minutes).  
- `b_bulk`: Effective berthing time allocated to the bulk carriers (minutes).  

**2. Parameters:**  
- `cycle_length = 90`: Total port cycle duration (minutes).  
- `total_lost_time = 10`: Lost time per cycle due to phase transitions (minutes).  
- `effective_berthing_total = 80`: Net time available for berthing phases (cycle_length - total_lost_time).  
- `demand_cont = 814.33`, `demand_bulk = 652.16`: Cargo demand rates (TEUs/hr for container ships, tons/hr for bulk carriers).  
- `saturation_flow_cont = 1,790.76`, `saturation_flow_bulk = 1,637.32`: Maximum cargo flow rates (TEUs/hr for container ships, tons/hr for bulk carriers).  
- `max_saturation_bulk = 0.932`: Upper bound for bulk carrier saturation level.  
- `min_berthing_time = 5`: Minimum berthing time per phase (minutes).  

**3. Objective Function:**  
Maximize the container ship effective berthing time:  
```  
Maximize: b_cont  
```  

**4. Constraints:**  
- **Total berthing time allocation:** The sum of berthing times must match the available effective berthing time.  
  ```  
  b_cont + b_bulk == 80  
  ```  
- **Bulk carrier saturation limit:** The bulk carrier berthing time must suffice to keep saturation below 0.932.  
  ```  
  b_bulk >= (demand_bulk * cycle_length) / (saturation_flow_bulk * max_saturation_bulk)  
  ```  
- **Minimum berthing times:** Both phases must receive at least 5 minutes.  
  ```  
  b_cont >= 5, b_bulk >= 5  
  ```  

---

3.
**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
cycle_length = 90  # minutes
lost_time_per_phase = 5  # minutes
total_lost_time = 2 * lost_time_per_phase
effective_berthing_total = cycle_length - total_lost_time

demand_cont = 814.3271698738796  # TEUs/hr
saturation_flow_cont = 1790.7583125894162  # TEUs/hr
demand_bulk = 652.1585799133381  # tons/hr
saturation_flow_bulk = 1637.317814069  # tons/hr

max_saturation_bulk = 0.93198600476181  # Service level constraint for bulk carriers
min_berthing_time = 5  # Minimum berthing time per phase

# --- Model Creation ---
model = gp.Model("Port_Berthing_Cycle_LP")

# --- Decision Variables ---
b_cont = model.addVar(name="berthing_cont", lb=min_berthing_time)
b_bulk = model.addVar(name="berthing_bulk", lb=min_berthing_time)

# --- Objective Function ---
model.setObjective(b_cont, sense=GRB.MAXIMIZE)

# --- Constraints ---
# Total effective berthing time equals available time in cycle
model.addConstr(b_cont + b_bulk == effective_berthing_total, name="total_berthing_time")

# Bulk carrier saturation constraint
min_b_bulk_for_saturation = (demand_bulk * cycle_length) / (saturation_flow_bulk * max_saturation_bulk)
model.addConstr(b_bulk >= min_b_bulk_for_saturation, name="bulk_saturation_limit")

# --- Optimization ---
model.optimize()

# --- Output Results ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    print(f"Optimal Container Ship Effective Berthing Time: {b_cont.X:.2f} minutes")
    print(f"Optimal Bulk Carrier Effective Berthing Time: {b_bulk.X:.2f} minutes")

    # Calculate actual saturation levels achieved
    sat_cont = (demand_cont * cycle_length) / (saturation_flow_cont * b_cont.X) if b_cont.X > 0 else float('inf')
    sat_bulk = (demand_bulk * cycle_length) / (saturation_flow_bulk * b_bulk.X) if b_bulk.X > 0 else float('inf')

    print(f"\nSaturation Analysis:")
    print(f"  Container Ship Saturation: {sat_cont:.3f}")
    print(f"  Bulk Carrier Saturation: {sat_bulk:.3f} (Constraint <= 0.93198600476181)")

    print(f"\nTiming Summary:")
    print(f"  Total Cycle Length: 90 minutes")
    print(f"  Total Lost Time: {total_lost_time} minutes")
    print(f"  Total Effective Berthing: {effective_berthing_total} minutes")
    print(f"  Minimum Required Bulk Carrier Berthing: {min_b_bulk_for_saturation:.2f} minutes")
elif model.status == GRB.INFEASIBLE:
    print(f"Optimization Status: Infeasible")
    print(f"Minimum required Bulk Carrier berthing time for saturation limit: {min_b_bulk_for_saturation:.2f} min")
    print(f"Minimum required Container Ship berthing time: {min_berthing_time:.2f} min")
    print(f"Total required minimum berthing: {min_b_bulk_for_saturation + min_berthing_time:.2f} min")
    print(f"Total available effective berthing: {effective_berthing_total:.2f} min")
else:
    print(f"Optimization Status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 2 rows, 2 columns and 3 nonzeros
Model fingerprint: 0x8f2e8f63
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [5e+00, 5e+00]
  RHS range        [4e+01, 8e+01]
Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    4.1536098e+01   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  4.153609760e+01

--- Optimization Results ---
Optimization Status: Optimal
Optimal Container Ship Effective Berthing Time: 41.54 minutes
Optimal Bulk Carrier Effective Berthing Time: 38.46 minutes

Saturation Analysis:
  Container Ship Saturation: 0.985
  Bulk Carrier Saturation: 0.932 (Constraint <= 0.93198600476181)

Timing Summary:
  Total Cycle Length: 90 minutes
  Total Lost Time: 10 minutes
  Total Effective Berthing: 80 minutes
  Minimum Required Bulk Carrier Berthing: 38.46 minutes



================================================================================



--- Problem 47 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
At a busy trucking terminal, three trucks—Truck 1, Truck 2, and Truck 3—arrive at staggered times, each requiring a depot for unloading and loading operations. The terminal has two depots available, and the challenge is to assign each truck to a depot while minimizing the total time taken to service all trucks (the *makespan*). Truck 1 arrives at time 1 and takes 6 hours to process, Truck 2 arrives at time 6 and also takes 6 hours, and Truck 3 arrives at time 11 with the same processing duration. The terminal manager must ensure that no two trucks assigned to the same depot overlap in their operations, respecting their arrival times. The goal is to find the optimal assignment and scheduling of trucks to depots so that the last truck finishes as early as possible, maximizing the terminal's efficiency.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary variable indicating whether truck `i` is assigned to depot `j`.  
     - `start_time(i)`: Continuous variable representing the start time of truck `i`.  
     - `completion_time(i)`: Continuous variable representing the completion time of truck `i`.  
     - `precedes(i, k, j)`: Binary variable indicating whether truck `i` precedes truck `k` at depot `j`.  
     - `makespan`: Continuous variable representing the total time until the last truck finishes.  

   - **2. Parameters:**  
     - `trucks = [1, 2, 3]`: List of trucks.  
     - `depots = [1, 2]`: List of depots.  
     - `arrival_times = {1: 1, 2: 6, 3: 11}`: Arrival times for each truck.  
     - `processing_times = {1: 6, 2: 6, 3: 6}`: Processing times for each truck.  
     - `H = 100`: A large constant (Big-M) for logical constraints.  

   - **3. Objective Function:**  
     - Minimize `makespan`.  

   - **4. Constraints:**  
     - Each truck must be assigned to exactly one depot:  
       `sum(assign(i, j) for j in depots) = 1` for all `i` in `trucks`.  
     - A truck cannot start before its arrival time:  
       `start_time(i) >= arrival_times[i]` for all `i` in `trucks`.  
     - Completion time is the start time plus processing time:  
       `completion_time(i) = start_time(i) + processing_times[i]` for all `i` in `trucks`.  
     - No overlapping at the same depot: For each depot `j`, if `i` precedes `k`, then `start_time(k) >= completion_time(i)`.  
     - Makespan is the maximum completion time:  
       `makespan >= completion_time(i)` for all `i` in `trucks`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
depots = [1, 2]
arrival_times = {1: 1, 2: 6, 3: 11}
processing_times = {1: 6, 2: 6, 3: 6} # Using base processing times
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_14_TRUCK_IGNORE") # Renamed model

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (using base proc time)
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the assignment of trucks to depots and their start and completion times
if m.status == GRB.OPTIMAL:
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.4f}")
                print(f"  Completion Time: {completion_time[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
19.0000
Truck 1 is assigned to Depot 2
  Start Time: 1.0000
  Completion Time: 7.0000
Truck 2 is assigned to Depot 2
  Start Time: 7.0000
  Completion Time: 13.0000
Truck 3 is assigned to Depot 2
  Start Time: 13.0000
  Completion Time: 19.0000


```

================================================================================



--- Problem 48 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
A logistics company is tasked with scheduling drivers across three distinct shifts to meet hourly demand while minimizing labor costs. The shifts begin at 6 AM, 2 PM, and 10 PM, each requiring a minimum number of drivers to ensure smooth operations. Specifically, the 6 AM shift needs at least 9 drivers, the 2 PM shift requires 13, and the 10 PM shift must have at least 4 drivers. Each driver assigned to a shift incurs a fixed cost of $189, regardless of the shift timing. The company’s challenge is to determine the exact number of drivers to assign to each shift such that all demand constraints are satisfied, and the total daily staffing cost is as low as possible. The core question is: *What is the most cost-effective way to staff these shifts while meeting all coverage requirements?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Let \( x_s \) represent the number of drivers assigned to shift \( s \), where \( s \) can be 1 (6 AM), 2 (2 PM), or 3 (10 PM). Each \( x_s \) is a non-negative integer.  
   - **2. Parameters:**  
     - Shift requirements: \( \text{requirements} = \{1: 9, 2: 13, 3: 4\} \).  
     - Cost per driver per shift: \( \text{cost\_per\_driver\_shift} = 189 \).  
   - **3. Objective Function:**  
     Minimize the total daily staffing cost:  
     \[ \text{Minimize: } 189 \cdot (x_1 + x_2 + x_3). \]  
   - **4. Constraints:**  
     - Coverage constraints for each shift:  
       \[ x_1 \geq 9, \quad x_2 \geq 13, \quad x_3 \geq 4. \]  
     - Non-negativity and integrality:  
       \[ x_1, x_2, x_3 \geq 0 \text{ and integer.} \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
requirements = {1: 9, 2: 13, 3: 4}
shift_starts = {1: '6am', 2: '2pm', 3: '10pm'} # Using the generated structure
cost_per_driver_shift = 189
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m31 = gp.Model("LOGISTICS_SCHEDULING_IP", env=env)

    # --- Decision Variables ---
    # Integer: Number of drivers starting each shift
    x = m31.addVars(shift_starts.keys(), vtype=GRB.INTEGER, name="drivers_start_shift", lb=0)

    # --- Objective Function ---
    # Minimize total daily staffing cost
    m31.setObjective(gp.quicksum(x[s] * cost_per_driver_shift for s in shift_starts.keys()), sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Coverage constraints for each requirement period (assuming 1-to-1 mapping)
    for shift_id, req in requirements.items():
         if shift_id in x: # Check if variable exists for this shift
             m31.addConstr(x[shift_id] >= req, name=f"cover_shift{shift_id}")

    # --- Optimization ---
    m31.optimize()

    # --- Store results ---
    results_dict['status'] = m31.status
    if m31.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m31.ObjVal
        # results_dict['x_sol'] = m31.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m31.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Ensure obj_val_print is a number before formatting
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}") # Original example didn't show decimals, but objval can be float
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m31.status == GRB.INFEASIBLE:
        print("No optimal solution found.") # Matches example's else case
    elif m31.status == GRB.TIME_LIMIT:
        print("No optimal solution found.") # Matches example's else case
    else:
        print("No optimal solution found.") # Matches example's else case


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the number of drivers for each shift
if m31.status == GRB.OPTIMAL:
    for shift_id in shift_starts.keys():
        print(f"Number of drivers for {shift_starts[shift_id]} shift: {x[shift_id].X}")
```
Answer:
Optimal objective value: 4914.00
Number of drivers for 6am shift: 9.0
Number of drivers for 2pm shift: 13.0
Number of drivers for 10pm shift: 4.0


```

================================================================================



--- Problem 49 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A port manager is tasked with optimizing the berthing time for two ships at a busy port to minimize total waiting time. The port operates with a fixed cycle time of 82 minutes, divided into two distinct berthing slots. Each slot has a minimum berthing time of 40 minutes and a maximum of 82 minutes, ensuring safe and efficient ship handling. The waiting time experienced by ships in each slot is influenced by the ship size, represented by size coefficients of 184 and 2363 for the respective slots. The challenge lies in allocating the berthing times between the two slots such that the total waiting time—calculated as the sum of waiting times across all slots—is minimized. The manager must ensure that the combined berthing times of both slots exactly match the cycle time, adhering to the operational constraints. The core question is: *What is the optimal allocation of berthing times between the two slots to minimize the total waiting time for all ships docking at the port?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `t_i`: Continuous variable representing the berthing time (in minutes) allocated to slot `i` (where `i = 1, 2`).  
     - Bounds: `40 ≤ t_i ≤ 82` for each slot.  

   - **2. Parameters:**  
     - `size_coeffs = [184, 2363]`: Ship size coefficients for slots 1 and 2, respectively.  
     - `cycle_time = 82`: Total cycle time (minutes).  
     - `lb_time = 40`, `ub_time = 82`: Lower and upper bounds for berthing times.  

   - **3. Objective Function:**  
     - Minimize the total waiting time:  
       `Minimize: sum(size_coeffs[i] * (cycle_time - t_i) for i in 1..2)`  

   - **4. Constraints:**  
     - **Total cycle time constraint:** The sum of berthing times must equal the cycle time:  
       `t_1 + t_2 = 82`  
     - **Variable bounds:**  
       `40 ≤ t_1 ≤ 82`, `40 ≤ t_2 ≤ 82`  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_slots = 2
lb_time = 40          # Lower bound for berthing time
ub_time = 82          # Upper bound for berthing time
cycle_time = 82   # Total cycle time (set equal to ub_time)
size_coeffs = [184, 2363] # Ship size coefficients per slot
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(size_coeffs) != num_slots:
    print("Error: size_coeffs length mismatch with num_slots")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: size_coeffs length"
    # raise ValueError("size_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_slots}-Slot Berthing Time", env=env)

        # --- Decision variables (dynamic based on num_slots) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_slots, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for slot i is proportional to size * idle_time = size * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(size_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_slots)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_slots)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_slots)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_slots):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 102248.00
------------------------------
Optimal berthing times (minutes):
  t1: 40.00, t2: 42.00


```

================================================================================



--- Problem 50 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port handles ship traffic from two primary directions: Direction A, with a heavy flow of 507 ships per hour, and Direction B, with a lighter flow of 206 ships per hour. The port's traffic signal must balance green time allocations to minimize delays while adhering to strict operational constraints. The signal operates on a fixed cycle time of 128 seconds, with each phase incurring a lost time of 9 seconds (due to safety clearance intervals). Additionally, safety regulations mandate a minimum green time of 20 seconds for each direction.  

The challenge is to allocate green times to Directions A and B in a way that maximizes the total flow-weighted green time—effectively prioritizing the busier direction while ensuring the cycle time and minimum green constraints are met. The question is: *What is the optimal distribution of green times between the two directions to maximize the overall efficiency of the port?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `g_A`: Green time allocated to Direction A (continuous, ≥ 20 seconds).  
     - `g_B`: Green time allocated to Direction B (continuous, ≥ 20 seconds).  

   - **2. Parameters:**  
     - `cycle_time = 128`: Total signal cycle time (seconds).  
     - `lost_time = 9`: Time lost per phase transition (seconds).  
     - `min_green = 20`: Minimum green time for any direction (seconds).  
     - `flow_A = 507`: Ship flow rate for Direction A (ships/hour).  
     - `flow_B = 206`: Ship flow rate for Direction B (ships/hour).  

   - **3. Objective Function:**  
     Maximize the flow-weighted green time:  
     `Maximize: flow_A * g_A + flow_B * g_B`.  

   - **4. Constraints:**  
     - **Cycle time constraint:** Total green and lost times must equal the cycle time:  
       `g_A + lost_time + g_B + lost_time = cycle_time`.  
     - **Minimum green time:**  
       `g_A ≥ min_green`, `g_B ≥ min_green`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cycle_time = 128 # seconds
lost_time = 9 # seconds per phase (safety clearance)
min_green = 20 # seconds
flow_A = 507 # ships per hour
flow_B = 206 # ships per hour
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_SIGNAL_TIMING", env=env)

    # --- Decision Variables ---
    # g_A: green time for direction A (seconds)
    g_A = m.addVar(lb=min_green, vtype=GRB.CONTINUOUS, name="g_A")
    # g_B: green time for direction B (seconds)
    g_B = m.addVar(lb=min_green, vtype=GRB.CONTINUOUS, name="g_B")

    # --- Objective Function: Maximize flow-weighted green time ---
    m.setObjective(flow_A * g_A + flow_B * g_B, GRB.MAXIMIZE)

    # --- Constraints ---
    # Cycle time constraint: sum of green times + lost times = cycle time
    m.addConstr(g_A + lost_time + g_B + lost_time == cycle_time, "CycleTimeConstraint")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['g_A_sol'] = g_A.X # Not needed for output
        # results_dict['g_B_sol'] = g_B.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}") # Weighted value
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the green times for each direction
if m.Status == GRB.OPTIMAL:
    print(f"Optimal objective value: {obj_val_print:.2f}")
    print(f"Green time for Direction A: {g_A.X:.2f} seconds")
    print(f"Green time for Direction B: {g_B.X:.2f} seconds")
```
Answer:
Optimal objective value: 49750.00
Optimal objective value: 49750.00
Green time for Direction A: 90.00 seconds
Green time for Direction B: 20.00 seconds


```

================================================================================



--- Problem 51 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy port, a maritime logistics manager faces the challenge of efficiently assigning 18 containers of varying weights to the fewest possible ships, each with a strict capacity limit of 62 units. The containers, weighing [9, 30, 3, 30, 62, 10, 18, 41, 31, 36, 22, 4, 39, 31, 38, 30, 9, 34], range from lightweight parcels to hefty crates, demanding careful allocation to avoid wasted space. The manager’s goal is to minimize the number of ships used while ensuring no ship exceeds its capacity—a classic bin packing problem with real-world implications for reducing shipping costs and optimizing storage. The central question is: *What is the most efficient way to assign these containers to achieve the smallest possible number of ships without violating capacity constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `x[i, j]`: Equals 1 if container *i* is assigned to ship *j*, else 0.  
     - Binary variable `y[j]`: Equals 1 if ship *j* is used (contains at least one container), else 0.  
   - **2. Parameters:**  
     - `containers[i]`: Weight of container *i* (given list).  
     - `capacity`: Maximum weight per ship (62 units).  
     - `num_containers`: Total containers (18).  
     - `num_ships`: Maximum possible ships (18, one per container).  
   - **3. Objective Function:**  
     - Minimize the total ships used: `Minimize sum(y[j] for all j)`.  
   - **4. Constraints:**  
     - **Container Assignment:** Each container must be in exactly one ship:  
       `sum(x[i, j] for all j) = 1` for every container *i*.  
     - **Ship Capacity:** Total weight in ship *j* cannot exceed capacity if the ship is used:  
       `sum(containers[i] * x[i, j] for all i) <= capacity * y[j]` for every ship *j*.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB

# --- Data Definition ---
containers = [9, 30, 3, 30, 62, 10, 18, 41, 31, 36, 22, 4, 39, 31, 38, 30, 9, 34]      # Weights of containers
capacity = 62           # Ship capacity
num_containers = 18     # len(containers)
num_ships = num_containers    # Maximum number of ships (worst case: one container per ship)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Time limit
# env.setParam('TimeLimit', 30)
env.start()

# Create Model
model = Model("Ship Packing Problem", env=env)

# --- Decision Variables ---
# x[i,j]: container i is assigned to ship j
x = model.addVars(num_containers, num_ships, vtype=GRB.BINARY, name="x")
# y[j]: ship j is used
y = model.addVars(num_ships, vtype=GRB.BINARY, name="y")

# --- Objective: Minimize the number of ships used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)

# --- Constraints ---
# 1. Each container must be assigned to exactly one ship
for i in range(num_containers):
    model.addConstr(x.sum(i, '*') == 1, name=f"Container_{i}_Assignment")

# 2. Ship capacity constraint: sum of weights in ship j <= capacity IF ship j is used (y[j]=1)
for j in range(num_ships):
    model.addConstr(gp.quicksum(containers[i] * x[i, j] for i in range(num_containers)) <= capacity * y[j], name=f"Ship_{j}_Capacity")

# --- Solve ---
print("Solving 1DSP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_ships = int(results_dict.get('obj_val', -1))
    print(f"\nOptimal number of ships used: {optimal_ships}")
    print("-" * 30)
    ship_details = []
    for j_sol in range(num_ships): # Loop through potential ships
        # Check if the ship variable y[j_sol] exists and is set to 1
        try:
            if y[j_sol].X > 0.5: # Check if ship j_sol is used
                # Find containers assigned to this ship j_sol
                assigned_containers_indices = [i for i in range(num_containers) if x[i, j_sol].X > 0.5]
                assigned_containers_weights = [containers[i] for i in assigned_containers_indices]
                ship_load = sum(assigned_containers_weights)
                print(f"Ship {j_sol + 1} (Load: {ship_load}/{capacity}): Containers (indices): {assigned_containers_indices}")
                # Optional: Print weights too
                # print(f"  Weights: {assigned_containers_weights}")
                ship_details.append({'ship_index': j_sol, 'container_indices': assigned_containers_indices, 'load': ship_load})
        except AttributeError:
            pass # Just skip if variable/attribute doesn't exist for unused ships/containers
    results_dict['ship_details'] = ship_details # Store details
    print("-" * 30)

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount to see if a feasible solution was found
     if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
     else: print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 1DSP instance...

Optimal number of ships used: 9
------------------------------
Ship 1 (Load: 60/62): Containers (indices): [10, 14]
Ship 2 (Load: 48/62): Containers (indices): [0, 12]
Ship 3 (Load: 60/62): Containers (indices): [1, 3]
Ship 4 (Load: 41/62): Containers (indices): [7]
Ship 5 (Load: 62/62): Containers (indices): [8, 13]
Ship 12 (Load: 43/62): Containers (indices): [16, 17]
Ship 13 (Load: 39/62): Containers (indices): [2, 9]
Ship 14 (Load: 62/62): Containers (indices): [5, 6, 11, 15]
Ship 16 (Load: 62/62): Containers (indices): [4]
------------------------------


```

================================================================================



--- Problem 52 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy railway station is tasked with scheduling four trains (`1`, `2`, `3`, `4`) to a single available platform (`1`), while adhering to strict arrival times and processing requirements. Each train arrives at a specific hour: Train 1 at 4, Train 2 at 5, Train 3 at 9, and Train 4 at 10. Once docked, every train requires exactly 6 hours to unload and process its cargo. The station also has a critical maintenance window from hour 14 to 19, during which the platform is unavailable. The goal is to sequence the trains' platform times to minimize the total operational time (makespan) while ensuring no train starts processing before its arrival, no two trains occupy the platform simultaneously, and all operations either conclude before maintenance begins or start only after maintenance ends. The central question is: *What is the optimal schedule that minimizes the total time to service all trains, respecting these constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary (1 if train `i` is assigned to platform `j`; 0 otherwise).  
   - `start_time[i]`: Continuous (start time of train `i`).  
   - `completion_time[i]`: Continuous (completion time of train `i`).  
   - `precedes[i, k, j]`: Binary (1 if train `i` precedes train `k` on platform `j`; 0 otherwise).  
   - `maint_choice[i, w]`: Binary (1 if train `i` finishes before maintenance window `w` starts; 0 if it starts after `w` ends).  
   - `makespan`: Continuous (total time to complete all operations).  

   **2. Parameters:**  
   - `arrival_times[i]`: Arrival time of train `i` (e.g., `{1:4, 2:5, ...}`).  
   - `processing_times[i]`: Processing time of train `i` (fixed at 6 for all).  
   - `maintenance_windows = [(14, 19)]`.  
   - `H = 100`: A large constant for disjunctive constraints.  

   **3. Objective Function:**  
   Minimize `makespan` (latest completion time across all trains).  

   **4. Constraints:**  
   - **Assignment:** Each train must use the platform (`assign[i, 1] = 1` for all `i`).  
   - **Arrival Time:** `start_time[i] >= arrival_times[i]`.  
   - **Completion Time:** `completion_time[i] = start_time[i] + processing_times[i]`.  
   - **Non-Overlapping:** For trains `i` and `k` on the same platform, enforce `start_time[k] >= completion_time[i]` or vice versa via `precedes`.  
   - **Maintenance:** For each train and window, enforce `completion_time[i] <= m_start` **OR** `start_time[i] >= m_end` using `maint_choice`.  
   - **Makespan Definition:** `makespan >= completion_time[i]` for all `i`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trains = [1, 2, 3, 4]
platforms = [1] # Should be [1]
arrival_times = {1: 4, 2: 5, 3: 9, 4: 10}
processing_times = {1: 6, 2: 6, 3: 6, 4: 6}
maintenance_windows = [(14, 19)] # List of (start, end) tuples
H = 100 # Big M
max_k = 20 # Not used
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("PLATFORM_PROBLEM_63_MULTI_MAINT")

    if not trains or not platforms or len(platforms)!=1: raise ValueError("Invalid trains/platforms")
    the_platform = platforms[0]
    # if not maintenance_windows: raise ValueError("Maintenance windows list is empty") # Allow empty list

    # --- Decision Variables ---
    assign = m.addVars(trains, platforms, vtype=GRB.BINARY, name="assign") # Trivial
    start_time = m.addVars(trains, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trains, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trains for k in trains if i < k for j in platforms],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    # Binary variable for each train and each maintenance window disjunction
    maint_choice = m.addVars(trains, range(len(maintenance_windows)), vtype=GRB.BINARY, name="maint_choice")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_platform] == 1 for i in trains), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trains), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trains), name="completion_time")
    # 4. Non-overlapping (on the single platform) using Indicators
    j = the_platform
    for i in trains:
        for k in trains:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trains), name="makespan_def")
    # 6. Maintenance window constraints (multiple windows)
    for i in trains:
        for w_idx, (m_start, m_end) in enumerate(maintenance_windows):
             # Disjunction: c[i] <= m_start OR s[i] >= m_end
             m.addConstr(completion_time[i] <= m_start + H * maint_choice[i, w_idx], name=f"maint_before_{i}_win{w_idx}")
             m.addConstr(start_time[i] >= m_end - H * (1 - maint_choice[i, w_idx]), name=f"maint_after_{i}_win{w_idx}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the start and completion times for each train
if m.status == GRB.OPTIMAL:
    for i in trains:
        print(f"Train {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
37.0000
Train 1 - Start Time: 4.0000, Completion Time: 10.0000
Train 2 - Start Time: 19.0000, Completion Time: 25.0000
Train 3 - Start Time: 31.0000, Completion Time: 37.0000
Train 4 - Start Time: 25.0000, Completion Time: 31.0000


```

================================================================================



--- Problem 53 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
A logistics company is tasked with optimizing a delivery route for a truck to minimize total travel distance while ensuring all delivery points are visited exactly once. The journey begins at the origin point 'O1' and must end at the destination 'D', passing through three delivery locations: 'D1', 'D2', and 'D3'. The distances between these points are predefined, with some routes being bidirectional (e.g., the distance from 'O1' to 'D1' is 9 units, the same as the return trip). The challenge is to determine the most efficient sequence of visits—starting at 'O1', hitting each delivery point, and concluding at 'D'—without revisiting any location or deviating into impractical paths. The goal is to

**Modeling Process:**
- **1. Decision Variables:**  
     - Binary variable `x[i, j]` for each arc (i, j), where `x[i, j] = 1` if the route includes travel from node *i* to node *j*, and `0` otherwise.  
     - Continuous variable `u[i]` for subtour elimination (MTZ constraints), representing the "position" of node *i* in the tour.  
   - **2. Parameters:**  
     - `dist_dict`: Predefined distances between nodes (e.g., `('O1', 'D1') = 9`).  
     - `start_idx`, `end_idx`: Indices of the origin ('O1') and destination ('D').  
     - `delivery_indices`: Indices of delivery nodes ('D1', 'D2', 'D3').  
   - **3. Objective Function:**  
     Minimize total distance:  
     `Minimize: sum(dist[i, j] * x[i, j] for all arcs (i, j))`.  
   - **4. Constraints:**  
     - **Flow constraints:**  
       - Leave 'O1' exactly once: `sum(x[start_idx, j] for all j) = 1`.  
       - Arrive at 'D' exactly once: `sum(x[i, end_idx] for all i) = 1`.  
       - No re-entry to 'O1' or exits from 'D': `sum(x[i, start_idx]) = 0` and `sum(x[end_idx, j]) = 0`.  
     - **Delivery visits:** Each delivery node must be entered and exited exactly once:  
       `sum(x[i, d]) = 1` and `sum(x[d, j]) = 1` for each delivery *d*.  
     - **Subtour elimination (MTZ):**  
       `u[i] - u[j] + N * x[i, j] ≤ N - 1` for all arcs (i, j), where *N* is the number of nodes.  

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
from itertools import permutations # Used inside template if needed

# --- Parameters ---
locations = ['O1', 'D1', 'D2', 'D3', 'D'] # List includes start, deliveries, end
delivery_points = ['D1', 'D2', 'D3']
start_node = 'O1'
end_node = 'D'
# Distances as dict of (name, name): dist
dist_dict = {('O1', 'D1'): 9, ('D1', 'O1'): 9, ('O1', 'D2'): 23, ('D2', 'O1'): 23, ('O1', 'D3'): 5, ('D3', 'O1'): 5, ('O1', 'D'): 8, ('D', 'O1'): 8, ('D1', 'D2'): 15, ('D2', 'D1'): 15, ('D1', 'D3'): 7, ('D3', 'D1'): 7, ('D1', 'D'): 19, ('D', 'D1'): 19, ('D2', 'D3'): 19, ('D3', 'D2'): 19, ('D2', 'D'): 13, ('D', 'D2'): 13, ('D3', 'D'): 22, ('D', 'D3'): 22}
# --- End Parameters ---

GUROBI_TIME_LIMIT = 120

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    # env.setParam('MIPFocus', 1) # Optional: Focus on finding feasible TSP tours
    env.start()

    # --- Data Preparation ---
    all_nodes_list = locations # Use the generated list
    node_map = {name: i for i, name in enumerate(all_nodes_list)}
    num_nodes = len(all_nodes_list)

    # Map distances to indices, handle missing keys & diagonal
    dist = {}
    for (u_name, v_name), d in dist_dict.items():
        if u_name in node_map and v_name in node_map:
             dist[node_map[u_name], node_map[v_name]] = d
    # Fill missing (e.g., diagonal, ensure symmetric if needed)
    for i in range(num_nodes):
         for j in range(num_nodes):
             if (i,j) not in dist:
                 if i == j: dist[i,j] = 0
                 elif (j,i) in dist: dist[i,j] = dist[j,i] # Use symmetry
                 else: dist[i,j] = 9999 # Assign high cost if missing

    # Create list of arcs (i != j)
    arcs = [(i, j) for i in range(num_nodes) for j in range(num_nodes) if i != j]

    # --- Model Creation ---
    m = gp.Model("DELIVERY_TSP", env=env)

    # --- Decision Variables ---
    # x[i, j] = 1 if arc (i, j) is used in the tour
    x = m.addVars(arcs, vtype=GRB.BINARY, name="x")
    # Auxiliary variables for MTZ subtour elimination
    u = m.addVars(num_nodes, vtype=GRB.CONTINUOUS, lb=0.0, name="u") # u >= 0

    # --- Indices ---
    start_idx = node_map[start_node]
    end_idx = node_map[end_node]
    delivery_indices = [node_map[d] for d in delivery_points]

    # --- Objective Function: Minimize total distance ---
    m.setObjective(gp.quicksum(dist.get((i, j), 9999) * x[i, j] for i, j in arcs), GRB.MINIMIZE)

    # --- Constraints ---
    # Must leave start node exactly once
    m.addConstr(gp.quicksum(x[start_idx, j] for j in range(num_nodes) if start_idx != j) == 1, "LeaveStart")

    # Must arrive at end node exactly once
    m.addConstr(gp.quicksum(x[i, end_idx] for i in range(num_nodes) if i != end_idx) == 1, "ArriveEnd")

    # Must not enter start node
    m.addConstr(gp.quicksum(x[i, start_idx] for i in range(num_nodes) if i != start_idx) == 0, "NoEnterStart")

    # Must not leave end node
    m.addConstr(gp.quicksum(x[end_idx, j] for j in range(num_nodes) if j != end_idx) == 0, "NoLeaveEnd")

    # Flow conservation and visit constraints for delivery points
    for d_idx in delivery_indices:
        # Enter = Leave
        m.addConstr(gp.quicksum(x[i, d_idx] for i in range(num_nodes) if i != d_idx) ==
                     gp.quicksum(x[d_idx, j] for j in range(num_nodes) if j != d_idx), f"FlowCons_{all_nodes_list[d_idx]}")
        # Must enter exactly once (which implies leaving once due to flow cons.)
        m.addConstr(gp.quicksum(x[i, d_idx] for i in range(num_nodes) if i != d_idx) == 1, f"Visit_{all_nodes_list[d_idx]}")

    # Subtour Elimination (MTZ formulation) - Simple version
    # u[i] can be interpreted as position or accumulated load/potential
    u[start_idx].lb = 0
    u[start_idx].ub = 0 # Fix start node potential

    for i in range(num_nodes):
        if i != start_idx:
             u[i].lb = 1.0 # Ensure other nodes have higher potential

    # if i -> j is taken, u[j] must be >= u[i] + 1 (roughly)
    # u[i] - u[j] + N * x[i,j] <= N - 1
    # Need N > num_nodes? Use num_nodes.
    mtz_n = num_nodes # Number of nodes
    for i, j in arcs:
        if i != start_idx and j != start_idx: # MTZ doesn't involve start node directly
            m.addConstr(u[i] - u[j] + mtz_n * x[i, j] <= mtz_n - 1, f"MTZ_{i}_{j}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per original example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.1f}") # Distance
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Add specific message for infeasible/unbounded for TSP
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible. Cannot find a valid tour.")
    elif m.Status == GRB.UNBOUNDED:
        print("Model is unbounded.")
    elif m.Status == GRB.TIME_LIMIT:
         # Check if a feasible solution was found before time limit
         if m.SolCount > 0:
             print(f"Time limit reached. Best objective found: {m.ObjVal:.1f}")
         else:
             print("Time limit reached. No feasible solution found.")
    else:
        print(f"Optimization ended with status {m.Status}")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code to print the optimal route
if m.Status == GRB.OPTIMAL:
    # Print the optimal objective value
    obj_val_print = results_dict.get('obj_val', 'N/A')
    if isinstance(obj_val_print, (int, float)):
        print(f"Optimal objective value: {obj_val_print:.1f}")  # Distance
    else:
        print(f"Optimal objective value: {obj_val_print}")

    # Print the optimal route
    print("Optimal Route:")
    for i, j in arcs:
        if x[i, j].X > 0.5:
            print(f"{all_nodes_list[i]} -> {all_nodes_list[j]}")
```
Answer:
Optimal objective value: 40.0
Optimal objective value: 40.0
Optimal Route:
O1 -> D3
D1 -> D2
D2 -> D
D3 -> D1


```

================================================================================



--- Problem 54 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy port terminal is facing a critical staffing challenge: determining the optimal number of crane operators to handle container unloading while balancing costs and service quality. With containers arriving at a steady rate of 72 per hour, each crane operator can process containers at a rate of 16 containers per hour. The terminal employs up to 6 crane operators, each costing $15 per hour. However, if the system becomes overloaded—specifically, if crane operator utilization exceeds 94%—a hefty penalty of $112 per hour is incurred due to excessive wait times for ships.

The operations team must strike a delicate balance: hire enough crane operators to avoid penalties but not so many that labor costs balloon unnecessarily. The core question is: *What is the minimum-cost staffing plan that ensures smooth operations while avoiding penalties?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x`: Integer number of crane operators to hire (1 ≤ `x` ≤ 6).  
   - `z`: Binary indicator (1 if penalty applies due to high utilization, 0 otherwise).  

   **2. Parameters:**  
   - `arrival_rate = 72` (containers/hour).  
   - `service_rate_per_operator = 16` (containers/hour/operator).  
   - `cost_per_operator = 15` ($/hour/operator).  
   - `penalty_high_wait = 112` ($/hour if `z=1`).  
   - `utilization_threshold = 0.94` (penalty triggers if utilization > 94%).  
   - `M = 1000` (large constant for constraint logic).  

   **3. Objective Function:**  
   Minimize total cost:  
   ```  
   Minimize: (x * cost_per_operator) + (z * penalty_high_wait)  
   ```  

   **4. Constraints:**  
   - If `x` ≥ `min_operators_no_penalty` (calculated as ceiling of `arrival_rate / (service_rate_per_operator * utilization_threshold)`), then `z=0`.  
   - If `x` ≤ `penalty_cutoff_operators` (one less than `min_operators_no_penalty`), then `z=1`.  
   - Binary and integer constraints enforce `z ∈ {0,1}` and `x` as an integer.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
max_operators = 6; arrival_rate = 72; service_rate_per_operator = 16
cost_per_operator = 15; penalty_high_wait = 112; utilization_threshold = 0.94
M = 1000
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    # Pre-calculate penalty cutoff inside try block
    min_operators_no_penalty = 0
    penalty_cutoff_operators = -1 # Default if penalty never applies or calculation fails
    if service_rate_per_operator > 1e-6 and utilization_threshold > 1e-6:
         min_operators_no_penalty_float = arrival_rate / (service_rate_per_operator * utilization_threshold)
         min_operators_no_penalty = math.ceil(min_operators_no_penalty_float)
         penalty_cutoff_operators = min_operators_no_penalty - 1
    elif arrival_rate <= 1e-6: # No arrivals, no penalty needed
         min_operators_no_penalty = 1 # Or 0 if allowed? Assume 1 operator min
         penalty_cutoff_operators = -1
    else: # Service rate is zero with positive arrivals, always penalty?
          # This logic implies infinite utilization, penalty always applies if threshold < infinity
          # Let's assume penalty applies for any operator count in this case
          min_operators_no_penalty = float('inf')
          penalty_cutoff_operators = max_operators # Penalty applies up to max operators

    # Ensure cutoff is not negative if min_operators_no_penalty is 0 or 1
    penalty_cutoff_operators = max(-1, penalty_cutoff_operators)

    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m15 = gp.Model("Crane_Operators_IP", env=env)
    # Vars
    x = m15.addVar(vtype=GRB.INTEGER, name="num_operators", lb=1, ub=max_operators)
    z = m15.addVar(vtype=GRB.BINARY, name="penalty_applies")
    # Objective
    m15.setObjective(x * cost_per_operator + z * penalty_high_wait, sense=GRB.MINIMIZE)
    # Constraints
    # Only add constraints if min_operators_no_penalty is finite
    if min_operators_no_penalty != float('inf'):
         m15.addConstr(x >= min_operators_no_penalty - M * z, name="force_z0_if_x_high")
         m15.addConstr(x <= penalty_cutoff_operators + M * (1 - z), name="force_z1_if_x_low")
    else: # If min_operators is infinite, penalty always applies (z=1)
         m15.addConstr(z == 1, name="force_z1_always")

    # Optimize
    m15.optimize()
    # Store results
    results_dict['status'] = m15.status
    if m15.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m15.objVal; results_dict['x_opt'] = x.X; results_dict['z_opt'] = z.X
    # Output Results
    print("--- Problem 15: Crane Operator Scheduling (IP) ---")
    if m15.status == GRB.OPTIMAL:
        num_operators_opt = int(round(results_dict.get('x_opt', 0)))
        rho_opt = arrival_rate / (num_operators_opt * service_rate_per_operator) if num_operators_opt * service_rate_per_operator > 1e-6 else float('inf')
        penalty_applied = results_dict.get('z_opt', 0) > 0.5
        operator_cost_opt = num_operators_opt * cost_per_operator
        penalty_cost_opt = penalty_high_wait if penalty_applied else 0
        print(f"Optimization Status: Optimal")
        print(f"Optimal number of operators: {num_operators_opt} / {max_operators}")
        print(f"  Resulting Utilization (rho): {rho_opt:.3f} (Threshold for penalty: > {utilization_threshold})")
        print(f"  Operator Cost: ${operator_cost_opt:.2f}/hr")
        print(f"  High Wait Penalty Applied (z=1): {'Yes' if penalty_applied else 'No'} (${penalty_cost_opt}.00)")
        print(f"Minimum Total Cost: ${m15.objVal:.2f}/hr")
    else: print(f"Optimization Status: {m15.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of CRANE_OPERATOR_SCHEDULING
```
Answer:
--- Problem 15: Crane Operator Scheduling (IP) ---
Optimization Status: Optimal
Optimal number of operators: 5 / 6
  Resulting Utilization (rho): 0.900 (Threshold for penalty: > 0.94)
  Operator Cost: $75.00/hr
  High Wait Penalty Applied (z=1): No ($0.00)
Minimum Total Cost: $75.00/hr



================================================================================



--- Problem 55 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy trucking depot, three trucks arrive at different times, each requiring a loading dock for unloading or loading operations. The depot has only one available dock, creating a scheduling challenge to minimize the total time taken to service all trucks (known as the *makespan*). Truck 1 arrives at time 3 and takes 3 hours to process, Truck 2 arrives at time 7 and requires 8 hours, and Truck 3 arrives at time 10 with an 8-hour processing time. The depot manager must decide the order in which these trucks are serviced to ensure the earliest possible completion of all operations, avoiding overlaps while respecting arrival times. The core question is: *What is the optimal schedule that minimizes the total completion time for all trucks, given the single dock constraint?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to dock *j*, else 0).  
   - `start_time(i)`: Continuous variable for the start time of truck *i*.  
   - `completion_time(i)`: Continuous variable for the completion time of truck *i*.  
   - `precedes(i, k, j)`: Binary variable (1 if truck *i* is scheduled before truck *k* on dock *j*, else 0).  
   - `makespan`: Continuous variable representing the total completion time.  

   **2. Parameters:**  
   - `trucks = [1, 2, 3]`, `docks = [1]`.  
   - `arrival_times = {1: 3, 2: 7, 3: 10}`.  
   - `processing_times = {1: 3, 2: 8, 3: 8}`.  
   - `H = 100` (a large constant for precedence constraints).  

   **3. Objective Function:**  
   Minimize `makespan`.  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to the single dock:  
     `sum(assign(i, j) for j in docks) = 1` for all trucks *i*.  
   - **Arrival Time:** Start time cannot be earlier than arrival time:  
     `start_time(i) >= arrival_times(i)` for all trucks *i*.  
   - **Completion Time:** Defined as `completion_time(i) = start_time(i) + processing_times(i)`.  
   - **Non-Overlapping:** For any two trucks *i* and *k* assigned to the same dock, one must precede the other:  
     - `precedes(i, k, j) + precedes(k, i, j) >= assign(i, j) + assign(k, j) - 1`.  
     - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
   - **Makespan Definition:** `makespan >= completion_time(i)` for all trucks *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
docks = [1]
arrival_times = {1: 3, 2: 7, 3: 10}
processing_times = {1: 3, 2: 8, 3: 8}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DOCKING_PROBLEM_2_MIN_MAKESPAN")

    if not trucks or not docks: raise ValueError("Empty trucks or docks")

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, docks, vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times[i] for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times[i] for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in docks:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Schedule:")
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
    print(f"Total Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
23.0000
Optimal Schedule:
Truck 1 - Start Time: 3.0000, Completion Time: 6.0000
Truck 2 - Start Time: 7.0000, Completion Time: 15.0000
Truck 3 - Start Time: 15.0000, Completion Time: 23.0000
Total Makespan: 23.0000


```

================================================================================



--- Problem 56 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
At a busy port, the harbor master must decide on the most efficient and cost-effective method for managing the berthing of incoming cargo ships. The options are to either allocate a dedicated berth (protected phase) or allow ships to wait in a common area until a berth becomes available (permitted phase). The protected phase ensures minimal waiting time but incurs a higher operational cost of $53 per hour due to the dedicated berth. The permitted phase is cheaper but introduces delays, estimated to cost $71 per hour in lost productivity and increased fuel consumption. The challenge is to determine which berthing method minimizes the total cost while balancing efficiency and operational costs.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y_prot`: Binary variable where `1` indicates selecting the protected phase, and `0` selects the permitted phase.  
   - **2. Parameters:**  
     - `cost_protected_phase = 53`: Hourly cost of the protected phase.  
     - `cost_permitted_delay = 71`: Hourly penalty (delay cost) of the permitted phase.  
   - **3. Objective Function:**  
     - Minimize total cost:  
       ```  
       Minimize: y_prot * 53 + (1 - y_prot) * 71  
       ```  
   - **4. Constraints:**  
     - None (unconstrained binary decision).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cost_protected_phase = 53 # Proxy cost/hr
cost_permitted_delay = 71 # Proxy penalty/hr
# --- End Parameters ---

GUROBI_TIME_LIMIT = 5

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m36 = gp.Model("SHIP_BERTHING_PHASE_DECISION_IP", env=env)

    # --- Decision Variables ---
    # Binary: y_prot = 1 if protected phase is chosen, 0 otherwise
    y_prot = m36.addVar(vtype=GRB.BINARY, name="use_protected_phase")

    # --- Objective Function ---
    # Minimize total cost = cost of chosen phase
    m36.setObjective(y_prot * cost_protected_phase + (1 - y_prot) * cost_permitted_delay, sense=GRB.MINIMIZE)

    # --- Constraints: None ---

    # --- Optimization ---
    m36.optimize()

    # --- Store results ---
    results_dict['status'] = m36.status
    if m36.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m36.ObjVal
        results_dict['y_prot_sol'] = y_prot.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 36: Ship Berthing Phase Decision (IP) ---") # Original problem number
    if m36.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        use_protected = results_dict.get('y_prot_sol', 0) > 0.5

        print(f"Optimization Status: Optimal")
        print(f"Optimal Decision: {'Use Protected Phase' if use_protected else 'Use Permitted Phase'}")
        print(f"  Cost of Protected Phase: ${float(cost_protected_phase):.2f}")
        print(f"  Estimated Cost of Permitted Phase (due to delay): ${float(cost_permitted_delay):.2f}")
        print(f"Minimum Estimated Cost: ${float(obj_val_print):.2f}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m36.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 36: Ship Berthing Phase Decision (IP) ---
Optimization Status: Optimal
Optimal Decision: Use Protected Phase
  Cost of Protected Phase: $53.00
  Estimated Cost of Permitted Phase (due to delay): $71.00
Minimum Estimated Cost: $53.00


```

================================================================================



--- Problem 57 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
At a busy port, the operations team needs to optimize the allocation of crane time between two berths, Berth A and Berth B. The total available crane time in a cycle is 90 minutes, but there is a transition time of 5 minutes per berth during which no loading or unloading can occur. This lost time reduces the total effective crane time available for operations.

Berth A has a high demand with 928.92 container moves per hour, and a saturation flow rate of 1746.18 container moves per hour. Berth B has a lower demand of 661.17 container moves per hour but a slightly lower saturation flow rate of 1525.45 container moves per hour. To prevent congestion, the saturation level at Berth B must be kept below 0.914, ensuring smooth operations. Additionally, each berth must have at least 5 minutes of crane time to allow for safe and efficient operations.

The core challenge is to allocate the remaining effective crane time—80 minutes after accounting for lost time—between the two berths. The goal is to maximize the crane time for Berth A while ensuring that Berth B meets its saturation constraint and minimum crane time requirement.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `c_a`: Effective crane time allocated to Berth A (in minutes), with a lower bound of 5 minutes.  
     - `c_b`: Effective crane time allocated to Berth B (in minutes), with a lower bound of 5 minutes.  

   - **2. Parameters:**  
     - `cycle_length = 90`: Total cycle duration (minutes).  
     - `lost_time_per_berth = 5`: Lost time per berth transition (minutes).  
     - `total_lost_time = 10`: Total lost time for both berths (minutes).  
     - `effective_crane_total = 80`: Total usable crane time (cycle_length - total_lost_time).  
     - `demand_a = 928.92`: Berth A demand (container moves/hr).  
     - `saturation_flow_a = 1746.18`: Berth A saturation flow rate (container moves/hr).  
     - `demand_b = 661.17`: Berth B demand (container moves/hr).  
     - `saturation_flow_b = 1525.45`: Berth B saturation flow rate (container moves/hr).  
     - `max_saturation_b = 0.914`: Maximum allowed saturation for Berth B.  
     - `min_crane_time = 5`: Minimum crane time per berth (minutes).  

   - **3. Objective Function:**  
     - Maximize `c_a` to prioritize Berth A crane time.  

   - **4. Constraints:**  
     - **Total crane time constraint:** `c_a + c_b = 80`.  
     - **Berth B saturation constraint:** `c_b >= (demand_b * cycle_length) / (saturation_flow_b * max_saturation_b)`.  
     - **Minimum crane time:** `c_a >= 5`, `c_b >= 5`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
cycle_length = 90  # minutes
lost_time_per_berth = 5  # minutes
total_lost_time = 2 * lost_time_per_berth
effective_crane_total = cycle_length - total_lost_time

demand_a = 928.9162194355567  # container moves/hr
saturation_flow_a = 1746.1843776970072  # container moves/hr
demand_b = 661.1655823821247  # container moves/hr
saturation_flow_b = 1525.44500658029  # container moves/hr

max_saturation_b = 0.9142631288320454  # Service level constraint for Berth B
min_crane_time = 5  # Minimum crane time per berth

# --- Model Creation ---
model = gp.Model("Crane_Time_Cycle_LP")

# --- Decision Variables ---
c_a = model.addVar(name="crane_a", lb=min_crane_time)
c_b = model.addVar(name="crane_b", lb=min_crane_time)

# --- Objective Function ---
model.setObjective(c_a, sense=GRB.MAXIMIZE)

# --- Constraints ---
# Total effective crane time equals available time in cycle
model.addConstr(c_a + c_b == effective_crane_total, name="total_crane_time")

# Berth B saturation constraint
min_c_b_for_saturation = (demand_b * cycle_length) / (saturation_flow_b * max_saturation_b)
model.addConstr(c_b >= min_c_b_for_saturation, name="b_saturation_limit")

# --- Optimization ---
model.optimize()

# --- Output Results ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    print(f"Optimal Berth A Effective Crane Time: {c_a.X:.2f} minutes")
    print(f"Optimal Berth B Effective Crane Time: {c_b.X:.2f} minutes")

    # Calculate actual saturation levels achieved
    sat_a = (demand_a * cycle_length) / (saturation_flow_a * c_a.X) if c_a.X > 0 else float('inf')
    sat_b = (demand_b * cycle_length) / (saturation_flow_b * c_b.X) if c_b.X > 0 else float('inf')

    print(f"\nSaturation Analysis:")
    print(f"  Berth A Saturation: {sat_a:.3f}")
    print(f"  Berth B Saturation: {sat_b:.3f} (Constraint <= 0.9142631288320454)")

    print(f"\nTiming Summary:")
    print(f"  Total Cycle Length: 90 minutes")
    print(f"  Total Lost Time: {total_lost_time} minutes")
    print(f"  Total Effective Crane: {effective_crane_total} minutes")
    print(f"  Minimum Required Berth B Crane: {min_c_b_for_saturation:.2f} minutes")
elif model.status == GRB.INFEASIBLE:
    print(f"Optimization Status: Infeasible")
    print(f"Minimum required Berth B crane time for saturation limit: {min_c_b_for_saturation:.2f} min")
    print(f"Minimum required Berth A crane time: {min_crane_time:.2f} min")
    print(f"Total required minimum crane: {min_c_b_for_saturation + min_crane_time:.2f} min")
    print(f"Total available effective crane: {effective_crane_total:.2f} min")
else:
    print(f"Optimization Status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 2 rows, 2 columns and 3 nonzeros
Model fingerprint: 0xc61ff7af
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [5e+00, 5e+00]
  RHS range        [4e+01, 8e+01]
Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    3.7333700e+01   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  3.733369966e+01

--- Optimization Results ---
Optimization Status: Optimal
Optimal Berth A Effective Crane Time: 37.33 minutes
Optimal Berth B Effective Crane Time: 42.67 minutes

Saturation Analysis:
  Berth A Saturation: 1.282
  Berth B Saturation: 0.914 (Constraint <= 0.9142631288320454)

Timing Summary:
  Total Cycle Length: 90 minutes
  Total Lost Time: 10 minutes
  Total Effective Crane: 80 minutes
  Minimum Required Berth B Crane: 42.67 minutes



================================================================================



--- Problem 58 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A logistics manager is tasked with loading a set of 18 valuable items into two trucks for delivery, each with a strict weight limit of 13 units. The items vary significantly in weight and value—some are lightweight but highly valuable (like item 0, weighing 2 units with a value of 67), while others are heavier but less lucrative (like item 3, weighing 12 units with a value of 87). The challenge is to maximize the total value of the loaded items while ensuring that no truck exceeds its weight capacity and that each item is assigned to at most one truck. The manager must strategically select which items to include and how to distribute them between the two trucks to achieve the highest possible total value. The critical question is: *What is the optimal selection and assignment of items to trucks to maximize the total delivered value without violating the weight constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether item `i` is placed in truck `j` (1 if yes, 0 otherwise).  
   - `y[j]`: Binary variable indicating whether truck `j` is used (1 if yes, 0 otherwise).  

   **2. Parameters:**  
   - `items`: List of tuples `(weight[i], value[i])` for each item `i`.  
   - `truck_capacity = 13`: Maximum weight each truck can hold.  
   - `num_trucks = 2`: Total trucks available.  

   **3. Objective Function:**  
   Maximize the total value of loaded items:  
   `Maximize: sum(value[i] * x[i, j] for all i, j)`  

   **4. Constraints:**  
   - **Truck Weight Limit:** For each truck `j`, the total weight of assigned items cannot exceed its capacity:  
     `sum(weight[i] * x[i, j] for all i) <= truck_capacity * y[j]`.  
   - **Truck Usage Trigger:** If any item is placed in truck `j`, the truck must be marked as used:  
     `x[i, j] <= y[j]` for all `i, j`.  
   - **Item Assignment:** Each item can be placed in at most one truck:  
     `sum(x[i, j] for all j) <= 1` for all `i`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Data Definition (Embedded) ---
items = [(2, 67), (5, 53), (3, 20), (12, 87), (2, 16), (13, 52), (10, 76), (3, 42), (3, 65), (7, 38), (7, 85), (8, 22), (9, 91), (10, 48), (2, 15), (4, 84), (8, 32), (3, 69)]          # List of (weight, value) tuples
truck_capacity = 13      # Maximum weight per truck
num_trucks = 2          # Maximum number of available trucks (parameter)
num_items = 18          # len(items) derived correctly
# --- End Data Definition ---

GUROBI_TIME_LIMIT = 60 # Time limit parameter

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi log in captured output
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Max-Value Truck Loading", env=env)

    # --- Decision variables ---
    x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")  # x[i, j] -> item i placed in truck j
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")  # y[j] -> truck j is used

    # --- Objective: Maximize total value of selected items ---
    # Sum over all items i and the truck j they are placed in
    model.setObjective(gp.quicksum(items[i][1] * x[i, j] for i in range(num_items) for j in range(num_trucks)), GRB.MAXIMIZE)

    # --- Constraint 1: Truck weight limit ---
    for j in range(num_trucks):
        model.addConstr(gp.quicksum(items[i][0] * x[i, j] for i in range(num_items)) <= truck_capacity * y[j], name=f"Truck_{j}_Weight")

    # --- Constraint 2: If an item is placed in a truck, that truck must be considered used ---
    # (This is often implied by C1 if capacity > 0, but good practice)
    for i in range(num_items):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Item_{i}_Triggers_Truck_{j}")

    # --- Constraint 3: Each item can be placed in at most one truck ---
    # (Items not placed contribute 0 to objective and constraints)
    for i in range(num_items):
        model.addConstr(x.sum(i, '*') <= 1, name=f"Item_{i}_AtMostOneTruck")

    # --- Solve the model ---
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal # Best solution found

    # --- Output results (for capture) ---
    if model.status == GRB.OPTIMAL:
        print(f"Optimal total value: {model.objVal:.2f}") # Format value
        print("-" * 30)
        printed_truck_count = 0
        for j in range(num_trucks):
            try:
                 if y[j].x > 0.5:  # Truck is used
                     printed_truck_count += 1
                     assigned_items = [i for i in range(num_items) if x[i, j].x > 0.5]
                     assigned_weights = [items[i][0] for i in assigned_items]
                     truck_load = sum(assigned_weights)
                     print(f"Truck {printed_truck_count} (Index {j}):")
                     print(f"  Load: {truck_load} / {truck_capacity}")
                     print(f"  Items (indices): {sorted(assigned_items)}")
                     # Optional: print item details
                     # print(f"  Items (w,v): {[items[i] for i in sorted(assigned_items)]}")
                     print("-" * 10)
            except AttributeError:
                 pass # Skip trucks not used or if .X missing
    elif model.status == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare if items fit capacity
    else:
        print(f"\nOptimization finished with status: {model.status}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total value: 443.00
------------------------------
Truck 1 (Index 0):
  Load: 13 / 13
  Items (indices): [0, 10, 15]
----------
Truck 2 (Index 1):
  Load: 13 / 13
  Items (indices): [4, 7, 8, 14, 17]
----------


```

================================================================================



--- Problem 59 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port terminal operates with two types of berths: Automated Berthing (AB) and Manual Berthing (MB). The terminal has 3 AB berths and 3 MB berths, each with distinct processing times—13 minutes per ship for AB and 21 minutes for MB. Over a 210-minute period, a total of 181 ships arrive, with 66% (119 ships) equipped for AB and 34% (62 ships) requiring MB. The berths have capacity limits: AB berths can handle 48.46 ships per period, while MB berths can manage 30.00.  

The challenge is to balance ship assignments to minimize congestion, measured by the maximum volume-to-capacity (V/C) ratio across berths. AB ships can use either berth type, but MB ships are restricted to MB berths. The goal is to distribute AB ships between AB and MB berths such that neither berth type becomes disproportionately overloaded, ensuring smooth traffic flow.  

**Core Question:** What is the optimal distribution of AB ships between berth types to minimize the worst-case congestion (V/C ratio) across all berths?  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- `n_ab_ab`: Integer, number of AB ships assigned to AB berths.  
- `n_ab_mb`: Integer, number of AB ships assigned to MB berths.  
- `n_mb_mb`: Integer, number of MB ships (fixed to 62, must use MB berths).  
- `MaxVC`: Continuous, represents the maximum V/C ratio across berths.  

**2. Parameters:**  
- `num_ab_ships = 119`, `num_mb_ships = 62`: Total AB/MB ships.  
- `cap_ab = 48.46`, `cap_mb = 30.00`: Capacities of AB/MB berths.  
- `epsilon = 1e-6`: Small constant to avoid division by zero.  

**3. Objective Function:**  
Minimize `MaxVC` (the worst-case V/C ratio).  

**4. Constraints:**  
- **Ship conservation:**  
  - AB ships: `n_ab_ab + n_ab_mb = 119`.  
  - MB ships: `n_mb_mb = 62`.  
- **V/C ratio bounds:**  
  - For AB berths: `MaxVC * (cap_ab + epsilon) >= n_ab_ab`.  
  - For MB berths: `MaxVC * (cap_mb + epsilon) >= n_ab_mb + n_mb_mb`.  
- **Non-negativity:** All variables >= 0.  

---

**

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_ab_berths = 3
num_mb_berths = 3
time_ab_m = 13
time_mb_m = 21
period_m = 210
total_arrivals = 181
pct_ab = 0.66
pct_mb = 0.34
# Calculated values
num_ab_ships = 119
num_mb_ships = 62
cap_ab = 48.46
cap_mb = 30.00
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTHING_BALANCING", env=env)

    # --- Decision Variables ---
    # n_ab_ab: Number of AB ships using AB berths
    n_ab_ab = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_ab_ab")
    # n_ab_mb: Number of AB ships using MB berths
    n_ab_mb = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_ab_mb")
    # n_mb_mb: Number of MB ships using MB berths (fixed by input)
    # This can be treated as data, but keep as variable for consistency if needed
    n_mb_mb = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_mb_mb")
    # MaxVC: Maximum V/C ratio across berth types
    MaxVC = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="MaxVC") # V/C >= 0

    # --- Objective Function: Minimize the maximum V/C ratio ---
    m.setObjective(MaxVC, GRB.MINIMIZE)

    # --- Constraints ---
    # Conservation of AB ships
    m.addConstr(n_ab_ab + n_ab_mb == num_ab_ships, "ABConserve")

    # Fix MB ships (must use MB berths)
    m.addConstr(n_mb_mb == num_mb_ships, "MBConserve")

    # Calculate flows
    flow_ab = n_ab_ab
    flow_mb = n_ab_mb + n_mb_mb

    # Max V/C calculation (using linear form MaxVC * Capacity >= Flow)
    # Use epsilon to avoid issues if capacity is exactly zero
    epsilon = 1e-6
    if cap_ab > 0:
        m.addConstr(MaxVC * (cap_ab + epsilon) >= flow_ab, "VC_AB")
    else:
         # If AB capacity is zero, no AB ships can use AB berths
         m.addConstr(n_ab_ab == 0, "ZeroCapAB")

    if cap_mb > 0:
        m.addConstr(MaxVC * (cap_mb + epsilon) >= flow_mb, "VC_MB")
    else:
        # If MB capacity is zero, no ships can use MB berths
        m.addConstr(n_ab_mb == 0, "ZeroCapMB_AB")
        m.addConstr(n_mb_mb == 0, "ZeroCapMB_MB") # Will likely make infeasible if num_mb > 0

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_ab_ab_sol'] = n_ab_ab.X # Not needed for output
        # results_dict['n_ab_mb_sol'] = n_ab_mb.X
        # results_dict['n_mb_mb_sol'] = n_mb_mb.X

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is Max V/C ratio
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show precision
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the decision variables
if m.Status == GRB.OPTIMAL:
    print(f"Number of AB ships assigned to AB berths: {n_ab_ab.X}")
    print(f"Number of AB ships assigned to MB berths: {n_ab_mb.X}")
    print(f"Number of MB ships assigned to MB berths: {n_mb_mb.X}")
```
Answer:
Optimal objective value: 2.3112
Number of AB ships assigned to AB berths: 112.0
Number of AB ships assigned to MB berths: 7.0
Number of MB ships assigned to MB berths: 62.0


```

================================================================================



--- Problem 60 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port is managing the berthing and unloading of 15 ships. The process involves two stages: berthing (where the ship docks) and unloading (where the cargo is removed). Each ship has distinct processing times for each stage—for instance, Ship 0 takes 83 minutes to berth and 77 minutes to unload, while Ship 14 requires 30 and 21 minutes, respectively. The port operates under strict sequencing rules: ships must proceed in a fixed order (0 to 14), and no stage can begin until the previous ship has finished at that stage. The operational goal is to minimize the total time taken to berth and unload all ships—the *makespan*—ensuring the last ship completes unloading as quickly as possible. The question is: *What is the shortest possible time to complete all berthing and unloading under these constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `C[i, j]`: Continuous variable representing the completion time of ship `i` at stage `j` (where `i` ranges from 0 to 14 and `j` is 0 for "Berthing" or 1 for "Unloading").  

   **2. Parameters:**  
   - `process_times[i][j]`: Processing time of ship `i` at stage `j` (e.g., `process_times[0][0] = 83`).  
   - `num_stages = 2` (fixed sequence: Berthing → Unloading).  

   **3. Objective Function:**  
   - Minimize `C[14, 1]` (completion time of the last ship at the final stage).  

   **4. Constraints:**  
   - **Stage 0 (Berthing) Sequencing:**  
     - First ship: `C[0, 0] >= process_times[0][0]`.  
     - Subsequent ships: `C[i, 0] >= C[i-1, 0] + process_times[i][0]` for `i = 1 to 14`.  
   - **Stage 1 (Unloading) Sequencing:**  
     - First ship: `C[0, 1] >= C[0, 0] + process_times[0][1]`.  
     - Subsequent ships:  
       - Must finish Stage 0 first: `C[i, 1] >= C[i, 0] + process_times[i][1]`.  
       - Must wait for prior ship at Stage 1: `C[i, 1] >= C[i-1, 1] + process_times[i][1]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] # List of ship indices [0, 1, ...]
# process_times[ship][stage], stage 0=Berthing, stage 1=Unloading
process_times = [[83, 77], [48, 33], [38, 43], [35, 34], [74, 49], [31, 55], [34, 57], [83, 76], [52, 89], [53, 84], [87, 54], [20, 76], [42, 68], [29, 17], [30, 21]]
num_stages = 2 # Should be 2 based on original code
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTHING_UNLOADING", env=env)

    # --- Basic Input Validation ---
    if not ships or num_stages <= 0 or not process_times or len(process_times) != len(ships):
        raise ValueError("Invalid input data for Port Berthing and Unloading")
    if any(len(row) != num_stages for row in process_times):
         raise ValueError("Inconsistent number of stages in process_times")

    # --- Decision Variables ---
    # C[i, j]: Completion time of ship i at stage j
    C = m.addVars(ships, range(num_stages), vtype=GRB.CONTINUOUS, lb=0, name="C")

    # --- Objective Function: Minimize the makespan ---
    # Makespan is completion time of the last ship at the last stage
    last_ship_idx = ships[-1]
    last_stage_idx = num_stages - 1
    m.setObjective(C[last_ship_idx, last_stage_idx], GRB.MINIMIZE)

    # --- Constraints ---
    # Stage 0 completion times (assuming fixed sequence 0, 1, 2...)
    # First ship at stage 0
    m.addConstr(C[0, 0] >= process_times[0][0], "C0_0")
    # Subsequent ships at stage 0
    for i in range(1, len(ships)):
        m.addConstr(C[i, 0] >= C[i-1, 0] + process_times[i][0], f"C0_{i}")

    # Completion times for subsequent stages (j > 0)
    for j in range(1, num_stages):
        # First ship at stage j
        m.addConstr(C[0, j] >= C[0, j-1] + process_times[0][j], f"C{j}_0")
        # Subsequent ships at stage j
        for i in range(1, len(ships)):
            # Must complete stage j-1 first
            m.addConstr(C[i, j] >= C[i, j-1] + process_times[i][j], f"C{j}_{i}_StagePrev")
            # Must wait for previous ship to finish stage j
            m.addConstr(C[i, j] >= C[i-1, j] + process_times[i][j], f"C{j}_{i}_ShipPrev")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['C_sol'] = m.getAttr('X', C) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}") # Makespan
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal objective value: 924.00


```

================================================================================



--- Problem 61 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port terminal is tasked with efficiently scheduling a set of 13 ships into standardized berths to minimize the total number of berths used. Each ship has unique dimensions, ranging from narrow and long (4 units wide by 1 unit high) to wide and bulky (19 units wide by 68 units high). The berths themselves measure 23 units in width and 81 units in length, providing a finite but flexible space for arranging the ships.

The challenge lies not only in fitting all ships into the berths but also in ensuring that no two ships within the same berth overlap, while respecting the berth's boundaries. The terminal manager must determine the optimal arrangement—assigning each ship to a berth and specifying its precise placement (front-left corner coordinates)—to minimize the total number of berths used. This problem mirrors real-world port operations, where efficient space utilization translates directly to cost savings in port operations and maintenance.

The core question is: *What is the minimum number of berths required to schedule all 13 ships without violating the geometric constraints, and how should the ships be positioned within those berths?*
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `x[i, j]`: Binary variable indicating whether ship `i` is assigned to berth `j` (1 if yes, 0 otherwise).
   - `y[j]`: Binary variable indicating whether berth `j` is used (1 if yes, 0 otherwise).
   - `px[i, j]`: Continuous variable representing the x-coordinate (horizontal position) of ship `i`'s front-left corner in berth `j`.
   - `py[i, j]`: Continuous variable representing the y-coordinate (vertical position) of ship `i`'s front-left corner in berth `j`.
   - `left[i, k, j]`, `right[i, k, j]`, `below[i, k, j]`, `above[i, k, j]`: Binary variables encoding the relative positioning of ships `i` and `k` within berth `j` to prevent overlaps.

**2. Parameters:**
   - `ships`: List of tuples specifying the width and length of each ship (e.g., `(5, 71)` for ship 0).
   - `berth_size`: Tuple `(23, 81)` defining the width and length of each berth.
   - `num_ships = 13`: Total number of ships to schedule.
   - `num_berths = 13`: Maximum possible berths (initialized to the number of ships, assuming worst-case one ship per berth).
   - `M_w = 23`, `M_h = 81`: "Big-M" values derived from berth dimensions to enforce logical constraints.

**3. Objective Function:**
   - Minimize the total number of berths used:  
     \[
     \text{Minimize: } \sum_{j=1}^{13} y[j]
     \]

**4. Constraints:**
   - **Ship Assignment:** Each ship must be placed in exactly one berth:
     \[
     \sum_{j=1}^{13} x[i, j] = 1 \quad \forall i \in \{0, 1, \dots, 12\}
     \]
   - **Berth Boundaries:** Ships must fit within their assigned berth:
     \[
     px[i, j] + \text{ship}_i\text{.width} \leq 23 + 23(1 - x[i, j]) \quad \forall i, j
     \]
     \[
     py[i, j] + \text{ship}_i\text{.length} \leq 81 + 81(1 - x[i, j]) \quad \forall i, j
     \]
   - **Non-Overlapping:** For any two ships `i` and `k` in the same berth `j`, enforce at least one relative positioning (left, right, below, above):
     \[
     \text{left}[i, k, j] + \text{right}[i, k, j] + \text{below}[i, k, j] + \text{above}[i, k, j] \geq x[i, j] + x[k, j] - 1 \quad \forall i < k, j
     \]
   - **Berth Activation:** A berth is marked as used if any ship is assigned to it:
     \[
     x[i, j] \leq y[j] \quad \forall i, j
     \]

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
ships = [(5, 71), (4, 1), (15, 48), (18, 50), (19, 64), (9, 77), (17, 18), (11, 71), (9, 43), (17, 4), (8, 10), (19, 68), (6, 32)]  # (width, length) of ships
berth_size = (23, 81)  # (width, length) of each berth
num_ships = 13 # len(ships)
# Maximum berths needed (worst case: one ship per berth)
# Can sometimes be reduced with lower bounds, but num_ships is safe
num_berths = num_ships
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using berth dimensions is common and valid)
M_w = berth_size[0]
M_h = berth_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Berth Scheduling", env=env)

# --- Decision Variables ---
# x[i,j]: ship i assigned to berth j
x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: front-left corner position of ship i if in berth j
px = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of ships *within the same berth*
left  = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="left")
right = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="right")
below = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="below")
above = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_berths))

# --- Constraints ---

# 1. Each ship must be assigned to exactly one berth
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Ship placement constraints within berth boundaries (Big-M formulation)
for j in range(num_berths):
    for i in range(num_ships):
        ship_w, ship_l = ships[i] # Get dimensions for ship i

        # Position variables must be 0 if ship i is not in berth j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Ship's right edge <= berth width IF ship is placed in berth (x[i,j]=1)
        model.addConstr(px[i, j] + ship_w <= berth_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Ship's top edge <= berth length IF ship is placed in berth (x[i,j]=1)
        model.addConstr(py[i, j] + ship_l <= berth_size[1] + M_h * (1 - x[i, j]), name=f"Length_Limit_{i}_{j}")

# 3. Non-overlapping constraints for ships within the same berth
for j in range(num_berths):
    for i in range(num_ships):
        for k in range(i + 1, num_ships): # Iterate over distinct pairs (i < k)
            ship_i_w, ship_i_l = ships[i]
            ship_k_w, ship_k_l = ships[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => ship i is to the left of ship k
            model.addConstr(px[i, j] + ship_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => ship i is to the right of ship k (k is left of i)
            model.addConstr(px[k, j] + ship_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => ship i is below ship k
            model.addConstr(py[i, j] + ship_i_l <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => ship i is above ship k (k is below i)
            model.addConstr(py[k, j] + ship_k_l <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH ship i and ship k are in berth j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link ship assignment to berth usage: If any ship i is in berth j, then berth j must be used (y[j]=1)
#    This can be done per ship or aggregated. Per ship is often tighter.
for j in range(num_berths):
    for i in range(num_ships):
        model.addConstr(x[i, j] <= y[j], name=f"Ship_Berth_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_ships * y[j], name=f"Berth_Activation_{j}")


# --- Solve ---
print("Solving 2DBP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of berths used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    berth_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_berths):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Berth {j_sol + 1} (Used):")
            ships_in_berth_info = []
            for i_sol in range(num_ships):
                if x[i_sol, j_sol].X > 0.5:
                    ship_data = {
                        "id": i_sol,
                        "dims": ships[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    ships_in_berth_info.append(ship_data)
                    print(f"  Ship {ship_data['id']} {ship_data['dims']} at {ship_data['pos']}")
            berth_details.append({'berth_index': j_sol, 'ships': ships_in_berth_info})
            print("-" * 10)
    results_dict['berth_details'] = berth_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 2DBP instance...
Gurobi Error code 10010: Model too large for size-limited license; visit https://gurobi.com/unrestricted for more information

Optimization finished with status: -1. No optimal solution found.


```

================================================================================



--- Problem 62 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port is managed by a three-phase crane scheduling system, where each phase must allocate operation time to different loading and unloading tasks while minimizing overall delay. The port experiences varying cargo volumes, quantified by flow coefficients of 1337, 2433, and 2425 containers per hour for phases 1, 2, and 3, respectively. The challenge is to distribute the total cycle time of 30 minutes among these phases such that the sum of operation times matches the cycle time, with each phase’s operation time constrained between 7 and 30 minutes. Delays occur when cranes wait during idle times, which are simply the cycle time minus the operation time for each phase. The goal is to strategically allocate operation times to minimize the total delay across all phases, ensuring smooth cargo handling while adhering to operational constraints. The critical question is: What is the optimal operation time allocation for each phase to achieve the lowest possible total delay?
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( t_i \) represent the operation time (in minutes) allocated to phase \( i \), where \( i \in \{1, 2, 3\} \). Each \( t_i \) is a continuous variable with bounds \( 7 \leq t_i \leq 30 \).  
   - **2. Parameters:**  
     - \( \text{flow_coeffs} = [1337, 2433, 2425] \): Cargo flow coefficients for each phase.  
     - \( \text{cycle_time} = 30 \): Total cycle time (minutes).  
     - \( \text{lb_time} = 7 \), \( \text{ub_time} = 30 \): Lower and upper bounds for operation times.  
   - **3. Objective Function:**  
     - Minimize the total delay:  
       \[ \text{Minimize: } \sum_{i=1}^3 \text{flow_coeffs}_i \cdot (\text{cycle_time} - t_i) \]  
   - **4. Constraints:**  
     - The sum of operation times must equal the cycle time:  
       \[ t_1 + t_2 + t_3 = 30 \]  
     - Bounds on operation times:  
       \[ 7 \leq t_i \leq 30 \quad \forall i \in \{1, 2, 3\} \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 3
lb_time = 7          # Lower bound for operation time
ub_time = 30          # Upper bound for operation time
cycle_time = 30   # Total cycle time (set equal to ub_time)
flow_coeffs = [1337, 2433, 2425] # Cargo flow coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Crane Scheduling", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for phase i is proportional to flow * idle_time = flow * (cycle_time - operation_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of operation times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal operation times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
Optimal total delay: 120588.00
------------------------------
Optimal operation times (minutes):
  t1: 7.00, t2: 16.00, t3: 7.00



================================================================================



--- Problem 63 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
At a busy port, the management faces the challenge of efficiently processing incoming ships—cargo and passenger vessels—with limited resources. The facility has a team of 10 dockworkers who must be allocated to operate berthing spots. Each cargo ship berthing spot requires 2 dockworkers and can process up to 16 cargo ships per hour, while each passenger vessel berthing spot also requires 2 dockworkers but can handle only 5 passenger vessels per hour due to the more thorough inspections needed. On this particular day, 292 cargo ships and 69 passenger vessels are expected to arrive. The goal is to maximize the total number of vessels processed by strategically opening the right mix of cargo and passenger berthing spots, ensuring dockworker availability is not exceeded, and processing does not surpass either the capacity of the berths or the actual arrivals. The critical question is: How many cargo and passenger berthing spots should be opened to process as many vessels as possible under these constraints?
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y_cargo`: Integer, number of cargo berthing spots to open.  
     - `y_passenger`: Integer, number of passenger berthing spots to open.  
     - `z_cargo`: Continuous, number of cargo ships processed.  
     - `z_passenger`: Continuous, number of passenger vessels processed.  

   - **2. Parameters:**  
     - `total_dockworkers = 10`: Total dockworkers available.  
     - `dockworkers_per_cargo_spot = 2`: Dockworkers needed per cargo berthing spot.  
     - `dockworkers_per_passenger_spot = 2`: Dockworkers needed per passenger berthing spot.  
     - `capacity_cargo_spot = 16`: Maximum cargo ships processed per cargo berthing spot per hour.  
     - `capacity_passenger_spot = 5`: Maximum passenger vessels processed per passenger berthing spot per hour.  
     - `arriving_cargo_ships = 292`: Total cargo ships arriving.  
     - `arriving_passenger_vessels = 69`: Total passenger vessels arriving.  

   - **3. Objective Function:**  
     Maximize `z_cargo + z_passenger` (total vessels processed).  

   - **4. Constraints:**  
     - Dockworker limit: `2 * y_cargo + 2 * y_passenger <= 10`.  
     - Cargo capacity: `z_cargo <= 16 * y_cargo`.  
     - Passenger capacity: `z_passenger <= 5 * y_passenger`.  
     - Cargo arrivals: `z_cargo <= 292`.  
     - Passenger arrivals: `z_passenger <= 69`.  
     - Non-negativity: `y_cargo, y_passenger >= 0` (integers); `z_cargo, z_passenger >= 0` (continuous).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_dockworkers = 10
dockworkers_per_cargo_spot = 2
dockworkers_per_passenger_spot = 2
capacity_cargo_spot = 16 # vessels per hour
capacity_passenger_spot = 5 # vessels per hour
arriving_cargo_ships = 292
arriving_passenger_vessels = 69
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTHING_ALLOC", env=env)

    # --- Decision Variables ---
    # y_cargo: number of cargo berthing spots to open
    y_cargo = m.addVar(vtype=GRB.INTEGER, lb=0, name="y_cargo")
    # y_passenger: number of passenger berthing spots to open
    y_passenger = m.addVar(vtype=GRB.INTEGER, lb=0, name="y_passenger")
    # z_cargo: number of cargo ships processed
    z_cargo = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="z_cargo")
    # z_passenger: number of passenger vessels processed
    z_passenger = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="z_passenger")

    # --- Objective Function: Maximize total vessels processed ---
    m.setObjective(z_cargo + z_passenger, GRB.MAXIMIZE)

    # --- Constraints ---
    # Dockworker availability constraint
    # Ensure dockworker counts are positive before adding constraint
    if dockworkers_per_cargo_spot > 0 and dockworkers_per_passenger_spot > 0:
        m.addConstr(dockworkers_per_cargo_spot * y_cargo + dockworkers_per_passenger_spot * y_passenger <= total_dockworkers, "DockworkerLimit")
    elif dockworkers_per_cargo_spot > 0:
         m.addConstr(dockworkers_per_cargo_spot * y_cargo <= total_dockworkers, "DockworkerLimit")
    elif dockworkers_per_passenger_spot > 0:
         m.addConstr(dockworkers_per_passenger_spot * y_passenger <= total_dockworkers, "DockworkerLimit")

    # Processed vessels cannot exceed capacity
    m.addConstr(z_cargo <= capacity_cargo_spot * y_cargo, "CargoCapacity")
    m.addConstr(z_passenger <= capacity_passenger_spot * y_passenger, "PassengerCapacity")

    # Processed vessels cannot exceed arrivals
    m.addConstr(z_cargo <= arriving_cargo_ships, "CargoArrivals")
    m.addConstr(z_passenger <= arriving_passenger_vessels, "PassengerArrivals")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['y_cargo_sol'] = y_cargo.X # Not needed for output
        # results_dict['y_passenger_sol'] = y_passenger.X # Not needed for output
        # results_dict['z_cargo_sol'] = z_cargo.X # Not needed for output
        # results_dict['z_passenger_sol'] = z_passenger.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Objective is total vessels, potentially float if z variables are float
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the number of cargo and passenger berthing spots and the number of vessels processed
if m.Status == GRB.OPTIMAL:
    print(f"Optimal objective value: {obj_val_print:.2f}")
    print(f"Number of cargo berthing spots to open: {y_cargo.X}")
    print(f"Number of passenger berthing spots to open: {y_passenger.X}")
    print(f"Number of cargo ships processed: {z_cargo.X}")
    print(f"Number of passenger vessels processed: {z_passenger.X}")
```
Answer:
Optimal objective value: 80.00
Optimal objective value: 80.00
Number of cargo berthing spots to open: 5.0
Number of passenger berthing spots to open: -0.0
Number of cargo ships processed: 80.0
Number of passenger vessels processed: 0.0


```

================================================================================



--- Problem 64 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A busy port authority must schedule the berthing of six cargo ships (`1` to `6`) at a single tidal berth (`1`). Each ship arrives at a fixed time (`Ship 1: 2h, Ship 2: 3h, ..., Ship 6: 19h`) and requires a specific processing time for unloading (`Ship 1: 4h, Ship 2: 3h, ..., Ship 6: 6h`). The berth is only accessible during high tide, which occurs every `11` hours (`tide_cycle`) and lasts for `6` hours (`tide_duration`). Outside these windows, the water level is too low for safe docking. The challenge is to assign each ship to a tidal window such that they are processed without overlap, respecting arrival times, and minimizing the total time until the last ship departs (`makespan`). Additionally, the port manager wants to ensure that no ship waits more than `5` hours after its arrival time before it starts processing. The port manager seeks the tightest possible schedule to maximize berth utilization while adhering to tidal constraints and the new waiting time limit.

**Key Question:** *What is the earliest possible completion time for all ships, given tidal accessibility, processing requirements, and the new waiting time limit?*  

---

**Modeling Process:**
**
**1. Decision Variables:**  
- `assign[i, j]`: Binary (1 if ship `i` is assigned to berth `j`; 0 otherwise).  
- `start_time[i]`: Continuous (when ship `i` begins processing).  
- `completion_time[i]`: Continuous (when ship `i` finishes).  
- `precedes[i, k, j]`: Binary (1 if ship `i` is scheduled before ship `k` on berth `j`).  
- `z[i, k]`: Binary (1 if ship `i` starts in tidal cycle `k`).  
- `makespan`: Continuous (total time until last ship departs).  

**2. Parameters:**  
- `ships`: `[1, 2, 3, 4, 5, 6]`.  
- `berths`: `[1]`.  
- `arrival_times`: `{1: 2, 2: 3, ..., 6: 19}`.  
- `processing_times`: `{1: 4, 2: 3, ..., 6: 6}`.  
- `tide_cycle`: `11h`, `tide_duration`: `6h`.  
- `H`: Large constant (`100`).  
- `max_k`: Maximum tidal cycles considered (`6`).  
- `waiting_limit`: Maximum waiting time after arrival (`5h`).

**3. Objective Function:**  
Minimize `makespan` (latest completion time).  

**4. Constraints:**  
- **Assignment:** Each ship must use the berth.  
- **Arrival Time:** Ships cannot start before arrival.  
- **Completion Time:** `completion_time[i] = start_time[i] + processing_times[i]`.  
- **Non-Overlapping:** For ships `i` and `k` on the same berth, one must precede the other.  
- **Tidal Windows:**  
  - Each ship starts in exactly one tidal cycle `k`.  
  - If `z[i, k] = 1`, `start_time[i]` must fall within cycle `k`’s window (`[k * tide_cycle, k * tide_cycle + tide_duration]`).  
  - Processing must finish within the same tidal window.  
- **Waiting Time Limit:**  
  - The waiting time for each ship, defined as `start_time[i] - arrival_times[i]`, must not exceed `waiting_limit`.

---

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3, 4, 5, 6]
berths = [1] # Should be [1]
arrival_times = {1: 2, 2: 3, 3: 8, 4: 11, 5: 15, 6: 19}
processing_times = {1: 4, 2: 3, 3: 4, 4: 3, 5: 3, 6: 6}
tide_cycle = 11
tide_duration = 6
H = 100 # Big M
max_k = 6 # Estimated max cycles needed
waiting_limit = 5 # New waiting time limit
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_13_TIDAL")

    if not ships or not berths or len(berths)!=1: raise ValueError("Invalid ships/berths")
    the_berth = berths[0]

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign") # Trivial
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in ships for k in ships if i < k for j in berths],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    # Tidal constraint variables
    z = m.addVars(ships, range(max_k), vtype=GRB.BINARY, name="start_cycle")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_berth] == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping (on the single berth) using Indicators
    j = the_berth
    for i in ships:
        for k in ships:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in ships), name="makespan_def")
    # 6. Tidal Constraint
    for i in ships:
        m.addConstr(z.sum(i, '*') == 1, name=f"ship_{i}_one_cycle")
        for k in range(max_k):
            window_start = k * tide_cycle
            # Allow starting exactly at window_end? Original logic might need <= window_end
            # Using strict < window_end by using window_start + duration as upper bound
            window_end_strict = window_start + tide_duration
            # If z[i,k]=1, then window_start <= s[i] < window_end_strict
            m.addGenConstrIndicator(z[i,k], True, start_time[i] >= window_start, name=f"tide_start_lower_{i}_{k}")
            # Cannot use strict inequality, use epsilon or ensure proc time fits
            # Ensure completion time is within the window if it starts in the window
            # This is the complex part often simplified. Let's ensure proc time fits.
            m.addGenConstrIndicator(z[i,k], True, start_time[i] + processing_times.get(i,0) <= window_end_strict, name=f"tide_end_upper_{i}_{k}")

    # 7. Waiting Time Limit
    m.addConstrs((start_time[i] - arrival_times.get(i, 0) <= waiting_limit for i in ships), name="waiting_limit")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    for i in ships:
        print(f"Ship {i} start time: {start_time[i].x:.4f}")
        print(f"Ship {i} completion time: {completion_time[i].x:.4f}")
        for k in range(max_k):
            if z[i, k].x > 0.5:
                print(f"Ship {i} starts in tidal cycle {k}")
    print(f"Makespan: {makespan.x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Infeasible


```

================================================================================



--- Problem 65 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the harbor master is tasked with coordinating the berthing times for four distinct ships to minimize total waiting time. Each ship has a specific arrival rate: 1,085, 1,672, 1,500, and 2,040 ships per hour for berths 1 through 4, respectively. The port operates on a fixed cycle time of 65 minutes, during which the sum of all berthing times must exactly match this duration. The harbor master must allocate berthing times between 16 and 65 minutes for each berth, ensuring no berth falls below the minimum required for safe docking. The core optimization task is to distribute these berthing times strategically, accounting for higher delays incurred when berths with heavier traffic are assigned shorter berthing times (resulting in longer waiting times). The question at hand: *What is the optimal berthing time allocation across all four berths to minimize the total waiting time experienced by ships at this port?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `t_i`: Continuous variable representing the berthing time (in minutes) allocated to berth `i`, where `i ∈ {1, 2, 3, 4}`. Each `t_i` is bounded between 16 and 65 minutes.  
   - **2. Parameters:**  
     - `arrival_rates = [1085, 1672, 1500, 2040]`: Arrival rates (ships/hour) for each berth.  
     - `cycle_time = 65`: Total cycle duration (minutes).  
     - `lb_time = 16`, `ub_time = 65`: Lower/upper bounds for berthing times.  
   - **3. Objective Function:**  
     - Minimize the total waiting time:  
       `Sum over all berths i: arrival_rates[i] * (cycle_time - t_i)`.  
       *(Waiting time for berth i is proportional to its arrival rate multiplied by its non-berthing time, where non-berthing time = cycle_time - berthing_time.)*  
   - **4. Constraints:**  
     - **Total cycle constraint:** The sum of berthing times must equal the cycle time:  
       `t_1 + t_2 + t_3 + t_4 = 65`.  
     - **Variable bounds:** `16 ≤ t_i ≤ 65` for all berths `i`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_berths = 4
lb_time = 16          # Lower bound for berthing time
ub_time = 65          # Upper bound for berthing time
cycle_time = 65   # Total cycle time (set equal to ub_time)
arrival_rates = [1085, 1672, 1500, 2040] # Arrival rates per berth
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_rates) != num_berths:
    print("Error: arrival_rates length mismatch with num_berths")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_rates length"
    # raise ValueError("arrival_rates length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_berths}-Berth Berthing Time Allocation", env=env)

        # --- Decision variables (dynamic based on num_berths) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_berths, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for berth i is proportional to arrival_rate * non-berthing_time = arrival_rate * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_rates[i] * (cycle_time - t_vars[i]) for i in range(num_berths)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_berths)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_berths)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_berths):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 306513.00
------------------------------
Optimal berthing times (minutes):
  t1: 16.00, t2: 16.00, t3: 16.00, t4: 17.00


```

================================================================================



--- Problem 66 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
A logistics company is tasked with packing a set of 14 items of varying weights into a selection of 9 available trucks, each with a unique capacity and associated cost. The items range from lightweight (1 unit) to heavy (96 units), while the trucks offer different combinations of capacity (ranging from 96 to 100 units) and cost (from $9 to $95). The challenge is to assign every item to exactly one truck without exceeding the truck's capacity, while minimizing the total cost incurred from using the trucks. The goal is to find the most cost-effective packing arrangement, ensuring no truck is overfilled and that the selection of trucks aligns with the items' weight distribution. The central question is: *What is the optimal assignment of items to trucks that satisfies all constraints and results in the lowest possible total cost?*

**Modeling Process:**
- **1. Decision Variables:**
     - `x[i, j]`: Binary variable indicating whether item `i` is assigned to truck `j` (1 if assigned, 0 otherwise).
     - `y[j]`: Binary variable indicating whether truck `j` is used (1 if used, 0 otherwise).
   - **2. Parameters:**
     - `items[i]`: Weight of item `i` (given as [50, 52, ..., 1, 2]).
     - `trucks[j]`: Tuple `(capacity, cost)` for truck `j` (e.g., (98, 20), (97, 53), etc.).
   - **3. Objective Function:**
     - Minimize the total cost: `sum(y[j] * trucks[j][1] for all j)`.
   - **4. Constraints:**
     - Each item must be assigned to exactly one truck: `sum(x[i, j] for all j) = 1` for every item `i`.
     - Truck capacity must not be exceeded: `sum(items[i] * x[i, j] for all i) <= trucks[j][0] * y[j]` for every truck `j`.
     - An item can only be assigned to a truck if the truck is used: `x[i, j] <= y[j]` for every item `i` and truck `j`.

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys # Make sys available inside exec if needed, e.g. for print traceback
import traceback

# --- Data Definition (Embedded) ---
items = [50, 52, 48, 96, 27, 16, 2, 6, 36, 74, 90, 55, 1, 2]      # Item weights
trucks = [(98, 20), (97, 53), (97, 85), (99, 86), (100, 50), (100, 9), (96, 95), (96, 90), (97, 75)]        # List of (Capacity, Cost) tuples
num_items = 14       # len(items)
num_trucks = 9         # len(trucks)
# --- End Data Definition ---

# Time limit (passed from outer scope via globals if needed, or hardcoded)
GUROBI_TIME_LIMIT = 60

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Keep output clean for saving
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Cost-Sensitive BPP", env=env)

    # --- Decision Variables ---
    x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")

    # --- Objective: Minimize total cost ---
    model.setObjective(gp.quicksum(y[j] * trucks[j][1] for j in range(num_trucks)), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Each item assignment
    for i in range(num_items):
        model.addConstr(x.sum(i, '*') == 1, name=f"Item_{i}_Assignment")

    # 2. Truck capacity
    for j in range(num_trucks):
        truck_capacity = trucks[j][0]
        if truck_capacity < 0: truck_capacity = 0
        model.addConstr(gp.quicksum(items[i] * x[i, j] for i in range(num_items)) <= truck_capacity * y[j], name=f"Truck_{j}_Capacity")

    # 3. Linking item to truck usage
    for i in range(num_items):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Item_{i}_Triggers_Truck_{j}")

    # --- Solve ---
    # print("Solving CS-BPP instance...") # Comment out or keep for debug inside output
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal

    # --- Output results (This will be captured) ---
    # This logic needs to be *inside* the template now
    if model.status == GRB.OPTIMAL:
        print(f"Minimum cost: ${model.objVal:.2f}") # Use model.objVal directly
        print("-" * 30) # Add separator for clarity
        printed_truck_count = 0
        for j in range(num_trucks):
            # Use try-except for safety when accessing .X
            try:
                 if y[j].x > 0.5:
                     printed_truck_count += 1
                     truck_capacity_out, truck_cost_out = trucks[j]
                     assigned_items = [i for i in range(num_items) if x[i, j].x > 0.5]
                     truck_load_out = sum(items[i] for i in assigned_items)
                     # Format output exactly as desired for the log file
                     print(f"Truck {printed_truck_count} (Type Index {j}, Capacity: {truck_capacity_out}, Cost: ${truck_cost_out:.2f}):")
                     print(f"  Load: {truck_load_out} / {truck_capacity_out}")
                     print(f"  Items (indices): {sorted(assigned_items)}") # Sort for consistency
                     print("-" * 10) # Separator between trucks
            except AttributeError:
                 pass # Ignore trucks not used or if .X attribute missing
    elif model.status == GRB.TIME_LIMIT:
        print("\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: ${model.ObjVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {model.status}")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}") # Print errors to captured output
    results_dict['status'] = -1 # Use dict to signal error type to main loop
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:") # Print errors
    traceback.print_exc(file=sys.stdout) # Print traceback to captured stdout
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
Minimum cost: $292.00
------------------------------
Truck 1 (Type Index 0, Capacity: 98, Cost: $20.00):
  Load: 98 / 98
  Items (indices): [3, 13]
----------
Truck 2 (Type Index 1, Capacity: 97, Cost: $53.00):
  Load: 96 / 97
  Items (indices): [7, 10]
----------
Truck 3 (Type Index 2, Capacity: 97, Cost: $85.00):
  Load: 82 / 97
  Items (indices): [4, 11]
----------
Truck 4 (Type Index 4, Capacity: 100, Cost: $50.00):
  Load: 88 / 100
  Items (indices): [1, 8]
----------
Truck 5 (Type Index 5, Capacity: 100, Cost: $9.00):
  Load: 100 / 100
  Items (indices): [0, 2, 6]
----------
Truck 6 (Type Index 8, Capacity: 97, Cost: $75.00):
  Load: 91 / 97
  Items (indices): [5, 9, 12]
----------



================================================================================



--- Problem 67 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
A maritime logistics company operates a fleet of 5 ships (with capacities 93, 70, 99, 84, and 100 units) to deliver goods from a central port (Node 0) to 9 customer locations (Nodes 1–9). Each customer has a specific demand (ranging from 12 to 90 units), and the travel distances between any two nodes are predefined, forming a symmetric distance matrix. The challenge is to design routes for the ships that:
- Ensure each customer is visited exactly once.
- Respect ship capacity limits.
- Begin and end at the port.
- Minimize the total distance traveled across all routes.

The operational stakes are high: inefficient routing would inflate fuel costs and delay deliveries. The key question is: *What is the most efficient set of routes that meets all constraints while minimizing total travel distance?*

---

**Modeling Process:**
**1. Decision Variables:**
- Binary variables `x(i, j, k)` for each ship `k` and node pair `(i, j)`, where `x(i, j, k) = 1` if ship `k` travels directly from node `i` to `j`, else `0`.
- Continuous variables `u(i)` for subtour elimination (MTZ constraints), representing the order of node `i` in a route.

**2. Parameters:**
- `N = 10` (nodes: 1 port + 9 customers).
- `K = 5` (ships).
- `Q[k]`: Capacity of ship `k` (e.g., 93, 70, ...).
- `q[j]`: Demand at customer `j` (e.g., 47, 43, ...).
- `d[i][j]`: Distance from node `i` to `j` (symmetric matrix).

**3. Objective Function:**
Minimize the total distance:
```
Minimize: sum(d[i][j] * x(i, j, k) for all k, i, j where i ≠ j)
```

**4. Constraints:**
- **Visit each customer once:**
  `sum(x(i, j, k) for all k, j where i ≠ j) = 1` for each customer `i`.
- **Flow conservation:**
  `sum(x(i, j, k) for j) = sum(x(j, i, k) for j)` for each node `i` and ship `k`.
- **Port departure/return:**
  Each ship `k` must leave and return to the port at most once.
- **Capacity limits:**
  `sum(q[j] * sum(x(i, j, k) for i) for j) ≤ Q[k]` for each ship `k`.
- **Subtour elimination (MTZ):**
  `u(i) - u(j) + (N-1) * x(i, j, k) ≤ N-2` for `i, j ≥ 1`, `i ≠ j`, and all `k`.

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 10
K = 5
Q = [93, 70, 99, 84, 100]
q = [0, 47, 43, 55, 90, 15, 71, 45, 12, 54]
d = [
    [0, 35, 96, 49, 9, 6, 5, 14, 53, 61],
    [35, 0, 59, 16, 34, 59, 58, 92, 44, 16],
    [96, 59, 0, 33, 44, 2, 76, 49, 52, 30],
    [49, 16, 33, 0, 19, 40, 91, 39, 37, 70],
    [9, 34, 44, 19, 0, 78, 5, 83, 45, 23],
    [6, 59, 2, 40, 78, 0, 3, 40, 33, 32],
    [5, 58, 76, 91, 5, 3, 0, 77, 66, 67],
    [14, 92, 49, 39, 83, 40, 77, 0, 35, 78],
    [53, 44, 52, 37, 45, 33, 66, 35, 0, 56],
    [61, 16, 30, 70, 23, 32, 67, 78, 56, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Ship Departure/Return from Port (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartPort_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnPort_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for ship {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for ship {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 531.00

Route for ship 1 (Capacity: 93):
0 -> 4 -> 0
Route Load: 90 / 93

Route for ship 2 (Capacity: 70):
0 -> 5 -> 1 -> 0
Route Load: 62 / 70

Route for ship 3 (Capacity: 99):
0 -> 9 -> 2 -> 0
Route Load: 97 / 99

Route for ship 4 (Capacity: 84):
0 -> 8 -> 6 -> 0
Route Load: 83 / 84

Route for ship 5 (Capacity: 100):
0 -> 3 -> 7 -> 0
Route Load: 100 / 100


```

================================================================================



--- Problem 68 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
At a busy port, the operations manager needs to allocate crane usage time between two berths, Berth A and Berth B. Berth A has a handling capacity of 1,288 containers per hour but is currently receiving only 401 containers, while Berth B can handle up to 1,675 containers per hour and is receiving 758 containers. The goal is to allocate crane usage time for each berth to maximize the weighted utilization of crane time, where weights reflect the ratio of arrival flow to handling capacity—effectively prioritizing berths with higher congestion relative to their capacity.  

The total crane cycle time is fixed at 72 minutes, with each berth incurring a 6-minute "setup time" (comprising 3 minutes of transition and 3 minutes of safety checks). The manager must ensure each berth gets at least 10 minutes of crane time to allow efficient loading and unloading. The core question is: *How should crane time be split between Berth A and Berth B to maximize the port's weighted efficiency while adhering to cycle constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `c_a`: Crane time (minutes) allocated to Berth A.  
     - `c_b`: Crane time (minutes) allocated to Berth B.  
     Both are continuous variables with a lower bound of 10 minutes.  

   - **2. Parameters:**  
     - Cycle time: 72 minutes.  
     - Setup time per berth: 6 minutes (transition + safety checks).  
     - Handling capacities: `cap_a = 1,288`, `cap_b = 1,675` (containers/hour).  
     - Arrival flows: `arr_a = 401`, `arr_b = 758` (containers/hour).  
     - Weights: `weight_a = arr_a / cap_a`, `weight_b = arr_b / cap_b`.  

   - **3. Objective Function:**  
     Maximize the weighted sum of crane times:  
     ```  
     Maximize: weight_a * c_a + weight_b * c_b  
     ```  

   - **4. Constraints:**  
     - Total cycle time:  
       ```  
       c_a + 6 + c_b + 6 = 72  
       ```  
     - Minimum crane times:  
       ```  
       c_a >= 10, c_b >= 10  
       ```  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cycle_time = 72
transition_time = 3
safety_check_time = 3
min_crane = 10
cap_a = 1288
arr_a = 401
cap_b = 1675
arr_b = 758
setup_time_per_berth = 6 # transition + safety_check
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("CRANE_USAGE_TIMING", env=env)

    # --- Decision Variables ---
    # c_a: crane time for Berth A (minutes)
    c_a = m.addVar(lb=min_crane, vtype=GRB.CONTINUOUS, name="c_a")
    # c_b: crane time for Berth B (minutes)
    c_b = m.addVar(lb=min_crane, vtype=GRB.CONTINUOUS, name="c_b")

    # --- Objective Function: Maximize weighted crane times ---
    # Weight by flow/capacity ratio (degree of saturation)
    # Avoid division by zero
    weight_a = arr_a / cap_a if cap_a > 1e-6 else 0
    weight_b = arr_b / cap_b if cap_b > 1e-6 else 0
    m.setObjective(weight_a * c_a + weight_b * c_b, GRB.MAXIMIZE)

    # --- Constraints ---
    # Cycle time constraint: sum of phase times must equal cycle time
    # Phase time = crane + setup_time_per_berth
    m.addConstr(c_a + setup_time_per_berth + c_b + setup_time_per_berth == cycle_time, "CycleTimeConstraint")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['c_a_sol'] = c_a.X # Not needed for output
        # results_dict['c_b_sol'] = c_b.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Format objective value (weighted crane time sum)
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show more decimals for weighted sum
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block to print the decision variables)
if m.Status == GRB.OPTIMAL:
    obj_val_print = results_dict.get('obj_val', 'N/A')
    c_a_sol = c_a.X
    c_b_sol = c_b.X
    # Format objective value (weighted crane time sum)
    if isinstance(obj_val_print, (int, float)):
        print(f"Optimal objective value: {obj_val_print:.4f}")
        print(f"Crane time for Berth A: {c_a_sol:.2f} minutes")
        print(f"Crane time for Berth B: {c_b_sol:.2f} minutes")
    else:
        print(f"Optimal objective value: {obj_val_print}")
```
Answer:
Optimal objective value: 25.7402
Optimal objective value: 25.7402
Crane time for Berth A: 10.00 minutes
Crane time for Berth B: 50.00 minutes


```

================================================================================



--- Problem 69 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port authority is tasked with efficiently scheduling a set of 11 ships to the fewest possible berths. Each ship has a specific length: [2, 7, 7, 7, 2, 9, 5, 7, 4, 2, 9] meters. The berths have a strict length limit of 9 meters each. The challenge is to assign each ship to exactly one berth without exceeding the berth's length, while minimizing the total number of berths used. This problem mirrors real-world scenarios like ship berthing or maritime logistics, where space is at a premium and efficient scheduling directly impacts operational costs. The central question is: *What is the minimal number of berths required to accommodate all ships without violating length constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `x[i, j]`: Equals 1 if ship `i` is assigned to berth `j`, and 0 otherwise.  
     - Binary variable `y[j]`: Equals 1 if berth `j` is used (i.e., contains at least one ship), and 0 otherwise.  
   - **2. Parameters:**  
     - `ships[i]`: Length of ship `i` (given as [2, 7, 7, 7, 2, 9, 5, 7, 4, 2, 9]).  
     - `length_limit`: Maximum length per berth (9 meters).  
     - `num_ships`: Total ships (11).  
     - `num_berths`: Upper bound on berths (11, one per ship in the worst case).  
   - **3. Objective Function:**  
     - Minimize the total number of berths used: `Minimize sum(y[j] for all j)`.  
   - **4. Constraints:**  
     - **Assignment:** Each ship must be in exactly one berth: `sum(x[i, j] for all j) = 1` for every ship `i`.  
     - **Length Limit:** The total length in berth `j` cannot exceed `length_limit` if the berth is used: `sum(ships[i] * x[i, j] for all i) <= length_limit * y[j]` for every berth `j`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB

# --- Data Definition ---
ships = [2, 7, 7, 7, 2, 9, 5, 7, 4, 2, 9]      # Lengths of ships
length_limit = 9           # Berth length limit
num_ships = 11     # len(ships)
num_berths = num_ships    # Maximum number of berths (worst case: one ship per berth)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Time limit
# env.setParam('TimeLimit', 30)
env.start()

# Create Model
model = Model("Berth Scheduling Problem", env=env)

# --- Decision Variables ---
# x[i,j]: ship i is assigned to berth j
x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")

# --- Objective: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)

# --- Constraints ---
# 1. Each ship must be assigned to exactly one berth
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Berth length constraint: sum of lengths in berth j <= length_limit IF berth j is used (y[j]=1)
for j in range(num_berths):
    model.addConstr(gp.quicksum(ships[i] * x[i, j] for i in range(num_ships)) <= length_limit * y[j], name=f"Berth_{j}_Length_Limit")

# --- Solve ---
print("Solving Berth Scheduling instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print(f"\nOptimal number of berths used: {optimal_berths}")
    print("-" * 30)
    berth_details = []
    for j_sol in range(num_berths): # Loop through potential berths
        # Check if the berth variable y[j_sol] exists and is set to 1
        try:
            if y[j_sol].X > 0.5: # Check if berth j_sol is used
                # Find ships assigned to this berth j_sol
                assigned_ships_indices = [i for i in range(num_ships) if x[i, j_sol].X > 0.5]
                assigned_ships_lengths = [ships[i] for i in assigned_ships_indices]
                berth_load = sum(assigned_ships_lengths)
                print(f"Berth {j_sol + 1} (Load: {berth_load}/{length_limit}): Ships (indices): {assigned_ships_indices}")
                # Optional: Print lengths too
                # print(f"  Lengths: {assigned_ships_lengths}")
                berth_details.append({'berth_index': j_sol, 'ship_indices': assigned_ships_indices, 'load': berth_load})
        except AttributeError:
            # This might happen if y[j_sol] was optimized to 0 and doesn't have an .X value
            # Or if the model was infeasible/not solved optimally.
            # Since we check for OPTIMAL status first, this is less likely for y,
            # but could happen if x[i, j_sol] is 0. The check x[i,j_sol].X > 0.5 handles this.
            pass # Just skip if variable/attribute doesn't exist for unused berths/ships
    results_dict['berth_details'] = berth_details # Store details
    print("-" * 30)

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount to see if a feasible solution was found
     if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
     else: print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving Berth Scheduling instance...

Optimal number of berths used: 7
------------------------------
Berth 1 (Load: 9/9): Ships (indices): [2, 9]
Berth 2 (Load: 7/9): Ships (indices): [7]
Berth 3 (Load: 9/9): Ships (indices): [5]
Berth 6 (Load: 9/9): Ships (indices): [0, 3]
Berth 7 (Load: 9/9): Ships (indices): [6, 8]
Berth 8 (Load: 9/9): Ships (indices): [10]
Berth 10 (Load: 9/9): Ships (indices): [1, 4]
------------------------------


```

================================================================================



--- Problem 70 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A logistics manager is tasked with optimizing the loading and unloading times at a busy distribution center with two distinct truck bays. The goal is to minimize the total delay experienced by trucks, which is directly influenced by the allocation of service time to each bay. The distribution center must adhere to a strict cycle time of 65 minutes, meaning the sum of service times for both bays cannot exceed this limit. Each bay has a minimum service time of 27 minutes and a maximum of 65 minutes, ensuring fairness and efficiency.  

The truck flow coefficients—666 for the first bay and 2,263 for the second—reflect the relative impact of delays on each bay. Higher coefficients indicate greater sensitivity to waiting time, making their optimization critical for reducing congestion. The manager must determine the optimal service time allocation for both bays such that the total delay, calculated as the sum of flow coefficients multiplied by their respective waiting times (cycle time minus service time), is minimized.  

The core challenge is: *How should the 65-minute cycle be split between the two bays to minimize the total delay while respecting the service time bounds?*
**

**Modeling Process:**
**
1. Decision Variables:  
   - `t_i`: Continuous variable representing the service time (in minutes) allocated to bay `i` (where `i = 1, 2`).  
   - Bounds: `27 ≤ t_i ≤ 65` for each bay.  

2. Parameters:  
   - `flow_coeffs = [666, 2263]`: Truck flow coefficients for bays 1 and 2, respectively.  
   - `cycle_time = 65`: Total cycle time (minutes).  
   - `lb_time = 27`, `ub_time = 65`: Lower and upper bounds for service times.  

3. Objective Function:  
   Minimize the total delay:  
   ```  
   Minimize: (flow_coeffs[0] * (cycle_time - t_1)) + (flow_coeffs[1] * (cycle_time - t_2))  
   ```  

4. Constraints:  
   - **Total cycle time constraint:** The sum of service times must equal the cycle time:  
     ```  
     t_1 + t_2 = 65  
     ```  
   - **Variable bounds:**  
     ```  
     27 ≤ t_1 ≤ 65  
     27 ≤ t_2 ≤ 65  
     ```  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_bays = 2
lb_time = 27          # Lower bound for service time
ub_time = 65          # Upper bound for service time
cycle_time = 65       # Total cycle time (set equal to ub_time)
flow_coeffs = [666, 2263] # Truck flow coefficients per bay
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_bays:
    print("Error: flow_coeffs length mismatch with num_bays")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_bays}-Bay Service Time Allocation", env=env)

        # --- Decision variables (dynamic based on num_bays) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_bays, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for bay i is proportional to flow * waiting_time = flow * (cycle_time - service_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_bays)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of service times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_bays)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_bays)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal service times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_bays):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total delay: 86409.00
------------------------------
Optimal service times (minutes):
  t1: 27.00, t2: 38.00


```

================================================================================



--- Problem 71 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A port manager is tasked with maximizing revenue from two distinct ship types: short-term and long-term vessels. The port has 167 berths available over a 9.3-hour operating window, offering a total capacity of 1,553.1 berth-hours. Short-term vessels dock for an average of 1.8 hours, paying $6.20 per hour, yielding $11.16 in revenue per vessel. Demand for short-term berthing is capped at 89 vessels. Long-term vessels, on the other hand, dock for a fixed duration of 7.9 hours at a flat rate of $20.94 per stay, with a maximum demand of 45 vessels. The challenge lies in allocating the limited berth-hours between these two segments to maximize total revenue while respecting both demand limits and the port’s capacity constraints. The manager must determine the optimal mix of short-term and long-term vessels to accept, balancing higher per-hour revenue from short-term vessels against the longer occupancy of long-term vessels.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x_s`: Number of short-term vessels accepted (continuous, ≥ 0).  
     - `x_l`: Number of long-term vessels accepted (continuous, ≥ 0).  

   - **2. Parameters:**  
     - `short_stay_hr = 1.8`: Hours per short-term vessel.  
     - `short_revenue = 11.16`: Revenue per short-term vessel.  
     - `short_max_demand = 89`: Maximum demand for short-term berthing.  
     - `long_stay_hr = 7.9`: Hours per long-term vessel.  
     - `long_revenue = 20.94`: Revenue per long-term vessel.  
     - `long_max_demand = 45`: Maximum demand for long-term berthing.  
     - `total_berth_hours = 1553.1`: Total available berth-hours.  

   - **3. Objective Function:**  
     Maximize total revenue:  
     \[
     \text{Maximize: } 11.16 \cdot x_s + 20.94 \cdot x_l
     \]  

   - **4. Constraints:**  
     - Berth-hour capacity:  
       \[
       1.8 x_s + 7.9 x_l \leq 1553.1
       \]  
     - Short-term demand limit:  
       \[
       x_s \leq 89
       \]  
     - Long-term demand limit:  
       \[
       x_l \leq 45
       \]  
     - Non-negativity:  
       \[
       x_s, x_l \geq 0
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_berths = 167
time_horizon_hr = 9.3
total_berth_hours = 1553.1

# Short-term vessels
short_stay_hr = 1.8
short_rate_per_hr = 6.20
short_revenue = 11.16 # Calculated: rate * stay
short_max_demand = 89

# Long-term vessels
long_stay_hr = 7.9
long_revenue = 20.94 # Flat rate
long_max_demand = 45
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m32 = gp.Model("PORT_BERTH_ALLOC_LP", env=env)

    # --- Decision Variables ---
    # Number of short-term and long-term vessels accepted (LP allows fractional)
    x_s = m32.addVar(name="num_short_term", lb=0)
    x_l = m32.addVar(name="num_long_term", lb=0)

    # --- Objective Function ---
    # Maximize total revenue
    m32.setObjective(short_revenue * x_s + long_revenue * x_l, sense=GRB.MAXIMIZE)

    # --- Constraints ---
    # Constraint 1: Berth-hour capacity
    m32.addConstr(short_stay_hr * x_s + long_stay_hr * x_l <= total_berth_hours, name="berth_hour_capacity")

    # Constraint 2: Short-term demand limit
    m32.addConstr(x_s <= short_max_demand, name="short_demand")

    # Constraint 3: Long-term demand limit
    m32.addConstr(x_l <= long_max_demand, name="long_demand")

    # --- Optimization ---
    m32.optimize()

    # --- Store results ---
    results_dict['status'] = m32.status
    if m32.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m32.ObjVal
        results_dict['x_s_sol'] = x_s.X
        results_dict['x_l_sol'] = x_l.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- PORT_BERTH_ALLOC: Berth Allocation for Differing Durations (LP) ---")
    if m32.status == GRB.OPTIMAL:
        opt_s = results_dict.get('x_s_sol', 0)
        opt_l = results_dict.get('x_l_sol', 0)
        obj_val_print = results_dict.get('obj_val', 0)
        berth_hours_used = opt_s * short_stay_hr + opt_l * long_stay_hr

        print(f"Optimization Status: Optimal")
        print(f"Maximum Total Revenue: ${obj_val_print:.2f}")
        # LP solutions can be fractional, print with decimals
        print(f"Optimal Short-term Vessels Accepted: {opt_s:.2f} (Max Demand: {short_max_demand})")
        print(f"Optimal Long-term Vessels Accepted: {opt_l:.2f} (Max Demand: {long_max_demand})")
        print(f"Total Berth-Hours Used: {berth_hours_used:.1f} / {total_berth_hours:.1f}")
        # Calculate breakdown based on potentially fractional optimal values
        revenue_s = opt_s * short_revenue
        revenue_l = opt_l * long_revenue
        print(f"Revenue Breakdown: Short=${revenue_s:.2f}, Long=${revenue_l:.2f}")

    elif m32.status == GRB.INFEASIBLE:
         # Should be rare for this LP structure unless inputs are nonsensical (e.g., negative)
         print(f"Optimization Status: Infeasible.")
         print(f"Check input parameters for validity (e.g., non-negative demands/times/berths).")
    elif m32.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m32.ObjVal is not None and abs(m32.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m32.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m32.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- PORT_BERTH_ALLOC: Berth Allocation for Differing Durations (LP) ---
Optimization Status: Optimal
Maximum Total Revenue: $1935.54
Optimal Short-term Vessels Accepted: 89.00 (Max Demand: 89)
Optimal Long-term Vessels Accepted: 45.00 (Max Demand: 45)
Total Berth-Hours Used: 515.7 / 1553.1
Revenue Breakdown: Short=$993.24, Long=$942.30


```

================================================================================



--- Problem 72 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
At a busy port, the operations team is tasked with coordinating the berthing times for two types of vessels: container ships and bulk carriers. The port operates on a fixed cycle time of 67 minutes, during which each vessel type must account for not only the berthing time but also the necessary transition periods—5 minutes of preparation time and 1 minute of clearance time per vessel type, totaling 6 minutes of "lost time" for each type. The minimum berthing time for any vessel type is 12 minutes to ensure safe docking and undocking.

The container ship approach handles a saturation flow of 2,161 vessels per day, with an actual arrival flow of 263 vessels, while the bulk carrier approach has a saturation flow of 1,788 vessels and an arrival flow of 676. The operations team aims to allocate berthing times in a way that maximizes the *weighted utilization* of the port, where the weights reflect the ratio of arrival flow to saturation flow for each vessel type. This prioritizes vessel types with higher demand relative to their capacity. The core question is: *How should berthing times be distributed between the container ships and bulk carriers to maximize the port's efficiency while adhering to the fixed cycle time and minimum berthing constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `b_cont`: Berthing time (minutes) allocated to the container ship phase.  
     - `b_bulk`: Berthing time (minutes) allocated to the bulk carrier phase.  
     Both variables are continuous and must be at least `min_berth = 12` minutes.  

   - **2. Parameters:**  
     - `cycle_time = 67`: Total duration (minutes) of the berthing cycle.  
     - `lost_time_per_phase = 6`: Sum of preparation and clearance times (minutes) per phase.  
     - `sat_flow_cont = 2161`, `arr_flow_cont = 263`: Saturation and arrival flows (vessels/day) for container ships.  
     - `sat_flow_bulk = 1788`, `arr_flow_bulk = 676`: Saturation and arrival flows (vessels/day) for bulk carriers.  
     - Weights: `weight_cont = arr_flow_cont / sat_flow_cont`, `weight_bulk = arr_flow_bulk / sat_flow_bulk`.  

   - **3. Objective Function:**  
     Maximize the weighted sum of berthing times:  
     `Maximize: weight_cont * b_cont + weight_bulk * b_bulk`.  

   - **4. Constraints:**  
     - Cycle time constraint:  
       `b_cont + lost_time_per_phase + b_bulk + lost_time_per_phase = cycle_time`.  
     - Minimum berthing time:  
       `b_cont >= min_berth`, `b_bulk >= min_berth`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cycle_time = 67
prep_time = 5
clearance_time = 1
min_berth = 12
sat_flow_cont = 2161
arr_flow_cont = 263
sat_flow_bulk = 1788
arr_flow_bulk = 676
lost_time_per_phase = 6 # prep + clearance
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTHING_TIMING", env=env)

    # --- Decision Variables ---
    # b_cont: berthing time for container ships (minutes)
    b_cont = m.addVar(lb=min_berth, vtype=GRB.CONTINUOUS, name="b_cont")
    # b_bulk: berthing time for bulk carriers (minutes)
    b_bulk = m.addVar(lb=min_berth, vtype=GRB.CONTINUOUS, name="b_bulk")

    # --- Objective Function: Maximize weighted berthing times ---
    # Weight by flow/saturation ratio (degree of saturation)
    # Avoid division by zero
    weight_cont = arr_flow_cont / sat_flow_cont if sat_flow_cont > 1e-6 else 0
    weight_bulk = arr_flow_bulk / sat_flow_bulk if sat_flow_bulk > 1e-6 else 0
    m.setObjective(weight_cont * b_cont + weight_bulk * b_bulk, GRB.MAXIMIZE)

    # --- Constraints ---
    # Cycle time constraint: sum of phase times must equal cycle time
    # Phase time = berthing + lost_time_per_phase
    m.addConstr(b_cont + lost_time_per_phase + b_bulk + lost_time_per_phase == cycle_time, "CycleTimeConstraint")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['b_cont_sol'] = b_cont.X # Not needed for output
        # results_dict['b_bulk_sol'] = b_bulk.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Format objective value (weighted berthing time sum)
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show more decimals for weighted sum
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the decision variables
if m.Status == GRB.OPTIMAL:
    b_cont_sol = b_cont.X
    b_bulk_sol = b_bulk.X
    print(f"Optimal berthing time for container ships: {b_cont_sol:.4f} minutes")
    print(f"Optimal berthing time for bulk carriers: {b_bulk_sol:.4f} minutes")
```
Answer:
Optimal objective value: 17.7177
Optimal berthing time for container ships: 12.0000 minutes
Optimal berthing time for bulk carriers: 43.0000 minutes


```

================================================================================



--- Problem 73 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
In a busy maritime port, five distinct berths—Berth_A to Berth_E—are dealing with the challenge of balancing the number of available cranes and the demand for crane operations. Each berth starts with a fixed number of available cranes (Berth_A: 109, Berth_B: 89, Berth_C: 91, Berth_D: 195, Berth_E: 94), but the demand for cranes varies significantly across locations (Berth_A: 116, Berth_B: 73, Berth_C: 65, Berth_D: 146, Berth_E: 102). The operational challenge lies in redistributing cranes to meet demand while minimizing relocation costs. Moving cranes between berths isn't free: transferring a crane from Berth_A to Berth_B costs $10, while Berth_D to Berth_E is a bargain at $4, with 20 such inter-berth cost combinations defined. The core dilemma? How to strategically reassign cranes—allowing some to stay put and others to move—so every berth meets or exceeds its demand at the lowest possible total relocation expense. The stakes are high: under-equipped berths risk lost revenue, while excessive moves inflate operational costs.
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `stay[b]`: Continuous, non-negative variable representing cranes remaining in berth *b*.  
- `move[i, j]`: Continuous, non-negative variable representing cranes moving from berth *i* to berth *j* (for all defined pairs in `move_costs`).  

**2. Parameters:**  
- `supply[b]`: Initial crane count in berth *b* (e.g., `Berth_A`: 109).  
- `demand[b]`: Required cranes in berth *b* (e.g., `Berth_E`: 102).  
- `move_costs[(i, j)]`: Cost per crane moved from *i* to *j* (e.g., `('Berth_C', 'Berth_A')`: $7).  

**3. Objective Function:**  
Minimize total relocation cost:  
`Minimize: sum(move[i, j] * move_costs[i, j] for all (i, j) in move_costs)`.  

**4. Constraints:**  
- **Supply conservation (per berth *b*):**  
  `stay[b] + sum(move[b, j] for all j ≠ b) = supply[b]`.  
- **Demand satisfaction (per berth *b*):**  
  `stay[b] + sum(move[i, b] for all i ≠ b) ≥ demand[b]`.  
- **Non-negativity:** All variables ≥ 0.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
berths = ['Berth_A', 'Berth_B', 'Berth_C', 'Berth_D', 'Berth_E']
supply = {'Berth_A': 109, 'Berth_B': 89, 'Berth_C': 91, 'Berth_D': 195, 'Berth_E': 94}
demand = {'Berth_A': 116, 'Berth_B': 73, 'Berth_C': 65, 'Berth_D': 146, 'Berth_E': 102}
move_costs = {('Berth_A', 'Berth_B'): 10, ('Berth_A', 'Berth_C'): 12, ('Berth_A', 'Berth_D'): 5, ('Berth_A', 'Berth_E'): 11, ('Berth_B', 'Berth_A'): 9, ('Berth_B', 'Berth_C'): 4, ('Berth_B', 'Berth_D'): 15, ('Berth_B', 'Berth_E'): 13, ('Berth_C', 'Berth_A'): 7, ('Berth_C', 'Berth_B'): 6, ('Berth_C', 'Berth_D'): 12, ('Berth_C', 'Berth_E'): 14, ('Berth_D', 'Berth_A'): 10, ('Berth_D', 'Berth_B'): 14, ('Berth_D', 'Berth_C'): 3, ('Berth_D', 'Berth_E'): 4, ('Berth_E', 'Berth_A'): 14, ('Berth_E', 'Berth_B'): 10, ('Berth_E', 'Berth_C'): 3, ('Berth_E', 'Berth_D'): 4} # Dict (from, to): cost
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m29 = gp.Model("CRANE_ALLOCATION_LP", env=env)

    # --- Decision Variables ---
    # Number of cranes moving between berths (use actual keys from move_costs)
    move_keys = list(move_costs.keys())
    move = m29.addVars(move_keys, name="move", lb=0)
    # Number of cranes staying in their berths
    stay = m29.addVars(berths, name="stay", lb=0)

    # --- Objective Function ---
    # Minimize total cost of moving cranes
    m29.setObjective(gp.quicksum(move[i, j] * move_costs[i, j] for i, j in move_keys), sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Crane source constraints (Cranes in berth must either stay or move out)
    for b in berths:
        # Sum outgoing moves using .get() for safety, although all keys should exist
        outgoing_moves = gp.quicksum(move.get((b, other_b), 0) for other_b in berths if b != other_b and (b, other_b) in move)
        m29.addConstr(stay[b] + outgoing_moves == supply[b], name=f"supply_{b}")

    # Demand satisfaction constraints (Cranes available in berth = stayed + moved in)
    for b in berths:
        # Sum incoming moves using .get()
        incoming_moves = gp.quicksum(move.get((other_b, b), 0) for other_b in berths if b != other_b and (other_b, b) in move)
        m29.addConstr(stay[b] + incoming_moves >= demand[b], name=f"demand_{b}")

    # --- Optimization ---
    m29.optimize()

    # --- Store results ---
    results_dict['status'] = m29.status
    if m29.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m29.ObjVal
        results_dict['stay_sol'] = m29.getAttr('X', stay)
        results_dict['move_sol'] = m29.getAttr('X', move)


    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- CRANE_ALLOCATION: Port Crane Allocation (LP) ---")
    if m29.status == GRB.OPTIMAL:
        stay_sol = results_dict.get('stay_sol', {})
        move_sol = results_dict.get('move_sol', {})
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Minimum Crane Moving Cost: ${obj_val_print:.2f}")
        print("Cranes Allocation:")
        for b in berths:
             print(f"  Stay in {b}: {stay_sol.get(b, 0):.1f}")

        total_moved = 0
        for (i, j), cost in move_costs.items():
            moved_val = move_sol.get((i,j), 0)
            if moved_val > 1e-4: # Print only if non-negligible move
                 print(f"  Move {i} -> {j}: {moved_val:.1f} (Cost/crane: ${cost})")
                 total_moved += moved_val
        print(f"  Total Cranes Moved: {total_moved:.1f}")


        print("\nBerth Fulfillment:")
        total_supply_check = sum(supply.values())
        total_demand_check = sum(demand.values())
        total_final_cranes = 0
        for b in berths:
            stayed = stay_sol.get(b, 0)
            moved_in = sum(move_sol.get((other_b, b), 0) for other_b in berths if b != other_b)
            final_cranes = stayed + moved_in
            total_final_cranes += final_cranes
            print(f"  Berth {b}: Has {final_cranes:.1f} cranes (Need: {demand.get(b, 'N/A')}, Supply: {supply.get(b, 'N/A')})")
        print(f"Total Cranes Accounted For: {total_final_cranes:.1f} (Initial Total Supply: {total_supply_check})")


    elif m29.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible.")
         # Calculate totals directly from input params for this message
         print(f"Total Supply Available: {sum(supply.values())}")
         print(f"Total Demand Required: {sum(demand.values())}")
         print("(Check if total supply >= total demand and if movement allows meeting local demand)")
    elif m29.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m29.ObjVal is not None and abs(m29.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m29.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m29.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- CRANE_ALLOCATION: Port Crane Allocation (LP) ---
Optimization Status: Optimal
Minimum Crane Moving Cost: $81.00
Cranes Allocation:
  Stay in Berth_A: 109.0
  Stay in Berth_B: 89.0
  Stay in Berth_C: 84.0
  Stay in Berth_D: 187.0
  Stay in Berth_E: 94.0
  Move Berth_C -> Berth_A: 7.0 (Cost/crane: $7)
  Move Berth_D -> Berth_E: 8.0 (Cost/crane: $4)
  Total Cranes Moved: 15.0

Berth Fulfillment:
  Berth Berth_A: Has 116.0 cranes (Need: 116, Supply: 109)
  Berth Berth_B: Has 89.0 cranes (Need: 73, Supply: 89)
  Berth Berth_C: Has 84.0 cranes (Need: 65, Supply: 91)
  Berth Berth_D: Has 187.0 cranes (Need: 146, Supply: 195)
  Berth Berth_E: Has 102.0 cranes (Need: 102, Supply: 94)
Total Cranes Accounted For: 578.0 (Initial Total Supply: 578)


```

================================================================================



--- Problem 74 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
In a busy port, a critical logistics challenge arises at the main container terminal where ships arrive and depart. During peak hours, 1,254 containers per hour need to be moved from berth A to berth B. The available paths include a direct link from A to B (segment AB) and an alternative route via berth C (segments AC and CB). However, each berth has strict capacity limits: AB can handle 926 containers/hour, AC accommodates 544 containers/hour, and CB supports up to 960 containers/hour.  

   The primary goal is to distribute the container flow efficiently to avoid congestion, particularly on the direct AB route, which is prone to bottlenecks. The optimization task focuses on minimizing any overflow—excess containers beyond AB's capacity—by rerouting traffic through the AC-CB pathway where possible. The core question is: *How should the container flow be allocated between these routes to ensure the smallest possible overflow on AB while respecting all capacity constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `f_AB`: Flow of containers from A to B (continuous, ≥0).  
   - `f_AC`: Flow of containers from A to C (continuous, ≥0).  
   - `f_CB`: Flow of containers from C to B (continuous, ≥0).  
   - `overflow_AB`: Excess containers beyond AB's capacity (continuous, ≥0).  

   **2. Parameters:**  
   - `total_flow_originating_A = 1254` (containers/hr): Total container flow from A.  
   - `capacity = {'AB': 926, 'AC': 544, 'CB': 960}` (containers/hr): Maximum flow per segment.  

   **3. Objective Function:**  
   Minimize the overflow on AB:  
   \[
   \text{Minimize: } \text{overflow\_AB}
   \]  

   **4. Constraints:**  
   - **Flow conservation at A:** The sum of flows leaving A must equal the total originating flow:  
     \[
     f\_AB + f\_AC = 1254
     \]  
   - **Flow conservation at C:** All containers entering C must exit to B:  
     \[
     f\_AC = f\_CB
     \]  
   - **AB overflow definition:** The overflow captures any excess beyond AB's capacity:  
     \[
     f\_AB \leq 926 + \text{overflow\_AB}
     \]  
   - **AC and CB capacity limits:**  
     \[
     f\_AC \leq 544, \quad f\_CB \leq 960
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_flow_originating_A = 1254 # containers/hr
capacity = {'AB': 926, 'AC': 544, 'CB': 960} # Dict segment: capacity (containers/hr)
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m33 = gp.Model("CONTAINER_REROUTING_LP", env=env)

    # --- Decision Variables ---
    # Flows on each segment
    f_AB = m33.addVar(name="flow_A_B", lb=0)
    f_AC = m33.addVar(name="flow_A_C", lb=0)
    f_CB = m33.addVar(name="flow_C_B", lb=0)
    # Overflow variable for the congested link AB
    overflow_AB = m33.addVar(name="overflow_A_B", lb=0)

    # --- Objective Function ---
    # Minimize the overflow on segment A->B
    m33.setObjective(overflow_AB, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Total flow conservation leaving node A
    m33.addConstr(f_AB + f_AC == total_flow_originating_A, name="flow_out_A")

    # Constraint 2: Flow conservation at node C
    m33.addConstr(f_AC == f_CB, name="flow_at_C")

    # Constraint 3: Calculate overflow for A->B link
    # overflow = max(0, f_AB - capacity_AB)
    cap_ab = capacity.get('AB', 0) # Get capacity safely
    m33.addConstr(f_AB <= cap_ab + overflow_AB, name="overflow_calc")

    # Constraint 4: Capacity constraint for A->C link
    cap_ac = capacity.get('AC', 0)
    m33.addConstr(f_AC <= cap_ac, name="capacity_AC")

    # Constraint 5: Capacity constraint for C->B link
    cap_cb = capacity.get('CB', 0)
    m33.addConstr(f_CB <= cap_cb, name="capacity_CB")

    # --- Optimization ---
    m33.optimize()

    # --- Store results ---
    results_dict['status'] = m33.status
    if m33.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m33.ObjVal # = overflow_AB.X
        results_dict['f_AB_sol'] = f_AB.X
        results_dict['f_AC_sol'] = f_AC.X
        results_dict['f_CB_sol'] = f_CB.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 33: Container Flow Rerouting (LP) ---") # Original problem number
    if m33.status == GRB.OPTIMAL:
        overflow_sol = results_dict.get('obj_val', 'N/A')
        f_ab_sol = results_dict.get('f_AB_sol', 'N/A')
        f_ac_sol = results_dict.get('f_AC_sol', 'N/A')
        f_cb_sol = results_dict.get('f_CB_sol', 'N/A')
        cap_ab_print = capacity.get('AB', 'N/A')
        cap_ac_print = capacity.get('AC', 'N/A')
        cap_cb_print = capacity.get('CB', 'N/A')

        print(f"Optimization Status: Optimal")
        # Format numerical output
        print(f"Minimum Overflow on A->B: {float(overflow_sol):.1f} containers/hr")
        print("Optimal Flow Distribution:")
        print(f"  Flow A -> B: {float(f_ab_sol):.1f} (Capacity: {cap_ab_print})")
        print(f"  Flow A -> C: {float(f_ac_sol):.1f} (Capacity: {cap_ac_print})")
        print(f"  Flow C -> B: {float(f_cb_sol):.1f} (Capacity: {cap_cb_print})")
        # Check total flow matches original
        total_flow_out = float(f_ab_sol) + float(f_ac_sol) if isinstance(f_ab_sol, (int, float)) and isinstance(f_ac_sol, (int, float)) else 'N/A'
        print(f"Total Flow from A: {total_flow_out:.1f} (Initial: {total_flow_originating_A})")

    elif m33.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible. Check capacities vs total flow.")
         print(f"Total Flow: {total_flow_originating_A}, Capacity AC+CB path: {capacity.get('AC', 0) + capacity.get('CB', 0)}?") # Simple check example
    else:
        print(f"Optimization Status: {m33.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 33: Container Flow Rerouting (LP) ---
Optimization Status: Optimal
Minimum Overflow on A->B: 0.0 containers/hr
Optimal Flow Distribution:
  Flow A -> B: 710.0 (Capacity: 926)
  Flow A -> C: 544.0 (Capacity: 544)
  Flow C -> B: 544.0 (Capacity: 960)
Total Flow from A: 1254.0 (Initial: 1254)


```

================================================================================



--- Problem 75 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port with four berths is experiencing congestion due to maintenance activities, each lasting between approximately 0.9 to 1.75 hours. To mitigate delays, port managers can dynamically divert ships to alternative berths during six consecutive 30-minute time periods. Each berth has distinct capacities: normal mainline flow (e.g., 3,321–5,410 ships/hour), reduced capacity during maintenance (1,575–1,957 ships/hour), and alternative berth limits (934–1,684 ships/hour). Arrival rates vary by berth and period, peaking at 4,907 ships/hour in some intervals. Diversion options include rerouting 10%, 30%, 50%, or 70% of traffic, but excessive rerouting risks overwhelming alternative berths or causing queueing delays on the main berths. The challenge is to determine, for each berth and time window, the optimal diversion percentage that minimizes total system delay—balancing rerouting penalties (extra travel time) against queue buildup on the main berths.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Binary variables `y(i,t,k)` indicate whether diversion option `k` (e.g., 10%, 30%) is selected for berth `i` in time period `t`.  
   - **2. Parameters:**  
     - `capacities_main_normal[i]`, `capacities_main_reduced[i]`: Main berth capacities under normal/maintenance conditions.  
     - `capacities_alt[i]`: Alternative berth capacity.  
     - `arrival_rates[i][t]`: Ships arriving at berth `i` in period `t`.  
     - `alt_berth_extra_times[i]`: Additional travel time (hours) for alternative berths.  
     - `diversion_options[k]`: Available rerouting percentages (0.1, 0.3, 0.5, 0.7).  
     - `TIME_PERIOD_LENGTH = 0.5`: Duration of each period (hours).  
   - **3. Objective Function:**  
     Minimize total delay: Sum of `y(i,t,k) * (delay_alt_k + delay_queue_main_k)` for all feasible `(i,t,k)`, where:  
     - `delay_alt_k = rerouted_flow * extra_time`.  
     - `delay_queue_main_k` accounts for queue dissipation if main berth flow exceeds reduced capacity.  
   - **4. Constraints:**  
     - **Feasibility:** For each `(i,t)`, exactly one feasible diversion option must be selected (sum of `y(i,t,k)` = 1).  
     - **Infeasibility:** If rerouting `k` exceeds alternative berth capacity, enforce `y(i,t,k) = 0`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 4
NUM_TIME_PERIODS = 6
TIME_PERIOD_LENGTH = 0.5  # h
capacities_main_normal = [3321, 4111, 5410, 3724]  # ships/h
capacities_main_reduced = [1575, 1957, 1928, 1601]  # ships/h
capacities_alt = [1617, 1684, 1442, 934]  # ships/h
arrival_rates = [[2396, 3585, 2499, 4016, 4487, 3923], [3105, 4231, 4556, 2526, 3626, 2225], [4907, 3940, 4830, 2744, 2449, 2426], [4775, 3435, 3630, 2770, 3840, 4741]]  # ships/h
maintenance_durations = [0.9007908143350833, 1.2248147853036815, 1.7463902880977413, 1.0133048703034615]  # h
alt_berth_extra_times = [0.224289717468318, 0.2044718917637679, 0.3013149376510012, 0.20938982692893493]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:

Berth 1:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)

Berth 2:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 0 (10%)

Berth 3:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)

Berth 4:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)



================================================================================



--- Problem 76 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
In a busy port, the harbor master is tasked with optimizing the allocation of berthing times for two types of ships: container ships and bulk carriers. The port handles two primary traffic flows: container ships with an arrival rate of 763.70 ships per day and bulk carriers with 539.17 ships per day. Each berth has a saturation handling rate of 1498.31 ships per day per berth, and the port operates with approximately 1.91 berths. Lost time per berthing phase—due to docking and undocking—is fixed at 4.06 hours. The berthing cycle must stay within a tight window: no shorter than 72.34 hours and no longer than 102.26 hours, with each berthing phase lasting at least 18.08 hours to ensure safe operations.

The core question is: *How should the berthing times for container ships and bulk carriers be allocated within these limits to maximize the port’s total capacity (ships per day) without violating safety or operational rules?*
**

**Modeling Process:**
**
- **Decision Variables:**  
     - `C`: Cycle length (hours), bounded between `C_min` and `C_max`.  
     - `g_CS`, `g_BC`: Berthing times (hours) for container ships and bulk carriers, each ≥ `g_min_time`.  
     - Intermediate variables `lambda_g_CS`, `lambda_g_BC` (berthing time ratios) and `Cap_CS`, `Cap_BC` (directional capacities).  

   - **Parameters:**  
     - Arrival rates: `lambda_CS_d = 763.70`, `lambda_BC_d = 539.17` (ships/day).  
     - Saturation flow: `S_berth_lane_d = 1498.31` (ships/day/berth), berth count `N_berths = 1.91`.  
     - Lost time: `L_lost_time_per_phase = 4.06` (h).  
     - Bounds: `C_min = 72.34`, `C_max = 102.26`, `g_min_time = 18.08` (h).  

   - **Objective Function:**  
     Maximize total throughput: `Cap_CS + Cap_BC`, where:  
     - `Cap_CS = N_berths * S_berth_lane_d * lambda_g_CS`  
     - `Cap_BC = N_berths * S_berth_lane_d * lambda_g_BC`.  

   - **Constraints:**  
     1. Cycle composition: `C = g_CS + g_BC + 2 * L_lost_time_per_phase`.  
     2. Berthing time ratios: `lambda_g_CS * C = g_CS`, `lambda_g_BC * C = g_BC`.  
     3. Capacity definitions (as above).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
lambda_CS_d = 763.695962757951  # ships/day
lambda_BC_d = 539.1715575881404  # ships/day
S_berth_lane_d = 1498.312847078996  # ships/day/berth
N_berths = 1.9135397641772738
L_lost_time_per_phase = 4.063824673925673  # h
C_min = 72.34207647178651  # h
C_max = 102.25578528898244  # h
g_min_time = 18.082627942592985  # h

# --- Gurobi Model ---
model = gp.Model("PortBerthingTiming")

# Decision Variables
C = model.addVar(name="CycleLength", lb=C_min, ub=C_max)
g_CS = model.addVar(name="Berthing_CS", lb=g_min_time)
g_BC = model.addVar(name="Berthing_BC", lb=g_min_time)

# Intermediate Variables
lambda_g_CS = model.addVar(name="lambda_g_CS", lb=0.0, ub=1.0)
lambda_g_BC = model.addVar(name="lambda_g_BC", lb=0.0, ub=1.0)
Cap_CS = model.addVar(name="Capacity_CS", lb=0.0)
Cap_BC = model.addVar(name="Capacity_BC", lb=0.0)

# Constraints
model.addConstr(C == g_CS + g_BC + 2 * L_lost_time_per_phase, name="CycleComposition")
model.addQConstr(lambda_g_CS * C == g_CS, name="CalcLambdaCS")
model.addQConstr(lambda_g_BC * C == g_BC, name="CalcLambdaBC")
model.addConstr(Cap_CS == N_berths * S_berth_lane_d * lambda_g_CS, name="CalcCapacityCS")
model.addConstr(Cap_BC == N_berths * S_berth_lane_d * lambda_g_BC, name="CalcCapacityBC")

# Objective
model.setObjective(Cap_CS + Cap_BC, GRB.MAXIMIZE)

# Optimize
model.Params.NonConvex = 2
model.optimize()

# Output
if model.status == GRB.OPTIMAL:
    print("\n--- Port Berthing Timing Results ---")
    print(f"Optimal Cycle Length: {C.X:.2f} h")
    print(f"Container Ships Berthing Time: {g_CS.X:.2f} h")
    print(f"Bulk Carriers Berthing Time: {g_BC.X:.2f} h")
    print(f"Container Ships Capacity: {Cap_CS.X:.2f} ships/day")
    print(f"Bulk Carriers Capacity: {Cap_BC.X:.2f} ships/day")
    print(f"Total Throughput: {model.objVal:.2f} ships/day")
else:
    print(f"Model status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 3 rows, 7 columns and 7 nonzeros
Model fingerprint: 0x88513529
Model has 2 quadratic constraints
Coefficient statistics:
  Matrix range     [1e+00, 3e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [1e+00, 1e+02]
  RHS range        [8e+00, 8e+00]
Presolve removed 2 rows and 2 columns

Continuous model is non-convex -- solving as a MIP

Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolved: 9 rows, 6 columns, 27 nonzeros
Presolved model has 2 bilinear constraint(s)
Variable types: 6 continuous, 0 integer (0 binary)
Found heuristic solution: objective 2639.1955166

Root relaxation: objective 2.990379e+03, 3 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0 2990.37888    0    2 2639.19552 2990.37888  13.3%     -    0s
     0     0 2873.57815    0    2 2639.19552 2873.57815  8.88%     -    0s
     0     2 2873.57815    0    2 2639.19552 2873.57815  8.88%     -    0s

Explored 65 nodes (39 simplex iterations) in 0.05 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 2639.2 

Optimal solution found (tolerance 1.00e-04)
Best objective 2.639195516621e+03, best bound 2.639195516621e+03, gap 0.0000%

--- Port Berthing Timing Results ---
Optimal Cycle Length: 102.26 h
Container Ships Berthing Time: 47.06 h
Bulk Carriers Berthing Time: 47.06 h
Container Ships Capacity: 1319.60 ships/day
Bulk Carriers Capacity: 1319.60 ships/day
Total Throughput: 2639.20 ships/day



================================================================================



--- Problem 77 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy trucking terminal, four delivery trucks—numbered 1 through 4—arrive at varying times, each requiring a single depot for unloading and servicing. The terminal has only one depot available, creating a tight scheduling challenge. Truck 1 arrives at 4 hours, followed by Truck 2 at 7 hours, Truck 3 at 11 hours, and Truck 4 at 13 hours. Each truck has a specific processing time: 6 hours for Truck 1, 7 hours for Trucks 2 and 3, and 6 hours for Truck 4. Delays are costly—waiting costs per hour are \$93 for Truck 1, \$129 for Truck 2, \$103 for Truck 3, and \$121 for Truck 4. Additionally, servicing each truck incurs an hourly cost: \$44 for Truck 1, \$59 for Truck 2, and \$42 for Trucks 3 and 4.

The terminal manager faces a dual challenge: minimizing the total operational time (makespan) and reducing the combined costs of waiting and servicing. These objectives are weighted, with 45% priority given to makespan and 55% to total cost. The core question is: *What is the optimal schedule for assigning trucks to the depot to balance these competing priorities while respecting arrival times and processing requirements?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary variable (1 if truck *i* is assigned to depot *j*, 0 otherwise).  
   - `start_time[i]`: Continuous variable representing when truck *i* begins processing.  
   - `completion_time[i]`: Continuous variable representing when truck *i* finishes processing.  
   - `precedes[i, k, j]`: Binary variable (1 if truck *i* is processed before truck *k* on depot *j*, 0 otherwise).  
   - `makespan`: Continuous variable representing the latest completion time across all trucks.  

   **2. Parameters:**  
   - `arrival_times[i]`: Arrival time of truck *i* (e.g., 4 for Truck 1).  
   - `processing_times[i]`: Processing duration of truck *i* (e.g., 6 for Truck 1).  
   - `waiting_costs[i]`: Cost per hour of delay for truck *i* (e.g., \$93 for Truck 1).  
   - `service_costs[i, j]`: Hourly servicing cost for truck *i* at depot *j* (e.g., \$44 for Truck 1 at Depot 1).  
   - `alpha = 0.45`, `beta = 0.55`: Weights for makespan and total cost in the objective.  

   **3. Objective Function:**  
   Minimize:  
   ```
   0.45 * makespan + 0.55 * (sum(waiting_costs[i] * (start_time[i] - arrival_times[i]) for all trucks i) 
   + sum(service_costs[i, j] * processing_times[i] * assign[i, j] for all trucks i and depots j)
   ```  

   **4. Constraints:**  
   - Each truck is assigned to exactly one depot: `sum(assign[i, j] for all j) = 1` for all trucks *i*.  
   - Start time cannot precede arrival: `start_time[i] >= arrival_times[i]` for all trucks *i*.  
   - Completion time definition: `completion_time[i] = start_time[i] + processing_times[i]` for all trucks *i*.  
   - Non-overlapping assignments: For each pair of trucks (*i*, *k*) and depot *j*, enforce `start_time[k] >= completion_time[i]` if *i* precedes *k*, and vice versa.  
   - Makespan definition: `makespan >= completion_time[i]` for all trucks *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4]
depots = [1]
arrival_times = {1: 4, 2: 7, 3: 11, 4: 13}
processing_times = {1: 6, 2: 7, 3: 7, 4: 6}
waiting_costs = {1: 93, 2: 129, 3: 103, 4: 121} # Cost per hour waiting
service_costs = {(1, 1): 44, (2, 1): 59, (3, 1): 42, (4, 1): 42} # Cost rate per hour servicing {(truck, depot): cost}
alpha = 0.45 # Weight for Makespan
beta = 0.55  # Weight for Total Cost
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_16_WEIGHTED_OBJ")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    waiting_cost_expr = gp.quicksum(waiting_costs.get(i, 0) * (start_time[i] - arrival_times.get(i, 0)) for i in trucks)
    service_cost_expr = gp.quicksum(service_costs.get((i,j), 0) * processing_times.get(i, 0) * assign[i,j]
                                   for i in trucks for j in depots)
    total_cost = waiting_cost_expr + service_cost_expr
    m.setObjective(alpha * makespan + beta * total_cost, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Weighted objective
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal Objective Value: {m.objVal:.4f}")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time for Truck {i}: {start_time[i].x:.4f}")
                print(f"Completion Time for Truck {i}: {completion_time[i].x:.4f}")
    print(f"Makespan: {makespan.x:.4f}")
    print(f"Total Waiting Cost: {waiting_cost_expr.getValue():.4f}")
    print(f"Total Service Cost: {service_cost_expr.getValue():.4f}")
    print(f"Total Cost: {total_cost.getValue():.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
1845.0000
Optimal Objective Value: 1845.0000
Truck 1 is assigned to Depot 1
Start Time for Truck 1: 4.0000
Completion Time for Truck 1: 10.0000
Truck 2 is assigned to Depot 1
Start Time for Truck 2: 10.0000
Completion Time for Truck 2: 17.0000
Truck 3 is assigned to Depot 1
Start Time for Truck 3: 23.0000
Completion Time for Truck 3: 30.0000
Truck 4 is assigned to Depot 1
Start Time for Truck 4: 17.0000
Completion Time for Truck 4: 23.0000
Makespan: 30.0000
Total Waiting Cost: 2107.0000
Total Service Cost: 1223.0000
Total Cost: 3330.0000


```

================================================================================



--- Problem 78 ---
**Difficulty:** easy
**Category:** LP

**Problem Description:**
**
A busy port is trying to manage the flow of ships entering from a channel into the main harbor. The channel currently experiences a demand of **655.41 ships per hour (ships/h)**, while the upstream harbor flow is **2,281.77 ships/h**. The downstream section of the harbor, however, can only handle a maximum of **3,036.64 ships/h** before congestion worsens. The challenge is to determine the optimal channel entry rate—the number of ships allowed to enter the harbor per hour—without exceeding the downstream capacity.  

The goal is to maximize the channel entry rate while ensuring the combined flow from the upstream harbor and the channel does not overwhelm the downstream bottleneck. If the channel demand is fully met, the total flow would reach **2,937.19 ships/h**, just below the capacity limit. However, if the downstream capacity were tighter, the channel might need to restrict entering ships, leading to queue growth. In this case, the optimal solution allows the full channel demand to enter, resulting in no queue growth (**0.00 ships/h**).  

**Key Question:** What is the highest possible channel entry rate that keeps the downstream harbor flow within its congested capacity?  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
   - **ChannelRate (c_channel):** The entry rate (ships/h) at which ships are allowed to enter from the channel (bounded by channel demand: \( 0 \leq c_{channel} \leq \lambda_{channel\_demand\_h} \)).  
   - **HarborFlowDownstream (lambda_harbor_downstream):** The total flow (ships/h) in the harbor after merging with channel ships.  

   **2. Parameters:**  
   - **Downstream Congested Capacity (C_harbor_congested_h):** Maximum allowable flow downstream (**3,036.64 ships/h**).  
   - **Channel Demand (lambda_channel_demand_h):** Maximum potential channel flow (**655.41 ships/h**).  
   - **Upstream Harbor Flow (lambda_harbor_upstream_h):** Existing harbor flow before merging (**2,281.77 ships/h**).  

   **3. Objective Function:**  
   Maximize the channel entry rate:  
   \[
   \text{Maximize: } c_{channel}
   \]  

   **4. Constraints:**  
   - **Downstream Flow Calculation:** The downstream flow equals the sum of upstream harbor flow and channel flow:  
     \[
     \lambda_{harbor\_downstream} = \lambda_{harbor\_upstream\_h} + c_{channel}
     \]  
   - **Capacity Limit:** The downstream flow must not exceed the congested capacity:  
     \[
     \lambda_{harbor\_downstream} \leq C_{harbor\_congested\_h}
     \]  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
C_harbor_congested_h = 3036.6440312845943
lambda_channel_demand_h = 655.4119608582669
lambda_harbor_upstream_h = 2281.773572264374

# --- Gurobi Model ---
model = gp.Model("ChannelEntryHarborCongestion")

# --- Decision Variables ---
c_channel = model.addVar(name="ChannelRate", lb=0.0, ub=lambda_channel_demand_h)
lambda_harbor_downstream = model.addVar(name="HarborFlowDownstream", lb=0.0)

# --- Constraints ---
model.addConstr(lambda_harbor_downstream == lambda_harbor_upstream_h + c_channel, name="DownstreamFlowCalc")
model.addConstr(lambda_harbor_downstream <= C_harbor_congested_h, name="DownstreamCapacityLimit")

# --- Objective Function ---
model.setObjective(c_channel, GRB.MAXIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    print(f"Optimal Channel Entry Rate: {c_channel.X:.2f} ships/h")
    print(f"  (Channel Demand was: {lambda_channel_demand_h:.0f} ships/h)")
    print(f"Resulting Downstream Harbor Flow: {lambda_harbor_downstream.X:.2f} ships/h")
    print(f"  (Downstream Capacity Limit: {C_harbor_congested_h:.0f} ships/h)")
    channel_queue_growth = lambda_channel_demand_h - c_channel.X
    print(f"Implied Queue Growth Rate on Channel: {channel_queue_growth:.2f} ships/h")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
    if lambda_harbor_upstream_h > C_harbor_congested_h:
         print(f"  Reason: Upstream harbor flow ({lambda_harbor_upstream_h}) already exceeds downstream capacity ({C_harbor_congested_h}).")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 2 rows, 2 columns and 3 nonzeros
Model fingerprint: 0xac4edb77
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [7e+02, 7e+02]
  RHS range        [2e+03, 3e+03]
Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    6.5541196e+02   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  6.554119609e+02

--- Optimization Results ---
Optimization Status: Optimal
Optimal Channel Entry Rate: 655.41 ships/h
  (Channel Demand was: 655 ships/h)
Resulting Downstream Harbor Flow: 2937.19 ships/h
  (Downstream Capacity Limit: 3037 ships/h)
Implied Queue Growth Rate on Channel: 0.00 ships/h



================================================================================



--- Problem 79 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a port, a team is tasked with scheduling the berthing of 18 ships at a limited number of berths. Each ship has a specific length and revenue, and the berths have a strict length capacity of 45 units. The challenge is to maximize the total revenue from the berthed ships while ensuring no berth exceeds its capacity and no ship is assigned to more than one berth. The port has only six berths available, adding another layer of complexity to the berthing strategy.  

   The ships vary significantly in length and revenue—some are short but highly profitable (like ship 10, with a length of 30 units and revenue of $96,000), while others are longer but less profitable (like ship 7, with a length of 42 units and revenue of $93,000). The team must carefully balance these trade-offs to extract the highest possible total revenue without violating any constraints. The critical question is: *How should the ships be distributed across the berths to achieve the maximum possible total revenue while respecting all berthing rules?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `x[i, j]` indicates whether ship `i` is berthed at berth `j` (1 if yes, 0 otherwise).  
   - Binary variable `y[j]` indicates whether berth `j` is used (1 if yes, 0 otherwise).  

   **2. Parameters:**  
   - `ships[i]`: A list of tuples where each tuple contains `(length, revenue)` for ship `i`.  
   - `berth_capacity = 45`: Maximum length a berth can hold.  
   - `num_berths = 6`: Total berths available.  
   - `num_ships = 18`: Total ships to berth.  

   **3. Objective Function:**  
   - **Maximize:** The sum of the revenues of all berthed ships:  
     \[
     \text{Maximize} \sum_{i=0}^{17} \sum_{j=0}^{5} \text{revenue}_i \cdot x[i, j]
     \]  

   **4. Constraints:**  
   - **Berth Length Limit:** For each berth `j`, the total length of ships assigned must not exceed its capacity:  
     \[
     \sum_{i=0}^{17} \text{length}_i \cdot x[i, j] \leq \text{berth\_capacity} \cdot y[j] \quad \forall j \in \{0, 1, ..., 5\}
     \]  
   - **Ship-Berth Link:** If a ship `i` is berthed at berth `j`, the berth must be marked as used:  
     \[
     x[i, j] \leq y[j] \quad \forall i \in \{0, 1, ..., 17\}, \forall j \in \{0, 1, ..., 5\}
     \]  
   - **Single Assignment:** Each ship can be berthed at at most one berth:  
     \[
     \sum_{j=0}^{5} x[i, j] \leq 1 \quad \forall i \in \{0, 1, ..., 17\}
     \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Data Definition (Embedded) ---
ships = [(42, 42000), (13, 95000), (43, 26000), (8, 21000), (25, 65000), (5, 54000), (42, 93000), (41, 5000), (36, 17000), (13, 23000), (30, 96000), (36, 59000), (23, 60000), (31, 26000), (27, 90000), (15, 100000), (41, 28000), (10, 64000)]          # List of (length, revenue) tuples
berth_capacity = 45      # Maximum length per berth
num_berths = 6          # Maximum number of available berths (parameter)
num_ships = 18          # len(ships) derived correctly
# --- End Data Definition ---

GUROBI_TIME_LIMIT = 60 # Time limit parameter

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi log in captured output
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Max-Revenue BPP", env=env)

    # --- Decision variables ---
    x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")  # x[i, j] -> ship i berthed at berth j
    y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")  # y[j] -> berth j is used

    # --- Objective: Maximize total revenue of selected ships ---
    # Sum over all ships i and the berth j they are berthed at
    model.setObjective(gp.quicksum(ships[i][1] * x[i, j] for i in range(num_ships) for j in range(num_berths)), GRB.MAXIMIZE)

    # --- Constraint 1: Berth length limit ---
    for j in range(num_berths):
        model.addConstr(gp.quicksum(ships[i][0] * x[i, j] for i in range(num_ships)) <= berth_capacity * y[j], name=f"Berth_{j}_Length")

    # --- Constraint 2: If a ship is berthed at a berth, that berth must be considered used ---
    # (This is often implied by C1 if capacity > 0, but good practice)
    for i in range(num_ships):
        for j in range(num_berths):
            model.addConstr(x[i, j] <= y[j], name=f"Ship_{i}_Triggers_Berth_{j}")

    # --- Constraint 3: Each ship can be berthed at at most one berth ---
    # (Ships not berthed contribute 0 to objective and constraints)
    for i in range(num_ships):
        model.addConstr(x.sum(i, '*') <= 1, name=f"Ship_{i}_AtMostOneBerth")

    # --- Solve the model ---
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal # Best solution found

    # --- Output results (for capture) ---
    if model.status == GRB.OPTIMAL:
        print(f"Optimal total revenue: {model.objVal:.2f}") # Format value
        print("-" * 30)
        printed_berth_count = 0
        for j in range(num_berths):
            try:
                 if y[j].x > 0.5:  # Berth is used
                     printed_berth_count += 1
                     assigned_ships = [i for i in range(num_ships) if x[i, j].x > 0.5]
                     assigned_lengths = [ships[i][0] for i in assigned_ships]
                     berth_load = sum(assigned_lengths)
                     print(f"Berth {printed_berth_count} (Index {j}):")
                     print(f"  Load: {berth_load} / {berth_capacity}")
                     print(f"  Ships (indices): {sorted(assigned_ships)}")
                     # Optional: print ship details
                     # print(f"  Ships (l,r): {[ships[i] for i in sorted(assigned_ships)]}")
                     print("-" * 10)
            except AttributeError:
                 pass # Skip berths not used or if .X missing
    elif model.status == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare if ships fit capacity
    else:
        print(f"\nOptimization finished with status: {model.status}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total revenue: 820000.00
------------------------------
Berth 1 (Index 0):
  Load: 42 / 45
  Ships (indices): [6]
----------
Berth 2 (Index 1):
  Load: 44 / 45
  Ships (indices): [3, 11]
----------
Berth 3 (Index 2):
  Load: 38 / 45
  Ships (indices): [12, 15]
----------
Berth 4 (Index 3):
  Load: 43 / 45
  Ships (indices): [9, 10]
----------
Berth 5 (Index 4):
  Load: 45 / 45
  Ships (indices): [1, 5, 14]
----------
Berth 6 (Index 5):
  Load: 35 / 45
  Ships (indices): [4, 17]
----------


```

================================================================================



--- Problem 80 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy port is tasked with efficiently allocating 1,171 incoming containers across four available storage areas, each with distinct capacities, costs, and distances from the main loading dock. The port aims to minimize the total cost incurred by the shipping companies, which includes both the storage fee and the "disutility" cost associated with the distance traveled—calculated as $0.0140 per meter.  

Storage Area A offers the largest capacity (670 containers) but is the farthest (1,844 meters) and charges $8 per container. Storage Area B (411 containers, 1,465 meters, $7) and Storage Area C (402 containers, 1,184 meters, $8) provide mid-range options, while Storage Area D (199 containers, 533 meters, $10) is the closest but has the smallest capacity and highest base fee. The port must allocate all containers to these areas without exceeding any area's capacity while ensuring the combined cost—storage fee plus distance disutility—is as low as possible.  

The central question: *How should the containers be distributed across the four storage areas to minimize the total cost while accommodating every container?*  

---
**

Modeling Process:**
**
**1. Decision Variables:**  
- Let \( x[\text{area}] \) represent the integer number of containers assigned to each storage area (Area_A, Area_B, Area_C, Area_D).  

**2. Parameters:**  
- **Total containers to store:** 1,171.  
- **Storage area capacities:**  
  - Area_A: 670 containers, Area_B: 411 containers, Area_C: 402 containers, Area_D: 199 containers.  
- **Cost components per storage area:**  
  - Base storage fee: Area_A ($8), Area_B ($7), Area_C ($8), Area_D ($10).  
  - Distance disutility: \( 0.0140 \times \text{distance (meters)} \).  
  - **Total cost per container (fee + disutility):**  
    - Area_A: \( 8 + 1844 \times 0.0140 = \$33.82 \).  
    - Area_B: \( 7 + 1465 \times 0.0140 = \$27.51 \).  
    - Area_C: \( 8 + 1184 \times 0.0140 = \$24.58 \).  
    - Area_D: \( 10 + 533 \times 0.0140 = \$17.46 \).  

**3. Objective Function:**  
Minimize the total cost:  
\[ \text{Minimize: } 33.82x[\text{Area_A}] + 27.51x[\text{Area_B}] + 24.58x[\text{Area_C}] + 17.46x[\text{Area_D}]. \]  

**4. Constraints:**  
- **Store all containers:** \( x[\text{Area_A}] + x[\text{Area_B}] + x[\text{Area_C}] + x[\text{Area_D}] = 1171 \).  
- **Storage area capacities:**  
  - \( x[\text{Area_A}] \leq 670 \),  
  - \( x[\text{Area_B}] \leq 411 \),  
  - \( x[\text{Area_C}] \leq 402 \),  
  - \( x[\text{Area_D}] \leq 199 \).  
- **Non-negativity:** \( x[\text{area}] \geq 0 \) and integer for all areas.  

---

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
total_containers_to_store = 1171; areas_data = {'Area_A': {'capacity': 670, 'cost': 8, 'distance': 1844}, 'Area_B': {'capacity': 411, 'cost': 7, 'distance': 1465}, 'Area_C': {'capacity': 402, 'cost': 8, 'distance': 1184}, 'Area_D': {'capacity': 199, 'cost': 10, 'distance': 533}}
distance_disutility_per_meter = 0.0140
area_ids = ['Area_A', 'Area_B', 'Area_C', 'Area_D']
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    total_cost_per_container = { area: areas_data[area]['cost'] + areas_data[area]['distance'] * distance_disutility_per_meter for area in area_ids }
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m11 = gp.Model("Port_Container_Allocation_IP", env=env)
    # Vars
    x = m11.addVars(area_ids, vtype=GRB.INTEGER, name="containers_in_area", lb=0)
    # Objective
    m11.setObjective(gp.quicksum(x[area] * total_cost_per_container[area] for area in area_ids), sense=GRB.MINIMIZE)
    # Constraints
    m11.addConstr(gp.quicksum(x[area] for area in area_ids) == total_containers_to_store, "store_all_containers")
    for area in area_ids: m11.addConstr(x[area] <= areas_data[area]['capacity'], f"capacity_area_{area}")
    # Optimize
    m11.optimize()
    # Store results
    results_dict['status'] = m11.status
    if m11.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m11.objVal; results_dict['x_sol'] = m11.getAttr('X', x)
    # Output Results
    print("--- Problem 11: Port Container Allocation (IP) ---")
    if m11.status == GRB.OPTIMAL:
        x_sol = results_dict.get('x_sol', {})
        print(f"Optimization Status: Optimal"); print(f"Minimum Total Cost (Storage Fee + Distance Disutility): ${m11.objVal:.2f}"); print("Container Allocation:")
        total_stored = 0
        for area in area_ids:
            containers_in_area = x_sol.get(area, 0)
            print(f"  Area {area}: {int(round(containers_in_area))} containers (Capacity: {areas_data[area]['capacity']}, Cost/Container: ${total_cost_per_container[area]:.2f})")
            total_stored += containers_in_area
        print(f"Total containers stored: {int(round(total_stored))} / {total_containers_to_store}")
    else: print(f"Optimization Status: {m11.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_CONTAINER
```
Answer:
--- Problem 11: Port Container Allocation (IP) ---
Optimization Status: Optimal
Minimum Total Cost (Storage Fee + Distance Disutility): $30037.84
Container Allocation:
  Area Area_A: 159 containers (Capacity: 670, Cost/Container: $33.82)
  Area Area_B: 411 containers (Capacity: 411, Cost/Container: $27.51)
  Area Area_C: 402 containers (Capacity: 402, Cost/Container: $24.58)
  Area Area_D: 199 containers (Capacity: 199, Cost/Container: $17.46)
Total containers stored: 1171 / 1171



================================================================================



--- Problem 81 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A port authority is facing the challenge of managing the berthing of 429 ships daily while minimizing operational costs. The port has two options for handling the ships: using its own berths or outsourcing to a nearby private port. Each berth can handle 10 ships per day, but the port is limited to a maximum of 31 berths. Operating each berth for a day incurs a fixed cost of $257, while outsourcing a ship to the private port costs $40. The port authority must strategically balance the use of its own berths and outsourcing to ensure all ships are berthed at the lowest possible cost. The core question is: *How many berths should the port authority use daily, and how many ships should be outsourced to minimize total costs while meeting the demand?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `n`: Integer number of berths to use (0 ≤ `n` ≤ 31).  
   - `outsourced`: Integer number of ships outsourced (≥ 0).  

   **2. Parameters:**  
   - `total_ships_demand = 429`: Total ships requiring berthing.  
   - `ships_per_berth_day = 10`: Ships a single berth can handle daily.  
   - `cost_per_berth_day = 257`: Daily cost of operating one berth.  
   - `cost_per_outsourced_ship = 40`: Cost per outsourced ship.  
   - `max_berths = 31`: Upper limit on available berths.  

   **3. Objective Function:**  
   Minimize the total cost:  
   \[
   \text{Minimize: } 257 \cdot n + 40 \cdot \text{outsourced}
   \]  

   **4. Constraints:**  
   - **Demand Fulfillment:** The sum of ships handled by the berths and outsourced must meet or exceed demand:  
     \[
     10 \cdot n + \text{outsourced} \geq 429
     \]  
   - **Berth Limit:** The number of berths cannot exceed the maximum available:  
     \[
     n \leq 31
     \]  
   - **Non-Negativity:**  
     \[
     n \geq 0, \quad \text{outsourced} \geq 0
     \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_ships_demand = 429
ships_per_berth_day = 10
cost_per_berth_day = 257
cost_per_outsourced_ship = 40
max_berths = 31
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m37 = gp.Model("BERTH_SIZE_OPTIMIZATION_IP", env=env)

    # --- Decision Variables ---
    # Integer: Number of berths to use
    n = m37.addVar(vtype=GRB.INTEGER, name="num_berths", lb=0, ub=max_berths)
    # Integer: Number of ships outsourced
    outsourced = m37.addVar(vtype=GRB.INTEGER, name="num_outsourced", lb=0)

    # --- Objective Function ---
    # Minimize total cost (berth cost + outsourcing cost)
    m37.setObjective(n * cost_per_berth_day + outsourced * cost_per_outsourced_ship, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Ensure total demand is met by own berths + outsourcing
    # Avoid division by zero for ships_per_berth_day
    if ships_per_berth_day > 0:
        m37.addConstr(n * ships_per_berth_day + outsourced >= total_ships_demand, name="demand_met")
    else:
        # If capacity is zero, all demand must be outsourced
        m37.addConstr(outsourced >= total_ships_demand, name="demand_met_zero_cap")
        m37.addConstr(n == 0, name="force_zero_berths") # Cannot use berths with zero capacity

    # --- Optimization ---
    m37.optimize()

    # --- Store results ---
    results_dict['status'] = m37.status
    if m37.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m37.ObjVal
        results_dict['n_sol'] = n.X
        results_dict['outsourced_sol'] = outsourced.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 37: Berth Size Optimization (IP) ---") # Original problem number
    if m37.status == GRB.OPTIMAL:
        opt_n = int(round(results_dict.get('n_sol', 0)))
        opt_outsourced = int(round(results_dict.get('outsourced_sol', 0)))
        capacity_own = opt_n * ships_per_berth_day
        cost_own = opt_n * cost_per_berth_day
        cost_outsource = opt_outsourced * cost_per_outsourced_ship
        obj_val_print = results_dict.get('obj_val', 'N/A')

        print(f"Optimization Status: Optimal")
        print(f"Optimal Number of Berths: {opt_n} (Max: {max_berths})")
        print(f"  Own Berth Capacity: {capacity_own} ships")
        print(f"Number of Outsourced Ships: {opt_outsourced}")
        print(f"Total Ships Berthed: {capacity_own + opt_outsourced} (Demand: {total_ships_demand})")
        print(f"\nCosts:")
        print(f"  Own Berth Cost: ${cost_own:.2f}")
        print(f"  Outsourcing Cost: ${cost_outsource:.2f}")
        print(f"Minimum Total Daily Cost: ${float(obj_val_print):.2f}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m37.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Leave empty as the code is complete and prints all required outputs)
```
Answer:
--- Problem 37: Berth Size Optimization (IP) ---
Optimization Status: Optimal
Optimal Number of Berths: 31 (Max: 31)
  Own Berth Capacity: 310 ships
Number of Outsourced Ships: 119
Total Ships Berthed: 429 (Demand: 429)

Costs:
  Own Berth Cost: $7967.00
  Outsourcing Cost: $4760.00
Minimum Total Daily Cost: $12727.00


```

================================================================================



--- Problem 82 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A fleet of nine delivery trucks (T1 through T9) arrives at a depot equipped with two distinct fueling stations. Each station operates at different fueling rates—Station 1 delivers 34.1 liters per minute, while Station 2 provides 20.3 liters per minute. The trucks have varying fuel demands, ranging from 26 liters (T2) to 77 liters (T9), necessitating different fueling durations depending on the station’s fueling rate. For instance, T1 requires 2.11 minutes on Station 1 but 3.55 minutes on Station 2, while T9’s fueling time spans 2.26 minutes or 3.79 minutes, respectively.

The depot manager faces a critical scheduling challenge: assign each truck to exactly one station to minimize the **total fueling time across all trucks**. This optimization ensures efficient use of limited fueling infrastructure, reducing wait times and operational bottlenecks. The core question is: *What is the optimal assignment of trucks to stations that achieves the smallest possible cumulative fueling duration?*  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable `x(t, s)` = 1 if truck `t` (e.g., T1, T2) is assigned to station `s` (1 or 2), and 0 otherwise.  

**2. Parameters:**  
- `fuel_duration(t, s)`: Precomputed time (minutes) for truck `t` on station `s` (e.g., 2.111 for T1 on Station 1).  
- `trucks`: List of trucks (T1–T9).  
- `stations`: List of stations (1, 2).  

**3. Objective Function:**  
Minimize the sum of fueling times:  
```  
Minimize: sum(fuel_duration(t, s) * x(t, s) for all t, s)  
```  

**4. Constraints:**  
- **Single assignment per truck:** Each truck must use exactly one station:  
  ```  
  For each truck t: sum(x(t, s) for s in stations) = 1  
  ```  

---

**

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError, tupledict; import sys; import traceback; import math

# --- Parameters ---
trucks = ['T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9']
stations = [1, 2]
demand_liters = {'T1': 72, 'T2': 26, 'T3': 38, 'T4': 53, 'T5': 55, 'T6': 31, 'T7': 29, 'T8': 33, 'T9': 77} # For context
rate_lpm = {1: 34.1, 2: 20.3}     # For context
# Calculated fuel durations (truck, station): duration_in_minutes
fuel_duration = {('T1', 1): 2.1114369501466275, ('T1', 2): 3.54679802955665, ('T2', 1): 0.7624633431085044, ('T2', 2): 1.2807881773399015, ('T3', 1): 1.1143695014662756, ('T3', 2): 1.8719211822660098, ('T4', 1): 1.5542521994134897, ('T4', 2): 2.610837438423645, ('T5', 1): 1.6129032258064515, ('T5', 2): 2.70935960591133, ('T6', 1): 0.9090909090909091, ('T6', 2): 1.5270935960591132, ('T7', 1): 0.8504398826979471, ('T7', 2): 1.4285714285714286, ('T8', 1): 0.9677419354838709, ('T8', 2): 1.625615763546798, ('T9', 1): 2.258064516129032, ('T9', 2): 3.793103448275862}
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("Truck_Fueling_ASSIGN_SUM_Sum", env=env)

    # --- Input Validation ---
    if not trucks or not stations: raise ValueError("Empty trucks or stations list")
    if any(t == float('inf') for t in fuel_duration.values()):
         print("Warning: Some station has zero rate or invalid duration.")

    # --- Decision Variables ---
    # x[i, j] = 1 if truck i is assigned to station j
    # Use tupledict for easier handling of potentially invalid pairs
    assign_keys = tupledict({(t, s): 1 for t, s in fuel_duration if fuel_duration[t,s] != float('inf')})
    if not assign_keys: raise ValueError("No valid truck-station assignments possible.")
    x = m.addVars(assign_keys.keys(), vtype=GRB.BINARY, name="x")

    # --- Objective Function: Minimize the sum of fueling times ---
    # Use tupledict prod method
    m.setObjective(x.prod(fuel_duration), GRB.MINIMIZE)

    # --- Constraints ---
    # Each truck must be assigned to exactly one station
    # Use tupledict sum method
    for t in trucks:
        m.addConstr(x.sum(t, '*') == 1, f"TruckAssignment_{t}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is sum of durations in minutes
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show more precision
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.") # Matches example
    else: # Other statuses
        print("No optimal solution found.") # Matches example

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the optimal assignment of trucks to stations
if m.Status == GRB.OPTIMAL:
    for t in trucks:
        for s in stations:
            if x[t, s].X > 0.5:
                print(f"Truck {t} is assigned to Station {s}")
```
Answer:
Optimal objective value: 12.1408
Truck T1 is assigned to Station 1
Truck T2 is assigned to Station 1
Truck T3 is assigned to Station 1
Truck T4 is assigned to Station 1
Truck T5 is assigned to Station 1
Truck T6 is assigned to Station 1
Truck T7 is assigned to Station 1
Truck T8 is assigned to Station 1
Truck T9 is assigned to Station 1


```

================================================================================



--- Problem 83 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A logistics company operates a delivery truck that must visit multiple locations in a single trip before returning to its starting point. The truck starts and ends at a central depot (node 0) and must visit three additional locations (nodes 1, 2, and 3) exactly once each. The travel times between these locations vary significantly: for instance, the trip from node 0 to node 1 takes 9 minutes, while the journey from node 1 to node 2 requires 30 minutes. The challenge is to determine the most efficient route that minimizes the total travel time while ensuring the truck visits every location exactly once and returns to the depot. Given the varying distances—such as the relatively short 7-minute trip from node 0 to node 3 compared to the 21-minute trip from node 3 to node 1—the optimal route must carefully balance these travel times to avoid inefficiencies. Additionally, the weather forecast predicts light rain, which may slightly affect the driving conditions but does not change the travel times. The central question is: What is the fastest possible route the truck can take to complete all deliveries and return to the depot?
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[i, j]`: Binary variable indicating whether the truck travels directly from node `i` to node `j` (1 if yes, 0 otherwise).  
     - `u[i]`: Continuous variable representing the order in which node `i` is visited (used to eliminate subtours).  
   - **2. Parameters:**  
     - `dist[i, j]`: Travel time (in minutes) between nodes `i` and `j` (e.g., `dist[0, 1] = 9`, `dist[1, 2] = 30`).  
     - `num_nodes = 4`: Total number of nodes (including the depot).  
   - **3. Objective Function:**  
     - Minimize the total travel time:  
       `Minimize: sum(x[i, j] * dist[i, j] for all valid i, j)`  
   - **4. Constraints:**  
     - **Leave each node once:** For each node `i`, `sum(x[i, j] for all j != i) = 1`.  
     - **Enter each node once:** For each node `j`, `sum(x[i, j] for all i != j) = 1`.  
     - **Subtour elimination (MTZ):** For nodes `i` and `j` (where `i, j != 0` and `i != j`),  
       `u[i] - u[j] + num_nodes * x[i, j] <= num_nodes - 1`.  

**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import itertools; import math
# Params
num_nodes = 4; nodes = [0, 1, 2, 3]; dist = {(0, 1): 9, (0, 2): 11, (0, 3): 7, (1, 0): 9, (1, 2): 30, (1, 3): 21, (2, 0): 11, (2, 1): 30, (2, 3): 15, (3, 0): 7, (3, 1): 21, (3, 2): 15}
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m17 = gp.Model("Delivery_Truck_TSP_MIP", env=env)
    # Check if dist keys are valid tuples
    valid_keys = [(i,j) for i in nodes for j in nodes if i != j]
    # Vars
    x = m17.addVars(valid_keys, vtype=GRB.BINARY, name="travel") # Use valid_keys
    u = m17.addVars(nodes, vtype=GRB.CONTINUOUS, name="order", lb=0.0)
    # Objective
    m17.setObjective(gp.quicksum(x[i, j] * dist.get((i,j), 9999) for i, j in valid_keys), sense=GRB.MINIMIZE) # Use .get
    # Constraints
    m17.addConstrs((gp.quicksum(x[i, j] for j in nodes if i != j) == 1 for i in nodes), name="leave_node")
    m17.addConstrs((gp.quicksum(x[j, i] for j in nodes if i != j) == 1 for i in nodes), name="enter_node")
    # MTZ Subtour Elimination
    for i in nodes:
        for j in nodes:
            if i != j and i != 0 and j != 0 and (i,j) in valid_keys: # Check key exists
                 m17.addConstr(u[i] - u[j] + num_nodes * x[i, j] <= num_nodes - 1, name=f"MTZ_{i}_{j}")
    # Optimize
    m17.optimize()
    # Store results
    results_dict['status'] = m17.status
    if m17.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m17.objVal; results_dict['x_sol'] = m17.getAttr('X', x)
    # Output Results
    print("--- Problem 17: Multi-Stop Delivery Truck Routing (TSP Variation) (MIP) ---")
    if m17.status == GRB.OPTIMAL:
        print(f"Optimization Status: Optimal"); print(f"Minimum Total Travel Time: {m17.objVal:.1f} minutes"); print("Optimal Route:")
        x_sol = results_dict.get('x_sol', {})
        current_node = 0; route = [0]; visited_count=0
        while len(route) < num_nodes and visited_count < num_nodes + 2:
            next_node = -1
            for j in nodes:
                if current_node != j and x_sol.get((current_node, j), 0) > 0.5: next_node = j; break
            if next_node != -1: route.append(next_node); current_node = next_node
            else: break # No next node found
            visited_count += 1
        if current_node != 0: route.append(0) # Add return if not already there
        if len(route) == num_nodes + 1: print(f"  {' -> '.join(map(str, route))}")
        else: print(f"  Error: Could not reconstruct full route. Found: {' -> '.join(map(str, route))}")
    else: print(f"Optimization Status: {m17.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of DELIVERY_TSP
```
Answer:
--- Problem 17: Multi-Stop Delivery Truck Routing (TSP Variation) (MIP) ---
Optimization Status: Optimal
Minimum Total Travel Time: 56.0 minutes
Optimal Route:
  0 -> 2 -> 3 -> 1 -> 0



================================================================================



--- Problem 84 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently packing a set of 17 items with varying weights into a selection of 8 available truck types, each with distinct capacities and associated costs. The items range from lightweight (e.g., 1 unit) to heavier ones (e.g., 95 units), while the trucks offer different capacities (from 95 to 100 units) and costs (from $36 to $99). The challenge is to assign each item to exactly one truck while respecting the truck capacities and minimizing the total cost of the trucks used.

The operational constraints are strict: every item must be placed in a truck, and the total weight of items in any truck cannot exceed its capacity. Additionally, using a truck incurs its full cost, regardless of how much capacity is utilized. The goal is to find the most cost-effective combination of trucks and item assignments that meets all these requirements. The central question is: *What is the minimum total cost required to pack all items while adhering to the truck capacities and usage rules?*
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `x[i, j]`: Binary variable indicating whether item `i` is assigned to truck `j` (1 if assigned, 0 otherwise).
   - `y[j]`: Binary variable indicating whether truck `j` is used (1 if used, 0 otherwise).

**2. Parameters:**
   - `items[i]`: Weight of item `i` (e.g., `items[0] = 89`, `items[1] = 2`, etc.).
   - `trucks[j]`: Tuple `(capacity, cost)` for truck `j` (e.g., `trucks[0] = (100, 99)`, `trucks[1] = (97, 49)`, etc.).
   - `num_items`: Total number of items (17).
   - `num_trucks`: Total number of truck types (8).

**3. Objective Function:**
   - Minimize the total cost of used trucks:  
     `Minimize: sum(y[j] * trucks[j][1] for j in range(num_trucks))`.

**4. Constraints:**
   - **Item Assignment:** Each item must be assigned to exactly one truck:  
     `For each item i: sum(x[i, j] for j in range(num_trucks)) == 1`.
   - **Truck Capacity:** The total weight of items in a truck cannot exceed its capacity:  
     `For each truck j: sum(items[i] * x[i, j] for i in range(num_items)) <= trucks[j][0] * y[j]`.
   - **Linking Constraint:** An item can only be assigned to a truck if the truck is used:  
     `For each item i and truck j: x[i, j] <= y[j]`.

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys # Make sys available inside exec if needed, e.g. for print traceback
import traceback

# --- Data Definition (Embedded) ---
items = [89, 2, 95, 31, 24, 93, 42, 1, 3, 68, 59, 27, 2, 11, 40, 28, 78]      # Item weights
trucks = [(100, 99), (97, 49), (98, 59), (95, 58), (96, 50), (99, 84), (98, 36), (99, 48)]        # List of (Capacity, Cost) tuples
num_items = 17       # len(items)
num_trucks = 8         # len(trucks)
# --- End Data Definition ---

# Time limit (passed from outer scope via globals if needed, or hardcoded)
GUROBI_TIME_LIMIT = 60

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Keep output clean for saving
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Cost-Sensitive Truck Packing", env=env)

    # --- Decision Variables ---
    x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")

    # --- Objective: Minimize total cost ---
    model.setObjective(gp.quicksum(y[j] * trucks[j][1] for j in range(num_trucks)), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Each item assignment
    for i in range(num_items):
        model.addConstr(x.sum(i, '*') == 1, name=f"Item_{i}_Assignment")

    # 2. Truck capacity
    for j in range(num_trucks):
        truck_capacity = trucks[j][0]
        if truck_capacity < 0: truck_capacity = 0
        model.addConstr(gp.quicksum(items[i] * x[i, j] for i in range(num_items)) <= truck_capacity * y[j], name=f"Truck_{j}_Capacity")

    # 3. Linking item to truck usage
    for i in range(num_items):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Item_{i}_Triggers_Truck_{j}")

    # --- Solve ---
    # print("Solving CS-TP instance...") # Comment out or keep for debug inside output
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal

    # --- Output results (This will be captured) ---
    # This logic needs to be *inside* the template now
    if model.status == GRB.OPTIMAL:
        print(f"Minimum cost: ${model.objVal:.2f}") # Use model.objVal directly
        print("-" * 30) # Add separator for clarity
        printed_truck_count = 0
        for j in range(num_trucks):
            # Use try-except for safety when accessing .X
            try:
                 if y[j].x > 0.5:
                     printed_truck_count += 1
                     truck_capacity_out, truck_cost_out = trucks[j]
                     assigned_items = [i for i in range(num_items) if x[i, j].x > 0.5]
                     truck_load_out = sum(items[i] for i in assigned_items)
                     # Format output exactly as desired for the log file
                     print(f"Truck {printed_truck_count} (Type Index {j}, Capacity: {truck_capacity_out}, Cost: ${truck_cost_out:.2f}):")
                     print(f"  Load: {truck_load_out} / {truck_capacity_out}")
                     print(f"  Items (indices): {sorted(assigned_items)}") # Sort for consistency
                     print("-" * 10) # Separator between trucks
            except AttributeError:
                 pass # Ignore trucks not used or if .X attribute missing
    elif model.status == GRB.TIME_LIMIT:
        print("\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: ${model.ObjVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {model.status}")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}") # Print errors to captured output
    results_dict['status'] = -1 # Use dict to signal error type to main loop
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:") # Print errors
    traceback.print_exc(file=sys.stdout) # Print traceback to captured stdout
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Minimum cost: $483.00
------------------------------
Truck 1 (Type Index 0, Capacity: 100, Cost: $99.00):
  Load: 98 / 100
  Items (indices): [1, 4, 7, 8, 14, 15]
----------
Truck 2 (Type Index 1, Capacity: 97, Cost: $49.00):
  Load: 91 / 97
  Items (indices): [12, 13, 16]
----------
Truck 3 (Type Index 2, Capacity: 98, Cost: $59.00):
  Load: 59 / 98
  Items (indices): [10]
----------
Truck 4 (Type Index 3, Capacity: 95, Cost: $58.00):
  Load: 73 / 95
  Items (indices): [3, 6]
----------
Truck 5 (Type Index 4, Capacity: 96, Cost: $50.00):
  Load: 95 / 96
  Items (indices): [2]
----------
Truck 6 (Type Index 5, Capacity: 99, Cost: $84.00):
  Load: 93 / 99
  Items (indices): [5]
----------
Truck 7 (Type Index 6, Capacity: 98, Cost: $36.00):
  Load: 89 / 98
  Items (indices): [0]
----------
Truck 8 (Type Index 7, Capacity: 99, Cost: $48.00):
  Load: 95 / 99
  Items (indices): [9, 11]
----------


```

================================================================================



--- Problem 85 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
**
A port operator faces the challenge of dynamically pricing berthing fees during different traffic periods to maximize revenue while respecting berth capacity limits. The port experiences two distinct periods: "off-peak" with a base demand of 966 ships per hour and "peak" with a significantly higher base demand of 2893 ships per hour. The operator can adjust berthing fees up to a maximum of $6 per ship, with demand sensitivity (alpha) set at 38 ships per hour for every dollar increase in berthing fee. The port's capacity is fixed at 1638 ships per hour, meaning the number of ships that can be berthed cannot exceed this limit regardless of demand.  

The core question is: What berthing fees should be set during off-peak and peak periods to maximize total revenue, ensuring that the resulting traffic flow does not exceed capacity and that demand responds linearly to price changes? The operator must balance higher fees (which reduce demand but increase revenue per ship) against lower fees (which attract more ships but may not fully utilize capacity).
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `fee[p]`: Berthing fee (in $) for period `p` (where `p` is either "off" or "peak"). Bounded between 0 and `max_fee` ($6).  
- `demand[p]`: Resulting demand (ships/hr) for period `p`, calculated as `base_demand[p] - alpha * fee[p]`.  
- `flow[p]`: Actual traffic flow (ships/hr) for period `p`, constrained by both demand and capacity.  

**2. Parameters:**  
- `capacity = 1638`: Maximum flow capacity (ships/hr).  
- `base_demand = {'off': 966, 'peak': 2893}`: Base demand (ships/hr) when berthing fees are $0.  
- `alpha = 38`: Demand sensitivity (ships/hr per $1 fee increase).  
- `max_fee = 6`: Upper bound on berthing fee ($).  

**3. Objective Function:**  
Maximize total revenue:  
`Maximize: sum(flow[p] * fee[p] for p in periods)`  

**4. Constraints:**  
- Demand calculation for each period `p`:  
  `demand[p] == base_demand[p] - alpha * fee[p]`  
- Flow cannot exceed capacity:  
  `flow[p] <= capacity`  
- Flow cannot exceed demand:  
  `flow[p] <= demand[p]`  
- Non-negativity:  
  `fee[p], demand[p], flow[p] >= 0`  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 1638; base_demand = {'off': 966, 'peak': 2893}; alpha = 38; max_fee = 6; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berthing_Fee_Pricing_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berthing Fee Pricing (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of TOLL_PRICING
```
Answer:
--- Problem 18: Dynamic Berthing Fee Pricing (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $14256.00
  Period: Off
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 738.0 ships/hr (Base: 966)
    Actual Flow (min(Demand, Capacity)): 738.0 ships/hr (Capacity: 1638)
    Revenue this period: $4428.00
  Period: Peak
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 2665.0 ships/hr (Base: 2893)
    Actual Flow (min(Demand, Capacity)): 1638.0 ships/hr (Capacity: 1638)
    Revenue this period: $9828.00
Total ships processed: 2376.0



================================================================================


--- Problem 86 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
At a busy port, the management team faces the daily challenge of efficiently processing incoming ships while managing limited dock resources. The port handles two distinct ship types: small cargo vessels and large container ships. Each small cargo vessel berth requires 1 dedicated dock worker and can process up to 33 vessels per hour, while each large container ship berth demands 2 dock workers and handles 13 ships hourly. With only 15 dock workers available, the team must strategically allocate these personnel between small cargo vessel and large container ship berths to maximize the total number of ships processed. On this particular shift, 101 small cargo vessels and 30 large container ships are queued for berthing. The critical question is: *How many small cargo vessel and large container ship berths should be opened to clear as many ships as possible without exceeding dock worker capacity or arrival volumes?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y_small`: Integer number of small cargo vessel berths to open.  
     - `y_large`: Integer number of large container ship berths to open.  
     - `z_small`: Continuous number of small cargo vessels processed (capped by arrivals/capacity).  
     - `z_large`: Continuous number of large container ships processed (capped by arrivals/capacity).  

   - **2. Parameters:**  
     - `total_workers = 15`: Total dock workers available.  
     - `workers_per_small_berth = 1`, `workers_per_large_berth = 2`: Dock workers required per berth type.  
     - `capacity_small_berth = 33`, `capacity_large_berth = 13`: Hourly processing capacity per berth.  
     - `arriving_small_vessels = 101`, `arriving_large_ships = 30`: Ships awaiting berthing.  

   - **3. Objective Function:**  
     Maximize total processed ships:  
     ```  
     Maximize: z_small + z_large  
     ```  

   - **4. Constraints:**  
     - Worker limit: `1*y_small + 2*y_large ≤ 15`  
     - Small cargo vessel capacity: `z_small ≤ 33*y_small`  
     - Large container ship capacity: `z_large ≤ 13*y_large`  
     - Arrival limits: `z_small ≤ 101`, `z_large ≤ 30`  
     - Non-negativity: `y_small, y_large ≥ 0 (integers)`; `z_small, z_large ≥ 0 (continuous)`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_workers = 15
workers_per_small_berth = 1
workers_per_large_berth = 2
capacity_small_berth = 33 # vessels per hour
capacity_large_berth = 13 # ships per hour
arriving_small_vessels = 101
arriving_large_ships = 30
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTHING_ALLOC", env=env)

    # --- Decision Variables ---
    # y_small: number of small cargo vessel berths to open
    y_small = m.addVar(vtype=GRB.INTEGER, lb=0, name="y_small")
    # y_large: number of large container ship berths to open
    y_large = m.addVar(vtype=GRB.INTEGER, lb=0, name="y_large")
    # z_small: number of small cargo vessels processed
    z_small = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="z_small")
    # z_large: number of large container ships processed
    z_large = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="z_large")

    # --- Objective Function: Maximize total ships processed ---
    m.setObjective(z_small + z_large, GRB.MAXIMIZE)

    # --- Constraints ---
    # Worker availability constraint
    # Ensure worker counts are positive before adding constraint
    if workers_per_small_berth > 0 and workers_per_large_berth > 0:
        m.addConstr(workers_per_small_berth * y_small + workers_per_large_berth * y_large <= total_workers, "WorkerLimit")
    elif workers_per_small_berth > 0:
         m.addConstr(workers_per_small_berth * y_small <= total_workers, "WorkerLimit")
    elif workers_per_large_berth > 0:
         m.addConstr(workers_per_large_berth * y_large <= total_workers, "WorkerLimit")

    # Processed ships cannot exceed capacity
    m.addConstr(z_small <= capacity_small_berth * y_small, "SmallCapacity")
    m.addConstr(z_large <= capacity_large_berth * y_large, "LargeCapacity")

    # Processed ships cannot exceed arrivals
    m.addConstr(z_small <= arriving_small_vessels, "SmallArrivals")
    m.addConstr(z_large <= arriving_large_ships, "LargeArrivals")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['y_small_sol'] = y_small.X # Not needed for output
        # results_dict['y_large_sol'] = y_large.X # Not needed for output
        # results_dict['z_small_sol'] = z_small.X # Not needed for output
        # results_dict['z_large_sol'] = z_large.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Objective is total ships, potentially float if z variables are float
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the number of small and large berths opened, and the number of ships processed
if m.Status == GRB.OPTIMAL:
    y_small_sol = y_small.X
    y_large_sol = y_large.X
    z_small_sol = z_small.X
    z_large_sol = z_large.X
    print(f"Number of small cargo vessel berths to open: {y_small_sol:.0f}")
    print(f"Number of large container ship berths to open: {y_large_sol:.0f}")
    print(f"Number of small cargo vessels processed: {z_small_sol:.0f}")
    print(f"Number of large container ships processed: {z_large_sol:.0f}")
```
Answer:
Optimal objective value: 131.00
Number of small cargo vessel berths to open: 9
Number of large container ship berths to open: 3
Number of small cargo vessels processed: 101
Number of large container ships processed: 30


```

================================================================================



--- Problem 87 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port with three critical berths is experiencing recurring disruptions, each reducing the capacity of the main berths for varying durations. Port managers must dynamically divert ships to alternative berths during these disruptions to minimize total delay. Each berth has distinct characteristics: normal and reduced main berth capacities (e.g., Berth 1 handles 3,843 ships/h normally but drops to 2,213 ships/h during disruptions), alternative berth capacities (1,314–1,643 ships/h), and disruption durations (0.53–1.99 hours). Arrival rates fluctuate across four 30-minute periods (e.g., Berth 3 sees peaks of 4,917 ships/h in Period 1). Diversion options (10%, 30%, 50%, 70%) are available, but each choice affects delays: diverted ships incur extra travel time (0.14–0.22 hours), while non-diverted ships face queueing delays if main berth demand exceeds reduced capacity. The challenge is to assign the optimal diversion ratio for each berth and time period, balancing alternative berth congestion and main berth queue buildup to minimize the system-wide delay.

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable \( y(i, t, k) \): 1 if diversion option \( k \) (e.g., 30%) is selected for berth \( i \) in time period \( t \); 0 otherwise.  

**2. Parameters:**  
- \( \text{arrival_rates}[i][t] \): Ships arriving at berth \( i \) in period \( t \) (e.g., 3,571 ships/h for Berth 1, Period 1).  
- \( \text{capacities_main_normal}[i] \), \( \text{capacities_main_reduced}[i] \): Normal/reduced main berth capacities (ships/h).  
- \( \text{capacities_alt}[i] \): Alternative berth capacity (ships/h).  
- \( \text{alt_berth_extra_times}[i] \): Additional travel time (hours) for alternative berths.  
- \( \text{TIME_PERIOD_LENGTH} = 0.5 \) hours.  
- \( \text{LARGE_DELAY} = 10^{12} \): Penalty for infeasible options.  

**3. Objective Function:**  
Minimize total delay:  
\[ \text{Minimize: } \sum_{i,t,k} y(i,t,k) \cdot \text{berth_period_option_delays}[i][t][k] \]  
where delays combine alternative berth delays (\( \text{flow_alt} \times \text{extra time} \)) and main berth queue delays (calculated via dissipation logic).  

**4. Constraints:**  
- **Feasibility:** For each berth \( i \) and period \( t \), exactly one feasible diversion option must be selected:  
  \[ \sum_{k \in \text{feasible options}} y(i,t,k) = 1 \]  
- **Infeasibility:** Force \( y(i,t,k) = 0 \) if option \( k \) exceeds alternative berth capacity.  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 3
NUM_TIME_PERIODS = 4
TIME_PERIOD_LENGTH = 0.5  # h
capacities_main_normal = [3843, 4067, 4159]  # ships/h
capacities_main_reduced = [2213, 1473, 2023]  # ships/h
capacities_alt = [1314, 1108, 1643]  # ships/h
arrival_rates = [[3571, 2072, 2764, 2560], [3371, 4738, 3561, 4251], [4917, 4389, 4085, 2018]]  # ships/h
disruption_durations = [1.9948219288927107, 1.6717554471797413, 0.5296956656646191]  # h
alt_berth_extra_times = [0.204695259297482, 0.21717250421855394, 0.13928641856496304]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:

Berth 1:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)

Berth 2:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 0 (10%)

Berth 3:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 0 (10%)



================================================================================



--- Problem 88 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
In a busy port, a harbor master is responsible for allocating berths to incoming ships. The port has two berths: Berth A and Berth B. There are 72 ships that need to be assigned to these berths. Berth A can accommodate up to 30 ships, while Berth B can handle up to 42 ships. The primary goal is to minimize the number of ships assigned to Berth B, ensuring efficient use of resources and adhering to the capacity constraints of each berth. Overloading Berth B could lead to inefficiencies, while underutilizing it might leave demand unmet. The core question is: *What is the minimum number of ships that must be assigned to Berth B to fully deploy the fleet without exceeding either berth’s capacity?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n_A`: Integer variable representing the number of ships assigned to Berth A.  
     - `n_B`: Integer variable representing the number of ships assigned to Berth B.  
   - **2. Parameters:**  
     - `total_ships = 72`: Total ships available for assignment.  
     - `capacity_A = 30`: Maximum ships allowed in Berth A.  
     - `capacity_B = 42`: Maximum ships allowed in Berth B.  
   - **3. Objective Function:**  
     Minimize the number of ships in Berth B:  
     \[
     \text{Minimize: } n_B
     \]  
   - **4. Constraints:**  
     - All ships must be assigned:  
       \[
       n_A + n_B = 72
       \]  
     - Berth A capacity limit:  
       \[
       n_A \leq 30
       \]  
     - Berth B capacity limit:  
       \[
       n_B \leq 42
       \]  
     - Non-negativity and integer constraints for `n_A` and `n_B`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_ships = 72
capacity_A = 30
capacity_B = 42
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("SHIP_BERTH_ALLOCATION", env=env)

    # --- Decision Variables ---
    # n_A: number of ships assigned to berth A
    n_A = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_A")
    # n_B: number of ships assigned to berth B
    n_B = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_B")

    # --- Objective Function: Minimize the number of ships in berth B ---
    m.setObjective(n_B, GRB.MINIMIZE)

    # --- Constraints ---
    # All ships must be assigned
    m.addConstr(n_A + n_B == total_ships, "TotalShips")

    # Capacity constraint for berth A
    m.addConstr(n_A <= capacity_A, "CapacityA")

    # Capacity constraint for berth B
    m.addConstr(n_B <= capacity_B, "CapacityB")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_A_sol'] = n_A.X # Not needed for output
        # results_dict['n_B_sol'] = n_B.X # Not needed for output (obj_val)

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is number of ships, should be integer
             print(f"Optimal objective value: {int(round(obj_val_print))}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block to print the number of ships assigned to each berth)
if m.Status == GRB.OPTIMAL:
    n_A_sol = n_A.X
    n_B_sol = n_B.X
    print(f"Number of ships assigned to Berth A: {int(round(n_A_sol))}")
    print(f"Number of ships assigned to Berth B: {int(round(n_B_sol))}")
```
Answer:
Optimal objective value: 42
Number of ships assigned to Berth A: 30
Number of ships assigned to Berth B: 42


```

================================================================================



--- Problem 89 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
A logistics company operates a busy distribution center where six trucks must be serviced at one of three available loading platforms. Each platform has varying service times for each truck, and some platforms cannot service certain trucks at all (indicated by a service time of -1). For instance, Truck 0 takes 47 minutes on Platform 0, 57 minutes on Platform 1, and 97 minutes on Platform 2, while Truck 1 cannot be serviced on Platform 2 due to incompatibility. The goal is to assign each truck to exactly one available platform and schedule their service times such that no two trucks assigned to the same platform overlap in service. The objective is to minimize the total completion time across all trucks, ensuring efficient use of resources and minimizing delays. Additionally, the company wants to ensure that the total service time on each platform does not exceed 300 minutes.

The challenge lies in navigating the complex interdependencies between truck assignments and service sequencing. For example, assigning Truck 4 to Platform 1 (51 minutes) might conflict with Truck 5 (45 minutes) if scheduled improperly. The optimization must account for these constraints while ensuring that precedence relationships (which truck is serviced before another on the same platform) are logically enforced. The question is: **What is the optimal assignment and scheduling of trucks to platforms that minimizes the sum of all completion times, while ensuring the total service time on each platform does not exceed 300 minutes?**

**Modeling Process:**
**1. Decision Variables:**  
   - Binary variable \(x_{i,j}\): 1 if Truck \(i\) is assigned to Platform \(j\), 0 otherwise.  
   - Continuous variable \(s_i\): Start time of Truck \(i\).  
   - Continuous variable \(C_i\): Completion time of Truck \(i\) (defined as \(s_i + \text{service time}\)).  
   - Binary variable \(y_{i,k}\): 1 if Truck \(i\) precedes Truck \(k\) on any platform, 0 otherwise.  

   **2. Parameters:**  
   - **Trucks**: [0, 1, 2, 3, 4, 5].  
   - **Platforms**: [0, 1, 2].  
   - **Service Times**: Matrix where entry \([i][j]\) is the time for Truck \(i\) on Platform \(j\) (-1 if unavailable).  
   - **Big-M (M)**: A sufficiently large constant (3331) to enforce logical constraints.  

   **3. Objective Function:**  
   Minimize the total completion time:  
   \[
   \text{Minimize: } \sum_{i \in \text{trucks}} C_i
   \]  

   **4. Constraints:**  
   - **Assignment**: Each truck must be assigned to exactly one available platform:  
     \[
     \sum_{j \in \text{platforms}, \text{service\_times}[i][j] \neq -1} x_{i,j} = 1 \quad \forall i \in \text{trucks}.
     \]  
   - **Unavailable Platforms**: Trucks cannot be assigned to incompatible platforms:  
     \[
     x_{i,j} = 0 \quad \forall i, j \text{ where service\_times}[i][j] = -1.
     \]  
   - **Completion Time Definition**:  
     \[
     C_i = s_i + \sum_{j \in \text{platforms}} \text{service\_times}[i][j] \cdot x_{i,j} \quad \forall i \in \text{trucks}.
     \]  
   - **Non-Overlapping Service**: If two trucks \(i\) and \(k\) share a platform, one must precede the other:  
     \[
     s_k \geq C_i - M \cdot (1 - y_{i,k}) - M \cdot (2 - x_{i,j} - x_{k,j}) \quad \forall i, k \neq i, j \in \text{platforms},
     \]  
     \[
     s_i \geq C_k - M \cdot y_{i,k} - M \cdot (2 - x_{i,j} - x_{k,j}) \quad \forall i, k \neq i, j \in \text{platforms},
     \]  
     \[
     y_{i,k} + y_{k,i} = 1 \quad \forall i < k.
     \]  
   - **Total Service Time on Each Platform**: The total service time on each platform should not exceed 300 minutes:  
     \[
     \sum_{i \in \text{trucks}} \text{service\_times}[i][j] \cdot x_{i,j} \leq 300 \quad \forall j \in \text{platforms}.
     \]

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [0, 1, 2, 3, 4, 5]
platforms = [0, 1, 2]
# service_times[truck][platform], -1 means unavailable
service_times = [[47, 57, 97], [74, 115, 76], [44, 61, 71], [51, 84, 77], [55, 51, 104], [84, 45, 72]]
M = 3331 # Big M
MAX_SERVICE_TIME_PER_PLATFORM = 300
# --- End Parameters ---

GUROBI_TIME_LIMIT = 120

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    # env.setParam('MIPFocus', 1) # Optional: Focus on finding feasible solutions quickly
    env.start()

    # --- Model Creation ---
    m = gp.Model("TRUCK_DOCK_SCHEDULING", env=env)

    # --- Basic Input Validation ---
    if not trucks or not platforms:
        raise ValueError("Empty trucks or platforms list")
    if len(service_times) != len(trucks) or any(len(row) != len(platforms) for row in service_times):
         raise ValueError("Service times dimensions mismatch trucks/platforms")

    # --- Decision Variables ---
    # x[i, j] = 1 if truck i assigned to platform j
    x = m.addVars(trucks, platforms, vtype=GRB.BINARY, name="x")
    # s[i] = start time for truck i
    s = m.addVars(trucks, vtype=GRB.CONTINUOUS, lb=0, name="s")
    # C[i] = completion time for truck i
    C = m.addVars(trucks, vtype=GRB.CONTINUOUS, lb=0, name="C")
    # y[i, k] = 1 if truck i precedes truck k on the same platform
    # Define y only for i < k to avoid redundancy? No, original used i,k and k,i implicitly. Let's stick to original structure.
    y = m.addVars(trucks, trucks, vtype=GRB.BINARY, name="y")

    # --- Objective Function: Minimize the sum of completion times ---
    m.setObjective(gp.quicksum(C[i] for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # Each truck assigned to exactly one *available* platform
    for i in trucks:
        m.addConstr(gp.quicksum(x[i, j] for j in platforms if service_times[i][j] != -1) == 1, f"Assignment_{i}")

    # Ensure assignment is 0 if platform is unavailable
    for i in trucks:
        for j in platforms:
            if service_times[i][j] == -1:
                m.addConstr(x[i, j] == 0, f"Unavailable_{i}_{j}")

    # Completion time definition (C[i] = s[i] + ActualServiceTime[i])
    m.addConstrs((C[i] == s[i] + gp.quicksum(service_times[i][j] * x[i, j]
                                            for j in platforms if service_times[i][j] != -1)
                 for i in trucks), "CompletionTime")

    # Non-overlapping constraint (Big-M) for pairs on the same platform
    for j in platforms:
        for i in trucks:
            for k in trucks:
                if i != k: # Consider distinct pairs
                    xi_j = x.get((i, j))
                    xk_j = x.get((k, j))
                    yi_k = y.get((i, k))
                    yk_i = y.get((k, i)) # Need both y[i,k] and y[k,i]

                    if xi_j is not None and xk_j is not None and yi_k is not None and yk_i is not None:
                        # If i before k (y[i,k]=1), then s[k] >= C[i]. Enforced by:
                        m.addConstr(s[k] >= C[i] - M * (1 - yi_k) - M * (2 - xi_j - xk_j), f"NonOverlap1_{i}_{k}_{j}")
                        # If k before i (y[k,i]=1, so yi_k=0), then s[i] >= C[k]. Enforced by:
                        m.addConstr(s[i] >= C[k] - M * yi_k - M * (2 - xi_j - xk_j), f"NonOverlap2_{i}_{k}_{j}")

                        # Ensure y[i,k] + y[k,i] = 1 if they are on the same pump j
                        if i < k:
                             m.addConstr(yi_k + yk_i == 1, f"PrecRel_{i}_{k}") # Assume one must precede the other globally

    # Total service time on each platform should not exceed 300 minutes
    for j in platforms:
        m.addConstr(gp.quicksum(service_times[i][j] * x[i, j] for i in trucks if service_times[i][j] != -1) <= MAX_SERVICE_TIME_PER_PLATFORM, f"MaxServiceTime_{j}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['C_sol'] = m.getAttr('X', C) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible") # Matches example
    elif m.Status == GRB.TIME_LIMIT:
         print(f"Optimization ended with status {m.Status}") # Matches example's generic else
    else: # Other statuses
        print(f"Optimization ended with status {m.Status}") # Matches example's generic else


except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the assignment and scheduling details
if m.Status == GRB.OPTIMAL:
    print(f"Optimal objective value: {obj_val_print:.2f}")
    for i in trucks:
        for j in platforms:
            if x[i, j].X > 0.5:
                print(f"Truck {i} is assigned to Platform {j} with start time {s[i].X:.2f} and completion time {C[i].X:.2f}")
    for j in platforms:
        total_service_time = sum(service_times[i][j] * x[i, j].X for i in trucks if service_times[i][j] != -1)
        print(f"Total service time on Platform {j}: {total_service_time:.2f} minutes")
```
Answer:
Optimal objective value: 494.00
Optimal objective value: 494.00
Truck 0 is assigned to Platform 0 with start time 44.00 and completion time 91.00
Truck 1 is assigned to Platform 2 with start time 0.00 and completion time 76.00
Truck 2 is assigned to Platform 0 with start time 0.00 and completion time 44.00
Truck 3 is assigned to Platform 0 with start time 91.00 and completion time 142.00
Truck 4 is assigned to Platform 1 with start time 45.00 and completion time 96.00
Truck 5 is assigned to Platform 1 with start time 0.00 and completion time 45.00
Total service time on Platform 0: 142.00 minutes
Total service time on Platform 1: 96.00 minutes
Total service time on Platform 2: 76.00 minutes


```

================================================================================



--- Problem 90 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
In a busy port, a critical berthing operation must efficiently allocate 15 uniquely colored containers into berths while adhering to strict capacity and color diversity rules. Each container has a specific weight (ranging from 20 to 66 units) and is labeled with one of 11 distinct colors: 'R', 'U', 'P', 'M', 'V', 'I', 'L', 'S', 'J', 'D', 'W', or 'G'. The berths have a fixed capacity of 69 weight units, and no berth can contain containers with more than two distinct colors. The challenge is to minimize the total number of berths used while ensuring all containers are packed, no berth exceeds its weight limit, and the color constraints are satisfied. This problem mirrors real-world scenarios in maritime logistics, where space optimization and categorization constraints are paramount. The central question is: **What is the smallest number of berths required to pack all containers under these constraints?**

**Modeling Process:**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether container `i` is placed in berth `j`.  
   - `y[j]`: Binary variable indicating whether berth `j` is used.  
   - `z[c, j]`: Binary variable indicating whether color `c` is present in berth `j`.  

   **2. Parameters:**  
   - `containers`: List of container weights: `[47, 54, 33, ..., 23]` (15 containers).  
   - `colors`: List of container colors: `['R', 'U', ..., 'G']` (15 entries).  
   - `capacity`: Berth weight limit (69 units).  
   - `unique_colors_list`: Sorted list of distinct colors (11 unique values).  

   **3. Objective Function:**  
   Minimize the total number of berths used:  
   ```  
   Minimize: sum(y[j] for all j)  
   ```  

   **4. Constraints:**  
   - **Container Assignment:** Each container must be placed in exactly one berth:  
     ```  
     For each container i: sum(x[i, j] for all j) == 1  
     ```  
   - **Berth Capacity:** The total weight in any berth cannot exceed its capacity:  
     ```  
     For each berth j: sum(containers[i] * x[i, j] for all i) <= capacity * y[j]  
     ```  
   - **Color Linking:** If a container of color `c` is in berth `j`, `z[c, j]` must be 1:  
     ```  
     For each berth j and color c: x[i, j] <= z[c, j] for all containers i of color c  
     ```  
   - **Color Limit:** No berth can contain more than 2 distinct colors if used:  
     ```  
     For each berth j: sum(z[c, j] for all c) <= 2 * y[j]  
     ```  

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
containers = [47, 54, 33, 47, 54, 57, 66, 35, 61, 28, 20, 42, 46, 20, 23]      # Weights of containers
colors = ['R', 'U', 'P', 'M', 'V', 'I', 'L', 'S', 'J', 'D', 'W', 'M', 'L', 'J', 'G']    # Colors of containers
capacity = 69         # Berth capacity
num_containers = 15       # len(containers) - derived correctly below
num_berths = num_containers      # Maximum berths (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(containers) != len(colors) or len(containers) != num_containers:
    print("Error: Data inconsistency (containers/colors/num_containers length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_colors_list = sorted(list(set(colors))) # Get unique colors deterministically
container_indices_by_color = {color: [i for i, c in enumerate(colors) if c == color] for color in unique_colors_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Color-Constrained Berth Packing", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_containers, num_berths, vtype=GRB.BINARY, name="x")  # x[i,j] -> container i in berth j
        y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")              # y[j] -> whether berth j is used
        # z[c,j] -> whether color c is PRESENT in berth j (Use unique_colors_list for keys)
        z = model.addVars(unique_colors_list, num_berths, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of berths used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each container must be assigned to exactly one berth ---
        for i in range(num_containers):
            model.addConstr(x.sum(i, '*') == 1, name=f"Container_{i}_Assignment")

        # --- Constraint 2: Berth capacity constraint ---
        for j in range(num_berths):
            model.addConstr(gp.quicksum(containers[i] * x[i, j] for i in range(num_containers)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

        # --- Constraint 3: Color constraint (at most 2 *different* colors per berth) ---

        # Part 3a: Link x (container in berth) and z (color in berth).
        for j in range(num_berths):
            for color in unique_colors_list:
                indices_of_this_color = container_indices_by_color.get(color, []) # Use .get for safety

                if not indices_of_this_color:
                    # If no containers of this color exist, z[color, j] must be 0.
                    model.addConstr(z[color, j] == 0, name=f"NoContainers_{color}_Berth_{j}")
                    continue

                # If any container 'i' of this 'color' is placed in berth 'j' (x[i,j]=1),
                # then the presence indicator for that 'color' in berth 'j' (z[color,j]) must be 1.
                for i in indices_of_this_color:
                    model.addConstr(x[i, j] <= z[color, j], name=f"Link_x{i}_z{color}_Berth{j}")

                # Ensure z[color, j] is 0 if no containers of that color are in the berth.
                # This helps tighten the formulation.
                model.addConstr(z[color, j] <= gp.quicksum(x[i, j] for i in indices_of_this_color), name=f"Link_z{color}_SumX_Berth{j}")


        # Part 3b: Limit the number of distinct colors (sum of z[c,j] for berth j) to 2 for USED berths.
        for j in range(num_berths):
            # sum(z[c,j] for c in unique_colors_list) gives the count of distinct colors in berth j.
            # This sum must be <= 2 *IF* the berth is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Colors_Berth_{j}")

        # --- Solve ---
        print("Solving CCBP instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of berths used: {optimal_berths}")
    print("-" * 30)

    berth_details = []
    printed_berth_count = 0
    for j_sol in range(num_berths): # Iterate through all potential berth indices
        try:
             # Check if this berth was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_berth_count += 1
                 assigned_containers_indices = [i for i in range(num_containers) if x[i, j_sol].X > 0.5]
                 assigned_containers_weights = [containers[i] for i in assigned_containers_indices]
                 assigned_containers_colors = [colors[i] for i in assigned_containers_indices]
                 distinct_colors_in_berth = sorted(list(set(assigned_containers_colors))) # Sort for consistent output
                 berth_load = sum(assigned_containers_weights)

                 print(f"Berth {printed_berth_count} (Internal Index {j_sol}):")
                 print(f"  Containers (indices): {assigned_containers_indices}")
                 # print(f"  Containers (weights): {assigned_containers_weights}") # Optional details
                 # print(f"  Containers (colors):  {assigned_containers_colors}") # Optional details
                 print(f"  Distinct Colors: {distinct_colors_in_berth} (Count: {len(distinct_colors_in_berth)})")
                 print(f"  Total weight:    {berth_load} / {capacity}")
                 print("-" * 10)

                 berth_data = {
                     'berth_index_internal': j_sol,
                     'berth_index_printed': printed_berth_count,
                     'container_indices': assigned_containers_indices,
                     'distinct_colors': distinct_colors_in_berth,
                     'load': berth_load
                 }
                 berth_details.append(berth_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for berth index {j_sol}: {e_print}")


    results_dict['berth_details'] = berth_details # Store details

    # Final sanity check
    if printed_berth_count != optimal_berths:
         print(f"Warning: Number of printed used berths ({printed_berth_count}) does not match objective value ({optimal_berths}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# The provided code already prints the key outputs, including the optimal number of berths used and detailed information for each berth.
# No additional print statements are necessary.
```
Answer:
Solving CCBP instance...
------------------------------

Optimal solution found.
Optimal number of berths used: 11
------------------------------
Berth 1 (Internal Index 0):
  Containers (indices): [8]
  Distinct Colors: ['J'] (Count: 1)
  Total weight:    61 / 69
----------
Berth 2 (Internal Index 4):
  Containers (indices): [3]
  Distinct Colors: ['M'] (Count: 1)
  Total weight:    47 / 69
----------
Berth 3 (Internal Index 5):
  Containers (indices): [9]
  Distinct Colors: ['D'] (Count: 1)
  Total weight:    28 / 69
----------
Berth 4 (Internal Index 6):
  Containers (indices): [2, 7]
  Distinct Colors: ['P', 'S'] (Count: 2)
  Total weight:    68 / 69
----------
Berth 5 (Internal Index 7):
  Containers (indices): [12, 13]
  Distinct Colors: ['J', 'L'] (Count: 2)
  Total weight:    66 / 69
----------
Berth 6 (Internal Index 8):
  Containers (indices): [4]
  Distinct Colors: ['V'] (Count: 1)
  Total weight:    54 / 69
----------
Berth 7 (Internal Index 9):
  Containers (indices): [5]
  Distinct Colors: ['I'] (Count: 1)
  Total weight:    57 / 69
----------
Berth 8 (Internal Index 11):
  Containers (indices): [11, 14]
  Distinct Colors: ['G', 'M'] (Count: 2)
  Total weight:    65 / 69
----------
Berth 9 (Internal Index 12):
  Containers (indices): [6]
  Distinct Colors: ['L'] (Count: 1)
  Total weight:    66 / 69
----------
Berth 10 (Internal Index 13):
  Containers (indices): [0, 10]
  Distinct Colors: ['R', 'W'] (Count: 2)
  Total weight:    67 / 69
----------
Berth 11 (Internal Index 14):
  Containers (indices): [1]
  Distinct Colors: ['U'] (Count: 1)
  Total weight:    54 / 69
----------


```

================================================================================



--- Problem 91 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy container terminal is tasked with efficiently scheduling the unloading of six incoming cargo trucks at two available depots, each with specific capabilities. Trucks arrive at staggered times: Truck 1 at 2 hours, Truck 2 at 5, Truck 3 at 10, Truck 4 at 15, Truck 5 at 16, and Truck 6 at 17. Each truck has a unique processing time, ranging from 5 to 8 hours, and belongs to one of two types: 'A' or 'B'. The depots have limited compatibility—Depot 1 can handle types 'D' and 'B', while Depot 2 accommodates types 'D' and 'A'. The terminal manager must assign each truck to a compatible depot while ensuring no two trucks scheduled at the same depot overlap in time. The goal is to minimize the total waiting time (start time minus arrival time) across all trucks, ensuring efficient use of resources and timely departures.  

**Key Question:** What is the optimal assignment of trucks to depots that minimizes total waiting time while respecting compatibility and scheduling constraints?  

---
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `assign(i, j)`: Binary variable (1 if truck *i* is assigned to depot *j*, 0 otherwise).  
- `start_time(i)`: Continuous variable representing the start time of truck *i*.  
- `completion_time(i)`: Continuous variable representing the completion time of truck *i*.  
- `precedes(i, k, j)`: Binary variable (1 if truck *i* is scheduled before truck *k* on depot *j*, 0 otherwise).  

**2. Parameters:**  
- `trucks`: [1, 2, 3, 4, 5, 6]  
- `depots`: [1, 2]  
- `arrival_times`: {1: 2, 2: 5, 3: 10, 4: 15, 5: 16, 6: 17}  
- `processing_times`: {1: 7, 2: 7, 3: 6, 4: 5, 5: 8, 6: 7}  
- `truck_types`: {1: 'A', 2: 'A', 3: 'B', 4: 'A', 5: 'A', 6: 'B'}  
- `depot_capabilities`: {1: ['D', 'B'], 2: ['D', 'A']}  
- `H`: Large constant (100) for linearization.  

**3. Objective Function:**  
Minimize the total waiting time:  
\[
\text{Minimize: } \sum_{i \in \text{trucks}} (\text{start_time}(i) - \text{arrival_times}(i))
\]

**4. Constraints:**  
- **Assignment:** Each truck must be assigned to exactly one depot:  
  \[
  \sum_{j \in \text{depots}} \text{assign}(i, j) = 1 \quad \forall i \in \text{trucks}
  \]  
- **Arrival Time:** Trucks cannot start before arrival:  
  \[
  \text{start_time}(i) \geq \text{arrival_times}(i) \quad \forall i \in \text{trucks}
  \]  
- **Completion Time:** Processing time must be accounted for:  
  \[
  \text{completion_time}(i) = \text{start_time}(i) + \text{processing_times}(i) \quad \forall i \in \text{trucks}
  \]  
- **Non-Overlapping:** For trucks on the same depot, enforce precedence:  
  \[
  \text{If } \text{precedes}(i, k, j) = 1 \Rightarrow \text{start_time}(k) \geq \text{completion_time}(i) \quad \forall i < k, j
  \]  
  \[
  \text{If } \text{precedes}(i, k, j) = 0 \Rightarrow \text{start_time}(i) \geq \text{completion_time}(k) \quad \forall i < k, j
  \]  
- **Compatibility:** Trucks can only be assigned to compatible depots:  
  \[
  \text{assign}(i, j) = 0 \quad \text{if truck type of } i \notin \text{depot_capabilities}(j)
  \]  

---

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
depots = [1, 2]
arrival_times = {1: 2, 2: 5, 3: 10, 4: 15, 5: 16, 6: 17}
processing_times = {1: 7, 2: 7, 3: 6, 4: 5, 5: 8, 6: 7}
truck_types = {1: 'A', 2: 'A', 3: 'B', 4: 'A', 5: 'A', 6: 'B'} # Dict {truck_id: type_str}
depot_capabilities = {1: ['D', 'B'], 2: ['D', 'A']} # Dict {depot_id: [list_of_types]}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Compatibility Constraint
    for i in trucks:
        truck_type = truck_types.get(i)
        if truck_type:
             for j in depots:
                 allowed_types = depot_capabilities.get(j, [])
                 if truck_type not in allowed_types:
                     m.addConstr(assign[i, j] == 0, name=f"compatibility_{i}_{j}")
        else: print(f"Warning: Truck type unknown for {i}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the assignment of trucks to depots and their start and completion times
if m.status == GRB.OPTIMAL:
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.2f}, Completion Time: {completion_time[i].x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
44.0000
Truck 1 is assigned to Depot 2
Start Time: 2.00, Completion Time: 9.00
Truck 2 is assigned to Depot 2
Start Time: 9.00, Completion Time: 16.00
Truck 3 is assigned to Depot 1
Start Time: 21.00, Completion Time: 27.00
Truck 4 is assigned to Depot 2
Start Time: 16.00, Completion Time: 21.00
Truck 5 is assigned to Depot 2
Start Time: 34.00, Completion Time: 42.00
Truck 6 is assigned to Depot 1
Start Time: 27.00, Completion Time: 34.00


```

================================================================================



--- Problem 92 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling five incoming trucks at its two available depots. Each truck arrives at a specific time: Truck 1 at hour 5, Truck 2 at hour 7, Truck 3 at hour 8, Truck 4 at hour 11, and Truck 5 at hour 14. The processing times vary—Truck 1 and Truck 2 each require 7 hours, Truck 3 needs 3 hours, Truck 4 takes 8 hours, and Truck 5 is quicker at 4 hours. Delays are costly: waiting costs per hour are $134 for Truck 1, $96 for Truck 2, $126 for Truck 3, $92 for Truck 4, and $130 for Truck 5. Additionally, servicing each truck at a depot incurs hourly costs, which differ by truck and depot. For example, servicing Truck 1 at Depot 1 costs $42/hour, while at Depot 2, it’s $64/hour. The logistics manager must assign each truck to exactly one depot and schedule their start times to minimize the total cost, which includes both waiting and servicing expenses. The core challenge is: *What is the optimal assignment and scheduling plan to minimize the total cost while ensuring no two trucks overlap at the same depot?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign[i, j]`: Binary variable (1 if Truck *i* is assigned to Depot *j*, 0 otherwise).  
     - `start_time[i]`: Continuous variable representing the start time of Truck *i*.  
     - `completion_time[i]`: Continuous variable representing the completion time of Truck *i*.  
     - `precedes[i, k, j]`: Binary variable (1 if Truck *i* precedes Truck *k* on Depot *j*, 0 otherwise).  

   - **2. Parameters:**  
     - `arrival_times[i]`: Arrival time of Truck *i*.  
     - `processing_times[i]`: Processing time of Truck *i*.  
     - `waiting_costs[i]`: Cost per hour of Truck *i* waiting.  
     - `service_costs[i, j]`: Cost per hour of servicing Truck *i* at Depot *j*.  
     - `H`: A large constant (100) for big-M constraints.  

   - **3. Objective Function:**  
     Minimize the sum of waiting costs and service costs:  
     ```
     Minimize: sum(waiting_costs[i] * (start_time[i] - arrival_times[i]) for all i) 
              + sum(service_costs[i, j] * processing_times[i] * assign[i, j] for all i, j)
     ```  

   - **4. Constraints:**  
     - **Assignment:** Each truck must be assigned to exactly one depot:  
       `sum(assign[i, j] for all j) = 1` for each Truck *i*.  
     - **Arrival Time:** Start time cannot be earlier than arrival time:  
       `start_time[i] >= arrival_times[i]` for each Truck *i*.  
     - **Completion Time:** Completion time is start time plus processing time:  
       `completion_time[i] = start_time[i] + processing_times[i]` for each Truck *i*.  
     - **Non-Overlapping:** If two trucks *i* and *k* are assigned to the same depot *j*, one must precede the other:  
       If `precedes[i, k, j] = 1`, then `start_time[k] >= completion_time[i]`.  
       If `precedes[i, k, j] = 0`, then `start_time[i] >= completion_time[k]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2]
arrival_times = {1: 5, 2: 7, 3: 8, 4: 11, 5: 14}
processing_times = {1: 7, 2: 7, 3: 3, 4: 8, 5: 4}
waiting_costs = {1: 134, 2: 96, 3: 126, 4: 92, 5: 130} # Cost per hour waiting
service_costs = {(1, 1): 42, (1, 2): 64, (2, 1): 40, (2, 2): 66, (3, 1): 54, (3, 2): 50, (4, 1): 59, (4, 2): 61, (5, 1): 49, (5, 2): 42} # Cost rate per hour servicing {(truck, depot): cost}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes") # y[i,k,j] = 1 if i before k on j

    # --- Objective Function ---
    waiting_cost_expr = gp.quicksum(waiting_costs.get(i, 0) * (start_time[i] - arrival_times.get(i, 0)) for i in trucks)
    service_cost_expr = gp.quicksum(service_costs.get((i,j), 0) * processing_times.get(i, 0) * assign[i,j]
                                   for i in trucks for j in depots)
    m.setObjective(waiting_cost_expr + service_cost_expr, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Assignment and Scheduling Plan:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.2f}, Completion Time: {completion_time[i].x:.2f}")
    print(f"Total Cost: {results_dict['obj_val']:.4f}")
# --- End of Supplemental Code Block ---
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
4530.0000
Optimal Assignment and Scheduling Plan:
Truck 1 is assigned to Depot 1
Start Time: 5.00, Completion Time: 12.00
Truck 2 is assigned to Depot 1
Start Time: 19.00, Completion Time: 26.00
Truck 3 is assigned to Depot 2
Start Time: 12.00, Completion Time: 15.00
Truck 4 is assigned to Depot 1
Start Time: 26.00, Completion Time: 34.00
Truck 5 is assigned to Depot 2
Start Time: 15.00, Completion Time: 19.00
Total Cost: 4530.0000


```

================================================================================



--- Problem 93 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy port, five distinct berths—Berth A through Berth E—each have a pool of available cranes and a specific demand for unloading cargo. The challenge lies in ensuring that each berth has enough cranes to meet its demand without unnecessary relocations, which incur costs. Berth A has 87 cranes available but only needs 70, while Berth B has 167 cranes against a demand of 134. Similarly, Berth C has 103 cranes for 72 cargo operations, Berth D has 121 for 102, and Berth E has 88 for 61. The cost of moving a crane between berths varies: for instance, relocating a crane from Berth A to Berth D costs $3, while moving from Berth B to Berth A costs just $1. The goal is to determine whether any crane relocations are necessary to meet demand or if the existing distribution is already optimal. The central question is: *What is the most cost-effective way to allocate cranes across berths to satisfy all demand, and what is the minimum total relocation cost required?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `stay[b]`: Number of cranes remaining in berth `b` (continuous, non-negative).  
   - `move[i, j]`: Number of cranes moving from berth `i` to berth `j` (continuous, non-negative).  

   **2. Parameters:**  
   - `supply[b]`: Total cranes available in berth `b` (e.g., `supply['Berth_A'] = 87`).  
   - `demand[b]`: Cranes required in berth `b` (e.g., `demand['Berth_A'] = 70`).  
   - `move_costs[(i, j)]`: Cost per crane moved from `i` to `j` (e.g., `move_costs[('Berth_A', 'Berth_B')] = 14`).  

   **3. Objective Function:**  
   Minimize the total relocation cost:  
   ```  
   Minimize: sum(move[i, j] * move_costs[i, j] for all (i, j) in move_costs)  
   ```  

   **4. Constraints:**  
   - **Supply constraints:** For each berth `b`, the sum of cranes staying and those moving out must equal the supply:  
     ```  
     stay[b] + sum(move[b, j] for all j ≠ b) == supply[b]  
     ```  
   - **Demand constraints:** For each berth `b`, the sum of cranes staying and those moving in must meet or exceed demand:  
     ```  
     stay[b] + sum(move[j, b] for all j ≠ b) >= demand[b]  
     ```  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
berths = ['Berth_A', 'Berth_B', 'Berth_C', 'Berth_D', 'Berth_E']
supply = {'Berth_A': 87, 'Berth_B': 167, 'Berth_C': 103, 'Berth_D': 121, 'Berth_E': 88}
demand = {'Berth_A': 70, 'Berth_B': 134, 'Berth_C': 72, 'Berth_D': 102, 'Berth_E': 61}
move_costs = {('Berth_A', 'Berth_B'): 14, ('Berth_A', 'Berth_C'): 13, ('Berth_A', 'Berth_D'): 3, ('Berth_A', 'Berth_E'): 11, ('Berth_B', 'Berth_A'): 1, ('Berth_B', 'Berth_C'): 8, ('Berth_B', 'Berth_D'): 2, ('Berth_B', 'Berth_E'): 5, ('Berth_C', 'Berth_A'): 5, ('Berth_C', 'Berth_B'): 13, ('Berth_C', 'Berth_D'): 4, ('Berth_C', 'Berth_E'): 2, ('Berth_D', 'Berth_A'): 3, ('Berth_D', 'Berth_B'): 11, ('Berth_D', 'Berth_C'): 11, ('Berth_D', 'Berth_E'): 12, ('Berth_E', 'Berth_A'): 15, ('Berth_E', 'Berth_B'): 15, ('Berth_E', 'Berth_C'): 6, ('Berth_E', 'Berth_D'): 13} # Dict (from, to): cost
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m29 = gp.Model("CRANE_ALLOCATION_LP", env=env)

    # --- Decision Variables ---
    # Number of cranes moving between berths (use actual keys from move_costs)
    move_keys = list(move_costs.keys())
    move = m29.addVars(move_keys, name="move", lb=0)
    # Number of cranes staying in their berths
    stay = m29.addVars(berths, name="stay", lb=0)

    # --- Objective Function ---
    # Minimize total cost of moving cranes
    m29.setObjective(gp.quicksum(move[i, j] * move_costs[i, j] for i, j in move_keys), sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Crane source constraints (Cranes in berth must either stay or move out)
    for b in berths:
        # Sum outgoing moves using .get() for safety, although all keys should exist
        outgoing_moves = gp.quicksum(move.get((b, other_b), 0) for other_b in berths if b != other_b and (b, other_b) in move)
        m29.addConstr(stay[b] + outgoing_moves == supply[b], name=f"supply_{b}")

    # Demand satisfaction constraints (Cranes available in berth = stayed + moved in)
    for b in berths:
        # Sum incoming moves using .get()
        incoming_moves = gp.quicksum(move.get((other_b, b), 0) for other_b in berths if b != other_b and (other_b, b) in move)
        m29.addConstr(stay[b] + incoming_moves >= demand[b], name=f"demand_{b}")

    # --- Optimization ---
    m29.optimize()

    # --- Store results ---
    results_dict['status'] = m29.status
    if m29.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m29.ObjVal
        results_dict['stay_sol'] = m29.getAttr('X', stay)
        results_dict['move_sol'] = m29.getAttr('X', move)


    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- CRANE_ALLOCATION: Port Crane Allocation (LP) ---")
    if m29.status == GRB.OPTIMAL:
        stay_sol = results_dict.get('stay_sol', {})
        move_sol = results_dict.get('move_sol', {})
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Minimum Crane Moving Cost: ${obj_val_print:.2f}")
        print("Cranes Allocation:")
        for b in berths:
             print(f"  Stay in {b}: {stay_sol.get(b, 0):.1f}")

        total_moved = 0
        for (i, j), cost in move_costs.items():
            moved_val = move_sol.get((i,j), 0)
            if moved_val > 1e-4: # Print only if non-negligible move
                 print(f"  Move {i} -> {j}: {moved_val:.1f} (Cost/crane: ${cost})")
                 total_moved += moved_val
        print(f"  Total Cranes Moved: {total_moved:.1f}")


        print("\nBerth Fulfillment:")
        total_supply_check = sum(supply.values())
        total_demand_check = sum(demand.values())
        total_final_cranes = 0
        for b in berths:
            stayed = stay_sol.get(b, 0)
            moved_in = sum(move_sol.get((other_b, b), 0) for other_b in berths if b != other_b)
            final_cranes = stayed + moved_in
            total_final_cranes += final_cranes
            print(f"  Berth {b}: Has {final_cranes:.1f} cranes (Need: {demand.get(b, 'N/A')}, Supply: {supply.get(b, 'N/A')})")
        print(f"Total Cranes Accounted For: {total_final_cranes:.1f} (Initial Total Supply: {total_supply_check})")


    elif m29.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible.")
         # Calculate totals directly from input params for this message
         print(f"Total Supply Available: {sum(supply.values())}")
         print(f"Total Demand Required: {sum(demand.values())}")
         print("(Check if total supply >= total demand and if movement allows meeting local demand)")
    elif m29.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m29.ObjVal is not None and abs(m29.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m29.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m29.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- CRANE_ALLOCATION: Port Crane Allocation (LP) ---
Optimization Status: Optimal
Minimum Crane Moving Cost: $0.00
Cranes Allocation:
  Stay in Berth_A: 87.0
  Stay in Berth_B: 167.0
  Stay in Berth_C: 103.0
  Stay in Berth_D: 121.0
  Stay in Berth_E: 88.0
  Total Cranes Moved: 0.0

Berth Fulfillment:
  Berth Berth_A: Has 87.0 cranes (Need: 70, Supply: 87)
  Berth Berth_B: Has 167.0 cranes (Need: 134, Supply: 167)
  Berth Berth_C: Has 103.0 cranes (Need: 72, Supply: 103)
  Berth Berth_D: Has 121.0 cranes (Need: 102, Supply: 121)
  Berth Berth_E: Has 88.0 cranes (Need: 61, Supply: 88)
Total Cranes Accounted For: 566.0 (Initial Total Supply: 566)


```

================================================================================



--- Problem 94 ---
**Difficulty:** very hard
**Category:** NLP

**Problem Description:**
**
A port faces a critical ship berthing management challenge during an incident that reduces the capacity of the main berth. The incident lasts approximately 1.39 hours, during which the main berth's capacity drops from 4,619.09 ships per hour (ships/h) to 3,099.04 ships/h. Meanwhile, an alternative berth with a fixed capacity of 2,135.90 ships/h is available, but using it incurs additional handling time due to congestion effects modeled by the BPR (Bureau of Public Roads) function. The total arrival rate of ships to the port is 4,112.27 ships/h, creating a delicate balance between rerouting ships to the alternative berth and managing congestion on the main berth.

The core challenge is to minimize the total system delay, which includes the additional handling time for ships diverted to the alternative berth and the queuing delay on the main berth. The BPR function parameters (α = 0.141, β = 2.866) dictate how handling time on the alternative berth increases with traffic volume. Additionally, the model must account for the queue formation and dissipation dynamics on the main berth, ensuring that the solution optimally balances flow allocation between the two berths.

The key question is: *What is the optimal split of ships between the main and alternative berths to minimize the total system delay, considering congestion effects, incident duration, and queue dynamics?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `flow_alt`: Flow rate (ships/h) diverted to the alternative berth.  
- `flow_main`: Flow rate (ships/h) remaining on the main berth.  
- `T_alt_actual`: Actual handling time (h) on the alternative berth, accounting for congestion.  
- `vol_cap_ratio`: Ratio of flow to capacity on the alternative berth.  
- `vol_cap_pow_beta`: The term `(vol_cap_ratio)^β` used in the BPR function.  
- `max_queue_main`: Maximum queue length (ships) on the main berth.  
- `dissipation_time_main`: Time (h) required to clear the queue after the incident ends.  
- `dissipation_rate_main`: Rate (ships/h) at which the queue dissipates.  

**2. Parameters:**  
- `capacity_main_normal`: Normal main berth capacity (4,619.09 ships/h).  
- `capacity_main_reduced`: Reduced main berth capacity during incident (3,099.04 ships/h).  
- `capacity_alt`: Alternative berth capacity (2,135.90 ships/h).  
- `arrival_rate_total`: Total ship arrival rate (4,112.27 ships/h).  
- `incident_duration`: Duration of the incident (1.3877 h).  
- `T0_alt`: Free-flow handling time on the alternative berth (0.3665 h).  
- `bpr_alpha`, `bpr_beta`: BPR function parameters (0.141, 2.866).  

**3. Objective Function:**  
Minimize the total system delay (ship-hours), composed of:  
- Additional handling time on the alternative berth: `incident_duration * flow_alt * (T_alt_actual - T0_alt)`  
- Queuing delay on the main berth: `0.5 * incident_duration * max_queue_main + 0.5 * max_queue_main * dissipation_time_main`  

**4. Constraints:**  
- **Flow conservation:** `flow_main + flow_alt = arrival_rate_total`  
- **Alternative berth capacity:** `flow_alt ≤ capacity_alt`  
- **Volume-capacity ratio:** `vol_cap_ratio = flow_alt / capacity_alt`  
- **BPR handling time:** `T_alt_actual = T0_alt * (1 + bpr_alpha * vol_cap_pow_beta)`  
- **Queue growth rate:** `queue_growth_rate = max(0, flow_main - capacity_main_reduced)`  
- **Max queue length:** `max_queue_main = queue_growth_rate * incident_duration`  
- **Dissipation dynamics:** `dissipation_rate_main = capacity_main_normal - flow_main`  
- **Queue clearance time:** `dissipation_time_main * dissipation_rate_main = max_queue_main`  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
capacity_main_normal = 4619.091904479548  # ships/h
capacity_main_reduced = 3099.0361588951314  # ships/h
capacity_alt = 2135.899282662635  # ships/h
arrival_rate_total = 4112.271252754545  # ships/h
incident_duration = 1.3876525214185647  # h
T0_alt = 0.36653252010360704  # h
bpr_alpha = 0.1411926123292767
bpr_beta = 2.865714725911453
EPSILON = 1e-6

# --- Gurobi Model ---
model = gp.Model("BerthRerouting")

# Decision Variables
flow_alt = model.addVar(name="flow_alt", lb=0.0, ub=arrival_rate_total)
flow_main = model.addVar(name="flow_main", lb=0.0)

# Intermediate Variables
T_alt_actual = model.addVar(name="T_alt_actual", lb=T0_alt)
vol_cap_ratio = model.addVar(name="vol_cap_ratio", lb=0.0)
vol_cap_pow_beta = model.addVar(name="vol_cap_pow_beta", lb=0.0)
max_queue_main = model.addVar(name="max_queue_main", lb=0.0)
dissipation_time_main = model.addVar(name="dissipation_time_main", lb=0.0)
dissipation_rate_main = model.addVar(name="dissipation_rate_main", lb=EPSILON)

# Constraints
model.addConstr(flow_main + flow_alt == arrival_rate_total, name="FlowConservation")
model.addConstr(flow_alt <= capacity_alt, name="AltBerthCapacity")
model.addConstr(vol_cap_ratio <= 1.0, name="VolCapRatioLimit")
model.addConstr(vol_cap_ratio * capacity_alt == flow_alt, name="CalcVolCapRatio")
model.addGenConstrPow(vol_cap_ratio, vol_cap_pow_beta, bpr_beta, name="CalcPowerTerm")
model.addConstr(T_alt_actual == T0_alt * (1.0 + bpr_alpha * vol_cap_pow_beta), name="CalcActualAltTime")

# Queue calculations
queue_growth_rate = model.addVar(name="queue_growth_rate", lb=0.0)
aux_growth_input = model.addVar(name="aux_growth_input", lb=-GRB.INFINITY)
model.addConstr(aux_growth_input == flow_main - capacity_main_reduced, name="CalcAuxGrowthInput")
model.addGenConstrMax(queue_growth_rate, [aux_growth_input], 0.0, name="CalcQueueGrowthRate")
model.addConstr(max_queue_main == queue_growth_rate * incident_duration, name="CalcMaxQueue")

# Dissipation calculations
model.addConstr(dissipation_rate_main == capacity_main_normal - flow_main, name="CalcDissipationRate")
model.addQConstr(dissipation_time_main * dissipation_rate_main == max_queue_main, name="CalcDissipationTime")

# Objective
obj = gp.QuadExpr()
obj += incident_duration * flow_alt * T_alt_actual - incident_duration * T0_alt * flow_alt
obj += 0.5 * incident_duration * max_queue_main
obj += 0.5 * max_queue_main * dissipation_time_main
model.setObjective(obj, GRB.MINIMIZE)

# Optimize
model.Params.NonConvex = 2
model.optimize()

# Output
if model.status == GRB.OPTIMAL:
    print("\n--- Berth Rerouting Results ---")
    print(f"Optimal Total System Delay: {model.objVal:.2f} ship-hours")
    print(f"Flow to Alternative Berth: {flow_alt.X:.2f} ships/h")
    print(f"Flow on Main Berth: {flow_main.X:.2f} ships/h")
    print(f"Alternative Berth Handling Time: {T_alt_actual.X * 60:.2f} min")
    print(f"Max Queue on Main Berth: {max_queue_main.X:.2f} ships")
    print(f"Queue Dissipation Time: {dissipation_time_main.X:.2f} h")
else:
    print(f"Model status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 8 rows, 10 columns and 14 nonzeros
Model fingerprint: 0x2093a858
Model has 2 quadratic objective terms
Model has 1 quadratic constraint
Model has 1 simple general constraint
  1 MAX
Model has 1 function constraint treated as nonlinear
  1 POW
Variable types: 10 continuous, 0 integer (0 binary)
Coefficient statistics:
  Matrix range     [5e-02, 2e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [5e-01, 7e-01]
  QObjective range [1e+00, 3e+00]
  Bounds range     [1e-06, 4e+03]
  RHS range        [4e-01, 5e+03]
Presolve removed 2 rows and 1 columns
Presolve time: 0.00s
Presolved: 20 rows, 13 columns, 45 nonzeros
Presolved model has 3 bilinear constraint(s)
Presolved model has 1 nonlinear constraint(s)

Solving non-convex MINLP

Variable types: 12 continuous, 1 integer (1 binary)
Found heuristic solution: objective 8.5860783

Root relaxation: objective 0.000000e+00, 6 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0    0.00000    0    2    8.58608    0.00000   100%     -    0s
     0     0    8.58243    0    2    8.58608    8.58243  0.04%     -    0s
     0     0          -    0         8.58608    8.58608  0.00%     -    0s

Explored 1 nodes (10 simplex iterations) in 0.01 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 8.58608 

Optimal solution found (tolerance 1.00e-04)
Best objective 8.586078303603e+00, best bound 8.586078301279e+00, gap 0.0000%

--- Berth Rerouting Results ---
Optimal Total System Delay: 8.59 ship-hours
Flow to Alternative Berth: 1013.24 ships/h
Flow on Main Berth: 3099.04 ships/h
Alternative Berth Handling Time: 22.36 min
Max Queue on Main Berth: 0.00 ships
Queue Dissipation Time: 0.00 h



================================================================================



--- Problem 95 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port is divided into three berths, each experiencing varying ship arrival rates and operational disruptions. During disruptions, port managers must decide how much of the incoming traffic to divert to alternative berths to minimize total delay. Each berth has distinct characteristics: normal and reduced capacities for the main berth, alternative berth capacities, arrival rates, disruption durations, and additional handling times for diverted ships. The available diversion ratios are 10%, 30%, 50%, and 70%.  

The challenge lies in selecting the optimal diversion strategy for each berth to minimize the cumulative delay across all berths. Delays arise from two sources: (1) the extra time taken by diverted ships on alternative berths and (2) queueing delays on the main berth if traffic exceeds the reduced capacity during disruptions. If traffic on the main berth exceeds its normal capacity, the delay becomes prohibitively large, representing an infeasible solution. The goal is to determine the best diversion percentage for each berth, balancing diverted traffic against congestion on the main berth while respecting capacity constraints.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `y[i, k]`: Binary variable indicating whether diversion option `k` (where `k` corresponds to 10%, 30%, 50%, or 70%) is selected for berth `i`.  

   **2. Parameters:**  
   - `NUM_BERTHS = 3`: Number of berths.  
   - `capacities_main_normal[i]`: Normal capacity of the main berth for berth `i` (ships/h).  
   - `capacities_main_reduced[i]`: Reduced capacity of the main berth during disruptions for berth `i` (ships/h).  
   - `capacities_alt[i]`: Capacity of the alternative berth for berth `i` (ships/h).  
   - `arrival_rates[i]`: Ship arrival rate for berth `i` (ships/h).  
   - `disruption_durations[i]`: Duration of the disruption for berth `i` (hours).  
   - `alt_berth_extra_times[i]`: Additional handling time for diverted ships on the alternative berth for berth `i` (hours).  
   - `diversion_options = [0.1, 0.3, 0.5, 0.7]`: Available diversion ratios.  
   - `berth_option_delays[i][k]`: Precomputed total delay for berth `i` if diversion option `k` is chosen.  
   - `berth_option_feasible[i][k]`: Boolean indicating whether diversion option `k` is feasible for berth `i`.  

   **3. Objective Function:**  
   Minimize the total delay across all berths:  
   ```
   Minimize: sum(y[i, k] * berth_option_delays[i][k] for all i, k where berth_option_feasible[i][k])
   ```

   **4. Constraints:**  
   - **Feasibility:** For each berth `i`, exactly one feasible diversion option must be selected:  
     ```
     sum(y[i, k] for k where berth_option_feasible[i][k]) = 1 for all i
     ```  
   - **Infeasible Options:** For each berth `i` and infeasible option `k`, enforce `y[i, k] = 0`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 3
capacities_main_normal = [3684, 4936, 5227]  # ships/h
capacities_main_reduced = [2468, 2592, 1961]  # ships/h
capacities_alt = [901, 817, 924]  # ships/h
arrival_rates = [4372, 2715, 4838]  # ships/h
disruption_durations = [1.2427688105420176, 1.3278185879719, 1.00286275172855]  # h
alt_berth_extra_times = [0.17144942722042933, 0.11219392256732662, 0.31979639736637155]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option and Berth ---
berth_option_delays = {}
berth_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_option_delays[i] = {}
    berth_option_feasible[i] = {}

    for k in range(num_options):
        p_k = diversion_options[k]
        flow_alt_k = arrival_rates[i] * p_k
        flow_main_k = arrival_rates[i] * (1 - p_k)

        # 1. Check Alternative Berth Capacity Feasibility
        if flow_alt_k > capacities_alt[i] + EPSILON:
            berth_option_feasible[i][k] = False
            berth_option_delays[i][k] = LARGE_DELAY
            continue

        berth_option_feasible[i][k] = True

        # 2. Calculate Alternative Berth Delay
        delay_alt_k = flow_alt_k * disruption_durations[i] * alt_berth_extra_times[i]

        # 3. Calculate Main Berth Queue Delay
        delay_queue_main_k = 0
        max_queue_main_k = 0

        if flow_main_k > capacities_main_reduced[i] + EPSILON:
            max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * disruption_durations[i]
            if flow_main_k >= capacities_main_normal[i] - EPSILON:
                delay_queue_main_k = LARGE_DELAY
            else:
                dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                if dissipation_rate_k < EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                    total_influence_time_k = disruption_durations[i] + dissipation_time_main_k
                    delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

        # 4. Calculate Total Delay for this option
        total_delay_k = delay_alt_k + delay_queue_main_k
        berth_option_delays[i][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    feasible_indices = [k for k in range(num_options) if berth_option_feasible[i][k]]
    if not feasible_indices:
        exit()

    m.addConstr(gp.quicksum(y[i,k] for k in feasible_indices) == 1, name="SelectOneFeasibleOption_Berth{0}".format(i))

    for k in range(num_options):
        if not berth_option_feasible[i][k]:
            m.addConstr(y[i,k] == 0, name="ForbidInfeasibleOption_Berth{0}_Option{1}".format(i,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,k] * berth_option_delays[i][k]
        for i in range(NUM_BERTHS)
        for k in range(num_options)
        if berth_option_feasible[i][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Diversion Strategy:")
    for i in range(NUM_BERTHS):
        for k in range(num_options):
            if y[i,k].X > 0.5:
                print("Berth {0}: Option {1} ({2:.0f}%)".format(
                    i+1, k, diversion_options[k]*100
                ))
                break
```
Answer:
Optimal Diversion Strategy:
Berth 1: Option 0 (10%)
Berth 2: Option 0 (10%)
Berth 3: Option 0 (10%)



================================================================================



--- Problem 96 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
In a busy port, the operations manager needs to select the fastest available tugboat to assist a ship in distress. Two tugboats, labeled **T1** and **T2**, are on standby, each with pre-calculated travel times to the ship's location: **T1** can arrive in **7.54 minutes**, while **T2** would take **12.69 minutes**. Every second counts in maritime emergencies, and the manager must choose **exactly one tugboat** to send, aiming to minimize the ship’s wait time. The challenge is straightforward but high-stakes: *Which tugboat should be deployed to ensure the fastest possible response, given their distinct travel times?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `y[t]` for each tugboat `t` in `{'T1', 'T2'}`:  
       `y[t] = 1` if tugboat `t` is dispatched, `0` otherwise.  
   - **2. Parameters:**  
     - `travel_times[t]`: Predefined time (minutes) for tugboat `t` to reach the ship (e.g., `travel_times['T1'] = 7.536`).  
   - **3. Objective Function:**  
     Minimize the response time:  
     `Minimize: y['T1'] * 7.536 + y['T2'] * 12.685`.  
   - **4. Constraints:**  
     - Dispatch exactly one tugboat:  
       `y['T1'] + y['T2'] = 1`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
travel_times = {'T1': 7.53656469870196, 'T2': 12.685112327219981}
tugboat_ids = list(travel_times.keys())

# --- Model Creation ---
model = gp.Model("Maritime_Vehicle_Dispatch_IP")

# --- Decision Variables ---
# Binary: y[t]=1 if tugboat t is dispatched
y = model.addVars(tugboat_ids, vtype=GRB.BINARY, name="dispatch_choice")

# --- Objective Function ---
# Minimize the response time of the dispatched unit
model.setObjective(gp.quicksum(y[t] * travel_times[t] for t in tugboat_ids), sense=GRB.MINIMIZE)

# --- Constraints ---
# Dispatch exactly one tugboat
model.addConstr(gp.quicksum(y[t] for t in tugboat_ids) == 1, name="dispatch_one")

# --- Optimization ---
model.optimize()

# --- Output Results ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    dispatched_tugboat = [t for t in tugboat_ids if y[t].X > 0.5][0]
    min_response_time = model.ObjVal
    print(f"Optimal Tugboat to Dispatch: {dispatched_tugboat}")
    print(f"Minimum Response Time: {min_response_time:.1f} minutes")
    print("\nAll Travel Times:")
    for t in tugboat_ids:
        print(f"  {t}: {travel_times[t]} minutes")
else:
    print(f"Optimization Status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 2 columns and 2 nonzeros
Model fingerprint: 0xe26185ed
Variable types: 0 continuous, 2 integer (2 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [8e+00, 1e+01]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 7.5365647
Presolve removed 1 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 1: 7.53656 

Optimal solution found (tolerance 1.00e-04)
Best objective 7.536564698702e+00, best bound 7.536564698702e+00, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Tugboat to Dispatch: T1
Minimum Response Time: 7.5 minutes

All Travel Times:
  T1: 7.53656469870196 minutes
  T2: 12.685112327219981 minutes



================================================================================



--- Problem 97 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port authority manages a busy container terminal where ships arrive to be serviced at one of several berths. The terminal has three berths (0, 1, 2), but not all berths can handle every ship due to compatibility constraints. For instance, Ship 1 cannot be serviced at Berth 2, as indicated by the `-1` in the service time matrix. The service times vary significantly—ranging from 48 to 113 minutes—depending on the ship-berth pairing.  

The challenge is to assign each of the four ships (0–3) to an available berth while ensuring that no two ships scheduled on the same berth overlap in time. The goal is to minimize the total completion time across all ships, which directly impacts operational efficiency and reduces delays for subsequent tasks. The big-M value (`M = 1645`) is used to enforce precedence constraints, ensuring that if two ships are assigned to the same berth, one must finish before the other begins.  

**Key Question:** What is the optimal assignment of ships to berths and their respective start times to minimize the sum of completion times, given the berth availability and service time constraints?  

---
**

Modeling Process:**
**
**1. Decision Variables:**  
- `x[i, j]`: Binary variable (1 if Ship *i* is assigned to Berth *j*; 0 otherwise).  
- `s[i]`: Continuous variable representing the start time of Ship *i*.  
- `C[i]`: Continuous variable representing the completion time of Ship *i*.  
- `y[i, k]`: Binary variable (1 if Ship *i* precedes Ship *k* on any berth; 0 otherwise).  

**2. Parameters:**  
- `ships = [0, 1, 2, 3]`: List of ships.  
- `berths = [0, 1, 2]`: List of berths.  
- `service_times[i][j]`: Time taken to service Ship *i* at Berth *j* (or `-1` if unavailable).  
- `M = 1645`: A sufficiently large constant for big-M constraints.  

**3. Objective Function:**  
Minimize the sum of completion times:  
\[
\text{Minimize: } \sum_{i \in \text{ships}} C[i]
\]  

**4. Constraints:**  
- **Assignment:** Each ship must be assigned to exactly one available berth:  
  \[
  \sum_{j \in \text{berths}, \text{service\_times}[i][j] \neq -1} x[i, j] = 1 \quad \forall i \in \text{ships}
  \]  
- **Unavailable Berths:** Ships cannot be assigned to incompatible berths:  
  \[
  x[i, j] = 0 \quad \forall i \in \text{ships}, j \in \text{berths} \text{ where } \text{service\_times}[i][j] = -1
  \]  
- **Completion Time Definition:**  
  \[
  C[i] = s[i] + \sum_{j \in \text{berths}} \text{service\_times}[i][j] \cdot x[i, j] \quad \forall i \in \text{ships}
  \]  
- **Non-Overlapping:** For any two ships assigned to the same berth, one must precede the other:  
  \[
  \begin{align*}
  s[k] &\geq C[i] - M \cdot (1 - y[i, k]) - M \cdot (2 - x[i, j] - x[k, j]) \quad \forall i, k \in \text{ships}, j \in \text{berths}, i \neq k \\
  s[i] &\geq C[k] - M \cdot y[i, k] - M \cdot (2 - x[i, j] - x[k, j]) \quad \forall i, k \in \text{ships}, j \in \text{berths}, i \neq k \\
  y[i, k] + y[k, i] &= 1 \quad \forall i, k \in \text{ships}, i < k
  \end{align*}
  \]  

---  

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3]
berths = [0, 1, 2]
# service_times[ship][berth], -1 means unavailable
service_times = [[97, 48, 83], [74, 113, -1], [95, 108, 76], [93, 52, 71]]
M = 1645 # Big M
# --- End Parameters ---

GUROBI_TIME_LIMIT = 120

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    # env.setParam('MIPFocus', 1) # Optional: Focus on finding feasible solutions quickly
    env.start()

    # --- Model Creation ---
    m = gp.Model("SHIP_BERTH_SCHEDULING", env=env)

    # --- Basic Input Validation ---
    if not ships or not berths:
        raise ValueError("Empty ships or berths list")
    if len(service_times) != len(ships) or any(len(row) != len(berths) for row in service_times):
         raise ValueError("Service times dimensions mismatch ships/berths")

    # --- Decision Variables ---
    # x[i, j] = 1 if ship i assigned to berth j
    x = m.addVars(ships, berths, vtype=GRB.BINARY, name="x")
    # s[i] = start time for ship i
    s = m.addVars(ships, vtype=GRB.CONTINUOUS, lb=0, name="s")
    # C[i] = completion time for ship i
    C = m.addVars(ships, vtype=GRB.CONTINUOUS, lb=0, name="C")
    # y[i, k] = 1 if ship i precedes ship k on the same berth
    # Define y only for i < k to avoid redundancy? No, original used i,k and k,i implicitly. Let's stick to original structure.
    y = m.addVars(ships, ships, vtype=GRB.BINARY, name="y")

    # --- Objective Function: Minimize the sum of completion times ---
    m.setObjective(gp.quicksum(C[i] for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    # Each ship assigned to exactly one *available* berth
    for i in ships:
        m.addConstr(gp.quicksum(x[i, j] for j in berths if service_times[i][j] != -1) == 1, f"Assignment_{i}")

    # Ensure assignment is 0 if berth is unavailable
    for i in ships:
        for j in berths:
            if service_times[i][j] == -1:
                m.addConstr(x[i, j] == 0, f"Unavailable_{i}_{j}")

    # Completion time definition (C[i] = s[i] + ActualServiceTime[i])
    m.addConstrs((C[i] == s[i] + gp.quicksum(service_times[i][j] * x[i, j]
                                            for j in berths if service_times[i][j] != -1)
                 for i in ships), "CompletionTime")


    # Non-overlapping constraint (Big-M) for pairs on the same berth
    for j in berths:
        for i in ships:
            for k in ships:
                # Original used i < k. Let's refine to avoid redundancy and simplify precedence.
                # New precedence var: y[i,k,j] = 1 if i precedes k on berth j
                # We still need the original y[i,k] to link precedence across all berths.
                # Sticking to original formulation for now. Check logic carefully.
                if i != k: # Consider distinct pairs
                    xi_j = x.get((i, j))
                    xk_j = x.get((k, j))
                    yi_k = y.get((i, k))
                    yk_i = y.get((k, i)) # Need both y[i,k] and y[k,i]

                    if xi_j is not None and xk_j is not None and yi_k is not None and yk_i is not None:
                        # If i before k (y[i,k]=1), then s[k] >= C[i]. Enforced by:
                        m.addConstr(s[k] >= C[i] - M * (1 - yi_k) - M * (2 - xi_j - xk_j), f"NonOverlap1_{i}_{k}_{j}")
                        # If k before i (y[k,i]=1, so yi_k=0), then s[i] >= C[k]. Enforced by:
                        m.addConstr(s[i] >= C[k] - M * yi_k - M * (2 - xi_j - xk_j), f"NonOverlap2_{i}_{k}_{j}")

                        # Ensure y[i,k] + y[k,i] = 1 if they are on the same berth j
                        # This is tricky because y is not berth specific.
                        # Let's use the simpler i < k iteration to avoid redundant constraints
                        if i < k:
                             # Need to ensure EITHER s[k] >= C[i] OR s[i] >= C[k] if x[i,j]=1 and x[k,j]=1
                             # Introduce berth specific precedence? Or rely on the existing y[i,k] logic?
                             # The original constraints might be sufficient IF coupled with y[i,k]+y[k,i]=1 globally?
                             m.addConstr(yi_k + yk_i == 1, f"PrecRel_{i}_{k}") # Assume one must precede the other globally
                             # If this global precedence holds, the non-overlap constraints should work.

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['C_sol'] = m.getAttr('X', C) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible") # Matches example
    elif m.Status == GRB.TIME_LIMIT:
         print(f"Optimization ended with status {m.Status}") # Matches example's generic else
    else: # Other statuses
        print(f"Optimization ended with status {m.Status}") # Matches example's generic else


except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the assignment of ships to berths and their start times
if m.Status == GRB.OPTIMAL:
    for i in ships:
        for j in berths:
            if x[i, j].X > 0.5:
                print(f"Ship {i} is assigned to Berth {j} with start time: {s[i].X:.2f} and completion time: {C[i].X:.2f}")
```
Answer:
Optimal objective value: 298.00
Ship 0 is assigned to Berth 1 with start time: 0.00 and completion time: 48.00
Ship 1 is assigned to Berth 0 with start time: 0.00 and completion time: 74.00
Ship 2 is assigned to Berth 2 with start time: 0.00 and completion time: 76.00
Ship 3 is assigned to Berth 1 with start time: 48.00 and completion time: 100.00


```

================================================================================



--- Problem 98 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the operations team is tasked with coordinating the berthing of ships at four different docks to minimize the total waiting time for all vessels. Each dock handles a specific number of ships per hour: Dock 1 handles 971 ships, Dock 2 serves 2,645, Dock 3 accommodates 1,086, and Dock 4 manages 413. The total available berthing time for all docks is fixed at 93 hours, meaning the sum of berthing times across all docks must equal this value. However, each dock's berthing time cannot be shorter than 9 hours or exceed 93 hours. The core challenge is to allocate berthing times in such a way that the total waiting time—calculated as the product of the number of ships and the non-berthing time (total berthing time minus berthing time) for each dock—is minimized. The question is: *What is the optimal distribution of berthing times across the four docks to achieve the least possible total waiting time for all ships?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Let \( t_i \) represent the berthing time (in hours) allocated to dock \( i \), where \( i \in \{1, 2, 3, 4\} \). Each \( t_i \) is a continuous variable bounded between 9 and 93 hours.  

   **2. Parameters:**  
   - \( \text{ship_coeffs} = [971, 2645, 1086, 413] \): Number of ships for each dock (ships/hour).  
   - \( \text{total_berthing_time} = 93 \): Total available berthing time (hours).  
   - \( \text{lb_time} = 9 \), \( \text{ub_time} = 93 \): Lower and upper bounds for berthing times (hours).  

   **3. Objective Function:**  
   Minimize the total waiting time:  
   \[
   \text{Minimize: } \sum_{i=1}^{4} \text{ship_coeffs}[i] \times (\text{total_berthing_time} - t_i)
   \]  

   **4. Constraints:**  
   - The sum of berthing times must equal the total berthing time:  
     \[
     \sum_{i=1}^{4} t_i = 93
     \]  
   - Bounds on berthing times:  
     \[
     9 \leq t_i \leq 93 \quad \text{for all } i \in \{1, 2, 3, 4\}
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_docks = 4
lb_time = 9          # Lower bound for berthing time
ub_time = 93          # Upper bound for berthing time
total_berthing_time = 93   # Total available berthing time (set equal to ub_time)
ship_coeffs = [971, 2645, 1086, 413] # Number of ships per dock
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(ship_coeffs) != num_docks:
    print("Error: ship_coeffs length mismatch with num_docks")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: ship_coeffs length"
    # raise ValueError("ship_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_docks}-Dock Berthing Time Allocation", env=env)

        # --- Decision variables (dynamic based on num_docks) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_docks, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for dock i is proportional to ship * non-berthing_time = ship * (total_berthing_time - berthing_time[i])
        model.setObjective(gp.quicksum(ship_coeffs[i] * (total_berthing_time - t_vars[i]) for i in range(num_docks)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the total berthing time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_docks)) == total_berthing_time, "TotalBerthingTime")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_docks)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_docks):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 278895.00
------------------------------
Optimal berthing times (hours):
  t1: 9.00, t2: 66.00, t3: 9.00, t4: 9.00


```

================================================================================



--- Problem 99 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy trucking terminal faces the challenge of efficiently scheduling incoming trucks to minimize operational costs while adhering to strict scheduling constraints. Two trucks, Truck 1 and Truck 2, arrive at the terminal with distinct arrival times—Truck 1 at 4 hours and Truck 2 at 7 hours. Each truck requires processing at one of two available depots, Depot 1 or Depot 2, with processing times of 6 hours for Truck 1 and 7 hours for Truck 2. The terminal incurs costs in two ways: waiting costs (for trucks delayed before servicing) and service costs (for actual depot operations). Specifically, waiting costs are $135 per hour for Truck 1 and $149 per hour for Truck 2. Service costs vary by truck-depot combination: servicing Truck 1 at Depot 1 costs $57 per hour, while Depot 2 reduces this to $51 per hour. For Truck 2, Depot 1 is cheaper at $44 per hour, but Depot 2 jumps to $68 per hour.  

The terminal manager must decide how to assign trucks to depots and schedule their start times to avoid overlaps while minimizing the total cost, which combines waiting and service expenses. The core question is: *What is the optimal depot assignment and start time schedule that minimizes the total cost while ensuring no two trucks occupy the same depot simultaneously?*  
**

---

**Modeling Process:**
**
**1. Decision Variables:**  
- `assign[i, j]`: Binary variable (1 if Truck *i* is assigned to Depot *j*, 0 otherwise).  
- `start_time[i]`: Continuous variable representing the start time of Truck *i*.  
- `completion_time[i]`: Continuous variable representing the completion time of Truck *i*.  
- `precedes[i, k, j]`: Binary variable (1 if Truck *i* precedes Truck *k* on Depot *j*, 0 otherwise).  

**2. Parameters:**  
- `trucks = [1, 2]`, `depots = [1, 2]`.  
- `arrival_times = {1: 4, 2: 7}` (hours).  
- `processing_times = {1: 6, 2: 7}` (hours).  
- `waiting_costs = {1: 135, 2: 149}` (cost per hour of waiting).  
- `service_costs = {(1,1): 57, (1,2): 51, (2,1): 44, (2,2): 68}` (cost per hour of servicing).  
- `H = 100`: A large constant (Big M) for logical constraints.  

**3. Objective Function:**  
Minimize:  
- Total waiting cost: `sum(waiting_costs[i] * (start_time[i] - arrival_times[i]) for all trucks i)`.  
- Total service cost: `sum(service_costs[(i,j)] * processing_times[i] * assign[i,j] for all trucks i and depots j)`.  

**4. Constraints:**  
1. **Assignment**: Each truck must be assigned to exactly one depot:  
   `sum(assign[i,j] for j in depots) = 1` for all trucks *i*.  
2. **Arrival time**: Start time cannot precede arrival time:  
   `start_time[i] >= arrival_times[i]` for all trucks *i*.  
3. **Completion time**: Completion time is start time plus processing time:  
   `completion_time[i] = start_time[i] + processing_times[i]` for all trucks *i*.  
4. **Non-overlapping**: For each depot *j*, if two trucks *i* and *k* are assigned to it, one must precede the other:  
   - Logical precedence: `precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1`.  
   - Mutual exclusion: `precedes[i,k,j] + precedes[k,i,j] <= 1`.  
   - Temporal enforcement: If `precedes[i,k,j] = 1`, then `start_time[k] >= completion_time[i]`.  
**

---

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2]
depots = [1, 2]
arrival_times = {1: 4, 2: 7}
processing_times = {1: 6, 2: 7}
waiting_costs = {1: 135, 2: 149} # Cost per hour waiting
service_costs = {(1, 1): 57, (1, 2): 51, (2, 1): 44, (2, 2): 68} # Cost rate per hour servicing {(truck, depot): cost}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    waiting_cost_expr = gp.quicksum(waiting_costs.get(i, 0) * (start_time[i] - arrival_times.get(i, 0)) for i in trucks)
    service_cost_expr = gp.quicksum(service_costs.get((i,j), 0) * processing_times.get(i, 0) * assign[i,j]
                                   for i in trucks for j in depots)
    m.setObjective(waiting_cost_expr + service_cost_expr, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} assigned to Depot {j}")
                print(f"Start Time for Truck {i}: {start_time[i].x:.4f} hours")
                print(f"Completion Time for Truck {i}: {completion_time[i].x:.4f} hours")
    print(f"Total Cost: {obj_val_print:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
614.0000
Optimal Solution Found:
Truck 1 assigned to Depot 2
Start Time for Truck 1: 4.0000 hours
Completion Time for Truck 1: 10.0000 hours
Truck 2 assigned to Depot 1
Start Time for Truck 2: 7.0000 hours
Completion Time for Truck 2: 14.0000 hours
Total Cost: 614.0000


```

================================================================================



--- Problem 100 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
A busy port terminal is experiencing a significant increase in ship traffic, and the port authority needs to optimize the berthing schedule to handle the influx efficiently. The terminal has two main berths, North-South (NS) and East-West (EW), with arrival rates of **647.79 ships/hour** and **549.37 ships/hour**, respectively. Due to recent weather conditions, the berthing capacity per berth has been reduced to **1605.83 ships/hour/berth**, with **2.13 berths** available per approach. The port authority must optimize the berthing schedule to maximize throughput while adhering to strict operational constraints: a minimum cycle length of **68.55 minutes**, a maximum of **109.72 minutes**, and a minimum berthing time of **19.79 minutes** per phase. Transition time between berthing phases totals **7.28 minutes** per cycle (3.64 minutes per phase). The core question: *How should berthing times be allocated between the NS and EW berths to maximize total ship throughput under these weather-imposed limitations?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `C`: Cycle length (minutes), bounded between `C_min` and `C_max`.  
     - `g_NS`, `g_EW`: Berthing times (minutes) for NS and EW berths, each ≥ `g_min_time`.  
     - Intermediate variables:  
       - `lambda_g_NS`, `lambda_g_EW`: Effective berthing ratios (`g_NS/C`, `g_EW/C`).  
       - `Cap_NS`, `Cap_EW`: Hourly capacities (ships/hour) for each approach.  

   - **2. Parameters:**  
     - Arrival rates: `lambda_NS_h = 647.79`, `lambda_EW_h = 549.37` ships/hour.  
     - Berthing capacity: `S_weather_approach_h = N_berths * S_weather_berth_h = 3417.74 ships/hour`.  
     - Lost time: `2 * L_lost_time_per_phase = 7.28 minutes`.  

   - **3. Objective Function:**  
     Maximize total throughput:  
     ```  
     Maximize: Cap_NS + Cap_EW  
     where Cap_NS = S_weather_approach_h * lambda_g_NS,  
           Cap_EW = S_weather_approach_h * lambda_g_EW.  
     ```  

   - **4. Constraints:**  
     - **Cycle composition:** `C = g_NS + g_EW + 7.28`.  
     - **Berthing ratio definitions:** `lambda_g_NS * C = g_NS`, `lambda_g_EW * C = g_EW`.  
     - **Capacity definitions:** As in objective.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
lambda_NS_h = 647.7940069639054  # ships/h
lambda_EW_h = 549.3714667987492  # ships/h
S_weather_berth_h = 1605.8281167559498  # ships/h/berth
N_berths = 2.1288529093789608
L_lost_time_per_phase = 3.63975928722657  # minutes
C_min = 68.55167278584982  # minutes
C_max = 109.71955007973473  # minutes
g_min_time = 19.79280736113445  # minutes

S_weather_approach_h = N_berths * S_weather_berth_h

# --- Gurobi Model ---
model = gp.Model("WeatherBerthingSchedule")

# --- Decision Variables ---
C = model.addVar(name="CycleLength", lb=C_min, ub=C_max)
g_NS = model.addVar(name="Berthing_NS", lb=g_min_time) # Actual berthing time NS
g_EW = model.addVar(name="Berthing_EW", lb=g_min_time) # Actual berthing time EW

# --- Intermediate Variables ---
# Effective berthing ratios (lambda = g/C)
lambda_g_NS = model.addVar(name="lambda_g_NS", lb=0.0, ub=1.0) # g_NS / C
lambda_g_EW = model.addVar(name="lambda_g_EW", lb=0.0, ub=1.0) # g_EW / C
# Capacities
Cap_NS = model.addVar(name="Capacity_NS", lb=0.0)
Cap_EW = model.addVar(name="Capacity_EW", lb=0.0)

# --- Constraints ---
# 1. Cycle length composition (2 phases)
model.addConstr(C == g_NS + g_EW + 2 * L_lost_time_per_phase, name="CycleComposition")

# 2. Calculate effective berthing ratios (non-linear: lambda = g/C)
# lambda * C = g
model.addQConstr(lambda_g_NS * C == g_NS, name="CalcLambdaNS")
model.addQConstr(lambda_g_EW * C == g_EW, name="CalcLambdaEW")

# 3. Calculate approach capacities
# Cap = S * lambda_g
model.addConstr(Cap_NS == S_weather_approach_h * lambda_g_NS, name="CalcCapacityNS")
model.addConstr(Cap_EW == S_weather_approach_h * lambda_g_EW, name="CalcCapacityEW")

# --- Objective Function ---
# Maximize total throughput (sum of capacities)
model.setObjective(Cap_NS + Cap_EW, GRB.MAXIMIZE)

# --- Optimize ---
# Needs NonConvex capabilities due to quadratic constraints (g = lambda * C)
model.Params.NonConvex = 2
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL or model.status == GRB.SUBOPTIMAL:
    print(f"Optimization Status: {model.status}")
    print(f"Optimal Cycle Length (C): {C.X:.2f} minutes")
    print(f"Optimal Berthing Time NS (g_NS): {g_NS.X:.2f} minutes")
    print(f"Optimal Berthing Time EW (g_EW): {g_EW.X:.2f} minutes")
    print(f"  Total Berthing = {g_NS.X+g_EW.X:.2f}min, Lost Time = {2*L_lost_time_per_phase:.1f}min, Sum = {g_NS.X+g_EW.X+2*L_lost_time_per_phase:.2f}min (matches C)")
    print(f"Resulting Capacity NS: {Cap_NS.X:.2f} ships/h (Demand={lambda_NS_h})")
    print(f"Resulting Capacity EW: {Cap_EW.X:.2f} ships/h (Demand={lambda_EW_h})")
    print(f"Maximized Total Throughput: {model.objVal:.2f} ships/h")
    # Check if demand constraints were implicitly met
    if Cap_NS.X < lambda_NS_h: print("  Warning: NS Demand exceeds capacity.")
    if Cap_EW.X < lambda_EW_h: print("  Warning: EW Demand exceeds capacity.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
    model.computeIIS()
    model.write("model_iis.ilp")
    print("IIS written to model_iis.ilp")
elif model.status == GRB.INF_OR_UNBD:
     print("Optimization Status: Infeasible or Unbounded")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 3 rows, 7 columns and 7 nonzeros
Model fingerprint: 0x99696c0f
Model has 2 quadratic constraints
Coefficient statistics:
  Matrix range     [1e+00, 3e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [1e+00, 1e+02]
  RHS range        [7e+00, 7e+00]
Presolve removed 2 rows and 2 columns

Continuous model is non-convex -- solving as a MIP

Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolved: 9 rows, 6 columns, 27 nonzeros
Presolved model has 2 bilinear constraint(s)
Variable types: 6 continuous, 0 integer (0 binary)
Found heuristic solution: objective 3191.7612551

Root relaxation: objective 3.773092e+03, 3 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0 3773.09238    0    2 3191.76126 3773.09238  18.2%     -    0s
     0     0 3581.40491    0    2 3191.76126 3581.40491  12.2%     -    0s
     0     2 3581.40491    0    2 3191.76126 3581.40491  12.2%     -    0s

Explored 77 nodes (42 simplex iterations) in 0.03 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 3191.76 

Optimal solution found (tolerance 1.00e-04)
Best objective 3.191761255077e+03, best bound 3.191761255077e+03, gap 0.0000%

--- Optimization Results ---
Optimization Status: 2
Optimal Cycle Length (C): 109.72 minutes
Optimal Berthing Time NS (g_NS): 51.22 minutes
Optimal Berthing Time EW (g_EW): 51.22 minutes
  Total Berthing = 102.44min, Lost Time = 7.3min, Sum = 109.72min (matches C)
Resulting Capacity NS: 1595.88 ships/h (Demand=647.7940069639054)
Resulting Capacity EW: 1595.88 ships/h (Demand=549.3714667987492)
Maximized Total Throughput: 3191.76 ships/h



================================================================================



--- Problem 101 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy delivery company is facing a logistical challenge: redistributing its fleet of packages across three distribution centers (A, B, and C) to meet demand while minimizing transportation costs. Distribution center A has a surplus of 63 packages, while centers B and C face deficits of 14 and 27 packages, respectively. The company has three trucks at its disposal, each with a capacity of 19 packages. Transporting packages from A to B incurs a cost of \$88 per truck, while sending trucks to C costs \$166 per trip. The goal is to determine how many trucks to dispatch to each center and how many packages to transport, ensuring deficits are met without exceeding available resources. The central question is: *What is the most cost-effective way to redistribute packages using the limited fleet of trucks while satisfying all demand constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `n_B`: Integer number of trucks sent to distribution center B (range: 0 to 3).  
   - `n_C`: Integer number of trucks sent to distribution center C (range: 0 to 3).  
   - `x_AB`: Integer number of packages transported from A to B (non-negative).  
   - `x_AC`: Integer number of packages transported from A to C (non-negative).  

   **2. Parameters:**  
   - `surplus_A = 63`: Packages available at A.  
   - `deficit_B = 14`: Packages needed at B.  
   - `deficit_C = 27`: Packages needed at C.  
   - `truck_capacity = 19`: Packages per truck.  
   - `num_trucks = 3`: Total trucks available.  
   - `cost_AB = 88`: Cost per truck to B.  
   - `cost_AC = 166`: Cost per truck to C.  

   **3. Objective Function:**  
   Minimize total transportation cost:  
   \[
   \text{Minimize: } 88 \cdot n_B + 166 \cdot n_C
   \]  

   **4. Constraints:**  
   - **Truck limit:** \( n_B + n_C \leq 3 \).  
   - **Capacity constraints (if trucks used):**  
     \( x_AB \leq 19 \cdot n_B \),  
     \( x_AC \leq 19 \cdot n_C \).  
   - **Supply limit at A:** \( x_AB + x_AC \leq 63 \).  
   - **Demand fulfillment:**  
     \( x_AB \geq 14 \),  
     \( x_AC \geq 27 \).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
surplus_A = 63
deficit_B = 14
deficit_C = 27
truck_capacity = 19
num_trucks = 3
cost_AB = 88
cost_AC = 166
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PACKAGE_REDISTRIBUTION_COST", env=env)

    # --- Decision Variables ---
    # n_B: number of trucks going to B
    n_B = m.addVar(vtype=GRB.INTEGER, lb=0, ub=num_trucks, name="n_B")
    # n_C: number of trucks going to C
    n_C = m.addVar(vtype=GRB.INTEGER, lb=0, ub=num_trucks, name="n_C")
    # x_AB: number of packages transported from A to B
    x_AB = m.addVar(vtype=GRB.INTEGER, lb=0, name="x_AB")
    # x_AC: number of packages transported from A to C
    x_AC = m.addVar(vtype=GRB.INTEGER, lb=0, name="x_AC")

    # --- Objective Function: Minimize transportation cost ---
    m.setObjective(cost_AB * n_B + cost_AC * n_C, GRB.MINIMIZE)

    # --- Constraints ---
    # Total number of trucks used
    m.addConstr(n_B + n_C <= num_trucks, "TotalTrucks")

    # Transported amount cannot exceed truck capacity
    # Handle truck_capacity = 0 case
    if truck_capacity > 0:
        m.addConstr(x_AB <= truck_capacity * n_B, "CapacityB")
        m.addConstr(x_AC <= truck_capacity * n_C, "CapacityC")
    else:
        # If capacity is 0, cannot transport packages
        m.addConstr(x_AB == 0, "CapacityB_Zero")
        m.addConstr(x_AC == 0, "CapacityC_Zero")

    # Transported amount cannot exceed surplus at A
    m.addConstr(x_AB + x_AC <= surplus_A, "SupplyA")

    # Transported amount must meet deficit (Original didn't require this, but realistic)
    # Making this optional based on original snippet focusing only on cost.
    # However, without a demand constraint, solution might be trivial (move 0 packages).
    # Let's assume the goal IS to meet demand if possible, while minimizing truck cost.
    # Add constraints to meet demand:
    m.addConstr(x_AB >= deficit_B, "MeetDemandB")
    m.addConstr(x_AC >= deficit_C, "MeetDemandC")
    # Note: The original snippet had these as upper bounds (<= deficit).
    # If the goal is just to minimize cost *given* fixed moves, the model changes.
    # Reverting to original snippet's logic (less realistic but matches code):
    # m.addConstr(x_AB <= deficit_B, "DemandB_Limit") # Limit packages moved
    # m.addConstr(x_AC <= deficit_C, "DemandC_Limit") # Limit packages moved
    # **Correction:** The goal is likely to meet demand *while* minimizing cost.
    # The model should try to fulfill demand. Keeping the >= constraints.

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_B_sol'] = n_B.X # Not needed for output
        # results_dict['n_C_sol'] = n_C.X
        # results_dict['x_AB_sol'] = x_AB.X
        # results_dict['x_AC_sol'] = x_AC.X

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
         print("Model is infeasible") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print missing outputs
if m.Status == GRB.OPTIMAL:
    print(f"Number of trucks to B: {n_B.X}")
    print(f"Number of trucks to C: {n_C.X}")
    print(f"Packages transported from A to B: {x_AB.X}")
    print(f"Packages transported from A to C: {x_AC.X}")
```
Answer:
Optimal objective value: 420.00
Number of trucks to B: 1.0
Number of trucks to C: 2.0
Packages transported from A to B: 14.0
Packages transported from A to C: 27.0


```

================================================================================



--- Problem 102 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
In a busy port, 18 ships must be efficiently assigned to one of five available berths to minimize the total service time across all operations. Each ship has a unique service time depending on the berth it is assigned to, ranging from as quick as 20 minutes to as long as 100 minutes. The challenge lies in determining the optimal berth assignment for each ship to ensure the cumulative service time is as low as possible. For instance, assigning Ship 10 to Berth 0 takes only 20 minutes, while assigning Ship 11 to Berth 2 would require a hefty 100 minutes. The goal is to strategically distribute the ships across the berths, respecting the rule that each ship can only be assigned to a single berth, to achieve the most time-efficient servicing plan. The central question is: *What is the optimal assignment of ships to berths that minimizes the total service time while ensuring every ship is serviced exactly once?*

**Modeling Process:**
- **1. Decision Variables:**  
     - `x[i, j]`: A binary variable where `x[i, j] = 1` if Ship `i` is assigned to Berth `j`, and `0` otherwise. Here, `i` ranges over the list of ships `[0, 1, ..., 17]`, and `j` ranges over the berths `[0, 1, 2, 3, 4]`.  
   - **2. Parameters:**  
     - `service_times[i, j]`: The time required to service Ship `i` in Berth `j`. This is a predefined dictionary with exact values for each `(i, j)` pair (e.g., `(0, 0): 43`, `(1, 1): 27`, etc.).  
   - **3. Objective Function:**  
     - Minimize the total service time:  
       `Minimize: sum(service_times[i, j] * x[i, j] for all (i, j))`.  
   - **4. Constraints:**  
     - Each ship must be assigned to exactly one berth:  
       `For each ship i: sum(x[i, j] for all berths j) = 1`.  
     - Binary constraints:  
       `x[i, j] ∈ {0, 1}` for all `(i, j)`.  

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17] # List of ship indices
berths = [0, 1, 2, 3, 4]       # List of berth indices
service_times = {(0, 0): 43, (0, 1): 74, (0, 2): 51, (0, 3): 87, (0, 4): 85, (1, 0): 35, (1, 1): 27, (1, 2): 83, (1, 3): 34, (1, 4): 62, (2, 0): 74, (2, 1): 88, (2, 2): 84, (2, 3): 56, (2, 4): 74, (3, 0): 72, (3, 1): 68, (3, 2): 29, (3, 3): 64, (3, 4): 65, (4, 0): 41, (4, 1): 30, (4, 2): 38, (4, 3): 69, (4, 4): 43, (5, 0): 30, (5, 1): 92, (5, 2): 35, (5, 3): 74, (5, 4): 50, (6, 0): 91, (6, 1): 80, (6, 2): 95, (6, 3): 86, (6, 4): 29, (7, 0): 37, (7, 1): 61, (7, 2): 73, (7, 3): 66, (7, 4): 94, (8, 0): 80, (8, 1): 72, (8, 2): 62, (8, 3): 25, (8, 4): 53, (9, 0): 34, (9, 1): 75, (9, 2): 75, (9, 3): 26, (9, 4): 91, (10, 0): 20, (10, 1): 45, (10, 2): 30, (10, 3): 36, (10, 4): 32, (11, 0): 29, (11, 1): 34, (11, 2): 100, (11, 3): 35, (11, 4): 98, (12, 0): 63, (12, 1): 51, (12, 2): 79, (12, 3): 39, (12, 4): 55, (13, 0): 87, (13, 1): 56, (13, 2): 56, (13, 3): 88, (13, 4): 59, (14, 0): 35, (14, 1): 47, (14, 2): 50, (14, 3): 77, (14, 4): 83, (15, 0): 40, (15, 1): 76, (15, 2): 44, (15, 3): 97, (15, 4): 97, (16, 0): 89, (16, 1): 46, (16, 2): 52, (16, 3): 93, (16, 4): 64, (17, 0): 23, (17, 1): 55, (17, 2): 40, (17, 3): 75, (17, 4): 84} # Dict of (ship, berth): time
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("SHIP_BERTH_ASSIGNMENT", env=env)

    # --- Decision Variables ---
    # x[i, j] = 1 if ship i is assigned to berth j, 0 otherwise
    # Use tuplelist for keys if service_times keys are tuples
    assignment_keys = list(service_times.keys())
    x = m.addVars(assignment_keys, vtype=GRB.BINARY, name="x")

    # --- Objective Function: Minimize total service time ---
    m.setObjective(gp.quicksum(service_times[i, j] * x[i, j] for i, j in assignment_keys), GRB.MINIMIZE)

    # --- Constraints ---
    # Each ship must be assigned to exactly one berth
    for i in ships:
        # Ensure we sum only existing keys for ship i
        m.addConstr(gp.quicksum(x[i, j] for j in berths if (i, j) in x) == 1, name=f"ShipAssignment_{i}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        results_dict['x_sol'] = m.getAttr('X', x) # Store variable values

    # --- Output Results ---
    print(f"--- SHIP_BERTH_ASSIGNMENT Results ---")
    if m.Status == GRB.OPTIMAL:
        x_sol = results_dict.get('x_sol', {})
        print(f"Optimization Status: Optimal")
        print(f"Minimum Total Service Time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("Optimal Assignment (Ship -> Berth):")
        assigned_count = 0
        for i in ships:
            for j in berths:
                 key = (i, j)
                 # Use .get on x_sol dictionary
                 if key in x_sol and x_sol.get(key, 0) > 0.5:
                     print(f"  Ship {i} -> Berth {j} (Service Time: {service_times.get(key, 'N/A')})")
                     assigned_count += 1
                     break # Move to next ship once assigned
        print(f"Total ships assigned: {assigned_count} / {len(ships)}")

    elif m.Status == GRB.INFEASIBLE:
        print(f"Optimization Status: Infeasible (This should not happen for assignment problems if setup correctly).")
    elif m.Status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m.ObjVal is not None and abs(m.ObjVal) < float('inf'):
              print(f"Best Objective Found: {m.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m.Status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- SHIP_BERTH_ASSIGNMENT Results ---
Optimization Status: Optimal
Minimum Total Service Time: 620.00
Optimal Assignment (Ship -> Berth):
  Ship 0 -> Berth 0 (Service Time: 43)
  Ship 1 -> Berth 1 (Service Time: 27)
  Ship 2 -> Berth 3 (Service Time: 56)
  Ship 3 -> Berth 2 (Service Time: 29)
  Ship 4 -> Berth 1 (Service Time: 30)
  Ship 5 -> Berth 0 (Service Time: 30)
  Ship 6 -> Berth 4 (Service Time: 29)
  Ship 7 -> Berth 0 (Service Time: 37)
  Ship 8 -> Berth 3 (Service Time: 25)
  Ship 9 -> Berth 3 (Service Time: 26)
  Ship 10 -> Berth 0 (Service Time: 20)
  Ship 11 -> Berth 0 (Service Time: 29)
  Ship 12 -> Berth 3 (Service Time: 39)
  Ship 13 -> Berth 2 (Service Time: 56)
  Ship 14 -> Berth 0 (Service Time: 35)
  Ship 15 -> Berth 0 (Service Time: 40)
  Ship 16 -> Berth 1 (Service Time: 46)
  Ship 17 -> Berth 0 (Service Time: 23)
Total ships assigned: 18 / 18


```

================================================================================



--- Problem 103 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the operations team is tasked with coordinating the berthing times for three different types of ships to minimize the total waiting time. Each type of ship has a different number of arrivals: Type 1 handles 2,595 arrivals, Type 2 manages 919 arrivals, and Type 3 accommodates 2,272 arrivals. The berthing slots must adhere to strict operational rules: each slot cannot be shorter than 5 minutes or exceed 59 minutes, and the combined berthing times across all types must exactly match the fixed cycle time of 59 minutes. The core dilemma is determining how to allocate these limited berthing minutes among the types to minimize the cumulative waiting time experienced by the ships—calculated as the product of the number of arrivals and the non-berthing time (cycle time minus berthing time) for each type. The optimization seeks the most efficient balance, ensuring high-arrival types receive adequate berthing time without starving others.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - \( t_i \): Continuous variable representing the berthing time (in minutes) allocated to ship type \( i \) (\( i = 1, 2, 3 \)), with bounds \( 5 \leq t_i \leq 59 \).  

   **2. Parameters:**  
   - \( \text{arrival_coeffs} = [2595, 919, 2272] \): Number of arrivals for each ship type.  
   - \( \text{cycle_time} = 59 \): Total fixed cycle time (minutes).  
   - \( \text{lb_time} = 5 \), \( \text{ub_time} = 59 \): Lower/upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize the total waiting time:  
   \[
   \text{Minimize: } \sum_{i=1}^{3} \text{arrival_coeffs}[i] \times (\text{cycle_time} - t_i)
   \]  

   **4. Constraints:**  
   - **Total cycle time:** The sum of berthing times must equal the cycle time:  
     \[
     t_1 + t_2 + t_3 = 59
     \]  
   - **Variable bounds:** Each \( t_i \) must satisfy \( 5 \leq t_i \leq 59 \).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_types = 3
lb_time = 5          # Lower bound for berthing time
ub_time = 59          # Upper bound for berthing time
cycle_time = 59   # Total cycle time (set equal to ub_time)
arrival_coeffs = [2595, 919, 2272] # Number of arrivals per ship type
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_coeffs) != num_types:
    print("Error: arrival_coeffs length mismatch with num_types")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_coeffs length"
    # raise ValueError("arrival_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_types}-Type Berthing Time", env=env)

        # --- Decision variables (dynamic based on num_types) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_types, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for type i is proportional to arrivals * non-berthing_time = arrivals * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_types)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_types)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_types)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_types):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 198264.00
------------------------------
Optimal berthing times (minutes):
  t1: 49.00, t2: 5.00, t3: 5.00


```

================================================================================



--- Problem 104 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy trucking depot with a single loading dock, a critical scheduling challenge arises due to the limited availability of the dock. Four trucks—numbered 1 through 4—arrive at staggered times (Truck 1 at 4 hours, Truck 2 at 7, Truck 3 at 11, and Truck 4 at 14) and require loading times of 5, 5, 5, and 4 hours, respectively. The loading dock is available in cycles that repeat every 12 hours, with each availability window lasting only 5 hours, during which trucks can safely load. The depot manager must assign each truck to the loading dock *exactly once* while ensuring their start and completion times fall entirely within one of these narrow availability windows. Overlapping assignments are forbidden, and the goal is to minimize the total time taken to service all trucks (the *makespan*). The core question: **What is the earliest possible completion time for all trucks, given these availability constraints and arrival schedules?**

---

**Modeling Process:**
**
**1. Decision Variables:**  
- `assign[i, j]`: Binary (1 if truck *i* is assigned to dock *j*; 0 otherwise).  
- `start_time[i]`: Continuous (when truck *i* begins service).  
- `completion_time[i]`: Continuous (when truck *i* finishes).  
- `precedes[i, k, j]`: Binary (1 if truck *i* is scheduled before truck *k* on dock *j*).  
- `z[i, k]`: Binary (1 if truck *i* starts in availability cycle *k*).  
- `makespan`: Continuous (total time to complete all trucks).  

**2. Parameters:**  
- `arrival_times[i]`: Truck *i*'s arrival (e.g., Truck 1 arrives at 4).  
- `processing_times[i]`: Service duration (e.g., Truck 1 takes 5 hours).  
- `availability_cycle = 12`, `availability_duration = 5`: Availability windows repeat every 12 hours, lasting 5 hours each.  
- `H = 100`: A large constant for logical constraints.  
- `max_k = 5`: Maximum availability cycles considered.  

**3. Objective Function:**  
Minimize `makespan` (the latest completion time across all trucks).  

**4. Constraints:**  
- **Assignment:** Each truck *i* must be assigned to the single dock: `assign[i, j] = 1` for all *i*.  
- **Arrival Time:** Trucks cannot start before arrival: `start_time[i] ≥ arrival_times[i]`.  
- **Completion Time:** `completion_time[i] = start_time[i] + processing_times[i]`.  
- **Non-Overlapping:** For trucks *i* and *k* on the same dock, either *i* precedes *k* or vice versa.  
- **Availability Windows:** For each truck *i*, `start_time[i]` and `completion_time[i]` must lie entirely within one availability window (enforced via `z[i, k]` indicators).  

---

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4]
docks = [1] # Should be [1]
arrival_times = {1: 4, 2: 7, 3: 11, 4: 14}
processing_times = {1: 5, 2: 5, 3: 5, 4: 4}
availability_cycle = 12
availability_duration = 5
H = 100 # Big M
max_k = 5 # Estimated max cycles needed
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("LOADING_DOCK_PROBLEM")

    if not trucks or not docks or len(docks)!=1: raise ValueError("Invalid trucks/docks")
    the_dock = docks[0]

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign") # Trivial
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    # Availability constraint variables
    z = m.addVars(trucks, range(max_k), vtype=GRB.BINARY, name="start_cycle")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_dock] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (on the single dock) using Indicators
    j = the_dock
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. Availability Constraint
    for i in trucks:
        m.addConstr(z.sum(i, '*') == 1, name=f"truck_{i}_one_cycle")
        for k in range(max_k):
            window_start = k * availability_cycle
            # Allow starting exactly at window_end? Original logic might need <= window_end
            # Using strict < window_end by using window_start + duration as upper bound
            window_end_strict = window_start + availability_duration
            # If z[i,k]=1, then window_start <= s[i] < window_end_strict
            m.addGenConstrIndicator(z[i,k], True, start_time[i] >= window_start, name=f"availability_start_lower_{i}_{k}")
            # Cannot use strict inequality, use epsilon or ensure proc time fits
            # Ensure completion time is within the window if it starts in the window
            # This is the complex part often simplified. Let's ensure proc time fits.
            m.addGenConstrIndicator(z[i,k], True, start_time[i] + processing_times.get(i,0) <= window_end_strict, name=f"availability_end_upper_{i}_{k}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal makespan: {m.objVal:.4f}")
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
52.0000
Optimal makespan: 52.0000
Truck 1 - Start Time: 24.0000, Completion Time: 29.0000
Truck 2 - Start Time: 12.0000, Completion Time: 17.0000
Truck 3 - Start Time: 36.0000, Completion Time: 41.0000
Truck 4 - Start Time: 48.0000, Completion Time: 52.0000


```

================================================================================



--- Problem 105 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A port's operations team is managing a ship berthing project that requires temporary adjustments to the number of berths available. The project involves two distinct options for berth configurations, each with its own capacity (measured in ships per hour) and associated operational cost. The first option offers a capacity of 2,251 ships per hour at an operational cost of $56 per hour, while the second option provides a higher capacity of 3,880 ships per hour but at a significantly higher operational cost of $218 per hour. The expected ship arrival rate during the project is 3,722 ships per hour. Delays occur if the chosen berth configuration cannot accommodate the demand, with each delayed ship incurring an additional cost of $8 per hour.

The operations team faces a critical decision: Which berth configuration should be implemented to minimize the total cost, balancing the direct operational expenses against the potential delay costs? The challenge lies in selecting the single best option (since only one can be chosen) that optimally trades off these competing costs while ensuring the solution is both feasible and cost-effective.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `y(k)`: Binary variable indicating whether berth configuration `k` is chosen (1 if selected, 0 otherwise), where `k` can be 1 or 2.  
   - `delayed_ships`: Non-negative continuous variable representing the number of ships delayed due to insufficient capacity.  

   **2. Parameters:**  
   - `options`: Dictionary with keys 1 and 2, where each entry contains:  
     - `capacity`: Capacity of the berth configuration (ships/hour).  
     - `operational_cost`: Hourly cost of implementing the configuration ($/hour).  
   - `demand`: Ship arrival rate (3,722 ships/hour).  
   - `delay_cost_per_ship`: Cost per delayed ship ($8/hour).  

   **3. Objective Function:**  
   Minimize the total cost, which is the sum of the operational cost and the delay cost:  
   ```  
   Minimize: sum(y(k) * options[k]['operational_cost'] for k in [1,2]) + delayed_ships * delay_cost_per_ship  
   ```  

   **4. Constraints:**  
   - **Single Option Selection:** Exactly one berth configuration must be chosen:  
     ```  
     sum(y(k) for k in [1,2]) == 1  
     ```  
   - **Delay Calculation:** The number of delayed ships is the excess of demand over capacity (if any):  
     ```  
     delayed_ships >= demand - sum(y(k) * options[k]['capacity'] for k in [1,2])  
     ```  
   - **Non-Negativity:** `delayed_ships` must be non-negative.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
options = {1: {'capacity': 2251, 'operational_cost': 56}, 2: {'capacity': 3880, 'operational_cost': 218}}; demand = 3722; delay_cost_per_ship = 8
# End Params
GUROBI_TIME_LIMIT = 60; M = 10000 # Big M if needed
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    option_keys = list(options.keys())
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m12 = gp.Model("Ship_Berthing_Config_IP", env=env)
    # Vars
    y = m12.addVars(option_keys, vtype=GRB.BINARY, name="berth_config_choice")
    delayed_ships = m12.addVar(name="delayed_ships", lb=0) # Must be non-negative
    # Intermediate Expressions (use directly in objective/constraints)
    total_capacity = gp.quicksum(y[k] * options[k]['capacity'] for k in option_keys)
    total_operational_cost = gp.quicksum(y[k] * options[k]['operational_cost'] for k in option_keys)
    # Objective
    m12.setObjective(total_operational_cost + delayed_ships * delay_cost_per_ship, sense=GRB.MINIMIZE)
    # Constraints
    m12.addConstr(gp.quicksum(y[k] for k in option_keys) == 1, "choose_one_option")
    # Delayed ships = max(0, demand - capacity)
    m12.addConstr(delayed_ships >= demand - total_capacity, "calculate_delayed_ships_lower")
    # Since delayed_ships has lb=0 and objective minimizes it, this is sufficient for LP/IP
    # No need for extra binary variable 'z' like in original example if delayed_ships is continuous/integer >= 0
    # Optimize
    m12.optimize()
    # Store results
    results_dict['status'] = m12.status
    if m12.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m12.objVal
        results_dict['y_sol'] = m12.getAttr('X', y)
        results_dict['delayed_ships_sol'] = delayed_ships.X
    # Output Results
    print("--- Problem 12: Ship Berthing Configuration (IP) ---")
    if m12.status == GRB.OPTIMAL:
        y_sol = results_dict.get('y_sol', {})
        delayed_ships = results_dict.get('delayed_ships_sol', 0)
        chosen_berth = -1
        for k in option_keys:
            if y_sol.get(k, 0) > 0.5: chosen_berth = k; break
        if chosen_berth != -1:
            final_capacity = options[chosen_berth]['capacity']
            final_operational_cost = options[chosen_berth]['operational_cost']
            final_delay_cost = delayed_ships * delay_cost_per_ship
            print(f"Optimization Status: Optimal")
            print(f"Optimal berth configuration to choose: {chosen_berth}")
            print(f"  Resulting Capacity: {final_capacity} ships/hr (Demand: {demand} ships/hr)")
            print(f"  Operational Cost: ${final_operational_cost:.2f}/hr")
            print(f"  Estimated Delayed Ships: {delayed_ships:.1f}") # Can be fractional if demand/cap not integer
            print(f"  Estimated Delay Cost: ${final_delay_cost:.2f}/hr")
            print(f"Minimum Total Cost: ${m12.objVal:.2f}/hr")
        else: print("Error: Optimal status but no option chosen.")
    else: print(f"Optimization Status: {m12.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of SHIP_BERTHING
```
Answer:
--- Problem 12: Ship Berthing Configuration (IP) ---
Optimization Status: Optimal
Optimal berth configuration to choose: 2
  Resulting Capacity: 3880 ships/hr (Demand: 3722 ships/hr)
  Operational Cost: $218.00/hr
  Estimated Delayed Ships: 0.0
  Estimated Delay Cost: $0.00/hr
Minimum Total Cost: $218.00/hr



================================================================================



--- Problem 106 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently packing 12 irregularly shaped items into standardized bins for shipment. Each item has a unique width and height, ranging from slender (1 unit wide, 86 units tall) to bulky (12 units wide, 59 units tall). The bins themselves measure 13 units in width and 93 units in height, imposing strict spatial limits. The challenge is to minimize the number of bins used while ensuring no items overlap or exceed bin boundaries. This problem mirrors real-world packing scenarios, where optimizing space reduces shipping costs and environmental impact. The core question: *What is the smallest number of bins required to pack all items without violations, and where should each item be placed within those bins?* Additionally, the company must ensure that the total weight of items in each bin does not exceed 100 units.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[i,j]`: Binary (0/1) indicating if item *i* is assigned to bin *j*.  
     - `y[j]`: Binary (0/1) indicating if bin *j* is used.  
     - `px[i,j]`, `py[i,j]`: Continuous variables for the bottom-left coordinates of item *i* in bin *j*.  
     - `left[i,k,j]`, `right[i,k,j]`, `below[i,k,j]`, `above[i,k,j]`: Binary variables enforcing non-overlapping conditions for items *i* and *k* in bin *j*.  

   - **2. Parameters:**  
     - `items`: List of tuples `(width, height, weight)` for each item (e.g., `(4, 41, 15)`).  
     - `bin_size`: Tuple `(13, 93)` defining bin dimensions.  
     - `num_items = 12`, `num_bins = 12` (worst-case upper bound).  
     - `max_bin_weight = 100`: Maximum weight allowed per bin.  
     - Big-M values `M_w = 13`, `M_h = 93` to deactivate constraints when items are in different bins.  

   - **3. Objective Function:**  
     Minimize the total bins used:  
     \[
     \text{Minimize: } \sum_{j=0}^{11} y[j]
     \]  

   - **4. Constraints:**  
     - **Assignment:** Each item *i* must be in exactly one bin:  
       \[
       \sum_{j=0}^{11} x[i,j] = 1 \quad \forall i \in \{0,\dots,11\}
       \]  
     - **Bin Boundaries:** Item *i* in bin *j* must fit within the bin:  
       \[
       px[i,j] + \text{item}_i\text{.width} \leq 13 + 13(1 - x[i,j]) \quad \forall i,j
       \]  
       (Analogous for height.)  
     - **Non-Overlapping:** For items *i* and *k* in the same bin *j*, enforce at least one spatial separation:  
       \[
       \text{left}[i,k,j] + \text{right}[i,k,j] + \text{below}[i,k,j] + \text{above}[i,k,j] \geq x[i,j] + x[k,j] - 1 \quad \forall i < k, j
       \]  
     - **Bin Activation:** If any item *i* is in bin *j*, mark bin *j* as used:  
       \[
       x[i,j] \leq y[j] \quad \forall i,j
       \]  
     - **Weight Limit:** The total weight of items in each bin *j* must not exceed 100 units:  
       \[
       \sum_{i=0}^{11} \text{item}_i\text{.weight} \cdot x[i,j] \leq 100 \quad \forall j
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
items = [(4, 41, 15), (3, 38, 10), (1, 86, 20), (7, 73, 25), (12, 59, 30), (7, 42, 18), (3, 21, 8), (6, 11, 5), (6, 48, 12), (1, 62, 10), (9, 62, 22), (6, 87, 15)]  # (width, height, weight) of items
bin_size = (13, 93)  # (width, height) of each bin
num_items = 12 # len(items)
# Maximum bins needed (worst case: one item per bin)
# Can sometimes be reduced with lower bounds, but num_items is safe
num_bins = num_items
max_bin_weight = 100  # Maximum weight allowed per bin
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using bin dimensions is common and valid)
M_w = bin_size[0]
M_h = bin_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Bin Packing", env=env)

# --- Decision Variables ---
# x[i,j]: item i assigned to bin j
x = model.addVars(num_items, num_bins, vtype=GRB.BINARY, name="x")
# y[j]: bin j is used
y = model.addVars(num_bins, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of item i if in bin j
px = model.addVars(num_items, num_bins, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_items, num_bins, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of items *within the same bin*
left  = model.addVars(num_items, num_items, num_bins, vtype=GRB.BINARY, name="left")
right = model.addVars(num_items, num_items, num_bins, vtype=GRB.BINARY, name="right")
below = model.addVars(num_items, num_items, num_bins, vtype=GRB.BINARY, name="below")
above = model.addVars(num_items, num_items, num_bins, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of bins used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_bins))

# --- Constraints ---

# 1. Each item must be assigned to exactly one bin
for i in range(num_items):
    model.addConstr(x.sum(i, '*') == 1, name=f"Item_{i}_Assignment")

# 2. Item placement constraints within bin boundaries (Big-M formulation)
for j in range(num_bins):
    for i in range(num_items):
        item_w, item_h, _ = items[i] # Get dimensions for item i

        # Position variables must be 0 if item i is not in bin j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Item's right edge <= bin width IF item is placed in bin (x[i,j]=1)
        model.addConstr(px[i, j] + item_w <= bin_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Item's top edge <= bin height IF item is placed in bin (x[i,j]=1)
        model.addConstr(py[i, j] + item_h <= bin_size[1] + M_h * (1 - x[i, j]), name=f"Height_Limit_{i}_{j}")

# 3. Non-overlapping constraints for items within the same bin
for j in range(num_bins):
    for i in range(num_items):
        for k in range(i + 1, num_items): # Iterate over distinct pairs (i < k)
            item_i_w, item_i_h, _ = items[i]
            item_k_w, item_k_h, _ = items[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => item i is to the left of item k
            model.addConstr(px[i, j] + item_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => item i is to the right of item k (k is left of i)
            model.addConstr(px[k, j] + item_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => item i is below item k
            model.addConstr(py[i, j] + item_i_h <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => item i is above item k (k is below i)
            model.addConstr(py[k, j] + item_k_h <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH item i and item k are in bin j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link item assignment to bin usage: If any item i is in bin j, then bin j must be used (y[j]=1)
#    This can be done per item or aggregated. Per item is often tighter.
for j in range(num_bins):
    for i in range(num_items):
        model.addConstr(x[i, j] <= y[j], name=f"Item_Bin_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_items * y[j], name=f"Bin_Activation_{j}")

# 5. Weight limit for each bin
for j in range(num_bins):
    model.addConstr(quicksum(items[i][2] * x[i, j] for i in range(num_items)) <= max_bin_weight, name=f"Weight_Limit_{j}")

# --- Solve ---
print("Solving 2DBP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of bins used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    bin_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_bins):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Bin {j_sol + 1} (Used):")
            items_in_bin_info = []
            for i_sol in range(num_items):
                if x[i_sol, j_sol].X > 0.5:
                    item_data = {
                        "id": i_sol,
                        "dims": (items[i_sol][0], items[i_sol][1]),
                        "weight": items[i_sol][2],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    items_in_bin_info.append(item_data)
                    print(f"  Item {item_data['id']} {item_data['dims']} (Weight: {item_data['weight']}) at {item_data['pos']}")
            bin_details.append({'bin_index': j_sol, 'items': items_in_bin_info})
            print("-" * 10)
    results_dict['bin_details'] = bin_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# The provided code already prints the optimal number of bins used and the detailed placement of items within each bin.
# No additional print statements are necessary.
```
Answer:
Solving 2DBP instance...
Gurobi Error code 10010: Model too large for size-limited license; visit https://gurobi.com/unrestricted for more information

Optimization finished with status: -1. No optimal solution found.


```

================================================================================



--- Problem 107 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port authority is tasked with efficiently scheduling a set of 12 ships to berths for unloading, each with a strict time limit of 27 hours. The ships vary significantly in the time required for unloading, ranging from as short as 2 hours to as long as 27 hours. The challenge lies in minimizing the number of berths used while ensuring no berth exceeds its time limit. This problem mirrors real-world scenarios like ship berthing or terminal operations, where optimizing space and time reduces costs and improves operational efficiency. The port authority must determine the most compact arrangement possible, assigning each ship to exactly one berth without violating time constraints. The core question is: *What is the minimum number of berths required to schedule all ships without exceeding the time limit per berth?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[i, j]`: Binary variable (0 or 1) indicating whether ship `i` is assigned to berth `j`.  
     - `y[j]`: Binary variable (0 or 1) indicating whether berth `j` is used.  
   - **2. Parameters:**  
     - `ships`: List of ship unloading times: `[15, 27, 12, 10, 18, 5, 12, 22, 5, 10, 2, 10]`.  
     - `capacity`: Maximum time per berth (27 hours).  
     - `num_ships`: Total ships (12).  
     - `num_berths`: Maximum possible berths (12, one per ship).  
   - **3. Objective Function:**  
     Minimize the total number of berths used:  
     `Minimize: sum(y[j] for all j)`  
   - **4. Constraints:**  
     - **Ship Assignment:** Each ship must be in exactly one berth:  
       `sum(x[i, j] for all j) = 1` for every ship `i`.  
     - **Berth Capacity:** The total time in any berth `j` cannot exceed its capacity if the berth is used:  
       `sum(ships[i] * x[i, j] for all i) <= capacity * y[j]` for every berth `j`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB

# --- Data Definition ---
ships = [15, 27, 12, 10, 18, 5, 12, 22, 5, 10, 2, 10]      # Unloading times of ships
capacity = 27           # Berth capacity in hours
num_ships = 12     # len(ships)
num_berths = num_ships    # Maximum number of berths (worst case: one ship per berth)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Time limit
# env.setParam('TimeLimit', 30)
env.start()

# Create Model
model = Model("Berth Scheduling Problem", env=env)

# --- Decision Variables ---
# x[i,j]: ship i is assigned to berth j
x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")

# --- Objective: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)

# --- Constraints ---
# 1. Each ship must be assigned to exactly one berth
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Berth capacity constraint: sum of unloading times in berth j <= capacity IF berth j is used (y[j]=1)
for j in range(num_berths):
    model.addConstr(gp.quicksum(ships[i] * x[i, j] for i in range(num_ships)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

# --- Solve ---
print("Solving Berth Scheduling instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print(f"\nOptimal number of berths used: {optimal_berths}")
    print("-" * 30)
    berth_details = []
    for j_sol in range(num_berths): # Loop through potential berths
        # Check if the berth variable y[j_sol] exists and is set to 1
        try:
            if y[j_sol].X > 0.5: # Check if berth j_sol is used
                # Find ships assigned to this berth j_sol
                assigned_ships_indices = [i for i in range(num_ships) if x[i, j_sol].X > 0.5]
                assigned_ships_times = [ships[i] for i in assigned_ships_indices]
                berth_load = sum(assigned_ships_times)
                print(f"Berth {j_sol + 1} (Load: {berth_load}/{capacity}): Ships (indices): {assigned_ships_indices}")
                # Optional: Print times too
                # print(f"  Times: {assigned_ships_times}")
                berth_details.append({'berth_index': j_sol, 'ship_indices': assigned_ships_indices, 'load': berth_load})
        except AttributeError:
            pass # Just skip if variable/attribute doesn't exist for unused berths/ships
    results_dict['berth_details'] = berth_details # Store details
    print("-" * 30)

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount to see if a feasible solution was found
     if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
     else: print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving Berth Scheduling instance...

Optimal number of berths used: 6
------------------------------
Berth 2 (Load: 22/27): Ships (indices): [7]
Berth 5 (Load: 27/27): Ships (indices): [6, 8, 11]
Berth 6 (Load: 27/27): Ships (indices): [1]
Berth 7 (Load: 27/27): Ships (indices): [0, 3, 10]
Berth 9 (Load: 22/27): Ships (indices): [2, 9]
Berth 12 (Load: 23/27): Ships (indices): [4, 5]
------------------------------


```

================================================================================



--- Problem 108 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy trucking depot, a critical scheduling challenge arises for a single loading dock that must accommodate three trucks with strict time constraints. Trucks 1, 2, and 3 arrive at times 3, 5, and 8, respectively, each requiring exactly 3 hours to load. The loading dock is only accessible during specific time windows that recur every 11 hours, with each window lasting precisely 3 hours. The depot manager must assign each truck to the loading dock such that their entire loading process—start to finish—fits entirely within one of these time windows. Overlapping assignments are impossible, as the dock can only handle one truck at a time. The goal is to minimize the total time taken to service all trucks (the *makespan*), ensuring the depot operates as efficiently as possible despite the restrictive time schedule. The core question: *What is the optimal schedule that meets all time constraints while finishing all loading as early as possible?*
**

**Modeling Process:**
**
- **Decision Variables:**  
     - `assign[i, j]`: Binary (1 if truck *i* is assigned to dock *j*; 0 otherwise).  
     - `start_time[i]`: Continuous (when truck *i* begins loading).  
     - `completion_time[i]`: Continuous (when truck *i* finishes loading).  
     - `precedes[i, k, j]`: Binary (1 if truck *i* is scheduled before truck *k* on dock *j*; 0 otherwise).  
     - `z[i, k]`: Binary (1 if truck *i* starts loading in time cycle *k*; 0 otherwise).  
     - `makespan`: Continuous (total time to finish all loading).  

   - **Parameters:**  
     - `arrival_times[i]`: Truck *i*’s arrival time (3, 5, 8).  
     - `processing_times[i]`: Loading duration (3 for all trucks).  
     - `time_cycle = 11`: Time between time window starts.  
     - `time_duration = 3`: Duration of each time window.  
     - `max_k = 4`: Maximum time cycles considered.  

   - **Objective Function:**  
     Minimize `makespan` (latest completion time across all trucks).  

   - **Constraints:**  
     1. **Assignment:** Each truck must use the single dock (`assign[i, j] = 1`).  
     2. **Arrival Time:** Trucks cannot start before arrival (`start_time[i] >= arrival_times[i]`).  
     3. **Completion Time:** Loading duration is fixed (`completion_time[i] = start_time[i] + processing_times[i]`).  
     4. **Non-Overlapping:** For any two trucks *i* and *k*, one must precede the other on the dock (enforced via `precedes` and indicator constraints).  
     5. **Time Windows:** Each truck’s loading must fit entirely within one time window (enforced via `z[i, k]` and indicator constraints on `start_time` and `completion_time`).  
     6. **Makespan Definition:** `makespan` is the maximum `completion_time` across all trucks.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
docks = [1] # Should be [1]
arrival_times = {1: 3, 2: 5, 3: 8}
processing_times = {1: 3, 2: 3, 3: 3}
time_cycle = 11
time_duration = 3
H = 100 # Big M
max_k = 4 # Estimated max cycles needed
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DOCKING_PROBLEM_13_TIME")

    if not trucks or not docks or len(docks)!=1: raise ValueError("Invalid trucks/docks")
    the_dock = docks[0]

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign") # Trivial
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    # Time constraint variables
    z = m.addVars(trucks, range(max_k), vtype=GRB.BINARY, name="start_cycle")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_dock] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (on the single dock) using Indicators
    j = the_dock
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. Time Constraint
    for i in trucks:
        m.addConstr(z.sum(i, '*') == 1, name=f"truck_{i}_one_cycle")
        for k in range(max_k):
            window_start = k * time_cycle
            # Allow starting exactly at window_end? Original logic might need <= window_end
            # Using strict < window_end by using window_start + duration as upper bound
            window_end_strict = window_start + time_duration
            # If z[i,k]=1, then window_start <= s[i] < window_end_strict
            m.addGenConstrIndicator(z[i,k], True, start_time[i] >= window_start, name=f"time_start_lower_{i}_{k}")
            # Cannot use strict inequality, use epsilon or ensure proc time fits
            # Ensure completion time is within the window if it starts in the window
            # This is the complex part often simplified. Let's ensure proc time fits.
            m.addGenConstrIndicator(z[i,k], True, start_time[i] + processing_times.get(i,0) <= window_end_strict, name=f"time_end_upper_{i}_{k}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Schedule:")
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
    print(f"Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
36.0000
Optimal Schedule:
Truck 1 - Start Time: 33.0000, Completion Time: 36.0000
Truck 2 - Start Time: 22.0000, Completion Time: 25.0000
Truck 3 - Start Time: 11.0000, Completion Time: 14.0000
Makespan: 36.0000


```

================================================================================



--- Problem 109 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with loading a set of 28 valuable items onto a limited number of trucks for delivery. Each item has a specific weight and value, and the trucks have a strict weight capacity of 72 units. The company can use up to 7 trucks, and the goal is to maximize the total value of the loaded items while ensuring no truck exceeds its weight limit.  

   The items vary significantly in weight and value—some are lightweight but highly valuable (e.g., (2, 77)), while others are heavier but less valuable (e.g., (66, 60)). The challenge is to strategically assign items to trucks so that the sum of their values is as high as possible, without overloading any truck. Additionally, each item can be placed in at most one truck, and a truck is only considered "used" if at least one item is assigned to it.  

   The central question is: **What is the optimal way to load these items into the available trucks to achieve the highest possible total value while respecting all constraints?**
**

Modeling Process:
**
**1. Decision Variables:**  
   - Binary variable `x[i, j]` indicates whether item `i` is placed in truck `j` (1 if yes, 0 otherwise).  
   - Binary variable `y[j]` indicates whether truck `j` is used (1 if yes, 0 otherwise).  

   **2. Parameters:**  
   - `items[i] = (weight, value)` for each item `i` (28 items total).  
   - `truck_capacity = 72` (maximum weight per truck).  
   - `num_trucks = 7` (maximum number of trucks available).  

   **3. Objective Function:**  
   - **Maximize:** Total value of loaded items:  
     \[
     \text{Maximize} \sum_{i=0}^{27} \sum_{j=0}^{6} \text{value}_i \cdot x[i, j]
     \]  

   **4. Constraints:**  
   - **Truck Weight Limit:** For each truck `j`, the total weight of assigned items must not exceed its capacity:  
     \[
     \sum_{i=0}^{27} \text{weight}_i \cdot x[i, j] \leq \text{truck\_capacity} \cdot y[j] \quad \forall j \in \{0, 1, ..., 6\}
     \]  
   - **Item-Truck Link:** If an item `i` is placed in truck `j`, then truck `j` must be marked as used:  
     \[
     x[i, j] \leq y[j] \quad \forall i \in \{0, 1, ..., 27\}, \forall j \in \{0, 1, ..., 6\}
     \]  
   - **Single Assignment:** Each item can be placed in at most one truck:  
     \[
     \sum_{j=0}^{6} x[i, j] \leq 1 \quad \forall i \in \{0, 1, ..., 27\}
     \]  
**

Corresponding Code:
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Data Definition (Embedded) ---
items = [(2, 51), (48, 35), (22, 18), (41, 93), (58, 73), (31, 27), (66, 60), (43, 83), (63, 7), (29, 89), (43, 34), (63, 98), (24, 49), (60, 64), (66, 58), (2, 77), (68, 77), (16, 8), (22, 70), (54, 31), (9, 66), (44, 51), (64, 99), (37, 93), (58, 88), (2, 80), (40, 84), (7, 92)]          # List of (weight, value) tuples
truck_capacity = 72      # Maximum weight per truck
num_trucks = 7          # Maximum number of available trucks (parameter)
num_items = 28          # len(items) derived correctly
# --- End Data Definition ---

GUROBI_TIME_LIMIT = 60 # Time limit parameter

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi log in captured output
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Max-Value Truck Loading", env=env)

    # --- Decision variables ---
    x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")  # x[i, j] -> item i placed in truck j
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")  # y[j] -> truck j is used

    # --- Objective: Maximize total value of selected items ---
    # Sum over all items i and the truck j they are placed in
    model.setObjective(gp.quicksum(items[i][1] * x[i, j] for i in range(num_items) for j in range(num_trucks)), GRB.MAXIMIZE)

    # --- Constraint 1: Truck weight limit ---
    for j in range(num_trucks):
        model.addConstr(gp.quicksum(items[i][0] * x[i, j] for i in range(num_items)) <= truck_capacity * y[j], name=f"Truck_{j}_Weight")

    # --- Constraint 2: If an item is placed in a truck, that truck must be considered used ---
    # (This is often implied by C1 if capacity > 0, but good practice)
    for i in range(num_items):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Item_{i}_Triggers_Truck_{j}")

    # --- Constraint 3: Each item can be placed in at most one truck ---
    # (Items not placed contribute 0 to objective and constraints)
    for i in range(num_items):
        model.addConstr(x.sum(i, '*') <= 1, name=f"Item_{i}_AtMostOneTruck")

    # --- Solve the model ---
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal # Best solution found

    # --- Output results (for capture) ---
    if model.status == GRB.OPTIMAL:
        print(f"Optimal total value: {model.objVal:.2f}") # Format value
        print("-" * 30)
        printed_truck_count = 0
        for j in range(num_trucks):
            try:
                 if y[j].x > 0.5:  # Truck is used
                     printed_truck_count += 1
                     assigned_items = [i for i in range(num_items) if x[i, j].x > 0.5]
                     assigned_weights = [items[i][0] for i in assigned_items]
                     truck_load = sum(assigned_weights)
                     print(f"Truck {printed_truck_count} (Index {j}):")
                     print(f"  Load: {truck_load} / {truck_capacity}")
                     print(f"  Items (indices): {sorted(assigned_items)}")
                     # Optional: print item details
                     # print(f"  Items (w,v): {[items[i] for i in sorted(assigned_items)]}")
                     print("-" * 10)
            except AttributeError:
                 pass # Skip trucks not used or if .X missing
    elif model.status == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare if items fit capacity
    else:
        print(f"\nOptimization finished with status: {model.status}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total value: 1239.00
------------------------------
Truck 1 (Index 0):
  Load: 71 / 72
  Items (indices): [22, 27]
----------
Truck 2 (Index 1):
  Load: 72 / 72
  Items (indices): [7, 9]
----------
Truck 3 (Index 2):
  Load: 59 / 72
  Items (indices): [18, 23]
----------
Truck 4 (Index 3):
  Load: 64 / 72
  Items (indices): [12, 26]
----------
Truck 5 (Index 4):
  Load: 72 / 72
  Items (indices): [11, 20]
----------
Truck 6 (Index 5):
  Load: 72 / 72
  Items (indices): [3, 5]
----------
Truck 7 (Index 6):
  Load: 64 / 72
  Items (indices): [0, 15, 24, 25]
----------


```

================================================================================



--- Problem 110 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port manager faces the daily challenge of maximizing revenue by strategically allocating berths between two types of ships: container ships and cruise ships. The port has a total of 301 berths, which can be utilized for up to 4,123.7 berth-hours per day (a berth-hour represents one berth occupied for one hour). Container ships pay a flat fee of $49 for a guaranteed 4-hour stay, while cruise ships generate $21.60 per ship for an average stay of 2.7 hours.

Demand for container ship berths is capped at 96 reservations, with a minimum requirement of 49 to ensure baseline revenue. Cruise ship demand cannot exceed 72 ships. The manager must balance these competing demands while respecting the port’s physical and operational limits. The core question is: *How many container ship reservations and cruise ship berths should be accepted to maximize daily revenue without exceeding berth-hour capacity or demand constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x_container`: Integer number of container ship reservations accepted (≥ 0).  
     - `x_cruise`: Integer number of cruise ship berths accepted (≥ 0).  

   - **2. Parameters:**  
     - `total_berth_hours = 4,123.7` (max available berth-hours).  
     - `container_price = $49`, `container_stay = 4.0` hours.  
     - `cruise_revenue_per_ship = $21.60`, `cruise_stay = 2.7` hours.  
     - `container_max_demand = 96`, `container_min_required = 49`.  
     - `cruise_max_demand = 72`.  

   - **3. Objective Function:**  
     Maximize total revenue:  
     `Maximize: (49 * x_container) + (21.60 * x_cruise)`.  

   - **4. Constraints:**  
     - Berth-hour capacity: `4.0 * x_container + 2.7 * x_cruise ≤ 4,123.7`.  
     - Container ship demand: `49 ≤ x_container ≤ 96`.  
     - Cruise ship demand: `x_cruise ≤ 72`.  
     - Physical berths: `x_container ≤ 301` (redundant due to berth-hour constraint).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_berths = 301
op_hours = 13.7
total_berth_hours = 4123.7
container_price = 49
container_stay = 4.0
container_max_demand = 96
container_min_required = 49
cruise_rate = 8
cruise_stay = 2.7
cruise_revenue_per_ship = 21.60
cruise_max_demand = 72
# --- End Parameters ---

GUROBI_TIME_LIMIT = 45

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m27 = gp.Model("PORT_REVENUE_MGT_MIP", env=env)

    # --- Decision Variables ---
    # Integer: Number of container ship reservations and cruise ship berths accepted
    x_container = m27.addVar(vtype=GRB.INTEGER, name="num_container_reservations", lb=0)
    x_cruise = m27.addVar(vtype=GRB.INTEGER, name="num_cruise_berths", lb=0)

    # --- Objective Function ---
    # Maximize total daily revenue
    m27.setObjective(container_price * x_container + cruise_revenue_per_ship * x_cruise, sense=GRB.MAXIMIZE)

    # --- Constraints ---
    # Constraint 1: Total berth-hour usage capacity
    m27.addConstr(x_container * container_stay + x_cruise * cruise_stay <= total_berth_hours, name="berth_hour_capacity")

    # Constraint 2: Container ship demand upper bound
    m27.addConstr(x_container <= container_max_demand, name="container_demand_max")

    # Constraint 3: Container ship minimum requirement
    m27.addConstr(x_container >= container_min_required, name="container_demand_min")

    # Constraint 4: Cruise ship demand upper bound
    m27.addConstr(x_cruise <= cruise_max_demand, name="cruise_demand_max")

    # Constraint 5: Physical berth limit (optional, but good check)
    m27.addConstr(x_container <= total_berths, name="container_berth_limit")
    # Physical limit for cruise is trickier, rely on berth hours

    # --- Optimization ---
    m27.optimize()

    # --- Store results ---
    results_dict['status'] = m27.status
    if m27.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m27.ObjVal
        results_dict['x_container_sol'] = x_container.X
        results_dict['x_cruise_sol'] = x_cruise.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- PORT_REVENUE_MGT: Port Revenue Management (MIP) ---")
    if m27.status == GRB.OPTIMAL:
        opt_container = int(round(results_dict.get('x_container_sol', 0))) # Round and convert to int
        opt_cruise = int(round(results_dict.get('x_cruise_sol', 0)))
        berth_hours_used = opt_container * container_stay + opt_cruise * cruise_stay
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Maximum Total Daily Revenue: ${obj_val_print:.2f}")
        print(f"Optimal number of Container Ship Reservations: {opt_container} (Demand: {container_min_required}-{container_max_demand})")
        print(f"Optimal number of Cruise Ship Berths: {opt_cruise} (Demand: {cruise_max_demand})")
        print(f"Total Berth-Hours Used: {berth_hours_used:.1f} / {total_berth_hours:.1f}")
        # Calculate breakdown based on optimal integer values
        revenue_container = opt_container * container_price
        revenue_cruise = opt_cruise * cruise_revenue_per_ship
        print(f"Revenue Breakdown: Container=${revenue_container:.2f}, Cruise=${revenue_cruise:.2f}")

    elif m27.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible.")
         print(f"Check constraints: Min Container Required ({container_min_required}) vs Max Demand ({container_max_demand}), Berth Hours ({total_berth_hours:.1f}), Berths ({total_berths}).")
         print(f"Min container requires {container_min_required * container_stay:.1f} berth-hours.")

    elif m27.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         # Try to get objective if available (MIPs might have feasible before timeout)
         if m27.ObjVal is not None and abs(m27.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m27.ObjVal:.2f} (Solution may be suboptimal or non-integer)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m27.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- PORT_REVENUE_MGT: Port Revenue Management (MIP) ---
Optimization Status: Optimal
Maximum Total Daily Revenue: $6259.20
Optimal number of Container Ship Reservations: 96 (Demand: 49-96)
Optimal number of Cruise Ship Berths: 72 (Demand: 72)
Total Berth-Hours Used: 578.4 / 4123.7
Revenue Breakdown: Container=$4704.00, Cruise=$1555.20


```

================================================================================



--- Problem 111 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A major construction project has temporarily reduced the capacity of a critical railway segment from two tracks to one, creating a bottleneck during peak traffic conditions. Over four consecutive 15-minute periods, trains arrive at varying rates (3563, 2226, 2972, and 2412 trains per hour, respectively). Train operators can either queue on the main track—now limited to a single track with a capacity of 1894 trains per hour per track—or divert to an alternative route. The alternate path offers a fixed capacity of 2050 trains per hour but adds an extra 8 minutes (0.133 hours) to travel time.  

The challenge is to dynamically allocate trains between the main track and the alternate route to minimize total delay. Delays arise from two sources: (1) queuing on the main track during the construction, and (2) the additional travel time for diverted trains. After the construction clears, the main track reverts to two tracks (3788 trn/h capacity), allowing any remaining queue to dissipate—provided the post-construction arrival rate (3536 trn/h) doesn’t exceed this restored capacity. The optimization must balance immediate rerouting decisions against the long-term cost of lingering congestion.  

**Core Question:** What is the optimal number of trains to divert each period to minimize total system delay, accounting for both queuing and rerouting penalties?  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- `flow_alt[t]`: Trains diverted to the alternate route in period *t* (continuous, ≥0).  
- `flow_main[t]`: Trains remaining on the main track in period *t* (derived: `arrival_rates[t] - flow_alt[t]`).  
- `queue_length[t]`: Queue length (trains) at the end of period *t* (continuous, ≥0).  

**2. Parameters:**  
- `arrival_rates = {1:3563, 2:2226, 3:2972, 4:2412}` (trn/h).  
- `capacity_main_reduced = 1894` (trn/h, 1 track).  
- `alt_route_capacity = 2050` (trn/h).  
- `alt_route_extra_time = 0.133` hours.  
- `dt = 0.25` hours (15-minute periods).  

**3. Objective Function:**  
Minimize total delay, combining:  
- **Main track delay:** Sum of trapezoidal queue areas over all periods (`0.5 * dt * Σ(queue[t-1] + queue[t])`).  
- **Alternate route delay:** Total diverted trains × extra time (`Σ(flow_alt[t] * dt * 0.133)`).  
- **Post-construction delay:** If the queue dissipates (`arrival_rate_post < capacity_main_normal`), penalize by the squared queue at clearance; otherwise, apply a large penalty for non-dissipating queues.  

**4. Constraints:**  
- **Flow conservation:** `flow_main[t] + flow_alt[t] = arrival_rates[t]` for all *t*.  
- **Alternate route capacity:** `flow_alt[t] ≤ 2050` for all *t*.  
- **Queue dynamics:**  
  - Unconstrained queue: `queue_unconstrained[t] = queue[t-1] + (flow_main[t] - 1894) * dt`.  
  - Actual queue: `queue[t] = max(queue_unconstrained[t], 0)`.  
- **Post-construction logic:** If dissipating, `queue_at_clearance = (3788 - 3536) * dissipation_time`; else, penalize `queue_at_clearance` heavily.  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
num_periods = 4
dt = 0.25 # h (15 minutes)
construction_duration_total = num_periods * dt # Should be 1.0 h
arrival_rates = {1: 3563, 2: 2226, 3: 2972, 4: 2412} # trn/h per period
arrival_rate_post = 3536 # trn/h after construction
capacity_per_track = 1894
num_tracks_normal = 2
num_tracks_reduced = 1
alt_route_capacity = 2050
alt_route_extra_time = 0.13333333333333333 # h

capacity_main_reduced = num_tracks_reduced * capacity_per_track
capacity_main_normal = num_tracks_normal * capacity_per_track

periods = range(1, num_periods + 1) # Periods 1, 2, 3, 4

# --- Gurobi Model Setup ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.setParam('TimeLimit', 30)
env.start()
m = gp.Model("DynamicConstructionRerouting_Silent", env=env)

# --- Decision Variables ---
flow_alt = m.addVars(periods, name="flow_alt", lb=0.0)

# --- Intermediate Variables ---
flow_main = m.addVars(periods, name="flow_main", lb=0.0)
queue_length = m.addVars(range(num_periods + 1), name="queue", lb=0.0)
queue_unconstrained = m.addVars(periods, name="queue_unconstrained", lb=-GRB.INFINITY)
delay_alt_total = m.addVar(name="delay_alt_total", lb=0.0)
queue_at_clearance = m.addVar(name="queue_at_clearance", lb=0.0)
delay_main_construction_total = m.addVar(name="delay_main_construction_total", lb=0.0)
dissipation_time = m.addVar(name="dissipation_time", lb=0.0)

# --- Constraints ---
m.addConstr(queue_length[0] == 0, name="InitialQueue")

for t in periods:
    m.addConstr(flow_main[t] + flow_alt[t] == arrival_rates[t], name="FlowConservation_P{0}".format(t))
    m.addConstr(flow_alt[t] <= alt_route_capacity, name="AltCapacity_P{0}".format(t))

for t in periods:
    m.addConstr(queue_unconstrained[t] == queue_length[t-1] + (flow_main[t] - capacity_main_reduced) * dt,
                name="QueueCalcUnc_P{0}".format(t))
    m.addGenConstrMax(queue_length[t], [queue_unconstrained[t]], 0.0, name="QueueEvolution_P{0}".format(t))

m.addConstr(delay_alt_total == gp.quicksum(flow_alt[t] * dt * alt_route_extra_time for t in periods),
            name="CalcAltTotalDelay")

m.addConstr(delay_main_construction_total == 0.5 * dt * gp.quicksum(queue_length[t-1] + queue_length[t] for t in periods),
            name="CalcMainConstructionDelay")

m.addConstr(queue_at_clearance == queue_length[num_periods], name="DefineQueueAtClearance")

# --- Objective Function ---
can_dissipate = arrival_rate_post < capacity_main_normal

if can_dissipate:
    dissipation_rate = capacity_main_normal - arrival_rate_post
    m.addConstr(queue_at_clearance == dissipation_rate * dissipation_time, name="CalcDissipationTime")
    obj = delay_main_construction_total + (0.5 / dissipation_rate) * queue_at_clearance * queue_at_clearance + delay_alt_total
    m.setObjective(obj, GRB.MINIMIZE)
else:
    penalty_factor_non_dissipating = 1000
    obj = delay_main_construction_total + delay_alt_total + penalty_factor_non_dissipating * queue_at_clearance
    m.setObjective(obj, GRB.MINIMIZE)
    m.addConstr(dissipation_time == 1e6, "DissipationTimePenalty")

# --- Optimize ---
m.optimize()

# --- Output Results ---
if m.status == GRB.OPTIMAL:
    for t in periods:
        print("{0:.2f}".format(flow_alt[t].X))
elif m.status == GRB.INFEASIBLE:
    print("Infeasible")
elif m.status == GRB.UNBOUNDED:
    print("Unbounded")
```
Answer:
1669.00
332.00
1078.00
518.00



================================================================================



--- Problem 112 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
A regional logistics company operates a centralized hub to streamline the distribution of goods from three suppliers (*Src_A*, *Src_B*, *Src_C*) to three retail destinations (*Dst_X*, *Dst_Y*, *Dst_Z*). The hub acts as a consolidation point, where shipments are rerouted to minimize transportation costs. Supplier capacities are tight: *Src_A* can provide up to 400 units, *Src_B* 80 units, and *Src_C* 180 units. Meanwhile, destinations have fixed demands: *Dst_X* requires 130 units, *Dst_Y* 110 units, and *Dst_Z* 160 units.  

   Transportation costs vary by route: Moving goods from suppliers to the hub costs $12/unit for *Src_A*, $6/unit for *Src_B*, and $8/unit for *Src_C*. From the hub to destinations, costs are $5/unit to *Dst_X*, $14/unit to *Dst_Y*, and $6/unit to *Dst_Z*. The logistics team must determine how much to ship along each route while ensuring the hub’s inflow matches its outflow, all without exceeding supplier capacities or falling short of demand. The core challenge: **What is the most cost-effective flow plan that meets all operational constraints?**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `flow[(i, j)]`: Continuous non-negative variable representing units shipped from location *i* to *j*, where *i* is a supplier or hub, and *j* is the hub or a destination.  

   **2. Parameters:**  
   - **Supply limits**: `supply = {'Src_A': 400, 'Src_B': 80, 'Src_C': 180}`  
   - **Demand requirements**: `demand = {'Dst_X': 130, 'Dst_Y': 110, 'Dst_Z': 160}`  
   - **Transport costs**: `costs = {('Src_A', 'Hub'): 12, ..., ('Hub', 'Dst_Z'): 6}`  

   **3. Objective Function:**  
   Minimize total cost:  
   ```  
   Minimize: sum(flow[(i, j)] * costs[(i, j)] for all (i, j) in routes)  
   ```  

   **4. Constraints:**  
   - **Supply limits**: For each supplier *s*, `flow[(s, 'Hub')] <= supply[s]`.  
   - **Demand satisfaction**: For each destination *d*, `flow[('Hub', d)] >= demand[d]`.  
   - **Hub balance**: `sum(flow[(s, 'Hub')] for all suppliers s) = sum(flow[('Hub', d)] for all destinations d)`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
sources = ['Src_A', 'Src_B', 'Src_C']
destinations = ['Dst_X', 'Dst_Y', 'Dst_Z']
hub = 'Hub' # Use !r for repr() to keep quotes for the string
supply = {'Src_A': 400, 'Src_B': 80, 'Src_C': 180}
demand = {'Dst_X': 130, 'Dst_Y': 110, 'Dst_Z': 160}
costs = {('Src_A', 'Hub'): 12, ('Src_B', 'Hub'): 6, ('Src_C', 'Hub'): 8, ('Hub', 'Dst_X'): 5, ('Hub', 'Dst_Y'): 14, ('Hub', 'Dst_Z'): 6}
# --- End Parameters ---

GUROBI_TIME_LIMIT = 60

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi console output within exec
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m25 = gp.Model("Logistics_Hub_Flow_LP", env=env)

    # --- Decision Variables ---
    # Flow variables for each arc
    flow_keys = list(costs.keys()) # Explicitly get keys for var creation
    flow = m25.addVars(flow_keys, name="flow", lb=0) # LP variables default to continuous

    # --- Objective Function ---
    # Minimize total transportation cost
    m25.setObjective(gp.quicksum(flow[i, j] * costs[i, j] for i, j in flow_keys), sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Supply constraints at sources
    for s in sources:
        # Ensure the key exists before adding constraint
        arc_key = (s, hub)
        if arc_key in flow:
            # Use string concatenation for name to avoid f-string formatting issues here
            m25.addConstr(flow[arc_key] <= supply[s], name="supply_" + s)
        # No else needed, if arc doesn't exist, can't use it

    # Demand constraints at destinations
    for d in destinations:
         # Ensure the key exists before adding constraint
         arc_key = (hub, d)
         if arc_key in flow:
            # Use string concatenation for name
            m25.addConstr(flow[arc_key] >= demand[d], name="demand_" + d)
         # No else needed

    # Flow balance at the Hub (Inflow = Outflow)
    # Check if keys exist before summing
    inflow_keys_hub = [k for k in flow_keys if k[1] == hub and k[0] in sources]
    outflow_keys_hub = [k for k in flow_keys if k[0] == hub and k[1] in destinations]

    # Check if lists are non-empty before creating expressions that might be empty
    inflow_hub_expr = gp.quicksum(flow[k] for k in inflow_keys_hub) if inflow_keys_hub else 0
    outflow_hub_expr = gp.quicksum(flow[k] for k in outflow_keys_hub) if outflow_keys_hub else 0
    m25.addConstr(inflow_hub_expr == outflow_hub_expr, name="hub_balance")

    # --- Optimization ---
    m25.optimize()

    # --- Store results ---
    results_dict['status'] = m25.status
    if m25.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m25.objVal
        # Store flow values, converting keys back to tuples if needed
        results_dict['flow_sol'] = {k: v for k, v in m25.getAttr('X', flow).items()}
        # Store expression values IF they are LinExpr (might be 0 if no flows)
        results_dict['inflow_val'] = inflow_hub_expr.getValue() if isinstance(inflow_hub_expr, gp.LinExpr) else inflow_hub_expr
        results_dict['outflow_val'] = outflow_hub_expr.getValue() if isinstance(outflow_hub_expr, gp.LinExpr) else outflow_hub_expr


    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print("--- Problem 25: Logistics Hub Truck Flow (LP) ---")
    if m25.status == GRB.OPTIMAL:
        flow_sol = results_dict.get('flow_sol', {}) # Get solution from dict
        print(f"Optimization Status: Optimal")
        # Use .get with a default for obj_val before formatting
        obj_val_print = results_dict.get('obj_val', 0) # Default to 0 if not found
        print(f"Minimum Total Transportation Cost: ${obj_val_print:.2f}")
        print("Optimal Flows:")
        total_supply_used_calc = 0
        total_demand_met_calc = 0
        # Use .items() for iterating through solution dictionary
        for (i, j), flow_val in flow_sol.items():
            if flow_val > 1e-6: # Print only non-negligible flows
                # Escape i, j, flow_val and braces for costs.get()
                print(f"  Flow from {i} to {j}: {flow_val:.1f} units (Cost/Unit: ${costs.get((i,j), 'N/A')})")
                if i in sources: total_supply_used_calc += flow_val
                if j in destinations: total_demand_met_calc += flow_val

        print("\nSummary:")
        # Use .get with defaults for calculated values before formatting
        inflow_print = results_dict.get('inflow_val', 0)
        outflow_print = results_dict.get('outflow_val', 0)
        # Ensure inflow/outflow values are numbers before formatting
        print(f"Total Flow In Hub: {float(inflow_print):.1f}")
        print(f"Total Flow Out Hub: {float(outflow_print):.1f}")
        # Re-calculate supply/demand usage from solution dict for detailed output
        for s in sources:
             flow_out = flow_sol.get((s, hub), 0)
             # Escape s, flow_out and braces for supply.get()
             print(f"  Supply from {s}: {flow_out:.1f} / {supply.get(s, 'N/A')}")
        for d in destinations:
             flow_in = flow_sol.get((hub, d), 0)
             # Escape d, flow_in and braces for demand.get()
             print(f"  Demand met for {d}: {flow_in:.1f} / {demand.get(d, 'N/A')}")

    elif m25.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible. Check if total supply >= total demand.")
         # Calculate totals directly from input params for this message
         # Escape braces for sum() values
         print(f"Total Supply Available: {sum(supply.values())}")
         print(f"Total Demand Required: {sum(demand.values())}")
    elif m25.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)") # Escape limit
         # If objective value exists (feasible solution found before limit), print it
         if m25.ObjVal is not None and abs(m25.ObjVal) < float('inf'):
              # Escape objval
              print(f"Best Objective Found: ${m25.ObjVal:.2f}")
         else:
              print("No feasible solution found within time limit.")
    else:
        # Handle other statuses like UNBOUNDED, INF_OR_UNBD etc.
        print(f"Optimization Status Code: {m25.status}") # Escape status

except GurobiError as e:
    # Escape errno and e message
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
except Exception as e:
    print(f"Python Error: {e}") # Escape error message
    print("--- Traceback ---")
    traceback.print_exc(file=sys.stdout)
    print("--- End Traceback ---")
    results_dict['status'] = -2 # Indicate Python execution error



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 25: Logistics Hub Truck Flow (LP) ---
Optimization Status: Optimal
Minimum Total Transportation Cost: $6750.00
Optimal Flows:
  Flow from Src_A to Hub: 140.0 units (Cost/Unit: $12)
  Flow from Src_B to Hub: 80.0 units (Cost/Unit: $6)
  Flow from Src_C to Hub: 180.0 units (Cost/Unit: $8)
  Flow from Hub to Dst_X: 130.0 units (Cost/Unit: $5)
  Flow from Hub to Dst_Y: 110.0 units (Cost/Unit: $14)
  Flow from Hub to Dst_Z: 160.0 units (Cost/Unit: $6)

Summary:
Total Flow In Hub: 400.0
Total Flow Out Hub: 400.0
  Supply from Src_A: 140.0 / 400
  Supply from Src_B: 80.0 / 80
  Supply from Src_C: 180.0 / 180
  Demand met for Dst_X: 130.0 / 130
  Demand met for Dst_Y: 110.0 / 110
  Demand met for Dst_Z: 160.0 / 160


```

================================================================================



--- Problem 113 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy trucking terminal faces the challenge of efficiently scheduling incoming trucks to a single loading dock, aiming to minimize total tardiness across all vehicles. Five trucks, labeled 1 through 5, arrive at distinct times: Truck 1 arrives at hour 2, Truck 2 at hour 3, Truck 3 at hour 4, Truck 4 at hour 9, and Truck 5 at hour 12. Each truck requires a specific processing time: 7 hours for Trucks 1 and 2, 4 hours for Truck 3, 3 hours for Truck 4, and 8 hours for Truck 5. The terminal must adhere to strict due times: Truck 1 by hour 11, Truck 2 by hour 15, Truck 3 by hour 10, Truck 4 by hour 19, and Truck 5 by hour 25. The central question is: What is the optimal sequence for servicing these trucks at the single loading dock to ensure the cumulative delay beyond their due times is as small as possible?
**

**Modeling Process:**
**
**1. Decision Variables:**
- `assign[i, j]`: Binary variable indicating whether truck `i` is assigned to loading dock `j` (always 1 here, as there’s only one loading dock).
- `start_time[i]`: Continuous variable representing the start time of truck `i` at the loading dock.
- `completion_time[i]`: Continuous variable representing the completion time of truck `i` (start time + processing time).
- `precedes[i, k, j]`: Binary variable indicating whether truck `i` precedes truck `k` at loading dock `j`.
- `tardiness[i]`: Continuous variable representing the tardiness of truck `i` (max(0, completion time - due time)).

**2. Parameters:**
- `trucks`: [1, 2, 3, 4, 5].
- `loading_docks`: [1] (single loading dock).
- `arrival_times`: {1: 2, 2: 3, 3: 4, 4: 9, 5: 12}.
- `processing_times`: {1: 7, 2: 7, 3: 4, 4: 3, 5: 8}.
- `due_times`: {1: 11, 2: 15, 3: 10, 4: 19, 5: 25}.
- `H`: 100 (a large constant for big-M constraints).

**3. Objective Function:**
- Minimize the sum of tardiness across all trucks: `Minimize: sum(tardiness[i] for i in trucks)`.

**4. Constraints:**
- Assignment: Each truck must be assigned to the single loading dock (`assign[i, j] = 1` for all `i`).
- Arrival time: Start time of truck `i` cannot be earlier than its arrival time (`start_time[i] >= arrival_times[i]`).
- Completion time: Completion time is the start time plus processing time (`completion_time[i] = start_time[i] + processing_times[i]`).
- Non-overlapping: For any two trucks `i` and `k`, one must precede the other at the loading dock (enforced via `precedes` variables and big-M constraints).
- Tardiness: Tardiness is the non-negative difference between completion time and due time (`tardiness[i] >= completion_time[i] - due_times[i]`).

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
loading_docks = [1] # Should be [1]
arrival_times = {1: 2, 2: 3, 3: 4, 4: 9, 5: 12}
processing_times = {1: 7, 2: 7, 3: 4, 4: 3, 5: 8}
due_times = {1: 11, 2: 15, 3: 10, 4: 19, 5: 25}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("LOADING_DOCK_PROBLEM_54_MIN_TARDINESS")

    if not trucks or not loading_docks or len(loading_docks)!=1: raise ValueError("Invalid trucks/loading_docks")
    the_loading_dock = loading_docks[0]

    # --- Decision Variables ---
    assign = m.addVars(trucks, loading_docks, vtype=GRB.BINARY, name="assign") # Trivial but keep
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in loading_docks],
                         vtype=GRB.BINARY, name="precedes")
    tardiness = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="tardiness")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(tardiness[i] for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_loading_dock] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (on the single loading dock) using Indicators
    j = the_loading_dock
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                # Link precedence var: if both assigned (always true), one must precede
                m.addConstr(precedes[i,k,j] + (1-precedes[i,k,j]) == 1, name=f"link_prec_{i}_{k}_{j}") # Enforce binary explicitly

    # 5. Tardiness definition
    m.addConstrs((tardiness[i] >= completion_time[i] - due_times.get(i, 0) for i in trucks), name="tardiness_calc")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Tardiness
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Sequence and Details:")
    for i in trucks:
        print(f"Truck {i}: Start Time = {start_time[i].x:.2f}, Completion Time = {completion_time[i].x:.2f}, Tardiness = {tardiness[i].x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
17.0000
Optimal Sequence and Details:
Truck 1: Start Time = 2.00, Completion Time = 9.00, Tardiness = 0.00
Truck 2: Start Time = 16.00, Completion Time = 23.00, Tardiness = 8.00
Truck 3: Start Time = 9.00, Completion Time = 13.00, Tardiness = 3.00
Truck 4: Start Time = 13.00, Completion Time = 16.00, Tardiness = 0.00
Truck 5: Start Time = 23.00, Completion Time = 31.00, Tardiness = 6.00


```

================================================================================



--- Problem 114 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy container terminal is tasked with efficiently assigning berths to a mix of high-priority and regular cargo ships. The terminal offers two types of berths: priority berths (B1, B2, B3) with faster loading/unloading times and standard berths (S1 to S9) with slower loading/unloading. The terminal must berth 12 ships, including 4 high-priority ships (H1 to H4) and 8 regular ships (R5 to R12). Loading/unloading a ship from a priority berth takes 2 hours, while a standard berth takes 4 hours. To prioritize high-priority ships, the terminal incurs a penalty of $15 for every high-priority ship assigned to a standard berth, reflecting the dissatisfaction of delayed service. The challenge is to assign each ship to exactly one berth while minimizing the total cost, which combines loading/unloading time and high-priority penalties. The goal is to find the optimal assignment that balances efficiency and customer satisfaction.
**

**Modeling Process:**
**
**1. Decision Variables:**
- `assign(s, b)`: A binary variable indicating whether ship `s` is assigned to berth `b` (1 if assigned, 0 otherwise).

**2. Parameters:**
- `priority_berths`: List of priority berths (B1, B2, B3).
- `standard_berths`: List of standard berths (S1 to S9).
- `all_berths`: Combined list of all berths.
- `high_priority_ships`: List of high-priority ships (H1 to H4).
- `regular_ships`: List of regular ships (R5 to R12).
- `loading_time`: Dictionary with loading/unloading times (2 hours for priority, 4 hours for standard).
- `high_priority_penalty_standard`: Penalty of $15 for assigning a high-priority ship to a standard berth.

**3. Objective Function:**
Minimize the total cost, which is the sum of loading/unloading times and high-priority penalties:
```
Minimize: sum(assign(s, p) * 2 for all ships s and priority berths p) + sum(assign(s, b) * 4 for all ships s and standard berths b) + sum(assign(s, b) * 15 for high-priority ships s and standard berths b)
```

**4. Constraints:**
- Each ship must be assigned to exactly one berth:
  ```
  For each ship s: sum(assign(s, b) for all berths b) = 1
  ```
- Each berth can accommodate at most one ship:
  ```
  For each berth b: sum(assign(s, b) for all ships s) <= 1
  ```

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
num_priority_berths = 3; num_standard_berths = 9
priority_berths = ['B1', 'B2', 'B3']; standard_berths = ['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8', 'S9']; all_berths = ['B1', 'B2', 'B3', 'S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8', 'S9']
num_total_ships = 12; num_high_priority_ships = 4
ships = ['H1', 'H2', 'H3', 'H4', 'R5', 'R6', 'R7', 'R8', 'R9', 'R10', 'R11', 'R12']; high_priority_ships = ['H1', 'H2', 'H3', 'H4']; regular_ships = ['R5', 'R6', 'R7', 'R8', 'R9', 'R10', 'R11', 'R12']
loading_time = {'Priority': 2, 'Standard': 4}; high_priority_penalty_standard = 15
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m16 = gp.Model("Berth_Assignment_MIP", env=env)
    # Vars
    assign = m16.addVars(ships, all_berths, vtype=GRB.BINARY, name="assign")
    # Objective
    total_loading_time = gp.quicksum(assign[s, p] * loading_time['Priority'] for s in ships for p in priority_berths) + gp.quicksum(assign[s, b] * loading_time['Standard'] for s in ships for b in standard_berths)
    total_penalty = gp.quicksum(assign[s, b] * high_priority_penalty_standard for s in high_priority_ships for b in standard_berths)
    m16.setObjective(total_loading_time + total_penalty, sense=GRB.MINIMIZE)
    # Constraints
    for s in ships: m16.addConstr(gp.quicksum(assign[s, berth] for berth in all_berths) == 1, f"ship_{s}_must_berth")
    for berth in all_berths: m16.addConstr(gp.quicksum(assign[s, berth] for s in ships) <= 1, f"berth_{berth}_capacity")
    # Optimize
    m16.optimize()
    # Store results
    results_dict['status'] = m16.status
    if m16.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m16.objVal
        results_dict['assign_sol'] = m16.getAttr('X', assign)
    # Output Results
    print("--- Problem 16: Berth Assignment (MIP) ---")
    if m16.status == GRB.OPTIMAL:
        print(f"Optimization Status: Optimal")
        print(f"Minimum Total Cost (Loading Time + Penalty): {m16.objVal:.2f}")
        print("Assignments & Costs:")
        assign_sol = results_dict.get('assign_sol', {})
        lt_sum = 0; pen_sum = 0; assignments_dict = {}
        for s in ships:
            for berth in all_berths:
                if assign_sol.get((s, berth), 0) > 0.5:
                    assignments_dict[s] = berth; is_priority = berth in priority_berths; is_high_priority = s in high_priority_ships
                    lt = loading_time['Priority'] if is_priority else loading_time['Standard']; pen = 0
                    if is_high_priority and not is_priority: pen = high_priority_penalty_standard
                    lt_sum += lt; pen_sum += pen
                    print(f"  Ship {s} ({'High-Priority' if is_high_priority else 'Regular'}) -> Berth {berth} ({'Priority' if is_priority else 'Standard'}) | LT: {lt} hours, Penalty: ${pen}")
        print(f"\nTotal Loading Time: {lt_sum} hours"); print(f"Total High-Priority Penalty: ${pen_sum}"); print(f"Objective Value Check: {lt_sum + pen_sum}")
    else: print(f"Optimization Status: {m16.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of BERTH_ASSIGNMENT
```
Answer:
--- Problem 16: Berth Assignment (MIP) ---
Optimization Status: Optimal
Minimum Total Cost (Loading Time + Penalty): 57.00
Assignments & Costs:
  Ship H1 (High-Priority) -> Berth S5 (Standard) | LT: 4 hours, Penalty: $15
  Ship H2 (High-Priority) -> Berth B3 (Priority) | LT: 2 hours, Penalty: $0
  Ship H3 (High-Priority) -> Berth B1 (Priority) | LT: 2 hours, Penalty: $0
  Ship H4 (High-Priority) -> Berth B2 (Priority) | LT: 2 hours, Penalty: $0
  Ship R5 (Regular) -> Berth S2 (Standard) | LT: 4 hours, Penalty: $0
  Ship R6 (Regular) -> Berth S9 (Standard) | LT: 4 hours, Penalty: $0
  Ship R7 (Regular) -> Berth S3 (Standard) | LT: 4 hours, Penalty: $0
  Ship R8 (Regular) -> Berth S8 (Standard) | LT: 4 hours, Penalty: $0
  Ship R9 (Regular) -> Berth S7 (Standard) | LT: 4 hours, Penalty: $0
  Ship R10 (Regular) -> Berth S6 (Standard) | LT: 4 hours, Penalty: $0
  Ship R11 (Regular) -> Berth S1 (Standard) | LT: 4 hours, Penalty: $0
  Ship R12 (Regular) -> Berth S4 (Standard) | LT: 4 hours, Penalty: $0

Total Loading Time: 42 hours
Total High-Priority Penalty: $15
Objective Value Check: 57



================================================================================



--- Problem 115 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy trucking depot, two trucks arrive at different times, each requiring a loading dock for unloading and processing. Truck 1 arrives at 5 hours, needing 4 hours to complete its operations, while Truck 2 arrives at 8 hours, requiring 7 hours of service. The depot has only one loading dock available, forcing a careful scheduling decision to minimize costs. Waiting is expensive: Truck 1 incurs a cost of $80 per hour while idle, and Truck 2 costs $120 per hour. Additionally, servicing each truck at the dock has its own cost structure: $57 per hour for Truck 1 and $56 per hour for Truck 2. The challenge is to assign the trucks to the dock in a way that minimizes the total cost, considering both waiting and service expenses, while ensuring no overlapping operations occur on the same dock. The key question is: *What is the optimal schedule that minimizes the total cost while adhering to arrival times and processing constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary variable (1 if truck `i` is assigned to dock `j`, else 0).  
   - `start_time[i]`: Continuous variable representing the start time of truck `i`.  
   - `completion_time[i]`: Continuous variable representing the completion time of truck `i`.  
   - `precedes[i, k, j]`: Binary variable (1 if truck `i` is scheduled before truck `k` on dock `j`, else 0).  

   **2. Parameters:**  
   - `trucks = [1, 2]`: List of trucks.  
   - `docks = [1]`: List of docks.  
   - `arrival_times = {1: 5, 2: 8}`: Arrival times for each truck.  
   - `processing_times = {1: 4, 2: 7}`: Processing durations for each truck.  
   - `waiting_costs = {1: 80, 2: 120}`: Cost per hour of waiting for each truck.  
   - `service_costs = {(1, 1): 57, (2, 1): 56}`: Cost per hour of servicing for each truck-dock pair.  
   - `H = 100`: A large constant (Big M) for constraint formulation.  

   **3. Objective Function:**  
   Minimize the total cost, which includes waiting costs and service costs:  
   ```  
   Minimize:  
   sum(waiting_costs[i] * (start_time[i] - arrival_times[i]) for i in trucks)  
   + sum(service_costs[(i, j)] * processing_times[i] * assign[i, j] for i in trucks, j in docks)  
   ```  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one dock:  
     ```  
     For each truck i: sum(assign[i, j] for j in docks) = 1  
     ```  
   - **Arrival Time:** A truck cannot start before its arrival time:  
     ```  
     For each truck i: start_time[i] >= arrival_times[i]  
     ```  
   - **Completion Time:** The completion time is the start time plus processing time:  
     ```  
     For each truck i: completion_time[i] = start_time[i] + processing_times[i]  
     ```  
   - **Non-Overlapping:** If two trucks are assigned to the same dock, one must precede the other:  
     ```  
     For each dock j, and trucks i, k (i < k):  
     If precedes[i, k, j] = 1, then start_time[k] >= completion_time[i]  
     If precedes[i, k, j] = 0, then start_time[i] >= completion_time[k]  
     ```  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2]
docks = [1]
arrival_times = {1: 5, 2: 8}
processing_times = {1: 4, 2: 7}
waiting_costs = {1: 80, 2: 120} # Cost per hour waiting
service_costs = {(1, 1): 57, (2, 1): 56} # Cost rate per hour servicing {(truck, dock): cost}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DOCKING_PROBLEM_3_MIN_COST")

    if not trucks or not docks: raise ValueError("Empty trucks or docks")

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes") # y[i,k,j] = 1 if i before k on j

    # --- Objective Function ---
    waiting_cost_expr = gp.quicksum(waiting_costs.get(i, 0) * (start_time[i] - arrival_times.get(i, 0)) for i in trucks)
    service_cost_expr = gp.quicksum(service_costs.get((i,j), 0) * processing_times.get(i, 0) * assign[i,j]
                                   for i in trucks for j in docks)
    m.setObjective(waiting_cost_expr + service_cost_expr, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in docks:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal Schedule:")
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
    print(f"Total Cost: {results_dict['obj_val']:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
740.0000
Optimal Schedule:
Truck 1 - Start Time: 5.0000, Completion Time: 9.0000
Truck 2 - Start Time: 9.0000, Completion Time: 16.0000
Total Cost: 740.0000


```

================================================================================



--- Problem 116 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy trucking terminal faces the challenge of efficiently scheduling incoming trucks to minimize their waiting times before unloading. Four trucks—labeled 1 through 4—arrive at staggered times: Truck 1 at time 2, Truck 2 at time 7, Truck 3 at time 11, and Truck 4 at time 12. Each truck requires a specific processing duration once it reaches a depot: Truck 1 takes 6 time units, Truck 2 takes 8, Truck 3 takes 3, and Truck 4 takes 8. The terminal has three depots available, each capable of handling one truck at a time. The goal is to assign trucks to depots and schedule their start times such that the total waiting time—defined as the difference between a truck’s start time and its arrival time—is minimized. The challenge lies in coordinating assignments and sequencing to avoid overlaps while respecting arrival times and processing requirements.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary `assign[i, j]`: 1 if truck `i` is assigned to depot `j`, else 0.  
     - Continuous `start_time[i]`: Time when truck `i` begins processing.  
     - Continuous `completion_time[i]`: Time when truck `i` finishes (`start_time[i] + processing_times[i]`).  
     - Binary `precedes[i, k, j]`: 1 if truck `i` is scheduled before truck `k` on depot `j`.  

   - **2. Parameters:**  
     - `arrival_times[i]`: Time truck `i` arrives (e.g., Truck 1: 2).  
     - `processing_times[i]`: Duration for truck `i` (e.g., Truck 1: 6).  
     - `H = 100`: A large constant for logical constraints.  

   - **3. Objective Function:**  
     Minimize the total waiting time:  
     `Minimize: sum(start_time[i] - arrival_times[i] for all trucks i)`.  

   - **4. Constraints:**  
     - Each truck is assigned to exactly one depot:  
       `sum(assign[i, j] for all j) = 1` for all trucks `i`.  
     - Start time cannot precede arrival time:  
       `start_time[i] >= arrival_times[i]` for all `i`.  
     - Completion time definition:  
       `completion_time[i] = start_time[i] + processing_times[i]` for all `i`.  
     - Non-overlapping on depots (if two trucks `i` and `k` share depot `j`, one must precede the other):  
       - If `precedes[i, k, j] = 1`, then `start_time[k] >= completion_time[i]`.  
       - If `precedes[i, k, j] = 0`, then `start_time[i] >= completion_time[k]`.  
     - Logical linking: If trucks `i` and `k` are both assigned to depot `j`, enforce precedence:  
       `assign[i, j] + assign[k, j] - 1 <= precedes[i, k, j] + (1 - precedes[i, k, j])`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4]
depots = [1, 2, 3]
arrival_times = {1: 2, 2: 7, 3: 11, 4: 12}
processing_times = {1: 6, 2: 8, 3: 3, 4: 8}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_1_MIN_WAIT")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes") # y[i,k,j] = 1 if i before k on j

    # --- Objective Function ---
    m.setObjective(gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    # Link precedence var: if both assigned, one must precede
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]), name=f"link_prec_{i}_{k}_{j}")


    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Wait time can have decimals
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded") # Should not happen
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
    print(f"Total Waiting Time: {obj_val_print:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
13.0000
Optimal Solution Found:
Truck 1 assigned to Depot 1
Start Time: 2.0000, Completion Time: 8.0000
Truck 2 assigned to Depot 1
Start Time: 8.0000, Completion Time: 16.0000
Truck 3 assigned to Depot 1
Start Time: 16.0000, Completion Time: 19.0000
Truck 4 assigned to Depot 1
Start Time: 19.0000, Completion Time: 27.0000
Total Waiting Time: 13.0000


```

================================================================================



--- Problem 117 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port with six berths is experiencing recurring incidents, each reducing the capacity of the main berthing area while alternative berthing areas remain available. Port managers must dynamically divert ships to minimize total delay while adhering to operational constraints. Each berth has distinct capacities for normal and reduced conditions, alternative berth capacities, and varying arrival rates across ten 30-minute time periods. The diversion strategy must balance between four predefined diversion ratios (10%, 30%, 50%, 70%), ensuring smooth transitions (no more than a 20% change between consecutive periods) and maintaining a system-wide diversion ratio between 30% and 70%. The challenge is to determine the optimal diversion percentage for each berth and time period, minimizing the combined delay from alternative berth travel times and main berth queuing, while respecting all feasibility and transition rules.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variables \( y[i,t,k] \): 1 if berth \( i \) at time \( t \) uses diversion option \( k \) (10%, 30%, 50%, or 70%), else 0.  
     - Continuous variable \( \text{TotalDiversion} \): Average diversion ratio across all berths and periods.  

   - **2. Parameters:**  
     - \( \text{capacities\_main\_normal}[i], \text{capacities\_main\_reduced}[i] \): Main berth capacities (ships/h) for berth \( i \).  
     - \( \text{capacities\_alt}[i] \): Alternative berth capacity (ships/h) for berth \( i \).  
     - \( \text{arrival\_rates}[i][t] \): Ship inflow (ships/h) for berth \( i \) at time \( t \).  
     - \( \text{alt\_berth\_extra\_times}[i] \): Additional travel time (h) for alternative berth of berth \( i \).  
     - \( \text{MAX\_DIVERSION\_CHANGE} = 0.2 \): Maximum allowed diversion ratio change between periods.  
     - \( \text{MIN\_TOTAL\_DIVERSION} = 0.3 \), \( \text{MAX\_TOTAL\_DIVERSION} = 0.7 \): Bounds for system-wide diversion.  

   - **3. Objective Function:**  
     Minimize total delay:  
     \[
     \text{Minimize: } \sum_{i,t,k} y[i,t,k] \cdot \text{berth\_period\_option\_delays}[i][t][k]
     \]  
     where delays combine alternative berth travel time and main berth queuing delays.  

   - **4. Constraints:**  
     - **Feasibility:** Only select diversion options \( k \) where alternative berth capacity is not exceeded.  
     - **Single Option:** Exactly one diversion option per berth and period.  
     - **Smooth Transitions:** Limit diversion ratio changes between consecutive periods to ≤20%.  
     - **Total Diversion Bounds:** Ensure \( 0.3 \leq \text{TotalDiversion} \leq 0.7 \).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 6
NUM_TIME_PERIODS = 10
TIME_PERIOD_LENGTH = 0.5  # h
MAX_DIVERSION_CHANGE = 0.2  # Maximum allowed change in diversion ratio
MIN_TOTAL_DIVERSION = 0.3  # Minimum total diversion ratio
MAX_TOTAL_DIVERSION = 0.7  # Maximum total diversion ratio
capacities_main_normal = [5252, 3063, 5801, 5884, 5258, 5967]  # ships/h
capacities_main_reduced = [3023, 1015, 3887, 3746, 3447, 3183]  # ships/h
capacities_alt = [1100, 1895, 1867, 1611, 1923, 1658]  # ships/h
arrival_rates = [[4918, 4262, 2160, 3897, 4721, 4682, 2441, 3978, 4457, 3612], [4249, 3719, 2445, 3939, 2718, 4969, 2882, 4861, 3775, 3092], [4304, 4648, 3067, 3106, 2682, 2542, 4397, 2129, 2237, 4829], [2174, 4513, 4353, 2316, 3927, 2097, 2176, 3287, 2974, 4999], [2015, 3011, 4180, 4081, 2982, 2704, 2699, 4981, 4112, 2516], [3200, 4093, 3992, 2602, 2610, 3801, 3502, 2935, 4129, 2403]]  # ships/h
incident_durations = [1.981613420761966, 1.545573225158, 1.3955616009998493, 1.8232096340693422, 1.166330161580831, 1.3213818042975742]  # h
alt_berth_extra_times = [0.2161110817102534, 0.332069549104257, 0.3279571747623844, 0.1153146162702008, 0.09933944034250554, 0.13180097963587517]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")
total_diversion = m.addVar(name="TotalDiversion")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

        # Add smooth transition constraints between periods
        if t > 0:
            for k1 in range(num_options):
                for k2 in range(num_options):
                    if abs(diversion_options[k1] - diversion_options[k2]) > MAX_DIVERSION_CHANGE:
                        m.addConstr(y[i,t-1,k1] + y[i,t,k2] <= 1,
                                  name="SmoothTransition_Berth{0}_Period{1}_Options{2}{3}".format(i,t,k1,k2))

# Calculate total diversion ratio
m.addConstr(total_diversion == gp.quicksum(
    y[i,t,k] * diversion_options[k]
    for i in range(NUM_BERTHS)
    for t in range(NUM_TIME_PERIODS)
    for k in range(num_options)
    if berth_period_option_feasible[i][t][k]
) / (NUM_BERTHS * NUM_TIME_PERIODS),
name="TotalDiversionRatio")

# Add total diversion ratio constraints
m.addConstr(total_diversion >= MIN_TOTAL_DIVERSION, name="MinTotalDiversion")
m.addConstr(total_diversion <= MAX_TOTAL_DIVERSION, name="MaxTotalDiversion")

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    print(f"Total Diversion Ratio: {0:.1f}%".format(total_diversion.X * 100))
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:
Total Diversion Ratio: 0.0%

Berth 1:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 0 (10%)
  Period 9 (4.0-4.5h): Option 0 (10%)
  Period 10 (4.5-5.0h): Option 1 (30%)

Berth 2:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 2 (50%)
  Period 3 (1.0-1.5h): Option 2 (50%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 2 (50%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 2 (50%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 2 (50%)
  Period 10 (4.5-5.0h): Option 2 (50%)

Berth 3:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 1 (30%)

Berth 4:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 1 (30%)

Berth 5:
  Period 1 (0.0-0.5h): Option 2 (50%)
  Period 2 (0.5-1.0h): Option 2 (50%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 1 (30%)

Berth 6:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 1 (30%)



================================================================================



--- Problem 118 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy maritime port, ten cargo ships arrive at varying times, each requiring a berth for unloading and processing. The port has four berths available, and each ship must be assigned to exactly one berth. The challenge lies in scheduling these ships to minimize their total waiting time—the time each ship spends idle between its arrival and the start of its processing.  

   The ships arrive at distinct times: Ship 1 at time 1, Ship 2 at time 2, and so on, up to Ship 10 at time 19. Each ship has a specific processing duration: for instance, Ship 1 takes 5 units of time, while Ship 10 requires 9 units. The port authority aims to optimize berth assignments to ensure minimal cumulative delay, balancing arrivals and processing times efficiently.  

   Additionally, the port authority is concerned about the impact of weather conditions, which may cause delays. However, this information is not directly used in the optimization model. The core question is: *How should the ships be assigned to berths, and when should their processing begin, to minimize the total waiting time across all ships while respecting arrival times and avoiding overlapping schedules at the same berth?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable indicating whether ship `i` is assigned to berth `j`.  
   - `start_time(i)`: Continuous variable representing the time when processing begins for ship `i`.  
   - `completion_time(i)`: Continuous variable representing the time when processing ends for ship `i`.  
   - `precedes(i, k, j)`: Binary variable indicating whether ship `i` is scheduled before ship `k` at berth `j`.  

   **2. Parameters:**  
   - `ships = [1, 2, ..., 10]`: List of ships.  
   - `berths = [1, 2, 3, 4]`: List of available berths.  
   - `arrival_times`: Dictionary mapping each ship to its arrival time (e.g., `{1: 1, 2: 2, ..., 10: 19}`).  
   - `processing_times`: Dictionary mapping each ship to its processing duration (e.g., `{1: 5, 2: 9, ..., 10: 9}`).  
   - `H = 200`: A large constant (Big M) for logical constraints.  

   **3. Objective Function:**  
   Minimize the total waiting time for all ships:  
   ```  
   Minimize: sum(start_time[i] - arrival_times[i] for all ships i)  
   ```  

   **4. Constraints:**  
   - **Assignment:** Each ship must be assigned to exactly one berth:  
     ```  
     For each ship i: sum(assign(i, j) for all berths j) = 1  
     ```  
   - **Arrival Time:** Processing cannot start before a ship arrives:  
     ```  
     For each ship i: start_time[i] >= arrival_times[i]  
     ```  
   - **Completion Time:** Processing ends at start time plus processing duration:  
     ```  
     For each ship i: completion_time[i] = start_time[i] + processing_times[i]  
     ```  
   - **Non-Overlapping:** Ships assigned to the same berth must not overlap:  
     ```  
     For each berth j and ships i < k:  
     If precedes(i, k, j) = 1, then start_time[k] >= completion_time[i]  
     If precedes(i, k, j) = 0, then start_time[i] >= completion_time[k]  
     ```  
     Additionally, the `precedes` variable is linked to the assignment variables:  
     ```  
     assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))  
     ```  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
berths = [1, 2, 3, 4]
arrival_times = {1: 1, 2: 2, 3: 5, 4: 6, 5: 9, 6: 10, 7: 14, 8: 16, 9: 18, 10: 19}
processing_times = {1: 5, 2: 9, 3: 4, 4: 6, 5: 5, 6: 9, 7: 9, 8: 8, 9: 5, 10: 9}
H = 200 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_17_LARGE_WAIT")

    if not ships or not berths: raise ValueError("Empty ships or berths")

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in ships for k in ships if i < k for j in berths],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")
        # Print best objective if available on timeout etc.
        if m.SolCount > 0 and abs(m.ObjVal) < GRB.INFINITY :
             print(f"{m.ObjVal:.4f}")
        elif m.status != GRB.INFEASIBLE and m.status != GRB.UNBOUNDED:
             print("No feasible solution found.")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in ships:
        for j in berths:
            if assign[i, j].x > 0.5:
                print(f"Ship {i} is assigned to Berth {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
169.0000
Optimal Solution Found:
Ship 1 is assigned to Berth 1
Start Time: 1.0000, Completion Time: 6.0000
Ship 2 is assigned to Berth 1
Start Time: 43.0000, Completion Time: 52.0000
Ship 3 is assigned to Berth 1
Start Time: 6.0000, Completion Time: 10.0000
Ship 4 is assigned to Berth 1
Start Time: 15.0000, Completion Time: 21.0000
Ship 5 is assigned to Berth 1
Start Time: 10.0000, Completion Time: 15.0000
Ship 6 is assigned to Berth 1
Start Time: 34.0000, Completion Time: 43.0000
Ship 7 is assigned to Berth 1
Start Time: 61.0000, Completion Time: 70.0000
Ship 8 is assigned to Berth 1
Start Time: 26.0000, Completion Time: 34.0000
Ship 9 is assigned to Berth 1
Start Time: 21.0000, Completion Time: 26.0000
Ship 10 is assigned to Berth 1
Start Time: 52.0000, Completion Time: 61.0000


```

================================================================================



--- Problem 119 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port authority faces the challenge of efficiently dispatching two tugboats, T1 and T2, to handle two ship berthing incidents, A and B, occurring at different times. Incident A occurs at time 0, while Incident B occurs 20 minutes later. Each tugboat has specific travel times to reach the incidents: T1 takes 29 minutes to reach A and 28 minutes to reach B, while T2 takes 22 minutes to A and 13 minutes to B. Once an incident is cleared, tugboats can travel between incidents with additional travel times (13 minutes from A to B, 21 minutes from B to A).  

The incidents disrupt port operations, reducing capacity. Incident A has a normal capacity of 3604 ships per hour (60.07 ships/min) and a reduced capacity of 1518 ships/hr (25.3 ships/min), while Incident B has a normal capacity of 5086 ships/hr (84.77 ships/min) and a reduced capacity of 2446 ships/hr (40.77 ships/min). Ships arrive at rates of 2843 ships/hr (47.38 ships/min) for A and 2948 ships/hr (49.13 ships/min) for B. If arrival rates exceed reduced capacity, queues form, increasing delays.  

The port authority must decide:  
- Which tugboat should be assigned to which incident first?  
- Should a tugboat move to the second incident after clearing the first?  
The goal is to minimize total port delay, accounting for queue buildup before clearance, during clearance, and dissipation time afterward. If a queue cannot dissipate naturally (due to insufficient capacity), a heavy penalty is applied.  

**Key Question:** What is the optimal assignment and sequencing of tugboats to incidents to minimize total port delay?  
**

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary `assign_first(k, i)`: 1 if tugboat `k` is assigned to incident `i` as its first task, else 0.  
- Binary `sequence(k, i, j)`: 1 if tugboat `k` moves from incident `i` to `j` after clearing `i`, else 0.  
- Continuous `start_clear(i)`: Time when clearance of incident `i` begins.  
- Continuous `end_clear(i)`: Time when clearance of incident `i` ends.  
- Auxiliary variables for queue calculations (e.g., `queue_at_start_clear(i)`, `dissipation_time(i)`).  

**2. Parameters:**  
- `time_occur(i)`: Incident occurrence time (A: 0, B: 20).  
- `travel_time_base(k, i)`: Tugboat `k`’s travel time to incident `i` (e.g., T1 to A: 29).  
- `travel_time_inter(i, j)`: Travel time between incidents (e.g., A→B: 13).  
- `clearance_time(i)`: Time to clear incident `i` (A: 53, B: 35).  
- `growth_rate_before(i)`: Queue growth rate before clearance (arrival_rate - reduced_capacity).  
- `dissipation_rate(i)`: Queue dissipation rate (normal_capacity - arrival_rate).  
- `non_dissipating_penalty`: 10000 (applied if queue cannot dissipate).  

**3. Objective Function:**  
Minimize total delay =  
- Delay before clearance: `0.5 * growth_rate_before(i) * (start_clear(i) - time_occur(i))^2`  
- Delay during clearance: `0.5 * (queue_at_start_clear(i) + queue_at_clear_end(i)) * clearance_time(i)`  
- Delay after clearance (if dissipatable): `0.5 * (queue_at_clear_end(i)^2) / dissipation_rate(i)`  
- Penalty (if non-dissipating): `10000 * queue_at_clear_end(i)`  

**4. Constraints:**  
- Each incident must be assigned to exactly one tugboat (first or after another incident).  
- Each tugboat can start at most one incident.  
- Sequencing logic: If a tugboat moves from `i` to `j`, it must have been assigned to `i`.  
- Start time constraints:  
  - First assignment: `start_clear(i) ≥ time_occur(i) + travel_time_base(k, i)` if `assign_first(k, i) = 1`.  
  - Sequential assignment: `start_clear(i) ≥ end_clear(j) + travel_time_inter(j, i)` if `sequence(k, j, i) = 1`.  
- Queue calculations:  
  - Queue at start of clearance: `max(0, growth_rate_before(i) * (start_clear(i) - time_occur(i)))`.  
  - Queue at end of clearance: `max(0, queue_at_start_clear(i) + growth_rate_before(i) * clearance_time(i))`.  
  - Dissipation time: `queue_at_clear_end(i) / dissipation_rate(i)` if dissipatable, else 0.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
incidents = ['A', 'B']
tugboats = ['T1', 'T2']

# Times in minutes from simulation start
time_occur = {'A': 0, 'B': 20}
travel_time_base = {('T1', 'A'): 29, ('T1', 'B'): 28, ('T2', 'A'): 22, ('T2', 'B'): 13}
travel_time_inter = {('A', 'B'): 13, ('B', 'A'): 21, ('A', 'A'): 0, ('B', 'B'): 0}
clearance_time = {'A': 53, 'B': 35}

# Capacities and Arrival rates (ships per minute)
cap_normal = {'A': 3604/60, 'B': 5086/60} # ships/min
cap_reduced = {'A': 1518/60, 'B': 2446/60} # ships/min
arrival_rate = {'A': 2843/60, 'B': 2948/60} # ships/min

M = 10000
EPSILON = 1e-6

# Pre-calculate rates
growth_rate_before = {}
dissipation_rate = {}
can_dissipate = {}
inv_dissipation_rate = {}
non_dissipating_penalty = 10000

for i in incidents:
    growth_rate_before[i] = max(0, arrival_rate[i] - cap_reduced[i])
    dissipation_rate[i] = cap_normal[i] - arrival_rate[i]
    can_dissipate[i] = dissipation_rate[i] > EPSILON
    if not can_dissipate[i]:
        inv_dissipation_rate[i] = 0
    else:
        inv_dissipation_rate[i] = 1.0 / dissipation_rate[i]

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("IncidentResourceAllocation", env=env)

# --- Decision Variables ---
assign_first = m.addVars(tugboats, incidents, vtype=GRB.BINARY, name="assign_first")
sequence = m.addVars(tugboats, incidents, incidents, vtype=GRB.BINARY, name="sequence")

# Timing variables
start_clear = m.addVars(incidents, name="start_clear", lb=0.0)
end_clear = m.addVars(incidents, name="end_clear", lb=0.0)

# Queue and Delay related variables
queue_start_clear_time_diff = m.addVars(incidents, name="queue_start_clear_time_diff", lb=0.0)
queue_at_start_clear = m.addVars(incidents, name="queue_at_start_clear", lb=0.0)
aux_q_start = m.addVars(incidents, name="aux_q_start", lb=-GRB.INFINITY)
queue_at_clear_end = m.addVars(incidents, name="queue_at_clear_end", lb=0.0)
aux_q_end = m.addVars(incidents, name="aux_q_end", lb=-GRB.INFINITY)
dissipation_time = m.addVars(incidents, name="dissipation_time", lb=0.0)

# --- Constraints ---
for i in incidents:
    m.addConstr(gp.quicksum(assign_first[k, i] for k in tugboats) +
                gp.quicksum(sequence[k, j, i] for k in tugboats for j in incidents if i != j) == 1,
                name="AssignIncident_{0}".format(i))

for k in tugboats:
    m.addConstr(gp.quicksum(assign_first[k, i] for i in incidents) <= 1, name="TugboatStart_{0}".format(k))

for k in tugboats:
    for i in incidents:
        tugboat_served_i = assign_first[k, i] + gp.quicksum(sequence[k, l, i] for l in incidents if l != i)
        m.addConstr(gp.quicksum(sequence[k, i, j] for j in incidents if i != j) <= tugboat_served_i,
                    name="SequenceLogic_{0}_{1}".format(k, i))
        m.addConstr(sequence[k,i,i] == 0, name="NoSelfLoop_{0}_{1}".format(k, i))
        for j in incidents:
             if i != j:
                  m.addConstr(sequence[k,i,j] + sequence[k,j,i] <= 1, name="NoImmediateLoop_{0}_{1}_{2}".format(k, i, j))

for k in tugboats:
    for i in incidents:
        m.addConstr(start_clear[i] >= time_occur[i] + travel_time_base[k, i] - M * (1 - assign_first[k, i]),
                    name="StartTimeFirst_{0}_{1}".format(k, i))
        for j in incidents:
            if i != j:
                m.addConstr(start_clear[i] >= end_clear[j] + travel_time_inter[j, i] - M * (1 - sequence[k, j, i]),
                            name="StartTimeFollow_{0}_{1}_{2}".format(k, j, i))

for i in incidents:
    m.addConstr(end_clear[i] == start_clear[i] + clearance_time[i], name="EndClearTime_{0}".format(i))
    m.addConstr(start_clear[i] >= time_occur[i], name="StartAfterOccur_{0}".format(i))

for i in incidents:
    m.addConstr(queue_start_clear_time_diff[i] >= start_clear[i] - time_occur[i], name="CalcTimeDiff_{0}".format(i))
    m.addConstr(aux_q_start[i] == growth_rate_before[i] * queue_start_clear_time_diff[i], name="CalcAuxQStart_{0}".format(i))
    m.addGenConstrMax(queue_at_start_clear[i], [aux_q_start[i]], 0.0, name="SetQStartMax_{0}".format(i))
    queue_growth_during_clearance = growth_rate_before[i] * clearance_time[i]
    m.addConstr(aux_q_end[i] == queue_at_start_clear[i] + queue_growth_during_clearance, name="CalcAuxQEnd_{0}".format(i))
    m.addGenConstrMax(queue_at_clear_end[i], [aux_q_end[i]], 0.0, name="SetQEndMax_{0}".format(i))
    if can_dissipate[i]:
         m.addConstr(dissipation_time[i] == queue_at_clear_end[i] * inv_dissipation_rate[i], name="CalcDissipationTime_{0}".format(i))
    else:
         m.addConstr(dissipation_time[i] == 0, name="SetDissipationTimeZero_{0}".format(i))

# --- Objective Function ---
objective = gp.QuadExpr()
for i in incidents:
    delay_before = 0.5 * growth_rate_before[i] * queue_start_clear_time_diff[i] * queue_start_clear_time_diff[i]
    objective += delay_before
    delay_during = 0.5 * (queue_at_start_clear[i] + queue_at_clear_end[i]) * clearance_time[i]
    objective += delay_during
    if can_dissipate[i]:
        delay_dissipation = 0.5 * inv_dissipation_rate[i] * queue_at_clear_end[i] * queue_at_clear_end[i]
        objective += delay_dissipation
    else:
        objective += non_dissipating_penalty * queue_at_clear_end[i]

m.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("{0:.2f}".format(m.objVal))
elif m.status == GRB.INFEASIBLE:
    print("Infeasible")
elif m.status == GRB.UNBOUNDED:
    print("Unbounded")
```
Answer:
190752.05



================================================================================



--- Problem 120 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling seven incoming trucks at two available depots to minimize the maximum waiting time experienced by any vehicle. Each truck arrives at a specific time: Truck 1 at 2 hours, Truck 2 at 3, Truck 3 at 5, Truck 4 at 8, Truck 5 at 10, Truck 6 at 14, and Truck 7 at 16. The processing times vary, with Truck 1 requiring 4 hours, Truck 2 needing 5, Truck 3 taking 7, Truck 4 demanding 8, Truck 5 using 4, Truck 6 occupying 8, and Truck 7 consuming 6 hours. The logistics authority aims to assign each truck to exactly one depot while ensuring no two trucks scheduled at the same depot overlap in service times. The critical objective is to determine the optimal scheduling that minimizes the longest wait any truck endures—the time between its arrival and the start of its processing.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable indicating whether truck `i` is assigned to depot `j`.  
   - `start_time(i)`: Continuous variable representing the time truck `i` begins processing.  
   - `completion_time(i)`: Continuous variable equal to `start_time(i) + processing_time(i)`.  
   - `precedes(i, k, j)`: Binary variable enforcing sequencing; 1 if truck `i` is processed before truck `k` at depot `j`.  
   - `max_wait_time`: Continuous variable capturing the maximum waiting time across all trucks.  

   **2. Parameters:**  
   - `trucks = [1, 2, 3, 4, 5, 6, 7]`, `depots = [1, 2]`.  
   - `arrival_times = {1: 2, 2: 3, ..., 7: 16}`.  
   - `processing_times = {1: 4, 2: 5, ..., 7: 6}`.  
   - `H = 100`: A large constant for logical constraints.  

   **3. Objective Function:**  
   Minimize `max_wait_time`.  

   **4. Constraints:**  
   - **Assignment:** Each truck is assigned to exactly one depot: `sum(assign(i, j) for j in depots) = 1` for all `i`.  
   - **Arrival Time:** Start time cannot precede arrival: `start_time(i) >= arrival_times(i)` for all `i`.  
   - **Completion Time:** `completion_time(i) = start_time(i) + processing_times(i)` for all `i`.  
   - **Non-Overlapping:** For each depot `j`, if `i` precedes `k`, then `start_time(k) >= completion_time(i)`.  
   - **Max Wait Definition:** `max_wait_time >= start_time(i) - arrival_times(i)` for all `i`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7]
depots = [1, 2]
arrival_times = {1: 2, 2: 3, 3: 5, 4: 8, 5: 10, 6: 14, 7: 16}
processing_times = {1: 4, 2: 5, 3: 7, 4: 8, 5: 4, 6: 8, 7: 6}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_MIN_MAX_WAIT")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    max_wait_time = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Wmax") # Objective var

    # --- Objective Function ---
    m.setObjective(max_wait_time, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Max waiting time definition
    m.addConstrs((max_wait_time >= start_time[i] - arrival_times.get(i, 0) for i in trucks), name="wmax_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Max wait time
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.4f}")
                print(f"  Completion Time: {completion_time[i].x:.4f}")
                print(f"  Waiting Time: {start_time[i].x - arrival_times[i]:.4f}")
    print(f"Maximum Waiting Time: {max_wait_time.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
22.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 2
  Start Time: 2.0000
  Completion Time: 6.0000
  Waiting Time: 0.0000
Truck 2 is assigned to Depot 2
  Start Time: 6.0000
  Completion Time: 11.0000
  Waiting Time: 3.0000
Truck 3 is assigned to Depot 2
  Start Time: 11.0000
  Completion Time: 18.0000
  Waiting Time: 6.0000
Truck 4 is assigned to Depot 2
  Start Time: 18.0000
  Completion Time: 26.0000
  Waiting Time: 10.0000
Truck 5 is assigned to Depot 2
  Start Time: 26.0000
  Completion Time: 30.0000
  Waiting Time: 16.0000
Truck 6 is assigned to Depot 2
  Start Time: 30.0000
  Completion Time: 38.0000
  Waiting Time: 16.0000
Truck 7 is assigned to Depot 2
  Start Time: 38.0000
  Completion Time: 44.0000
  Waiting Time: 22.0000
Maximum Waiting Time: 22.0000


```

================================================================================



--- Problem 121 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port terminal is tasked with efficiently scheduling a set of 11 ships to berths to minimize the number of berths used and reduce operational costs. Each berth has strict dimensions of 70 units wide and 19 units long, and the ships vary significantly in size—from a compact (4, 11) unit ship to a bulky (70, 10) unit vessel. The challenge is to arrange these ships into the fewest possible berths without overlaps or boundary violations, ensuring optimal space utilization. The operational stakes are high: every unused berth translates to cost savings, but improper scheduling risks delays or safety issues. The core question is: *What is the minimal number of berths required to fit all ships, and where should each ship be placed within those berths to achieve this?*
**

2. **Modeling Process:**
**
**1. Decision Variables:**  
   - Binary `x[i, j]`: 1 if ship *i* is assigned to berth *j*, else 0.  
   - Binary `y[j]`: 1 if berth *j* is used, else 0.  
   - Continuous `px[i, j]`, `py[i, j]`: Bottom-left coordinates of ship *i* in berth *j*.  
   - Binary `left[i, k, j]`, `right[i, k, j]`, `below[i, k, j]`, `above[i, k, j]`: 1 if ship *i* is positioned left/right/below/above ship *k* in berth *j*.  

   **2. Parameters:**  
   - `ships`: List of ship dimensions (e.g., (46, 11)).  
   - `berth_size`: (70, 19).  
   - `M_w`, `M_h`: Big-M values (70 and 19, respectively).  

   **3. Objective Function:**  
   Minimize total berths used:  
   \[
   \text{Minimize: } \sum_{j} y[j]
   \]  

   **4. Constraints:**  
   - **Assignment:** Each ship *i* must be in exactly one berth:  
     \[
     \sum_{j} x[i, j] = 1 \quad \forall i
     \]  
   - **Berth Boundaries:** Ship *i* in berth *j* must fit within the berth:  
     \[
     px[i, j] + \text{ship}_i\text{.width} \leq 70 + M_w (1 - x[i, j]) \quad \forall i, j
     \]  
     (Analogous for height.)  
   - **Non-Overlapping:** For ships *i* and *k* in the same berth *j*, enforce at least one spatial relation (left/right/below/above):  
     \[
     \text{left}[i, k, j] + \text{right}[i, k, j] + \text{below}[i, k, j] + \text{above}[i, k, j] \geq x[i, j] + x[k, j] - 1 \quad \forall i < k, j
     \]  
   - **Berth Activation:** Berth *j* is used if any ship is assigned to it:  
     \[
     x[i, j] \leq y[j] \quad \forall i, j
     \]  
**

3. **Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
ships = [(46, 11), (6, 18), (60, 3), (19, 6), (68, 17), (4, 11), (12, 5), (16, 6), (47, 6), (70, 10), (17, 18)]  # (width, length) of ships
berth_size = (70, 19)  # (width, length) of each berth
num_ships = 11 # len(ships)
# Maximum berths needed (worst case: one ship per berth)
# Can sometimes be reduced with lower bounds, but num_ships is safe
num_berths = num_ships
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using berth dimensions is common and valid)
M_w = berth_size[0]
M_h = berth_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Berth Packing", env=env)

# --- Decision Variables ---
# x[i,j]: ship i assigned to berth j
x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of ship i if in berth j
px = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of ships *within the same berth*
left  = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="left")
right = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="right")
below = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="below")
above = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_berths))

# --- Constraints ---

# 1. Each ship must be assigned to exactly one berth
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Ship placement constraints within berth boundaries (Big-M formulation)
for j in range(num_berths):
    for i in range(num_ships):
        ship_w, ship_l = ships[i] # Get dimensions for ship i

        # Position variables must be 0 if ship i is not in berth j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Ship's right edge <= berth width IF ship is placed in berth (x[i,j]=1)
        model.addConstr(px[i, j] + ship_w <= berth_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Ship's top edge <= berth length IF ship is placed in berth (x[i,j]=1)
        model.addConstr(py[i, j] + ship_l <= berth_size[1] + M_h * (1 - x[i, j]), name=f"Length_Limit_{i}_{j}")

# 3. Non-overlapping constraints for ships within the same berth
for j in range(num_berths):
    for i in range(num_ships):
        for k in range(i + 1, num_ships): # Iterate over distinct pairs (i < k)
            ship_i_w, ship_i_l = ships[i]
            ship_k_w, ship_k_l = ships[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => ship i is to the left of ship k
            model.addConstr(px[i, j] + ship_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => ship i is to the right of ship k (k is left of i)
            model.addConstr(px[k, j] + ship_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => ship i is below ship k
            model.addConstr(py[i, j] + ship_i_l <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => ship i is above ship k (k is below i)
            model.addConstr(py[k, j] + ship_k_l <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH ship i and ship k are in berth j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link ship assignment to berth usage: If any ship i is in berth j, then berth j must be used (y[j]=1)
#    This can be done per ship or aggregated. Per ship is often tighter.
for j in range(num_berths):
    for i in range(num_ships):
        model.addConstr(x[i, j] <= y[j], name=f"Ship_Berth_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_ships * y[j], name=f"Berth_Activation_{j}")


# --- Solve ---
print("Solving 2DBP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of berths used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    berth_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_berths):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Berth {j_sol + 1} (Used):")
            ships_in_berth_info = []
            for i_sol in range(num_ships):
                if x[i_sol, j_sol].X > 0.5:
                    ship_data = {
                        "id": i_sol,
                        "dims": ships[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    ships_in_berth_info.append(ship_data)
                    print(f"  Ship {ship_data['id']} {ship_data['dims']} at {ship_data['pos']}")
            berth_details.append({'berth_index': j_sol, 'ships': ships_in_berth_info})
            print("-" * 10)
    results_dict['berth_details'] = berth_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# The provided code already prints the optimal number of berths used and the detailed placement of each ship within the berths.
# No additional print statements are necessary.
```
Answer:
Solving 2DBP instance...
Gurobi Error code 10010: Model too large for size-limited license; visit https://gurobi.com/unrestricted for more information

Optimization finished with status: -1. No optimal solution found.


```

================================================================================



--- Problem 122 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy maritime port is tasked with efficiently scheduling six incoming ships (S1 to S6) across three available berths (B1 to B3). Each ship arrives at a specific time: S1 at 5 hours, S2 at 8, S3 at 13, S4 at 17, S5 at 19, and S6 at 22. The port must carefully manage these arrivals, as each ship requires a distinct processing time: S1 and S2 take 6 hours each, S3 and S6 require 8 hours, S4 needs 3 hours, and S5 demands 7 hours.  

   The port faces a critical operational challenge: minimizing the total time to service all ships (the *makespan*) while adhering to strict rules. Ships cannot overlap on the same berth, and each must start processing only after arrival. Additionally, Ship S1 has a special service-level agreement (SLA): its waiting time (start time minus arrival time) must not exceed 9.1 hours. The port’s central question is: *How can ships be assigned to berths and sequenced to finish all operations as early as possible, while respecting the SLA constraint?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary `assign(i, j)`: 1 if ship *i* is assigned to berth *j*, else 0.  
   - Continuous `start_time(i)`: When ship *i* begins processing.  
   - Continuous `completion_time(i)`: When ship *i* finishes (`start_time(i) + processing_time(i)`).  
   - Binary `precedes(i, k, j)`: 1 if ship *i* is processed before ship *k* on berth *j*, else 0.  
   - Continuous `makespan`: Latest completion time across all ships.  

   **2. Parameters:**  
   - `arrival_times[i]`: Ship *i*’s arrival (e.g., S1: 5).  
   - `processing_times[i]`: Ship *i*’s service duration (e.g., S1: 6).  
   - `sla_ship = 5`: SLA applies to S1.  
   - `sla_max_wait = 9.1`: Max allowed wait for S1.  
   - `H = 100`: A large constant for precedence constraints.  

   **3. Objective Function:**  
   Minimize `makespan` (the latest completion time).  

   **4. Constraints:**  
   - Each ship assigned to exactly one berth: `sum(assign(i, j) for all j) = 1` for all *i*.  
   - Start time ≥ arrival time: `start_time(i) ≥ arrival_times[i]` for all *i*.  
   - Completion time definition: `completion_time(i) = start_time(i) + processing_times[i]`.  
   - No overlapping on berths: For each berth *j*, if ships *i* and *k* are assigned to *j*, enforce `precedes(i, k, j)` or `precedes(k, i, j)` to sequence them.  
   - SLA for S1: `start_time(1) - arrival_times[1] ≤ 9.1`.  
   - `makespan` is the maximum completion time: `makespan ≥ completion_time(i)` for all *i*.  
   - New Constraint: Ensure that no two ships with processing times greater than 5 hours are scheduled consecutively on the same berth.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3, 4, 5, 6]
berths = [1, 2, 3]
arrival_times = {1: 5, 2: 8, 3: 13, 4: 17, 5: 19, 6: 22}
processing_times = {1: 6, 2: 6, 3: 8, 4: 3, 5: 7, 6: 8}
H = 100 # Big M
sla_ship = 5
sla_max_wait = 9.1
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_60_SLA")

    if not ships or not berths: raise ValueError("Empty ships or berths")
    if sla_ship not in ships: raise ValueError("SLA ship not in ships list")

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(ships, ships, berths, vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in ships), name="makespan_def")
    # 6. SLA Constraint
    m.addConstr(start_time[sla_ship] - arrival_times.get(sla_ship, 0) <= sla_max_wait, name=f"SLA_ship_{sla_ship}")

    # 7. New Constraint: No two ships with processing times > 5 hours consecutively on the same berth
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k and processing_times[i] > 5 and processing_times[k] > 5:
                    m.addConstr(precedes[i, k, j] == 0, name=f"no_consecutive_long_{i}_{k}_{j}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in ships:
        for j in berths:
            if assign[i, j].x > 0.5:
                print(f"Ship S{i} is assigned to Berth B{j}")
    for i in ships:
        print(f"Start time for Ship S{i}: {start_time[i].x:.4f}")
        print(f"Completion time for Ship S{i}: {completion_time[i].x:.4f}")
    print(f"Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
32.0000
Optimal Solution Found:
Ship S1 is assigned to Berth B1
Ship S2 is assigned to Berth B3
Ship S3 is assigned to Berth B1
Ship S4 is assigned to Berth B2
Ship S5 is assigned to Berth B3
Ship S6 is assigned to Berth B2
Start time for Ship S1: 21.0000
Completion time for Ship S1: 27.0000
Start time for Ship S2: 26.0000
Completion time for Ship S2: 32.0000
Start time for Ship S3: 13.0000
Completion time for Ship S3: 21.0000
Start time for Ship S4: 17.0000
Completion time for Ship S4: 20.0000
Start time for Ship S5: 19.0000
Completion time for Ship S5: 26.0000
Start time for Ship S6: 22.0000
Completion time for Ship S6: 30.0000
Makespan: 32.0000


```

================================================================================



--- Problem 123 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling five incoming trucks at two available depots, each with strict arrival and processing time constraints. Truck 1 arrives at 5:00, followed by Truck 2 at 8:00, Truck 3 at 9:00, Truck 4 at 10:00, and Truck 5 at 14:00. Their processing times vary: Trucks 1 and 2 require 5 hours each, Trucks 3 and 4 need 8 hours, and Truck 5 takes 7 hours. The hub manager must assign each truck to exactly one depot while ensuring no two trucks at the same depot overlap in service time. The primary goal is to minimize the total operational time (makespan)—the moment the last truck departs—to maximize depot availability for future arrivals. The core question is: *What is the optimal assignment and scheduling of trucks to depots to achieve the shortest possible completion time?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary `assign(i, j)`: 1 if truck *i* is assigned to depot *j*, else 0.  
   - Continuous `start_time(i)`: Start time of truck *i*.  
   - Continuous `completion_time(i)`: Completion time of truck *i* (start time + processing time).  
   - Binary `precedes(i, k, j)`: 1 if truck *i* precedes truck *k* at depot *j*, else 0 (for pairwise sequencing).  
   - Continuous `makespan`: Latest completion time across all trucks.  

   **2. Parameters:**  
   - `trucks`: [1, 2, 3, 4, 5].  
   - `depots`: [1, 2].  
   - `arrival_times`: {1:5, 2:8, 3:9, 4:10, 5:14}.  
   - `processing_times`: {1:5, 2:5, 3:8, 4:8, 5:7}.  
   - `H` (Big M): 100 (a sufficiently large constant for linearization).  

   **3. Objective Function:**  
   Minimize `makespan`.  

   **4. Constraints:**  
   - **Assignment:** Each truck is assigned to exactly one depot: `sum(assign(i, j) for j in depots) = 1` for all *i*.  
   - **Arrival Time:** Start time cannot precede arrival: `start_time(i) >= arrival_times[i]` for all *i*.  
   - **Completion Time:** `completion_time(i) = start_time(i) + processing_times[i]` for all *i*.  
   - **Non-Overlapping:** For each depot *j* and trucks *i*, *k* (*i* < *k*):  
     - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
     - If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.  
     - Logical linkage: `assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))`.  
   - **Makespan Definition:** `makespan >= completion_time(i)` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2]
arrival_times = {1: 5, 2: 8, 3: 9, 4: 10, 5: 14}
processing_times = {1: 5, 2: 5, 3: 8, 4: 8, 5: 7}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM_MIN_MAKESPAN")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Assignment and Scheduling:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
    print(f"Total Makespan: {makespan.x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
38.0000
Optimal Assignment and Scheduling:
Truck 1 assigned to Depot 2
Start Time: 5.0000, Completion Time: 10.0000
Truck 2 assigned to Depot 2
Start Time: 10.0000, Completion Time: 15.0000
Truck 3 assigned to Depot 2
Start Time: 15.0000, Completion Time: 23.0000
Truck 4 assigned to Depot 2
Start Time: 23.0000, Completion Time: 31.0000
Truck 5 assigned to Depot 2
Start Time: 31.0000, Completion Time: 38.0000
Total Makespan: 38.0000


```

================================================================================



--- Problem 124 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy trucking depot, a critical scheduling challenge arises: efficiently managing the unloading of eight cargo trucks (Trucks 1 through 8) at a single unloading bay to minimize the total operational time (makespan). Each truck arrives at a specific time: Truck 1 at 2 hours, Truck 2 at 5 hours, and so on, with the last arrival being Truck 8 at 26 hours. The processing times vary, ranging from 3 hours (Truck 2) to 7 hours (Trucks 3 and 6). A stringent service-level agreement (SLA) mandates that Truck 8—the highest-priority vehicle—must begin unloading within 5 hours of its arrival. The depot management seeks an optimal schedule that respects arrival times, avoids overlapping assignments, and adheres to the SLA while ensuring the earliest possible completion of all operations. The core question: *What is the minimal makespan achievable under these constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary `assign(i, j)`: 1 if Truck *i* is assigned to Bay *j*, else 0.  
   - Continuous `start_time(i)`: When Truck *i* begins processing.  
   - Continuous `completion_time(i)`: When Truck *i* finishes (`start_time(i) + processing_time(i)`).  
   - Binary `precedes(i, k, j)`: 1 if Truck *i* is scheduled before Truck *k* on Bay *j*, else 0.  
   - Continuous `makespan`: Maximum completion time across all trucks.  

   **2. Parameters:**  
   - `arrival_times[i]`: Truck *i*'s arrival (e.g., Truck 1: 2, Truck 8: 26).  
   - `processing_times[i]`: Truck *i*'s service duration (e.g., Truck 1: 6, Truck 8: 4).  
   - `sla_truck = 8`: Priority truck.  
   - `sla_max_wait = 5`: Max wait time for Truck 8.  
   - `H = 100`: A large constant for precedence constraints.  

   **3. Objective Function:**  
   Minimize `makespan`.  

   **4. Constraints:**  
   - Each truck assigned to exactly one bay: `sum(assign(i, j) for j in bays) = 1` for all *i*.  
   - Start time ≥ arrival time: `start_time(i) ≥ arrival_times[i]` for all *i*.  
   - Completion time definition: `completion_time(i) = start_time(i) + processing_times[i]`.  
   - Non-overlapping on the same bay: For each bay *j* and trucks *i*, *k* (*i < k*), enforce either `precedes(i, k, j)` or `precedes(k, i, j)` via indicator constraints.  
   - SLA for Truck 8: `start_time(8) - arrival_times[8] ≤ 5`.  
   - Makespan definition: `makespan ≥ completion_time(i)` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7, 8]
bays = [1]
arrival_times = {1: 2, 2: 5, 3: 10, 4: 13, 5: 17, 6: 20, 7: 24, 8: 26}
processing_times = {1: 6, 2: 3, 3: 7, 4: 6, 5: 4, 6: 7, 7: 6, 8: 4}
H = 100 # Big M
sla_truck = 8
sla_max_wait = 5.0
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("UNLOADING_BAY_PROBLEM_60_SLA")

    if not trucks or not bays: raise ValueError("Empty trucks or bays")
    if sla_truck not in trucks: raise ValueError("SLA truck not in trucks list")

    # --- Decision Variables ---
    assign = m.addVars(trucks, bays, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, bays, vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in bays:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. SLA Constraint
    m.addConstr(start_time[sla_truck] - arrival_times.get(sla_truck, 0) <= sla_max_wait, name=f"SLA_truck_{sla_truck}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    print("Optimal Schedule:")
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.2f}, Completion Time: {completion_time[i].x:.2f}")
    print(f"SLA Truck 8 Start Time: {start_time[sla_truck].x:.2f}")
    print(f"Total Makespan: {makespan.x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
45.0000
Optimal Schedule:
Truck 1 - Start Time: 2.00, Completion Time: 8.00
Truck 2 - Start Time: 8.00, Completion Time: 11.00
Truck 3 - Start Time: 11.00, Completion Time: 18.00
Truck 4 - Start Time: 18.00, Completion Time: 24.00
Truck 5 - Start Time: 35.00, Completion Time: 39.00
Truck 6 - Start Time: 24.00, Completion Time: 31.00
Truck 7 - Start Time: 39.00, Completion Time: 45.00
Truck 8 - Start Time: 31.00, Completion Time: 35.00
SLA Truck 8 Start Time: 31.00
Total Makespan: 45.00


```

================================================================================



--- Problem 125 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A railway incident has reduced the capacity of a critical track segment from two tracks to one, creating a bottleneck during peak traffic hours. The incident lasts for exactly one hour, divided into four 15-minute periods. Railway traffic managers must dynamically reroute trains to an alternative route to minimize total delay while respecting the reduced capacity of the main track and the finite capacity of the alternative route.

The main track’s normal capacity is 3,564 trains per hour (2 tracks × 1,782 trains per track/hour), but during the incident, it drops to 1,782 trains/hour (1 track). The alternative route can handle up to 2,947 trains/hour but adds an extra 8 minutes (0.133 hours) of travel time per train. Train demand fluctuates across the four periods: 2,148, 3,511, 3,094, and 2,710 trains/hour, respectively. After the incident, train demand stabilizes at 2,577 trains/hour.

The challenge is to determine the optimal number of trains to divert to the alternative route in each period, balancing congestion on the main track (where queues form if demand exceeds reduced capacity) against the fixed delay penalty of the alternative route. The goal is to minimize the total delay, which includes both the time trains spend waiting in queues on the main track and the extra travel time for diverted trains.
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `flow_alt[t]`: Trains diverted to the alternative route in period *t* (continuous, ≥ 0).  

**2. Intermediate Variables:**  
- `flow_main[t]`: Trains remaining on the main track in period *t*.  
- `queue_length[t]`: Queue length at the end of period *t* (≥ 0).  
- `queue_unconstrained[t]`: Temporary queue calculation (unbounded).  
- `delay_alt_total`: Total delay from diverted trains (sum of `flow_alt[t] × extra time`).  
- `delay_main_incident_total`: Total delay from queuing on the main track (trapezoidal area under queue-length curve).  
- `queue_at_clearance`: Queue remaining when the incident ends.  
- `dissipation_time`: Time to clear the residual queue post-incident (if demand < normal capacity).  

**3. Parameters:**  
- `arrival_rates[t]`: Demand in period *t* (2,148, 3,511, 3,094, 2,710 trains/hour).  
- `capacity_main_reduced`: 1,782 trains/hour.  
- `alt_route_capacity`: 2,947 trains/hour.  
- `alt_route_extra_time`: 0.133 hours/train.  
- `dt`: 0.25 hours (15 minutes).  

**4. Objective Function:**  
Minimize total delay:  
- If post-incident demand (2,577) < normal capacity (3,564):  
  - Total delay = `delay_main_incident_total` + `delay_alt_total` + `0.5 × (queue_at_clearance² / dissipation_rate)`.  
- Else: Penalize residual queue with a large penalty term (1,000 × `queue_at_clearance`).  

**5. Constraints:**  
- Flow conservation: `flow_main[t] + flow_alt[t] = arrival_rates[t]` for all *t*.  
- Alternative route capacity: `flow_alt[t] ≤ 2,947` for all *t*.  
- Queue dynamics:  
  - `queue_unconstrained[t] = queue_length[t-1] + (flow_main[t] - 1,782) × 0.25`.  
  - `queue_length[t] = max(queue_unconstrained[t], 0)`.  
- Total delays:  
  - `delay_alt_total = sum(flow_alt[t] × 0.25 × 0.133 for all t)`.  
  - `delay_main_incident_total = 0.5 × 0.25 × sum(queue_length[t-1] + queue_length[t] for all t)`.  
- Post-incident queue clearance (if applicable): `queue_at_clearance = (3,564 - 2,577) × dissipation_time`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
num_periods = 4
dt = 0.25 # h (15 minutes)
incident_duration_total = num_periods * dt # Should be 1.0 h
arrival_rates = {1: 2148, 2: 3511, 3: 3094, 4: 2710} # trains/h per period
arrival_rate_post = 2577 # trains/h after incident
capacity_per_track = 1782
num_tracks_normal = 2
num_tracks_reduced = 1
alt_route_capacity = 2947
alt_route_extra_time = 0.13333333333333333 # h

capacity_main_reduced = num_tracks_reduced * capacity_per_track
capacity_main_normal = num_tracks_normal * capacity_per_track

periods = range(1, num_periods + 1) # Periods 1, 2, 3, 4

# --- Gurobi Model Setup ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.setParam('TimeLimit', 30)
env.start()
m = gp.Model("DynamicRailwayRerouting_Silent", env=env)

# --- Decision Variables ---
flow_alt = m.addVars(periods, name="flow_alt", lb=0.0)

# --- Intermediate Variables ---
flow_main = m.addVars(periods, name="flow_main", lb=0.0)
queue_length = m.addVars(range(num_periods + 1), name="queue", lb=0.0)
queue_unconstrained = m.addVars(periods, name="queue_unconstrained", lb=-GRB.INFINITY)
delay_alt_total = m.addVar(name="delay_alt_total", lb=0.0)
queue_at_clearance = m.addVar(name="queue_at_clearance", lb=0.0)
delay_main_incident_total = m.addVar(name="delay_main_incident_total", lb=0.0)
dissipation_time = m.addVar(name="dissipation_time", lb=0.0)

# --- Constraints ---
m.addConstr(queue_length[0] == 0, name="InitialQueue")

for t in periods:
    m.addConstr(flow_main[t] + flow_alt[t] == arrival_rates[t], name="FlowConservation_P{0}".format(t))
    m.addConstr(flow_alt[t] <= alt_route_capacity, name="AltCapacity_P{0}".format(t))

for t in periods:
    m.addConstr(queue_unconstrained[t] == queue_length[t-1] + (flow_main[t] - capacity_main_reduced) * dt,
                name="QueueCalcUnc_P{0}".format(t))
    m.addGenConstrMax(queue_length[t], [queue_unconstrained[t]], 0.0, name="QueueEvolution_P{0}".format(t))

m.addConstr(delay_alt_total == gp.quicksum(flow_alt[t] * dt * alt_route_extra_time for t in periods),
            name="CalcAltTotalDelay")

m.addConstr(delay_main_incident_total == 0.5 * dt * gp.quicksum(queue_length[t-1] + queue_length[t] for t in periods),
            name="CalcMainIncidentDelay")

m.addConstr(queue_at_clearance == queue_length[num_periods], name="DefineQueueAtClearance")

# --- Objective Function ---
can_dissipate = arrival_rate_post < capacity_main_normal

if can_dissipate:
    dissipation_rate = capacity_main_normal - arrival_rate_post
    m.addConstr(queue_at_clearance == dissipation_rate * dissipation_time, name="CalcDissipationTime")
    obj = delay_main_incident_total + (0.5 / dissipation_rate) * queue_at_clearance * queue_at_clearance + delay_alt_total
    m.setObjective(obj, GRB.MINIMIZE)
else:
    penalty_factor_non_dissipating = 1000
    obj = delay_main_incident_total + delay_alt_total + penalty_factor_non_dissipating * queue_at_clearance
    m.setObjective(obj, GRB.MINIMIZE)
    m.addConstr(dissipation_time == 1e6, "DissipationTimePenalty")

# --- Optimize ---
m.optimize()

# --- Output Results ---
if m.status == GRB.OPTIMAL:
    for t in periods:
        print("{0:.2f}".format(flow_alt[t].X))
elif m.status == GRB.INFEASIBLE:
    print("Infeasible")
elif m.status == GRB.UNBOUNDED:
    print("Unbounded")
```
Answer:
366.00
1729.00
1312.00
895.10



================================================================================



--- Problem 126 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
In a busy port, the harbor master needs to coordinate the berthing times for three different types of ships (cargo, tanker, and passenger) to minimize the total waiting time. Each type of ship has a specific arrival rate, quantified by flow coefficients of 1092, 548, and 544 ships per hour, respectively. The port operates under strict timing constraints: berthing times for each type must fall between 17 and 80 minutes, and the total cycle time—the duration before the berthing pattern repeats—is fixed at 80 minutes. Waiting times arise when ships wait during non-berthing periods, calculated as the product of the ship flow and the non-berthing time (cycle time minus berthing time). The core question is: *How should the 80-minute cycle be allocated among the three types of ships to minimize the cumulative waiting time experienced by all ships?*

**Modeling Process:**
- **1. Decision Variables:**  
     Let \( t_i \) represent the berthing time (in minutes) allocated to ship type \( i \), where \( i \in \{1, 2, 3\} \). Each \( t_i \) is a continuous variable bounded between 17 and 80.  
   - **2. Parameters:**  
     - \( \text{flow_coeffs} = [1092, 548, 544] \): Arrival rates for each ship type.  
     - \( \text{cycle_time} = 80 \): Total duration of the berthing cycle.  
     - \( \text{lb_time} = 17 \), \( \text{ub_time} = 80 \): Lower/upper bounds for berthing times.  
   - **3. Objective Function:**  
     Minimize the total waiting time:  
     \[
     \text{Minimize: } \sum_{i=1}^{3} \text{flow_coeffs}[i] \times (\text{cycle_time} - t_i)
     \]  
   - **4. Constraints:**  
     - **Total cycle time:** The sum of berthing times must equal 80 minutes:  
       \[
       t_1 + t_2 + t_3 = 80
       \]  
     - **Variable bounds:** Each \( t_i \) must satisfy \( 17 \leq t_i \leq 80 \).  

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_ship_types = 3
lb_time = 17          # Lower bound for berthing time
ub_time = 80          # Upper bound for berthing time
cycle_time = 80   # Total cycle time (set equal to ub_time)
flow_coeffs = [1092, 548, 544] # Arrival rates per ship type
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_ship_types:
    print("Error: flow_coeffs length mismatch with num_ship_types")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_ship_types}-Type Ship Berthing", env=env)

        # --- Decision variables (dynamic based on num_ship_types) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_ship_types, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for ship type i is proportional to flow * non-berthing_time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_ship_types)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_ship_types)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_ship_types)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_ship_types):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
Optimal total waiting time: 105924.00
------------------------------
Optimal berthing times (minutes):
  t1: 46.00, t2: 17.00, t3: 17.00



================================================================================



--- Problem 127 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A port authority is facing the challenge of managing the berthing of 221 ships daily while minimizing operational costs. The port has two options: using its own berths or outsourcing to a nearby private port. Each berth can handle up to 9 ships per day at a cost of $165 per berth. Outsourcing, while flexible, comes at a higher marginal cost of $39 per ship. The port is limited to a maximum of 22 berths, adding a layer of complexity to the decision. The core question is: *How many berths should the port use daily, and how many ships should be outsourced, to meet demand at the lowest possible total cost?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n`: Integer number of berths to use (0 ≤ `n` ≤ 22).  
     - `outsourced`: Integer number of ships outsourced (≥ 0).  
   - **2. Parameters:**  
     - Total demand = 221 ships.  
     - Ships per berth = 9.  
     - Cost per berth = $165.  
     - Cost per outsourced ship = $39.  
   - **3. Objective Function:**  
     Minimize total cost:  
     \[ \text{Total Cost} = 165 \cdot n + 39 \cdot \text{outsourced} \]  
   - **4. Constraints:**  
     - Demand fulfillment:  
       \[ 9 \cdot n + \text{outsourced} \geq 221 \]  
     - Berth limit:  
       \[ n \leq 22 \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_ships_demand = 221
ships_per_berth_day = 9
cost_per_berth_day = 165
cost_per_outsourced_ship = 39
max_berths = 22
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m37 = gp.Model("BERTH_SIZE_OPTIMIZATION_IP", env=env)

    # --- Decision Variables ---
    # Integer: Number of berths to use
    n = m37.addVar(vtype=GRB.INTEGER, name="num_berths", lb=0, ub=max_berths)
    # Integer: Number of ships outsourced
    outsourced = m37.addVar(vtype=GRB.INTEGER, name="num_outsourced", lb=0)

    # --- Objective Function ---
    # Minimize total cost (berth cost + outsourcing cost)
    m37.setObjective(n * cost_per_berth_day + outsourced * cost_per_outsourced_ship, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Ensure total demand is met by own berths + outsourcing
    # Avoid division by zero for ships_per_berth_day
    if ships_per_berth_day > 0:
        m37.addConstr(n * ships_per_berth_day + outsourced >= total_ships_demand, name="demand_met")
    else:
        # If capacity is zero, all demand must be outsourced
        m37.addConstr(outsourced >= total_ships_demand, name="demand_met_zero_cap")
        m37.addConstr(n == 0, name="force_zero_berths") # Cannot use berths with zero capacity

    # --- Optimization ---
    m37.optimize()

    # --- Store results ---
    results_dict['status'] = m37.status
    if m37.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m37.ObjVal
        results_dict['n_sol'] = n.X
        results_dict['outsourced_sol'] = outsourced.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 37: Berth Size Optimization (IP) ---") # Original problem number
    if m37.status == GRB.OPTIMAL:
        opt_n = int(round(results_dict.get('n_sol', 0)))
        opt_outsourced = int(round(results_dict.get('outsourced_sol', 0)))
        capacity_own = opt_n * ships_per_berth_day
        cost_own = opt_n * cost_per_berth_day
        cost_outsource = opt_outsourced * cost_per_outsourced_ship
        obj_val_print = results_dict.get('obj_val', 'N/A')

        print(f"Optimization Status: Optimal")
        print(f"Optimal Number of Berths: {opt_n} (Max: {max_berths})")
        print(f"  Own Berth Capacity: {capacity_own} ships")
        print(f"Number of Outsourced Ships: {opt_outsourced}")
        print(f"Total Ships Covered: {capacity_own + opt_outsourced} (Demand: {total_ships_demand})")
        print(f"\nCosts:")
        print(f"  Own Berth Cost: ${cost_own:.2f}")
        print(f"  Outsourcing Cost: ${cost_outsource:.2f}")
        print(f"Minimum Total Daily Cost: ${float(obj_val_print):.2f}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m37.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 37: Berth Size Optimization (IP) ---
Optimization Status: Optimal
Optimal Number of Berths: 22 (Max: 22)
  Own Berth Capacity: 198 ships
Number of Outsourced Ships: 23
Total Ships Covered: 221 (Demand: 221)

Costs:
  Own Berth Cost: $3630.00
  Outsourcing Cost: $897.00
Minimum Total Daily Cost: $4527.00


```

================================================================================



--- Problem 128 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
A busy trucking terminal is facing the challenge of efficiently scheduling incoming cargo trucks to minimize the total time required to service all vehicles. Five trucks, labeled 1 through 5, arrive at staggered times: Truck 1 at hour 4, Truck 2 at hour 9, Truck 3 at hour 10, Truck 4 at hour 12, and Truck 5 at hour 14. Each truck requires a specific processing duration: Truck 1 takes 3 hours, Truck 2 takes 6 hours, Truck 3 takes 3 hours, Truck 4 takes 7 hours, and Truck 5 takes 5 hours. The terminal has only two depots available, and each truck must be assigned to exactly one depot without overlapping schedules. The key operational rule is that no two trucks can occupy the same depot simultaneously—if assigned to the same depot, one must finish before the next begins. The terminal manager seeks the optimal assignment and scheduling of trucks to depots to ensure the last truck departs as early as possible, minimizing the total operational time, or *makespan*. The core question is: **What is the optimal depot assignment and start times for each truck to achieve the shortest possible completion time for all trucks?**

**Modeling Process:**
- **1. Decision Variables:**  
     - Binary `assign(i, j)`: 1 if truck *i* is assigned to depot *j*, else 0.  
     - Continuous `start_time(i)`: Start time of truck *i*.  
     - Continuous `completion_time(i)`: Completion time of truck *i* (start time + processing time).  
     - Binary `precedes(i, k, j)`: 1 if truck *i* precedes truck *k* on depot *j*, else 0.  
     - Continuous `makespan`: Total time until the last truck departs (objective).  

   - **2. Parameters:**  
     - `trucks`: [1, 2, 3, 4, 5].  
     - `depots`: [1, 2].  
     - `arrival_times`: {1:4, 2:9, 3:10, 4:12, 5:14}.  
     - `processing_times`: {1:3, 2:6, 3:3, 4:7, 5:5}.  
     - `H` (Big M): 100 (a sufficiently large constant for precedence constraints).  

   - **3. Objective Function:**  
     Minimize `makespan` (the latest completion time among all trucks).  

   - **4. Constraints:**  
     - **Assignment:** Each truck assigned to exactly one depot: `sum(assign(i, j) for j in depots) = 1` for all *i*.  
     - **Arrival Time:** Start time of truck *i* ≥ its arrival time: `start_time(i) ≥ arrival_times(i)` for all *i*.  
     - **Completion Time:** `completion_time(i) = start_time(i) + processing_times(i)` for all *i*.  
     - **Non-Overlapping:** For each depot *j*, if trucks *i* and *k* are assigned to *j*, one must precede the other:  
       - `precedes(i, k, j) + precedes(k, i, j) ≥ assign(i, j) + assign(k, j) - 1` (enforce precedence if both assigned to *j*).  
       - `precedes(i, k, j) + precedes(k, i, j) ≤ 1` (mutual exclusion).  
       - If `precedes(i, k, j) = 1`, then `start_time(k) ≥ completion_time(i)` (no overlap).  
     - **Makespan Definition:** `makespan ≥ completion_time(i)` for all *i*.  

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2]
arrival_times = {1: 4, 2: 9, 3: 10, 4: 12, 5: 14}
processing_times = {1: 3, 2: 6, 3: 3, 4: 7, 5: 5}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_2_MIN_MAKESPAN")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times[i] for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times[i] for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
    print(f"Total Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
20.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 2
Start Time: 6.0000, Completion Time: 9.0000
Truck 2 is assigned to Depot 2
Start Time: 9.0000, Completion Time: 15.0000
Truck 3 is assigned to Depot 1
Start Time: 10.0000, Completion Time: 13.0000
Truck 4 is assigned to Depot 1
Start Time: 13.0000, Completion Time: 20.0000
Truck 5 is assigned to Depot 2
Start Time: 15.0000, Completion Time: 20.0000
Total Makespan: 20.0000


```

================================================================================



--- Problem 129 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
A port operator faces the challenge of dynamically adjusting berthing fees for two distinct periods—off-peak and peak—to maximize revenue while respecting infrastructure constraints. During off-peak hours, the base demand for berthing is 1,155 ships per hour, while peak hours see a significantly higher base demand of 3,198 ships per hour. The operator knows that demand is sensitive to fee changes: for every $1 increase in fees, demand drops by 62 ships per hour. The port has a fixed capacity of 3,996 ships per hour, meaning the actual flow of ships cannot exceed this limit, regardless of demand. Additionally, the operator cannot charge more than $15 per ship in any period.

The operator’s dilemma is to determine the optimal berthing fees for each period that will maximize total revenue, balancing the trade-off between higher fees (which reduce demand but increase per-ship revenue) and lower fees (which attract more ships but yield less revenue per ship). The solution must also ensure that the actual flow of ships never surpasses the port’s capacity or the demand for that period. The core question is: *What berthing fees should be set for off-peak and peak periods to achieve the highest possible total revenue, given these constraints?*

---

**Modeling Process:**
#### 1. **Decision Variables:**
   - `fee[p]`: The berthing fee (in dollars) for period `p` (where `p` is either 'off' or 'peak'). Bounded between 0 and 15.
   - `demand[p]`: The resulting demand (in ships per hour) for period `p`, calculated as a function of the base demand and fee sensitivity.
   - `flow[p]`: The actual flow of ships (in ships per hour) for period `p`, which is the minimum of demand and capacity.

#### 2. **Parameters:**
   - `base_demand = {'off': 1155, 'peak': 3198}`: Base demand (ships/hr) for each period.
   - `alpha = 62`: Fee sensitivity coefficient (demand drops by 62 ships/hr per $1 increase).
   - `capacity = 3996`: Maximum flow capacity (ships/hr) of the port.
   - `max_fee = 15`: Upper bound on berthing fee ($).

#### 3. **Objective Function:**
   - Maximize the total revenue across both periods:
     ```
     Maximize: sum(flow[p] * fee[p] for p in periods)
     ```

#### 4. **Constraints:**
   - **Demand Calculation:** For each period `p`, demand is linearly dependent on fee:
     ```
     demand[p] = base_demand[p] - alpha * fee[p]
     ```
   - **Flow Capacity:** The actual flow cannot exceed the port’s capacity:
     ```
     flow[p] <= capacity for each p
     ```
   - **Flow Demand:** The actual flow cannot exceed the demand:
     ```
     flow[p] <= demand[p] for each p
     ```
   - **Non-Negativity:** All variables (`fee`, `demand`, `flow`) are non-negative.

---

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 3996; base_demand = {'off': 1155, 'peak': 3198}; alpha = 62; max_fee = 15; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berthing_Fees_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berthing Fees (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of TOLL_PRICING
```
Answer:
--- Problem 18: Dynamic Berthing Fees (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $39399.13
  Period: Off
    Optimal Fee: $9.31 (Max: $15)
    Resulting Demand: 577.5 ships/hr (Base: 1155)
    Actual Flow (min(Demand, Capacity)): 577.5 ships/hr (Capacity: 3996)
    Revenue this period: $5379.13
  Period: Peak
    Optimal Fee: $15.00 (Max: $15)
    Resulting Demand: 2268.0 ships/hr (Base: 3198)
    Actual Flow (min(Demand, Capacity)): 2268.0 ships/hr (Capacity: 3996)
    Revenue this period: $34020.00
Total ships processed: 2845.5



================================================================================


--- Problem 130 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy maritime port, the port manager faces a critical scheduling challenge: seven cargo ships, each with strict deadlines, must be serviced at a single available berth. The goal is to minimize the total tardiness—ensuring that ships depart as close to their due times as possible to avoid costly delays. Each ship arrives at a specific time (Ship 1 at 5 hours, Ship 2 at 7 hours, etc.), requires a fixed processing duration (e.g., Ship 1 needs 8 hours), and has a hard deadline (Ship 1’s due time is 18 hours). The berth can only handle one ship at a time, forcing careful sequencing to avoid overlaps. Additionally, the weather forecast predicts mild conditions, which should not affect the operations. The core question is: *What is the optimal schedule that minimizes the total tardiness across all ships, given their arrival times, processing requirements, and deadlines?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign[i, j]`: Binary (1 if ship *i* is assigned to berth *j*; always 1 here).  
     - `start_time[i]`: Continuous, ≥0 (when ship *i* begins service).  
     - `completion_time[i]`: Continuous, ≥0 (`start_time[i] + processing_times[i]`).  
     - `precedes[i, k, j]`: Binary (1 if ship *i* is scheduled before ship *k* on berth *j*).  
     - `tardiness[i]`: Continuous, ≥0 (max(0, `completion_time[i] - due_times[i]`)).  

   - **2. Parameters:**  
     - `ships`: [1, 2, 3, 4, 5, 6, 7].  
     - `berths`: [1] (single berth).  
     - `arrival_times`: {1:5, 2:7, ..., 7:20}.  
     - `processing_times`: {1:8, 2:5, ..., 7:5}.  
     - `due_times`: {1:18, 2:20, ..., 7:38}.  
     - `H=100`: Large constant for precedence constraints.  

   - **3. Objective Function:**  
     Minimize total tardiness:  
     ```  
     Minimize: sum(tardiness[i] for all ships i)  
     ```  

   - **4. Constraints:**  
     - **Assignment:** Each ship *i* must use the berth (`assign[i, 1] = 1`).  
     - **Arrival time:** `start_time[i] ≥ arrival_times[i]`.  
     - **Completion time:** `completion_time[i] = start_time[i] + processing_times[i]`.  
     - **Non-overlapping:** For ships *i* and *k* (*i < k*), enforce:  
       - If `precedes[i,k,1] = 1`, then `start_time[k] ≥ completion_time[i]`.  
       - Else, `start_time[i] ≥ completion_time[k]`.  
     - **Tardiness:** `tardiness[i] ≥ completion_time[i] - due_times[i]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3, 4, 5, 6, 7]
berths = [1] # Should be [1]
arrival_times = {1: 5, 2: 7, 3: 8, 4: 10, 5: 15, 6: 19, 7: 20}
processing_times = {1: 8, 2: 5, 3: 4, 4: 5, 5: 6, 6: 5, 7: 5}
due_times = {1: 18, 2: 20, 3: 22, 4: 20, 5: 27, 6: 45, 7: 38}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_54_MIN_TARDINESS")

    if not ships or not berths or len(berths)!=1: raise ValueError("Invalid ships/berths")
    the_berth = berths[0]

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign") # Trivial but keep
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in ships for k in ships if i < k for j in berths],
                         vtype=GRB.BINARY, name="precedes")
    tardiness = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="tardiness")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(tardiness[i] for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_berth] == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping (on the single berth) using Indicators
    j = the_berth
    for i in ships:
        for k in ships:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                # Link precedence var: if both assigned (always true), one must precede
                m.addConstr(precedes[i,k,j] + (1-precedes[i,k,j]) == 1, name=f"link_prec_{i}_{k}_{j}") # Enforce binary explicitly

    # 5. Tardiness definition
    m.addConstrs((tardiness[i] >= completion_time[i] - due_times.get(i, 0) for i in ships), name="tardiness_calc")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Tardiness
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Schedule:")
    for i in ships:
        print(f"Ship {i}: Start Time = {start_time[i].x:.2f}, Completion Time = {completion_time[i].x:.2f}, Tardiness = {tardiness[i].x:.2f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
13.0000
Optimal Schedule:
Ship 1: Start Time = 5.00, Completion Time = 13.00, Tardiness = 0.00
Ship 2: Start Time = 13.00, Completion Time = 18.00, Tardiness = 0.00
Ship 3: Start Time = 18.00, Completion Time = 22.00, Tardiness = 0.00
Ship 4: Start Time = 22.00, Completion Time = 27.00, Tardiness = 7.00
Ship 5: Start Time = 27.00, Completion Time = 33.00, Tardiness = 6.00
Ship 6: Start Time = 38.00, Completion Time = 43.00, Tardiness = 0.00
Ship 7: Start Time = 33.00, Completion Time = 38.00, Tardiness = 0.00


```

================================================================================



--- Problem 131 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A busy maritime port is tasked with efficiently scheduling the berthing of incoming ships to minimize delays while adhering to strict operational constraints. Five ships (1 through 5) arrive at staggered times: Ship 1 at 4 hours, Ship 2 at 5, Ship 3 at 7, Ship 4 at 11, and Ship 5 at 15. Each ship requires a specific processing time: 8, 3, 6, 8, and 8 hours, respectively. The port has three berths available, but a critical rule complicates scheduling: Ships 1, 2, and 5 must all dock at the *same* berth, likely due to shared cargo handling requirements or specialized equipment. Additionally, the port has a new constraint that no ship can start processing before 6 hours after its arrival time. The goal is to assign ships to berths and schedule their start times such that no two ships occupy the same berth simultaneously, all ships start *after* their arrival, and the total waiting time (start time minus arrival time) across all ships is minimized. The challenge lies in balancing berth utilization while respecting the group constraint and temporal dependencies.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary (1 if ship *i* is assigned to berth *j*).  
   - `start_time(i)`: Continuous (start time of ship *i*).  
   - `completion_time(i)`: Continuous (completion time of ship *i*).  
   - `precedes(i, k, j)`: Binary (1 if ship *i* precedes ship *k* on berth *j*).  
   - `group_berth(j)`: Binary (1 if berth *j* is selected for the group of ships).  

   **2. Parameters:**  
   - `arrival_times[i]`: Arrival time of ship *i* (e.g., 4 for Ship 1).  
   - `processing_times[i]`: Processing duration of ship *i* (e.g., 8 for Ship 1).  
   - `group_A_ships`: Ships requiring the same berth (1, 2, 5).  
   - `H`: Large constant (100) for logical constraints.  

   **3. Objective Function:**  
   Minimize the total waiting time:  
   `Minimize: sum(start_time[i] - arrival_times[i] for all ships i)`.  

   **4. Constraints:**  
   - Each ship assigned to exactly one berth: `sum(assign(i, j) for all j) = 1` for all *i*.  
   - Start time ≥ arrival time: `start_time[i] ≥ arrival_times[i]` for all *i*.  
   - Start time ≥ 6 hours after arrival time: `start_time[i] ≥ arrival_times[i] + 6` for all *i*.  
   - Completion time definition: `completion_time[i] = start_time[i] + processing_times[i]`.  
   - Non-overlapping on berths: For each berth *j*, if `assign(i, j) = 1` and `assign(k, j) = 1`, enforce `precedes(i, k, j)` to sequence ships.  
   - Group constraint: Exactly one berth hosts all group ships: `sum(group_berth[j] for all j) = 1`, and `assign(i, j) ≤ group_berth[j]` for group ships *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3, 4, 5]
berths = [1, 2, 3]
arrival_times = {1: 4, 2: 5, 3: 7, 4: 11, 5: 15}
processing_times = {1: 8, 2: 3, 3: 6, 4: 8, 5: 8}
group_A_ships = [1, 2, 5] # Ships that must use the same berth
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_65_GROUP")

    if not ships or not berths: raise ValueError("Empty ships or berths")
    # if not group_A_ships: print("Warning: group_A_ships is empty") # Allow empty group

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in ships for k in ships if i < k for j in berths],
                         vtype=GRB.BINARY, name="precedes")
    group_berth = m.addVars(berths, vtype=GRB.BINARY, name="group_berth")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. New Constraint: Start time ≥ 6 hours after arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) + 6 for i in ships), name="min_start_time")
    # 4. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 5. Non-overlapping using Indicator constraints
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 6. Group Constraint
    if group_A_ships:
        m.addConstr(group_berth.sum('*') == 1, name="one_group_berth")
        for i in group_A_ships:
            for j in berths:
                m.addConstr(assign[i, j] <= group_berth[j], name=f"group_A_assign_{i}_{j}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in ships:
        for j in berths:
            if assign[i, j].x > 0.5:
                print(f"Ship {i} assigned to Berth {j}")
    for i in ships:
        print(f"Start time for Ship {i}: {start_time[i].x:.4f}")
        print(f"Completion time for Ship {i}: {completion_time[i].x:.4f}")
    for j in berths:
        if group_berth[j].x > 0.5:
            print(f"Berth {j} is selected for the group of ships")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
67.0000
Optimal Solution Found:
Ship 1 assigned to Berth 1
Ship 2 assigned to Berth 1
Ship 3 assigned to Berth 1
Ship 4 assigned to Berth 1
Ship 5 assigned to Berth 1
Start time for Ship 1: 20.0000
Completion time for Ship 1: 28.0000
Start time for Ship 2: 11.0000
Completion time for Ship 2: 14.0000
Start time for Ship 3: 14.0000
Completion time for Ship 3: 20.0000
Start time for Ship 4: 36.0000
Completion time for Ship 4: 44.0000
Start time for Ship 5: 28.0000
Completion time for Ship 5: 36.0000
Berth 1 is selected for the group of ships


```

================================================================================



--- Problem 132 ---
**Difficulty:** easy
**Category:** LP

**Problem Description:**
**
In a busy port, the harbor master is tasked with coordinating the berthing times for two distinct types of cargo ships to minimize delays. The port operates with **2 distinct berthing phases**, each serving a specific type of ship. The harbor master must allocate berthing time to each phase within a strict **total cycle time of 17 hours**, ensuring smooth operations while adhering to practical limits: no phase can have less than **5 hours** or more than **17 hours** of berthing time.  

   The **cargo handling characteristics** further complicate the decision. Phase 1 handles a high-volume flow with a delay coefficient of **498**, meaning every hour of non-berthing time (cycle time minus berthing time) contributes significantly to congestion. Phase 2, with a coefficient of **2401**, is even more sensitive to delays—its ships experience nearly five times the delay impact per hour of waiting. The core question is: *How should the 17-hour cycle be split between the two phases to minimize the total delay experienced by all ships?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( t_1 \) and \( t_2 \) represent the berthing time (in hours) allocated to Phase 1 and Phase 2, respectively. Both are continuous variables bounded between 5 and 17.  
   - **2. Parameters:**  
     - \( \text{flow_coeffs} = [498, 2401] \): Delay coefficients per phase.  
     - \( \text{cycle_time} = 17 \): Fixed total cycle time.  
     - \( \text{lb_time} = 5 \), \( \text{ub_time} = 17 \): Lower/upper bounds for berthing times.  
   - **3. Objective Function:**  
     Minimize the total delay:  
     \[ \text{Minimize: } 498 \times (17 - t_1) + 2401 \times (17 - t_2). \]  
   - **4. Constraints:**  
     - The sum of berthing times must match the cycle time:  
       \[ t_1 + t_2 = 17. \]  
     - Bounds on variables:  
       \[ 5 \leq t_1 \leq 17, \quad 5 \leq t_2 \leq 17. \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 2
lb_time = 5          # Lower bound for berthing time
ub_time = 17          # Upper bound for berthing time
cycle_time = 17   # Total cycle time (set equal to ub_time)
flow_coeffs = [498, 2401] # Cargo handling coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Time Allocation", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for phase i is proportional to flow * non-berthing_time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
Optimal total delay: 17981.00
------------------------------
Optimal berthing times (hours):
  t1: 5.00, t2: 12.00



================================================================================



--- Problem 133 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy inland logistics hub faces the challenge of efficiently scheduling six incoming trucks at two available depots. Each truck arrives at a specific time: Truck 1 at 2 hours, Truck 2 at 7 hours, Truck 3 at 11 hours, Truck 4 at 13 hours, Truck 5 at 14 hours, and Truck 6 at 18 hours. The processing time for each truck varies depending on the depot it is assigned to. For instance, Truck 1 takes 3 hours at Depot 1 but only 2 hours at Depot 2, while Truck 2 requires 4 hours at Depot 1 and 6 hours at Depot 2. Similar variability exists for the other trucks. The logistics manager must assign each truck to exactly one depot and schedule their start times such that no two trucks occupy the same depot simultaneously. The goal is to minimize the total processing time across all trucks, ensuring efficient use of resources and timely departures. The core question is: What is the optimal assignment and scheduling of trucks to depots that achieves the minimum total processing time while respecting arrival times and depot occupancy constraints?
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary variable indicating whether Truck *i* is assigned to Depot *j*.  
   - `start_time[i]`: Continuous variable representing the start time of Truck *i*.  
   - `completion_time[i]`: Continuous variable representing the completion time of Truck *i*.  
   - `precedes[i, k, j]`: Binary variable indicating whether Truck *i* precedes Truck *k* at Depot *j*.  

   **2. Parameters:**  
   - `trucks`: List of trucks [1, 2, 3, 4, 5, 6].  
   - `depots`: List of depots [1, 2].  
   - `arrival_times[i]`: Arrival time of Truck *i*.  
   - `processing_times[i, j]`: Processing time of Truck *i* at Depot *j*.  
   - `H`: A large constant (100) used for big-M constraints.  

   **3. Objective Function:**  
   Minimize the total processing time:  
   `Minimize: sum(processing_times[i, j] * assign[i, j] for all i, j)`  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot:  
     `sum(assign[i, j] for all j) = 1 for all i`.  
   - **Arrival Time:** A truck cannot start before its arrival time:  
     `start_time[i] >= arrival_times[i] for all i`.  
   - **Completion Time:** The completion time is the start time plus the processing time:  
     `completion_time[i] = start_time[i] + sum(processing_times[i, j] * assign[i, j] for all j) for all i`.  
   - **Non-Overlapping:** For each depot, trucks must not overlap:  
     If `precedes[i, k, j] = 1`, then `start_time[k] >= completion_time[i]`.  
     If `precedes[i, k, j] = 0`, then `start_time[i] >= completion_time[k]`.  
     Additionally, `assign[i, j] + assign[k, j] - 1 <= precedes[i, k, j] + (1 - precedes[i, k, j])`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
depots = [1, 2]
arrival_times = {1: 2, 2: 7, 3: 11, 4: 13, 5: 14, 6: 18}
processing_times = {(1, 1): 3, (1, 2): 2, (2, 1): 4, (2, 2): 6, (3, 1): 3, (3, 2): 6, (4, 1): 3, (4, 2): 1, (5, 1): 2, (5, 2): 2, (6, 1): 5, (6, 2): 5} # Dict {(truck, depot): time}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    # Minimize total actual processing time used
    m.setObjective(gp.quicksum(processing_times.get((i,j), 0) * assign[i,j] for i in trucks for j in depots), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (depot dependent)
    m.addConstrs((completion_time[i] == start_time[i] + gp.quicksum(processing_times.get((i,j), 0) * assign[i,j] for j in depots)
                  for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Total proc time
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the assignment and scheduling details
if m.status == GRB.OPTIMAL:
    print("Optimal Assignment and Scheduling:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.2f}")
                print(f"  Completion Time: {completion_time[i].x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
17.0000
Optimal Assignment and Scheduling:
Truck 1 assigned to Depot 2
  Start Time: 2.00
  Completion Time: 4.00
Truck 2 assigned to Depot 1
  Start Time: 7.00
  Completion Time: 11.00
Truck 3 assigned to Depot 1
  Start Time: 11.00
  Completion Time: 14.00
Truck 4 assigned to Depot 2
  Start Time: 14.00
  Completion Time: 15.00
Truck 5 assigned to Depot 2
  Start Time: 15.00
  Completion Time: 17.00
Truck 6 assigned to Depot 2
  Start Time: 18.00
  Completion Time: 23.00


```

================================================================================



--- Problem 134 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy inland logistics hub, a critical scheduling challenge arises for a single depot that must accommodate three trucks with strict time window constraints. Trucks 1, 2, and 3 arrive at times 3, 4, and 9, respectively, and require processing times of 3, 4, and 3 hours to unload their cargo. The depot operates in cycles, with each cycle lasting 9 hours, and each operational window within a cycle is only 5 hours long, during which trucks can safely dock. The logistics manager must assign each truck to the depot such that their start and completion times fall entirely within one of these operational windows, while ensuring no two trucks occupy the depot simultaneously. The goal is to minimize the total makespan—the time when the last truck departs—so the depot can efficiently handle future arrivals. Given the tight operational restrictions and overlapping arrival times, the central question is: *What is the optimal schedule that adheres to operational constraints and minimizes the total operational time?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary variable (1 if truck *i* is assigned to depot *j*, else 0).  
   - `start_time[i]`: Continuous variable for the start time of truck *i*.  
   - `completion_time[i]`: Continuous variable for the completion time of truck *i*.  
   - `precedes[i, k, j]`: Binary variable (1 if truck *i* precedes truck *k* on depot *j*, else 0).  
   - `makespan`: Continuous variable representing the latest completion time.  
   - `z[i, k]`: Binary variable (1 if truck *i* starts in operational cycle *k*, else 0).  

   **2. Parameters:**  
   - `trucks = [1, 2, 3]`, `depots = [1]`.  
   - `arrival_times = {1: 3, 2: 4, 3: 9}`.  
   - `processing_times = {1: 3, 2: 4, 3: 3}`.  
   - `operational_cycle = 9`, `operational_duration = 5`.  
   - `H = 100` (large constant for constraints).  
   - `max_k = 5` (maximum operational cycles considered).  

   **3. Objective Function:**  
   Minimize `makespan`.  

   **4. Constraints:**  
   - **Assignment:** Each truck must use the depot: `assign[i, j] = 1` for all *i*.  
   - **Arrival Time:** `start_time[i] >= arrival_times[i]`.  
   - **Completion Time:** `completion_time[i] = start_time[i] + processing_times[i]`.  
   - **Non-Overlapping:** For trucks *i* and *k* on the same depot, either *i* precedes *k* (`start_time[k] >= completion_time[i]`) or vice versa.  
   - **Makespan:** `makespan >= completion_time[i]` for all *i*.  
   - **Operational Windows:** Each truck must start and finish within one operational window:  
     - `sum(z[i, k] for k) = 1` (truck *i* uses exactly one window).  
     - If `z[i, k] = 1`, then `start_time[i]` and `completion_time[i]` must lie within the *k*-th window (`[k * operational_cycle, k * operational_cycle + operational_duration]`).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
depots = [1] # Should be [1]
arrival_times = {1: 3, 2: 4, 3: 9}
processing_times = {1: 3, 2: 4, 3: 3}
operational_cycle = 9
operational_duration = 5
H = 100 # Big M
max_k = 5 # Estimated max cycles needed
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_13_OPERATIONAL")

    if not trucks or not depots or len(depots)!=1: raise ValueError("Invalid trucks/depots")
    the_depot = depots[0]

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign") # Trivial
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    # Operational constraint variables
    z = m.addVars(trucks, range(max_k), vtype=GRB.BINARY, name="start_cycle")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_depot] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (on the single depot) using Indicators
    j = the_depot
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. Operational Constraint
    for i in trucks:
        m.addConstr(z.sum(i, '*') == 1, name=f"truck_{i}_one_cycle")
        for k in range(max_k):
            window_start = k * operational_cycle
            # Allow starting exactly at window_end? Original logic might need <= window_end
            # Using strict < window_end by using window_start + duration as upper bound
            window_end_strict = window_start + operational_duration
            # If z[i,k]=1, then window_start <= s[i] < window_end_strict
            m.addGenConstrIndicator(z[i,k], True, start_time[i] >= window_start, name=f"operational_start_lower_{i}_{k}")
            # Cannot use strict inequality, use epsilon or ensure proc time fits
            # Ensure completion time is within the window if it starts in the window
            # This is the complex part often simplified. Let's ensure proc time fits.
            m.addGenConstrIndicator(z[i,k], True, start_time[i] + processing_times.get(i,0) <= window_end_strict, name=f"operational_end_upper_{i}_{k}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal Makespan: {m.objVal:.4f}")
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
        for k in range(max_k):
            if z[i, k].x > 0.5:
                print(f"Truck {i} starts in cycle {k} (Window: [{k * operational_cycle}, {(k * operational_cycle) + operational_duration}])")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
30.0000
Optimal Makespan: 30.0000
Truck 1 - Start Time: 27.0000, Completion Time: 30.0000
Truck 1 starts in cycle 3 (Window: [27, 32])
Truck 2 - Start Time: 18.0000, Completion Time: 22.0000
Truck 2 starts in cycle 2 (Window: [18, 23])
Truck 3 - Start Time: 9.0000, Completion Time: 12.0000
Truck 3 starts in cycle 1 (Window: [9, 14])


```

================================================================================



--- Problem 135 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy container terminal is facing the challenge of efficiently allocating incoming ships to available berths across its three docks, each with distinct characteristics. Dock 1 offers the lowest berthing cost but has limited empty berths, while Dock 3, though costlier, provides more space. With 23 ships arriving, the terminal must assign them to docks in a way that minimizes the total berthing cost while respecting each dock's capacity constraints. The goal is to strike a balance between cost and availability: Dock 1 costs $2 per ship, Dock 2 costs $4, and Dock 3 costs $12. Empty berths are scarce—24 on Dock 1, 39 on Dock 2, and 16 on Dock 3. The central question is: *How should the ships be distributed across the docks to achieve the lowest possible total berthing cost without exceeding any dock's capacity?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n[i]`: Integer variable representing the number of ships assigned to dock `i` (where `i` ∈ {1, 2, 3}).  
   - **2. Parameters:**  
     - `arriving_ships = 23`: Total ships to assign.  
     - `empty_berths = {1: 24, 2: 39, 3: 16}`: Maximum ships each dock can accommodate.  
     - `berthing_cost = {1: 2, 2: 4, 3: 12}`: Cost per ship berthed at dock `i`.  
   - **3. Objective Function:**  
     - Minimize the total cost:  
       `Minimize: 2*n[1] + 4*n[2] + 12*n[3]`.  
   - **4. Constraints:**  
     - Total ships assigned must equal arrivals:  
       `n[1] + n[2] + n[3] = 23`.  
     - Dock capacities cannot be exceeded:  
       `n[1] ≤ 24`, `n[2] ≤ 39`, `n[3] ≤ 16`.  
     - Non-negativity and integer constraints for `n[i]`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
docks = [1, 2, 3]
capacity = {1: 62, 2: 106, 3: 108} # For context
empty_berths = {1: 24, 2: 39, 3: 16}
arriving_ships = 23
berthing_cost = {1: 2, 2: 4, 3: 12} # Cost per ship berthed at dock i
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("SHIP_BERTHING_COST", env=env)

    # --- Input Validation ---
    if not docks: raise ValueError("Empty docks list")
    if arriving_ships < 0: raise ValueError("Arriving ships cannot be negative")
    if sum(empty_berths.get(i, 0) for i in docks) < arriving_ships:
        # This case should be prevented by generator, but double-check
        print("Warning: Total empty berths less than arriving ships, likely infeasible.")
        # raise ValueError("Total empty berths less than arriving ships")


    # --- Decision Variables ---
    # n[i]: number of ships assigned to dock i
    n = m.addVars(docks, vtype=GRB.INTEGER, lb=0, name="n")

    # --- Objective Function: Minimize total berthing cost ---
    m.setObjective(gp.quicksum(berthing_cost.get(i, 0) * n[i] for i in docks), GRB.MINIMIZE)

    # --- Constraints ---
    # Total number of assigned ships must equal arriving ships
    m.addConstr(gp.quicksum(n[i] for i in docks) == arriving_ships, "TotalShips")

    # Number of assigned ships cannot exceed empty berths on each dock
    m.addConstrs((n[i] <= empty_berths.get(i, 0) for i in docks), "DockCapacity")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_sol'] = m.getAttr('X', n) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible. Not enough total capacity for arriving ships.") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the number of ships assigned to each dock
if m.Status == GRB.OPTIMAL:
    for i in docks:
        print(f"Number of ships assigned to Dock {i}: {n[i].X}")
```
Answer:
Optimal objective value: 46.00
Number of ships assigned to Dock 1: 23.0
Number of ships assigned to Dock 2: -0.0
Number of ships assigned to Dock 3: -0.0


```

================================================================================



--- Problem 136 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port terminal is managed by a three-phase ship berthing system, where each phase controls the berthing of ships from a specific direction. The port managers face a critical challenge: determining the optimal duration for each berthing phase to minimize the total delay experienced by ships across all directions. The terminal operates on a fixed cycle time of 51 minutes, meaning the sum of all berthing times must precisely match this duration. Each phase has a minimum berthing time of 7 minutes and a maximum of 51 minutes, ensuring both safety and efficiency.

The ship traffic varies significantly by phase, with coefficients of 2063, 2621, and 275 ships per hour for phases 1, 2, and 3, respectively. These coefficients represent the relative impact of delays—longer non-berthing times for high-traffic phases lead to disproportionately larger delays. The core question is: *How should the 51-minute cycle be allocated among the three phases to minimize the total delay for all ships passing through the terminal?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - \( t_i \): The berthing time allocated to phase \( i \) (where \( i = 1, 2, 3 \)). Each \( t_i \) is a continuous variable bounded between 7 and 51 minutes.  

   **2. Parameters:**  
   - \( \text{ship_coeffs} = [2063, 2621, 275] \): Ship traffic coefficients for each phase.  
   - \( \text{cycle_time} = 51 \): Total cycle time (minutes).  
   - \( \text{lb_time} = 7 \), \( \text{ub_time} = 51 \): Lower and upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize the total delay, calculated as:  
   \[
   \text{Minimize: } \sum_{i=1}^{3} \text{ship_coeffs}[i] \times (\text{cycle_time} - t_i)
   \]  
   Here, \( (\text{cycle_time} - t_i) \) represents the non-berthing time for phase \( i \), and the objective penalizes delays proportional to ship traffic.  

   **4. Constraints:**  
   - The sum of berthing times must equal the cycle time:  
     \[
     t_1 + t_2 + t_3 = 51
     \]  
   - Bounds on berthing times:  
     \[
     7 \leq t_i \leq 51 \quad \text{for } i = 1, 2, 3.
     \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 3
lb_time = 7          # Lower bound for berthing time
ub_time = 51          # Upper bound for berthing time
cycle_time = 51   # Total cycle time (set equal to ub_time)
ship_coeffs = [2063, 2621, 275] # Ship traffic coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(ship_coeffs) != num_phases:
    print("Error: ship_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: ship_coeffs length"
    # raise ValueError("ship_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for phase i is proportional to flow * non-berthing_time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(ship_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total delay: 139566.00
------------------------------
Optimal berthing times (minutes):
  t1: 7.00, t2: 37.00, t3: 7.00


```

================================================================================



--- Problem 137 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port terminal is tasked with efficiently scheduling three ships to berths to minimize the number of berths used. The berths have fixed dimensions of 81 units in length and 50 units in width. The ships vary in size: the first measures 35×2 units, the second 32×43 units, and the third 80×39 units. The challenge is to arrange these ships within the berths such that no two ships overlap and the total number of berths used is as small as possible. This problem mirrors real-world ship berthing scenarios, where optimizing berth utilization directly reduces costs and improves operational efficiency. The core question is: *What is the minimum number of berths required to berth all ships without violating spatial constraints, and how should the ships be positioned within these berths?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether ship *i* is assigned to berth *j*.  
   - `y[j]`: Binary variable indicating whether berth *j* is used.  
   - `px[i, j]`, `py[i, j]`: Continuous variables representing the bottom-left coordinates of ship *i* in berth *j*.  
   - `left[i, k, j]`, `right[i, k, j]`, `below[i, k, j]`, `above[i, k, j]`: Binary variables enforcing non-overlapping constraints between ships *i* and *k* in berth *j*.  

   **2. Parameters:**  
   - `ships`: List of ship dimensions [(35, 2), (32, 43), (80, 39)].  
   - `berth_size`: Berth dimensions (81, 50).  
   - `num_ships`: Number of ships (3).  
   - `num_berths`: Maximum possible berths (3, one per ship).  
   - `M_w`, `M_h`: Big-M values (81 and 50, respectively).  

   **3. Objective Function:**  
   Minimize the total number of berths used:  
   \[
   \text{Minimize: } \sum_{j} y[j]
   \]  

   **4. Constraints:**  
   - **Assignment:** Each ship must be placed in exactly one berth:  
     \[
     \sum_{j} x[i, j] = 1 \quad \forall i
     \]  
   - **Berth Boundaries:** Ships must fit within their assigned berth:  
     \[
     px[i, j] + \text{ship}_i\text{.length} \leq \text{berth\_length} + M_w (1 - x[i, j]) \quad \forall i, j
     \]  
     \[
     py[i, j] + \text{ship}_i\text{.width} \leq \text{berth\_width} + M_h (1 - x[i, j]) \quad \forall i, j
     \]  
   - **Non-Overlapping:** Ships in the same berth must not overlap:  
     \[
     \text{left}[i, k, j] + \text{right}[i, k, j] + \text{below}[i, k, j] + \text{above}[i, k, j] \geq x[i, j] + x[k, j] - 1 \quad \forall i < k, j
     \]  
   - **Berth Activation:** A berth is used if any ship is assigned to it:  
     \[
     x[i, j] \leq y[j] \quad \forall i, j
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
ships = [(35, 2), (32, 43), (80, 39)]  # (length, width) of ships
berth_size = (81, 50)  # (length, width) of each berth
num_ships = 3 # len(ships)
# Maximum berths needed (worst case: one ship per berth)
# Can sometimes be reduced with lower bounds, but num_ships is safe
num_berths = num_ships
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using berth dimensions is common and valid)
M_w = berth_size[0]
M_h = berth_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("Ship Berthing", env=env)

# --- Decision Variables ---
# x[i,j]: ship i assigned to berth j
x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of ship i if in berth j
px = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of ships *within the same berth*
left  = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="left")
right = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="right")
below = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="below")
above = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_berths))

# --- Constraints ---

# 1. Each ship must be assigned to exactly one berth
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Ship placement constraints within berth boundaries (Big-M formulation)
for j in range(num_berths):
    for i in range(num_ships):
        ship_l, ship_w = ships[i] # Get dimensions for ship i

        # Position variables must be 0 if ship i is not in berth j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Ship's right edge <= berth length IF ship is placed in berth (x[i,j]=1)
        model.addConstr(px[i, j] + ship_l <= berth_size[0] + M_w * (1 - x[i, j]), name=f"Length_Limit_{i}_{j}")
        # Ship's top edge <= berth width IF ship is placed in berth (x[i,j]=1)
        model.addConstr(py[i, j] + ship_w <= berth_size[1] + M_h * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")

# 3. Non-overlapping constraints for ships within the same berth
for j in range(num_berths):
    for i in range(num_ships):
        for k in range(i + 1, num_ships): # Iterate over distinct pairs (i < k)
            ship_i_l, ship_i_w = ships[i]
            ship_k_l, ship_k_w = ships[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => ship i is to the left of ship k
            model.addConstr(px[i, j] + ship_i_l <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => ship i is to the right of ship k (k is left of i)
            model.addConstr(px[k, j] + ship_k_l <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => ship i is below ship k
            model.addConstr(py[i, j] + ship_i_w <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => ship i is above ship k (k is below i)
            model.addConstr(py[k, j] + ship_k_w <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH ship i and ship k are in berth j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link ship assignment to berth usage: If any ship i is in berth j, then berth j must be used (y[j]=1)
#    This can be done per ship or aggregated. Per ship is often tighter.
for j in range(num_berths):
    for i in range(num_ships):
        model.addConstr(x[i, j] <= y[j], name=f"Ship_Berth_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_ships * y[j], name=f"Berth_Activation_{j}")


# --- Solve ---
print("Solving Ship Berthing instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of berths used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    berth_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_berths):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Berth {j_sol + 1} (Used):")
            ships_in_berth_info = []
            for i_sol in range(num_ships):
                if x[i_sol, j_sol].X > 0.5:
                    ship_data = {
                        "id": i_sol,
                        "dims": ships[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    ships_in_berth_info.append(ship_data)
                    print(f"  Ship {ship_data['id']} {ship_data['dims']} at {ship_data['pos']}")
            berth_details.append({'berth_index': j_sol, 'ships': ships_in_berth_info})
            print("-" * 10)
    results_dict['berth_details'] = berth_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving Ship Berthing instance...

Optimal number of berths used: 2
------------------------------
Berth 1 (Used):
  Ship 0 (35, 2) at (0.0, 0.0)
  Ship 1 (32, 43) at (0.0, 2.0)
----------
Berth 3 (Used):
  Ship 2 (80, 39) at (0.0, 0.0)
----------


```

================================================================================



--- Problem 138 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port terminal is tasked with efficiently scheduling a diverse set of 15 ships into berths, each with a strict weight limit of 90 units. The ships vary significantly in weight, ranging from as light as 3 units to as heavy as 82 units. Adding complexity, each ship is labeled with one of 10 distinct categories (e.g., 'R', 'K', 'U', 'T', 'O', 'W', 'I', 'G', 'X', 'F'), and the terminal enforces a unique rule: no berth may contain ships of more than two different categories. This constraint ensures streamlined handling and reduces the risk of operational conflicts. The challenge is to determine the minimal number of berths required to schedule all ships while respecting both the weight limits and the category diversity rules.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[i, j]`: Binary variable indicating whether ship `i` is assigned to berth `j`.  
     - `y[j]`: Binary variable indicating whether berth `j` is used.  
     - `z[c, j]`: Binary variable indicating whether category `c` is present in berth `j`.  
   - **2. Parameters:**  
     - `ships`: List of ship weights (e.g., `[5, 5, 54, ..., 35]`).  
     - `categories`: List of ship categories (e.g., `['R', 'K', ..., 'X']`).  
     - `capacity`: Maximum berth weight (90 units).  
     - `unique_categories_list`: Sorted list of distinct categories (e.g., `['F', 'G', 'I', 'K', 'O', 'R', 'T', 'U', 'W', 'X']`).  
   - **3. Objective Function:**  
     - Minimize the total number of berths used: `Minimize: sum(y[j] for all j)`.  
   - **4. Constraints:**  
     - **Assignment:** Each ship must be assigned to exactly one berth: `For each ship i: sum(x[i, j] for all j) = 1`.  
     - **Capacity:** Berth weight cannot exceed capacity: `For each berth j: sum(ships[i] * x[i, j] for all i) <= capacity * y[j]`.  
     - **Category Linking:** If any ship of category `c` is in berth `j`, `z[c, j]` must be 1: `For each category c and berth j: x[i, j] <= z[c, j] for all i of category c`.  
     - **Category Limit:** Each used berth has at most 2 distinct categories: `For each berth j: sum(z[c, j] for all c) <= 2 * y[j]`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
ships = [5, 5, 54, 60, 6, 30, 56, 46, 12, 33, 3, 11, 82, 27, 35]      # Weights of ships
categories = ['R', 'K', 'U', 'T', 'R', 'O', 'W', 'I', 'K', 'U', 'G', 'X', 'F', 'U', 'X']    # Categories of ships
capacity = 90         # Berth capacity
num_ships = 15       # len(ships) - derived correctly below
num_berths = num_ships      # Maximum berths (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(ships) != len(categories) or len(ships) != num_ships:
    print("Error: Data inconsistency (ships/categories/num_ships length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_categories_list = sorted(list(set(categories))) # Get unique categories deterministically
ship_indices_by_category = {category: [i for i, c in enumerate(categories) if c == category] for category in unique_categories_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Category-Constrained Berth Scheduling", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")  # x[i,j] -> ship i in berth j
        y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")              # y[j] -> whether berth j is used
        # z[c,j] -> whether category c is PRESENT in berth j (Use unique_categories_list for keys)
        z = model.addVars(unique_categories_list, num_berths, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of berths used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each ship must be assigned to exactly one berth ---
        for i in range(num_ships):
            model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

        # --- Constraint 2: Berth capacity constraint ---
        for j in range(num_berths):
            model.addConstr(gp.quicksum(ships[i] * x[i, j] for i in range(num_ships)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

        # --- Constraint 3: Category constraint (at most 2 *different* categories per berth) ---

        # Part 3a: Link x (ship in berth) and z (category in berth).
        for j in range(num_berths):
            for category in unique_categories_list:
                indices_of_this_category = ship_indices_by_category.get(category, []) # Use .get for safety

                if not indices_of_this_category:
                    # If no ships of this category exist, z[category, j] must be 0.
                    model.addConstr(z[category, j] == 0, name=f"NoShips_{category}_Berth_{j}")
                    continue

                # If any ship 'i' of this 'category' is placed in berth 'j' (x[i,j]=1),
                # then the presence indicator for that 'category' in berth 'j' (z[category,j]) must be 1.
                for i in indices_of_this_category:
                    model.addConstr(x[i, j] <= z[category, j], name=f"Link_x{i}_z{category}_Berth{j}")

                # Ensure z[category, j] is 0 if no ships of that category are in the berth.
                # This helps tighten the formulation.
                model.addConstr(z[category, j] <= gp.quicksum(x[i, j] for i in indices_of_this_category), name=f"Link_z{category}_SumX_Berth{j}")


        # Part 3b: Limit the number of distinct categories (sum of z[c,j] for berth j) to 2 for USED berths.
        for j in range(num_berths):
            # sum(z[c,j] for c in unique_categories_list) gives the count of distinct categories in berth j.
            # This sum must be <= 2 *IF* the berth is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Categories_Berth_{j}")

        # --- Solve ---
        print("Solving CCBS instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of berths used: {optimal_berths}")
    print("-" * 30)

    berth_details = []
    printed_berth_count = 0
    for j_sol in range(num_berths): # Iterate through all potential berth indices
        try:
             # Check if this berth was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_berth_count += 1
                 assigned_ships_indices = [i for i in range(num_ships) if x[i, j_sol].X > 0.5]
                 assigned_ships_weights = [ships[i] for i in assigned_ships_indices]
                 assigned_ships_categories = [categories[i] for i in assigned_ships_indices]
                 distinct_categories_in_berth = sorted(list(set(assigned_ships_categories))) # Sort for consistent output
                 berth_load = sum(assigned_ships_weights)

                 print(f"Berth {printed_berth_count} (Internal Index {j_sol}):")
                 print(f"  Ships (indices): {assigned_ships_indices}")
                 # print(f"  Ships (weights): {assigned_ships_weights}") # Optional details
                 # print(f"  Ships (categories):  {assigned_ships_categories}") # Optional details
                 print(f"  Distinct Categories: {distinct_categories_in_berth} (Count: {len(distinct_categories_in_berth)})")
                 print(f"  Total weight:    {berth_load} / {capacity}")
                 print("-" * 10)

                 berth_data = {
                     'berth_index_internal': j_sol,
                     'berth_index_printed': printed_berth_count,
                     'ship_indices': assigned_ships_indices,
                     'distinct_categories': distinct_categories_in_berth,
                     'load': berth_load
                 }
                 berth_details.append(berth_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for berth index {j_sol}: {e_print}")


    results_dict['berth_details'] = berth_details # Store details

    # Final sanity check
    if printed_berth_count != optimal_berths:
         print(f"Warning: Number of printed used berths ({printed_berth_count}) does not match objective value ({optimal_berths}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# The provided code already prints the required outputs, so no additional print statements are needed.
```
Answer:
Solving CCBS instance...
------------------------------

Optimal solution found.
Optimal number of berths used: 6
------------------------------
Berth 1 (Internal Index 0):
  Ships (indices): [1, 2, 8]
  Distinct Categories: ['K', 'U'] (Count: 2)
  Total weight:    71 / 90
----------
Berth 2 (Internal Index 1):
  Ships (indices): [10, 12]
  Distinct Categories: ['F', 'G'] (Count: 2)
  Total weight:    85 / 90
----------
Berth 3 (Internal Index 5):
  Ships (indices): [0, 4, 9, 13]
  Distinct Categories: ['R', 'U'] (Count: 2)
  Total weight:    71 / 90
----------
Berth 4 (Internal Index 11):
  Ships (indices): [7, 14]
  Distinct Categories: ['I', 'X'] (Count: 2)
  Total weight:    81 / 90
----------
Berth 5 (Internal Index 13):
  Ships (indices): [3, 5]
  Distinct Categories: ['O', 'T'] (Count: 2)
  Total weight:    90 / 90
----------
Berth 6 (Internal Index 14):
  Ships (indices): [6, 11]
  Distinct Categories: ['W', 'X'] (Count: 2)
  Total weight:    67 / 90
----------


```

================================================================================



--- Problem 139 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port is managed by a three-phase crane scheduling system, where each phase controls the loading and unloading of containers from specific berths. The port manager faces the challenge of allocating operation times to each phase to minimize the total delay experienced by ships, a critical metric for reducing congestion and improving port efficiency. The port operates on a fixed cycle time of 34 minutes, meaning the sum of operation times across all phases must equal this value. Each phase has a minimum operation time of 10 minutes and a maximum of 34 minutes, ensuring fairness and safety.

The container flow coefficients—2,636, 1,791, and 2,115 for phases 1, 2, and 3, respectively—represent the relative volume of containers in each phase. Higher coefficients indicate heavier traffic, making delays more costly. The delay for each phase is proportional to its flow multiplied by its idle time (cycle time minus operation time). The manager must strategically distribute the limited operation time to minimize the cumulative delay across all phases, balancing the needs of high-traffic flows while adhering to the strict cycle constraint.

The core question is: *How should the 34-minute cycle be divided among the three phases to minimize the total delay for all ships passing through the port?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `t_i`: Continuous variable representing the operation time (in minutes) allocated to phase `i` (where `i = 1, 2, 3`).  
   - Bounds: Each `t_i` must satisfy `10 ≤ t_i ≤ 34`.  

   **2. Parameters:**  
   - `flow_coeffs = [2636, 1791, 2115]`: Container flow coefficients for phases 1, 2, and 3.  
   - `cycle_time = 34`: Total cycle time (minutes).  
   - `lb_time = 10`, `ub_time = 34`: Lower and upper bounds for operation times.  

   **3. Objective Function:**  
   Minimize the total delay, calculated as:  
   ```
   Minimize: sum(flow_coeffs[i] * (cycle_time - t_i) for all phases i)
   ```  

   **4. Constraints:**  
   - **Total cycle time:** The sum of operation times must equal the cycle time:  
     ```
     t_1 + t_2 + t_3 = 34
     ```  
   - **Variable bounds:** Each `t_i` must lie within its specified range.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 3
lb_time = 10          # Lower bound for operation time
ub_time = 34          # Upper bound for operation time
cycle_time = 34       # Total cycle time (minutes)
flow_coeffs = [2636, 1791, 2115] # Container flow coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Crane Scheduling", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for phase i is proportional to flow * idle_time = flow * (cycle_time - operation_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of operation times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal operation times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
Optimal total delay: 146464.00
------------------------------
Optimal operation times (minutes):
  t1: 14.00, t2: 10.00, t3: 10.00



================================================================================



--- Problem 140 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
A maritime logistics company operates a fleet of 10 ships to serve 10 customer ports, including a central port (node 0). Each ship has a unique capacity, ranging from 12 to 100 units, and each customer port has a specific demand that must be fulfilled. The distances between all pairs of ports are precisely known, forming a symmetric cost matrix. The challenge is to design routes that minimize the total travel distance while ensuring that:  
- Every customer port is visited exactly once.  
- Each ship starts and ends its journey at the central port.  
- The total demand served by any ship does not exceed its capacity.  
- Subtours (disconnected cycles) are eliminated to ensure coherent routes.  

The company aims to optimize its delivery operations by finding the most efficient allocation of customer ports to ships, balancing capacity utilization and travel costs. The key question is: **What is the optimal set of routes that minimizes total distance while satisfying all operational constraints?**

---

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variables \(x_{i,j,k}\) for each ship \(k\) and each pair of nodes \(i, j\) (where \(i \neq j\)), indicating whether ship \(k\) travels directly from node \(i\) to node \(j\).  
- Continuous variables \(u_i\) for each customer node \(i\) (excluding the central port), used in the Miller-Tucker-Zemlin (MTZ) subtour elimination constraints.  

**2. Parameters:**  
- \(N = 10\): Total number of nodes (central port + customer ports).  
- \(K = 10\): Number of ships.  
- \(Q_k\): Capacity of ship \(k\) (given as [94, 100, ..., 15]).  
- \(q_j\): Demand of customer port \(j\) (given as [0, 13, ..., 68], where \(q_0 = 0\) for the central port).  
- \(d_{i,j}\): Distance between nodes \(i\) and \(j\) (symmetric matrix provided).  

**3. Objective Function:**  
Minimize the total travel distance:  
\[
\text{Minimize: } \sum_{k=0}^{K-1} \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} d_{i,j} \cdot x_{i,j,k} \quad \text{(for } i \neq j\text{)}
\]

**4. Constraints:**  
- **Visit each customer port once:**  
  \[
  \sum_{k=0}^{K-1} \sum_{j=0}^{N-1} x_{i,j,k} = 1 \quad \text{for each customer port } i \geq 1.
  \]  
- **Flow conservation:**  
  \[
  \sum_{j=0}^{N-1} x_{i,j,k} = \sum_{j=0}^{N-1} x_{j,i,k} \quad \text{for each node } i \text{ and ship } k.
  \]  
- **Central port departure and return:**  
  \[
  \sum_{j=1}^{N-1} x_{0,j,k} \leq 1 \quad \text{and} \quad \sum_{j=1}^{N-1} x_{0,j,k} = \sum_{j=1}^{N-1} x_{j,0,k} \quad \text{for each ship } k.
  \]  
- **Capacity constraints:**  
  \[
  \sum_{j=1}^{N-1} q_j \cdot \left( \sum_{i=0}^{N-1} x_{i,j,k} \right) \leq Q_k \quad \text{for each ship } k.
  \]  
- **Subtour elimination (MTZ):**  
  \[
  u_i - u_j + (N-1) \cdot x_{i,j,k} \leq N-2 \quad \text{for } i,j \geq 1, i \neq j, \text{ and each ship } k.
  \]  
---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 10
K = 10
Q = [94, 100, 31, 68, 12, 89, 58, 37, 91, 15]
q = [0, 13, 40, 61, 99, 28, 41, 44, 13, 68]
d = [
    [0, 40, 54, 60, 7, 69, 93, 23, 23, 10],
    [40, 0, 52, 39, 4, 69, 15, 88, 80, 27],
    [54, 52, 0, 70, 65, 98, 16, 48, 83, 15],
    [60, 39, 70, 0, 5, 49, 7, 11, 95, 94],
    [7, 4, 65, 5, 0, 43, 95, 55, 63, 80],
    [69, 69, 98, 49, 43, 0, 31, 78, 18, 19],
    [93, 15, 16, 7, 95, 31, 0, 73, 85, 29],
    [23, 88, 48, 11, 55, 78, 73, 0, 58, 18],
    [23, 80, 83, 95, 63, 18, 85, 58, 0, 11],
    [10, 27, 15, 94, 80, 19, 29, 18, 11, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer port (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Ship Departure/Return from Central Port (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartPort_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnPort_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for ship {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for ship {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 407.00

Route for ship 1 (Capacity: 94):
0 -> 2 -> 6 -> 1 -> 0
Route Load: 94 / 94

Route for ship 2 (Capacity: 100):
0 -> 4 -> 0
Route Load: 99 / 100

Route for ship 6 (Capacity: 89):
0 -> 8 -> 9 -> 0
Route Load: 81 / 89

Route for ship 7 (Capacity: 58):
0 -> 7 -> 0
Route Load: 44 / 58

Route for ship 9 (Capacity: 91):
0 -> 5 -> 3 -> 0
Route Load: 89 / 91


```

================================================================================



--- Problem 141 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A port terminal must coordinate the berthing times for three distinct ships to minimize total waiting time. Each ship has a specific arrival rate, with measured coefficients of 2053, 2403, and 1294 ships per hour for ships 1, 2, and 3, respectively. The challenge lies in allocating berthing times within strict bounds: each ship must berth for at least 13 minutes but no more than 54 minutes, while the total berthing cycle time—the sum of all berthing times—must exactly match the upper limit of 54 minutes. Waiting times arise when ships wait during non-berthing periods, calculated as the product of the arrival rate and the non-berthing time (cycle time minus berthing time). The core question is: *How should the 54-minute cycle be divided among the three ships to minimize the cumulative waiting time experienced by all ships?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Let \( t_i \) represent the berthing time (in minutes) allocated to ship \( i \), where \( i \in \{1, 2, 3\} \). Each \( t_i \) is a continuous variable bounded between 13 and 54.  
   - **2. Parameters:**  
     - \( \text{arrival_rates} = [2053, 2403, 1294] \): Arrival rates for each ship.  
     - \( \text{cycle_time} = 54 \): Fixed total cycle duration (minutes).  
     - \( \text{lb_time} = 13 \), \( \text{ub_time} = 54 \): Lower/upper bounds for berthing times.  
   - **3. Objective Function:**  
     Minimize the total waiting time:  
     \[
     \text{Minimize: } \sum_{i=1}^3 \text{arrival_rates}[i] \times (\text{cycle_time} - t_i)
     \]  
   - **4. Constraints:**  
     - Total berthing time must equal the cycle time:  
       \[
       t_1 + t_2 + t_3 = 54
       \]  
     - Bounds on individual berthing times:  
       \[
       13 \leq t_i \leq 54 \quad \forall i \in \{1, 2, 3\}
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_ships = 3
lb_time = 13          # Lower bound for berthing time
ub_time = 54          # Upper bound for berthing time
cycle_time = 54   # Total cycle time (set equal to ub_time)
arrival_rates = [2053, 2403, 1294] # Arrival rates per ship
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_rates) != num_ships:
    print("Error: arrival_rates length mismatch with num_ships")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_rates length"
    # raise ValueError("arrival_rates length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_ships}-Ship Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_ships) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_ships, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for ship i is proportional to arrival_rate * non-berthing_time = arrival_rate * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_rates[i] * (cycle_time - t_vars[i]) for i in range(num_ships)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_ships)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_ships)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_ships):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 199705.00
------------------------------
Optimal berthing times (minutes):
  t1: 13.00, t2: 28.00, t3: 13.00


```

================================================================================



--- Problem 142 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A busy port is facing the challenge of maximizing its daily revenue while managing the competing demands of short-term and long-term cargo shipments. The port has a total of 191 berthing spots, but the real constraint lies in the total available "berth-hours" — a measure of how long each berth is occupied. With 1,528 berth-hours available each day, the port must decide how many short-term and long-term shipments to accommodate to generate the highest possible revenue.

Short-term shipments stay for an average of 2 hours, paying $10 for their stay, while long-term shipments occupy a berth for 7 hours, contributing $61 to the port's revenue. Demand is high: up to 47 short-term shipments and 54 long-term shipments could seek berthing on any given day. However, the port must ensure that at least 49 berths are reserved for short-term shipments at all times, limiting the number of long-term shipments to a maximum of 142 to avoid overcrowding and ensure availability for short-term customers.

The central question is: How many short-term and long-term shipments should the port accept to maximize daily revenue without exceeding the total berth-hour capacity or violating the minimum short-term berth requirement?
**

**Modeling Process:**
**
**1. Decision Variables:**
- `x_short_term`: The number of short-term shipments to accept (continuous, non-negative).
- `x_long_term`: The number of long-term shipments to accept (continuous, non-negative).

**2. Parameters:**
- `revenue_per_short_term = 10`: Revenue per short-term shipment ($).
- `revenue_per_long_term = 61`: Revenue per long-term shipment ($).
- `short_term_stay = 2`: Berth-hours consumed by each short-term shipment.
- `long_term_stay = 7`: Berth-hours consumed by each long-term shipment.
- `total_berth_hours = 1528`: Total berth-hours available per day.
- `max_short_term_demand = 47`: Maximum potential short-term shipments.
- `max_long_term_demand = 54`: Maximum potential long-term shipments.
- `max_berths_for_long_term = 142`: Maximum long-term shipments allowed to reserve berths for short-term shipments.

**3. Objective Function:**
Maximize total daily revenue:
\[
\text{Maximize: } 10 \cdot x_{\text{short_term}} + 61 \cdot x_{\text{long_term}}
\]

**4. Constraints:**
- Berth-hour capacity: 
  \[
  2 \cdot x_{\text{short_term}} + 7 \cdot x_{\text{long_term}} \leq 1528
  \]
- Short-term demand limit:
  \[
  x_{\text{short_term}} \leq 47
  \]
- Long-term demand limit:
  \[
  x_{\text{long_term}} \leq 54
  \]
- Long-term berth limit for short-term reservation:
  \[
  x_{\text{long_term}} \leq 142
  \]
- Non-negativity:
  \[
  x_{\text{short_term}}, x_{\text{long_term}} \geq 0
  \]

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
total_spots = 191; op_hours = 8; hourly_rate = 5; short_term_stay = 2
daily_rate = 61; long_term_stay = 7; max_short_term_demand = 47
max_long_term_demand = 54; min_spots_for_short_term = 49
# Derived Params (passed from generator)
revenue_per_short_term = 10; revenue_per_long_term = 61
total_berth_hours = 1528; max_berths_for_long_term = 142
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m19 = gp.Model("Port_Berthing_Price_Differentiation_LP", env=env)
    # Vars
    x_short_term = m19.addVar(name="num_short_term_shipments", lb=0)
    x_long_term = m19.addVar(name="num_long_term_shipments", lb=0)
    # Objective
    m19.setObjective(revenue_per_short_term * x_short_term + revenue_per_long_term * x_long_term, sense=GRB.MAXIMIZE)
    # Constraints
    m19.addConstr(x_short_term * short_term_stay + x_long_term * long_term_stay <= total_berth_hours, "berth_hour_capacity")
    m19.addConstr(x_short_term <= max_short_term_demand, "short_term_demand")
    m19.addConstr(x_long_term <= max_long_term_demand, "long_term_demand")
    # Ensure long-term shipments don't use berths needed for min short-term requirement.
    # This constraint might need re-evaluation: it limits the *number* of long-term shipments based on total berths,
    # not directly guaranteeing berth availability *at any given time* for short-term.
    # A simulation or more complex model might be needed for strict guarantee.
    # Keeping user's formulation:
    m19.addConstr(x_long_term <= max_berths_for_long_term, "long_term_berth_limit_for_short_term")
    # Optimize
    m19.optimize()
    # Store results
    results_dict['status'] = m19.status
    if m19.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m19.objVal; results_dict['xst_opt'] = x_short_term.X; results_dict['xlt_opt'] = x_long_term.X
    # Output Results
    print("--- Problem 19: Port Berthing Price Differentiation (LP) ---")
    if m19.status == GRB.OPTIMAL:
        xst = results_dict.get('xst_opt', 0); xlt = results_dict.get('xlt_opt', 0)
        berth_hours_used = xst * short_term_stay + xlt * long_term_stay
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Daily Revenue: ${m19.objVal:.2f}")
        print(f"Optimal number of Short-Term Shipments to accept: {xst:.2f} (Demand: {max_short_term_demand})")
        print(f"Optimal number of Long-Term Shipments to accept: {xlt:.2f} (Demand: {max_long_term_demand}, Max allowed by short-term min: {max_berths_for_long_term})")
        print(f"Total Berth-Hours Used: {berth_hours_used:.1f} / {total_berth_hours}")
    else: print(f"Optimization Status: {m19.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_BERTHING_PRICE
```
Answer:
--- Problem 19: Port Berthing Price Differentiation (LP) ---
Optimization Status: Optimal
Maximum Total Daily Revenue: $3764.00
Optimal number of Short-Term Shipments to accept: 47.00 (Demand: 47)
Optimal number of Long-Term Shipments to accept: 54.00 (Demand: 54, Max allowed by short-term min: 142)
Total Berth-Hours Used: 472.0 / 1528



================================================================================



--- Problem 143 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently loading 15 packages of varying weights into a selection of 7 available trucks, each with distinct capacities and associated costs. The packages range from lightweight (e.g., 1 unit) to heavier ones (e.g., 94 units), while the trucks offer different capacities (from 94 to 99 units) and costs (from $1 to $92). The goal is to assign every package to exactly one truck without exceeding the truck’s capacity while minimizing the total cost incurred from using these trucks.

The operational twist lies in the cost variability: some trucks are cheap but may require careful package allocation due to tighter capacity limits, while others are expensive but offer more flexibility. For instance, Truck 1 (Capacity: 99, Cost: $52) is moderately priced, whereas Truck 2 (Capacity: 94, Cost: $1) is very affordable but risks overloading if not packed precisely. The central question is: *How can the packages be distributed across the trucks to meet all constraints while achieving the lowest possible total cost?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `x[i, j]`: Equals 1 if package *i* is assigned to truck *j*, else 0.  
     - Binary variable `y[j]`: Equals 1 if truck *j* is used (i.e., at least one package is assigned to it), else 0.  
   - **2. Parameters:**  
     - `packages[i]`: Weight of package *i* (e.g., `packages[0] = 1`, `packages[9] = 94`).  
     - `trucks[j]`: Tuple `(capacity, cost)` for truck *j* (e.g., `trucks[0] = (99, 52)`).  
   - **3. Objective Function:**  
     - Minimize total cost:  
       \[
       \text{Minimize: } \sum_{j=0}^{6} y[j] \times \text{trucks}[j][1]
       \]  
   - **4. Constraints:**  
     - **Package assignment:** Each package *i* must be in exactly one truck:  
       \[
       \sum_{j=0}^{6} x[i, j] = 1 \quad \forall i \in \{0, \dots, 14\}
       \]  
     - **Truck capacity:** Total weight in truck *j* cannot exceed its capacity:  
       \[
       \sum_{i=0}^{14} \text{packages}[i] \times x[i, j] \leq \text{trucks}[j][0] \times y[j] \quad \forall j \in \{0, \dots, 6\}
       \]  
     - **Linking constraint:** A package can only be placed in truck *j* if the truck is used:  
       \[
       x[i, j] \leq y[j] \quad \forall i, j
       \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys # Make sys available inside exec if needed, e.g. for print traceback
import traceback

# --- Data Definition (Embedded) ---
packages = [1, 60, 4, 5, 10, 12, 25, 37, 83, 94, 45, 87, 8, 77, 36]      # Package weights
trucks = [(99, 52), (94, 1), (96, 12), (97, 1), (97, 49), (96, 16), (95, 92)]        # List of (Capacity, Cost) tuples
num_packages = 15       # len(packages)
num_trucks = 7         # len(trucks)
# --- End Data Definition ---

# Time limit (passed from outer scope via globals if needed, or hardcoded)
GUROBI_TIME_LIMIT = 60

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Keep output clean for saving
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Cost-Sensitive TLP", env=env)

    # --- Decision Variables ---
    x = model.addVars(num_packages, num_trucks, vtype=GRB.BINARY, name="x")
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")

    # --- Objective: Minimize total cost ---
    model.setObjective(gp.quicksum(y[j] * trucks[j][1] for j in range(num_trucks)), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Each package assignment
    for i in range(num_packages):
        model.addConstr(x.sum(i, '*') == 1, name=f"Package_{i}_Assignment")

    # 2. Truck capacity
    for j in range(num_trucks):
        truck_capacity = trucks[j][0]
        if truck_capacity < 0: truck_capacity = 0
        model.addConstr(gp.quicksum(packages[i] * x[i, j] for i in range(num_packages)) <= truck_capacity * y[j], name=f"Truck_{j}_Capacity")

    # 3. Linking package to truck usage
    for i in range(num_packages):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Package_{i}_Triggers_Truck_{j}")

    # --- Solve ---
    # print("Solving CS-TLP instance...") # Comment out or keep for debug inside output
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal

    # --- Output results (This will be captured) ---
    # This logic needs to be *inside* the template now
    if model.status == GRB.OPTIMAL:
        print(f"Minimum cost: ${model.objVal:.2f}") # Use model.objVal directly
        print("-" * 30) # Add separator for clarity
        printed_truck_count = 0
        for j in range(num_trucks):
            # Use try-except for safety when accessing .X
            try:
                 if y[j].x > 0.5:
                     printed_truck_count += 1
                     truck_capacity_out, truck_cost_out = trucks[j]
                     assigned_packages = [i for i in range(num_packages) if x[i, j].x > 0.5]
                     truck_load_out = sum(packages[i] for i in assigned_packages)
                     # Format output exactly as desired for the log file
                     print(f"Truck {printed_truck_count} (Type Index {j}, Capacity: {truck_capacity_out}, Cost: ${truck_cost_out:.2f}):")
                     print(f"  Load: {truck_load_out} / {truck_capacity_out}")
                     print(f"  Packages (indices): {sorted(assigned_packages)}") # Sort for consistency
                     print("-" * 10) # Separator between trucks
            except AttributeError:
                 pass # Ignore trucks not used or if .X attribute missing
    elif model.status == GRB.TIME_LIMIT:
        print("\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: ${model.ObjVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {model.status}")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}") # Print errors to captured output
    results_dict['status'] = -1 # Use dict to signal error type to main loop
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:") # Print errors
    traceback.print_exc(file=sys.stdout) # Print traceback to captured stdout
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Minimum cost: $223.00
------------------------------
Truck 1 (Type Index 0, Capacity: 99, Cost: $52.00):
  Load: 84 / 99
  Packages (indices): [0, 8]
----------
Truck 2 (Type Index 1, Capacity: 94, Cost: $1.00):
  Load: 94 / 94
  Packages (indices): [9]
----------
Truck 3 (Type Index 2, Capacity: 96, Cost: $12.00):
  Load: 64 / 96
  Packages (indices): [1, 2]
----------
Truck 4 (Type Index 3, Capacity: 97, Cost: $1.00):
  Load: 97 / 97
  Packages (indices): [4, 11]
----------
Truck 5 (Type Index 4, Capacity: 97, Cost: $49.00):
  Load: 74 / 97
  Packages (indices): [3, 6, 12, 14]
----------
Truck 6 (Type Index 5, Capacity: 96, Cost: $16.00):
  Load: 89 / 96
  Packages (indices): [5, 13]
----------
Truck 7 (Type Index 6, Capacity: 95, Cost: $92.00):
  Load: 82 / 95
  Packages (indices): [7, 10]
----------


```

================================================================================



--- Problem 144 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling six incoming trucks at three available depots, each with varying arrival times and processing requirements. Truck 1 arrives at 2 hours, followed by Truck 2 at 4 hours, Truck 3 at 7 hours, Truck 4 at 12 hours, Truck 5 at 16 hours, and Truck 6 at 21 hours. Processing times differ: Trucks 1 and 2 require 6 hours each, Truck 3 needs 8 hours, Trucks 4 and 6 take 5 hours, and Truck 5 demands 5 hours. The hub aims to minimize the maximum waiting time any truck experiences before being processed—a critical metric for customer satisfaction and operational efficiency. The challenge lies in assigning trucks to depots while respecting arrival times, avoiding overlapping schedules, and ensuring no truck waits longer than necessary. The core question: *What is the optimal depot assignment and scheduling sequence to achieve the smallest possible maximum waiting time across all trucks?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary `assign(i, j)`: 1 if truck *i* is assigned to depot *j*, else 0.  
     - Continuous `start_time(i)`: When truck *i* begins processing.  
     - Continuous `completion_time(i)`: When truck *i* finishes (start time + processing time).  
     - Binary `precedes(i, k, j)`: 1 if truck *i* is scheduled before truck *k* on depot *j*.  
     - Continuous `max_wait_time`: Maximum difference between a truck’s start time and arrival time.  

   - **2. Parameters:**  
     - `arrival_times[i]`: Arrival time for truck *i* (e.g., Truck 1: 2 hours).  
     - `processing_times[i]`: Processing duration for truck *i* (e.g., Truck 3: 8 hours).  
     - `H = 100`: A large constant for logical constraints.  

   - **3. Objective Function:**  
     Minimize `max_wait_time` (the worst-case waiting time across all trucks).  

   - **4. Constraints:**  
     - Each truck is assigned to exactly one depot: `sum(assign(i, j) for j in depots) = 1` for all *i*.  
     - Start time cannot precede arrival: `start_time[i] >= arrival_times[i]` for all *i*.  
     - Completion time calculation: `completion_time[i] = start_time[i] + processing_times[i]`.  
     - Non-overlapping schedules on the same depot: If `precedes(i, k, j) = 1`, then `start_time[k] >= completion_time[i]`; else, `start_time[i] >= completion_time[k]`.  
     - Link assignment to precedence: `assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))`.  
     - Define `max_wait_time` as the upper bound of all individual waiting times: `max_wait_time >= start_time[i] - arrival_times[i]` for all *i*.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
depots = [1, 2, 3]
arrival_times = {1: 2, 2: 4, 3: 7, 4: 12, 5: 16, 6: 21}
processing_times = {1: 6, 2: 6, 3: 8, 4: 5, 5: 5, 6: 5}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_12_MIN_MAX_WAIT")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    max_wait_time = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Wmax") # Objective var

    # --- Objective Function ---
    m.setObjective(max_wait_time, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Max waiting time definition
    m.addConstrs((max_wait_time >= start_time[i] - arrival_times.get(i, 0) for i in trucks), name="wmax_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Max wait time
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Ensure Complete Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.2f} hours")
                print(f"  Completion Time: {completion_time[i].x:.2f} hours")
                print(f"  Waiting Time: {start_time[i].x - arrival_times[i]:.2f} hours")
    print(f"Maximum Waiting Time: {max_wait_time.x:.4f} hours")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
11.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 1
  Start Time: 2.00 hours
  Completion Time: 8.00 hours
  Waiting Time: 0.00 hours
Truck 2 is assigned to Depot 1
  Start Time: 8.00 hours
  Completion Time: 14.00 hours
  Waiting Time: 4.00 hours
Truck 3 is assigned to Depot 1
  Start Time: 14.00 hours
  Completion Time: 22.00 hours
  Waiting Time: 7.00 hours
Truck 4 is assigned to Depot 1
  Start Time: 22.00 hours
  Completion Time: 27.00 hours
  Waiting Time: 10.00 hours
Truck 5 is assigned to Depot 1
  Start Time: 27.00 hours
  Completion Time: 32.00 hours
  Waiting Time: 11.00 hours
Truck 6 is assigned to Depot 1
  Start Time: 32.00 hours
  Completion Time: 37.00 hours
  Waiting Time: 11.00 hours
Maximum Waiting Time: 11.0000 hours


```

================================================================================



--- Problem 145 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy container terminal is facing the challenge of efficiently managing its operations while minimizing costs. The terminal has a total of 11 berths available, but operating all of them would be prohibitively expensive. Ships arrive at a steady rate of 1,260 per hour, and each berth can process up to 260 ships per hour when operational. The cost of operating a single berth is $17 per hour. The management must strike a delicate balance: ensuring that the total processing capacity meets or exceeds the arrival rate to prevent congestion, while also minimizing operating expenses. The critical question is: *What is the smallest number of berths that must be opened to handle the incoming traffic without exceeding the available infrastructure, and what is the associated hourly cost?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x`: The number of berths to open (non-negative integer).  
   - **2. Parameters:**  
     - `total_berths = 11`: Maximum number of berths available.  
     - `arrival_rate = 1260`: Ships arriving per hour.  
     - `service_rate_per_berth = 260`: Ships processed per hour per berth.  
     - `cost_per_berth = 17`: Hourly cost per berth in dollars.  
   - **3. Objective Function:**  
     - Minimize the total operating cost: `Minimize: cost_per_berth * x`.  
   - **4. Constraints:**  
     - **Capacity Constraint:** The total processing capacity must meet or exceed the arrival rate: `service_rate_per_berth * x >= arrival_rate`.  
     - **Availability Constraint:** The number of open berths cannot exceed the total available berths: `x <= total_berths`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
total_berths = 11
arrival_rate = 1260 # ships/hour
service_rate_per_berth = 260 # ships/hour/berth
cost_per_berth = 17 # $/hour
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# --- Model Creation ---
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    m1 = gp.Model("Berth_Operating_Cost", env=env)

    # --- Decision Variables ---
    # Number of berths to open (ensure non-negative integer)
    x = m1.addVar(vtype=GRB.INTEGER, name="num_open_berths", lb=0)

    # --- Objective Function ---
    # Minimize total operating cost
    m1.setObjective(cost_per_berth * x, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Total processing capacity must meet arrival rate
    # Ensure service rate is positive before adding constraint
    if service_rate_per_berth > 0:
        m1.addConstr(service_rate_per_berth * x >= arrival_rate, name="capacity_constraint")
    else:
        # Handle case where service rate is zero (problem likely infeasible if arrival > 0)
        if arrival_rate > 0:
            print("Warning: Service rate is zero but arrival rate is positive. Setting model infeasible.")
            # How to force infeasibility? Add contradictory constraint
            m1.addConstr(x >= 1, "ForceInfeasible1")
            m1.addConstr(x <= 0, "ForceInfeasible2")
        else:
             # If arrival is also 0, x=0 is optimal, capacity constraint is 0 >= 0
             m1.addConstr(0 * x >= 0, name="capacity_constraint_zero")


    # Constraint 2: Number of open berths cannot exceed total available berths
    m1.addConstr(x <= total_berths, name="availability_constraint")

    # --- Optimization ---
    m1.optimize()

    # --- Store results ---
    results_dict['status'] = m1.status
    if m1.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m1.objVal
        results_dict['x_optimal'] = x.X # Store optimal X value

    # --- Output Results (for capture) ---
    if m1.status == GRB.OPTIMAL:
        # Use .X attribute to get the value
        optimal_x = results_dict.get('x_optimal', 'N/A')
        if not isinstance(optimal_x, (int, float)): optimal_x = -1 # Handle case where it wasn't stored

        print(f"Optimization Status: Optimal")
        print(f"Optimal number of berths to open: {int(round(optimal_x))}") # Round before int() for safety
        print(f"Minimum total operating cost: ${m1.objVal:.2f}/hour")
        print(f"Total processing capacity: {service_rate_per_berth * optimal_x:.0f} ships/hour (Arrival rate: {arrival_rate})")
    elif m1.status == GRB.INFEASIBLE:
        print(f"Optimization Status: Infeasible")
    else:
        print(f"Optimization Status: {m1.status}")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimization Status: Optimal
Optimal number of berths to open: 5
Minimum total operating cost: $85.00/hour
Total processing capacity: 1300 ships/hour (Arrival rate: 1260)


```

================================================================================



--- Problem 146 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
A maritime logistics company operates a port with two parallel berths, where a fleet of 12 ships must be serviced. Each ship requires a specific service time that varies depending on the berth it is assigned to. For instance, Ship 0 takes 71 minutes in Berth 0 but 89 minutes in Berth 1, while Ship 11 requires 94 minutes in Berth 0 and only 15 minutes in Berth 1. The goal is to assign each ship to exactly one berth such that the total service time across the busiest berth is minimized. This ensures balanced workload distribution, preventing bottlenecks and maximizing operational efficiency. The challenge lies in finding the optimal assignment that avoids overburdening any single berth, especially given the varying service times.

**Modeling Process:**
**1. Decision Variables:**
   - `x[i, j]`: Binary variable indicating whether Ship `i` is assigned to Berth `j` (1 if assigned, 0 otherwise).
   - `C_max`: Continuous variable representing the maximum total service time across all berths.

**2. Parameters:**
   - `ships = [0, 1, ..., 11]`: Indices of the 12 ships.
   - `berths = [0, 1]`: Indices of the two berths.
   - `service_times[i][j]`: Service time of Ship `i` in Berth `j` (e.g., `service_times[0][0] = 71`).

**3. Objective Function:**
   Minimize `C_max` (the maximum total service time across all berths).

**4. Constraints:**
   - **Ship Assignment:** Each ship must be assigned to exactly one berth:
     `sum(x[i, j] for j in berths) == 1` for all `i` in `ships`.
   - **Makespan:** The total service time for each berth must not exceed `C_max`:
     `sum(service_times[i][j] * x[i, j] for i in ships) <= C_max` for all `j` in `berths`.

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] # List of ship indices
berths = [0, 1]       # List of berth indices
# Service times as list of lists: service_times[ship][berth]
service_times = [[71, 89], [31, 81], [47, 109], [73, 68], [24, 74], [87, 46], [84, 18], [69, 46], [119, 81], [88, 25], [30, 66], [94, 15]]
# --- End Parameters ---

GUROBI_TIME_LIMIT = 45

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("SHIP_BERTH_MAKESPAN_Approx", env=env)

    # --- Decision Variables ---
    # x[i, j] = 1 if ship i is assigned to berth j, 0 otherwise
    x = m.addVars(ships, berths, vtype=GRB.BINARY, name="x")
    # C_max: The maximum total service time assigned to any berth
    C_max = m.addVar(vtype=GRB.CONTINUOUS, name="C_max", lb=0) # Ensure non-negative

    # --- Objective Function: Minimize the maximum workload (C_max) ---
    m.setObjective(C_max, GRB.MINIMIZE)

    # --- Constraints ---
    # Each ship must be assigned to exactly one berth
    # Check indices are valid before creating constraints
    if ships and berths:
        m.addConstrs((gp.quicksum(x[i, j] for j in berths) == 1 for i in ships), "ShipAssignment")

        # C_max must be >= the total service time assigned to each berth
        # Check if service_times has correct dimensions
        valid_times = isinstance(service_times, list) and                       all(isinstance(row, list) and len(row) == len(berths) for row in service_times) and                       len(service_times) == len(ships)

        if valid_times:
             m.addConstrs((gp.quicksum(service_times[i][j] * x[i, j] for i in ships) <= C_max for j in berths), "MakespanConstraint")
        else:
             print("Warning: Service times data structure mismatch, MakespanConstraint skipped.")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output
        # results_dict['C_max_sol'] = C_max.X # Redundant, same as obj_val

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Format objective value (makespan)
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}") # Show decimals for makespan
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the assignment of ships to berths
if m.Status == GRB.OPTIMAL:
    for i in ships:
        for j in berths:
            if x[i, j].X > 0.5:
                print(f"Ship {i} is assigned to Berth {j}")
```
Answer:
Optimal objective value: 272.00
Ship 0 is assigned to Berth 0
Ship 1 is assigned to Berth 0
Ship 2 is assigned to Berth 0
Ship 3 is assigned to Berth 1
Ship 4 is assigned to Berth 0
Ship 5 is assigned to Berth 1
Ship 6 is assigned to Berth 1
Ship 7 is assigned to Berth 0
Ship 8 is assigned to Berth 1
Ship 9 is assigned to Berth 1
Ship 10 is assigned to Berth 0
Ship 11 is assigned to Berth 1


```

================================================================================



--- Problem 147 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling incoming trucks to minimize the total time taken to service all vehicles. Three trucks—Truck 1, Truck 2, and Truck 3—arrive at staggered times: Truck 1 at time 2, Truck 2 at time 6, and Truck 3 at time 9. The hub has only a single depot available, meaning trucks must be scheduled sequentially without overlap. Each truck requires a specific processing time: Truck 1 takes 6 units of time, Truck 2 takes 8, and Truck 3 takes 3. The hub manager must determine the optimal scheduling sequence to ensure all trucks are serviced as quickly as possible, minimizing the total completion time (makespan). The core question is: *What is the best sequence to assign trucks to the depot so that the last truck finishes as early as possible?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable indicating whether truck `i` is assigned to depot `j`.  
   - `start_time(i)`: Continuous variable representing the time truck `i` begins processing.  
   - `completion_time(i)`: Continuous variable representing the time truck `i` finishes processing.  
   - `precedes(i, k, j)`: Binary variable indicating whether truck `i` is scheduled before truck `k` on depot `j`.  
   - `makespan`: Continuous variable representing the total completion time (objective).  

   **2. Parameters:**  
   - `trucks = [1, 2, 3]`: The set of trucks.  
   - `depots = [1]`: The single depot available.  
   - `arrival_times = {1: 2, 2: 6, 3: 9}`: The arrival times for each truck.  
   - `processing_times = {1: 6, 2: 8, 3: 3}`: The time required to process each truck.  
   - `H = 100`: A large constant (Big-M) for enforcing sequencing constraints.  

   **3. Objective Function:**  
   Minimize `makespan` (the latest completion time among all trucks).  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot.  
     - `sum(assign(i, j) for j in depots) = 1` for all `i` in `trucks`.  
   - **Arrival Time:** A truck cannot start processing before it arrives.  
     - `start_time(i) >= arrival_times[i]` for all `i` in `trucks`.  
   - **Completion Time:** The completion time is the start time plus processing time.  
     - `completion_time(i) = start_time(i) + processing_times[i]` for all `i` in `trucks`.  
   - **Non-Overlapping:** Trucks assigned to the same depot must not overlap.  
     - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
     - If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.  
   - **Makespan Definition:** The makespan is the maximum completion time.  
     - `makespan >= completion_time(i)` for all `i` in `trucks`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
depots = [1]
arrival_times = {1: 2, 2: 6, 3: 9}
processing_times = {1: 6, 2: 8, 3: 3} # Using base processing times
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM") # Renamed model

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (using base proc time)
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the optimal sequence and start/completion times for each truck
if m.status == GRB.OPTIMAL:
    print("Optimal Sequence and Times:")
    for i in trucks:
        print(f"Truck {i}: Start Time = {start_time[i].x:.4f}, Completion Time = {completion_time[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
19.0000
Optimal Sequence and Times:
Truck 1: Start Time = 2.0000, Completion Time = 8.0000
Truck 2: Start Time = 8.0000, Completion Time = 16.0000
Truck 3: Start Time = 16.0000, Completion Time = 19.0000


```

================================================================================



--- Problem 148 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port is experiencing a temporary reduction in the capacity of its main berth due to an unexpected maintenance issue, forcing port managers to dynamically adjust the fees for using an alternative berth to minimize total system delay. The main berth’s normal capacity is 6,083 container moves per hour, but during the incident, it drops to 2,691 container moves per hour. Meanwhile, the alternative berth can handle up to 3,024 container moves per hour. The initial demand consists of 5,072 container moves preferring the main berth and 517 container moves opting for the alternative berth.  

   The fee adjustment strategy aims to incentivize shippers to switch from the congested main berth to the alternative berth by reducing the fee from its normal rate of $4.85. For every dollar decrease in the fee, an additional 155 container moves are expected to shift to the alternative berth. However, the alternative berth’s capacity limits the maximum flow it can absorb. The key challenge is to select the optimal fee from predefined options ($0, $1, $2, $3, $4, $5) that minimizes the total system delay, accounting for both queueing delays at the main berth and additional handling time at the alternative berth.  

   The central question is: **What fee achieves the lowest combined delay for all container moves in the system during the incident?**

---

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable \( y_p \) for each fee option \( p \in \{0, 1, 2, 3, 4, 5\} \), where \( y_p = 1 \) if fee \( p \) is selected, and \( 0 \) otherwise.  

   **2. Parameters:**  
   - \( C_{\text{main\_norm}} = 6,083 \): Main berth’s normal capacity (container moves/h).  
   - \( C_{\text{main\_red}} = 2,691 \): Main berth’s reduced capacity during the incident (container moves/h).  
   - \( C_{\text{alt}} = 3,024 \): Alternative berth capacity (container moves/h).  
   - \( \lambda_{\text{demand\_main}} = 5,072 \): Initial demand for the main berth (container moves/h).  
   - \( \lambda_{\text{alt\_initial}} = 517 \): Initial demand for the alternative berth (container moves/h).  
   - \( T_{\text{inc}} = 1.93 \): Duration of the incident (hours).  
   - \( T_{\text{extra\_alt}} = 0.075 \): Additional handling time per container move on the alternative berth (hours).  
   - \( \text{Flow\_increase\_per\_dollar} = 154.63 \): Additional alternative berth demand per $1 fee reduction (container moves/h).  

   **3. Objective Function:**  
   Minimize the total system delay:  
   \[
   \text{Minimize: } \sum_{p} y_p \cdot \text{delay}_p
   \]  
   where \( \text{delay}_p \) is the precomputed total delay (main berth + alternative berth) for fee \( p \).  

   **4. Constraints:**  
   - **Single fee selection:** Exactly one fee must be chosen:  
     \[
     \sum_{p} y_p = 1
     \]  
   - **Binary variables:** \( y_p \in \{0, 1\} \) for all \( p \).  

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
C_main_norm = 6083.307044766536
C_main_red = 2690.881518192503
lambda_demand_main_initial = 5071.5628323531255
C_alt = 3023.750939588118
T_extra_alt_h = 0.07528290166691198
Fee_norm = 4.854281398457681
lambda_alt_initial = 516.8864881453403
T_inc_h = 1.929292655349223
Flow_increase_per_dollar = 154.63041037828165
Fee_options = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]

Lambda_total = lambda_demand_main_initial + lambda_alt_initial

# --- Calculate total delay for each fee option ---
option_delays = {}
print("--- System Delay Calculation per Fee Option ---")

for p in Fee_options:
    fee_decrease = Fee_norm - p
    flow_increase_expected = fee_decrease * Flow_increase_per_dollar
    lambda_alt_expected = lambda_alt_initial + flow_increase_expected

    # Effective alternative berth flow considering capacity
    lambda_alt_effective = min(lambda_alt_expected, C_alt)

    # Remaining flow on main berth
    lambda_main = Lambda_total - lambda_alt_effective

    # Calculate delays
    # Alternative berth delay (extra handling time only)
    delay_alt = lambda_alt_effective * T_inc_h * T_extra_alt_h

    # Main berth queueing delay
    delay_main = 0
    q_max = 0
    t_diss = float('nan')
    if lambda_main > C_main_red:
        q_max = (lambda_main - C_main_red) * T_inc_h
        dissipation_rate = C_main_norm - lambda_main
        if dissipation_rate > 1e-6:
            t_diss = q_max / dissipation_rate
            delay_main = 0.5 * q_max * (T_inc_h + t_diss)
        else:
            delay_main = float('inf') # Queue doesn't dissipate naturally
    else:
         delay_main = 0 # No queue forms

    total_delay = delay_main + delay_alt if delay_main != float('inf') else float('inf')
    option_delays[p] = total_delay

    print(f" Fee=${p:.2f}: AltFlow={lambda_alt_effective:.0f}, MainFlow={lambda_main:.0f} -> MainDelay={delay_main:.2f}, AltDelay={delay_alt:.2f} => Total={total_delay:.2f}")

# --- Gurobi Model (Select best fee) ---
model = gp.Model("DynamicFeePricingIncident")

# --- Decision Variables ---
y = model.addVars(Fee_options, vtype=GRB.BINARY, name="ChooseFee")

# --- Constraints ---
model.addConstr(gp.quicksum(y[p] for p in Fee_options) == 1, name="SelectOneFee")

# --- Objective Function ---
# Minimize total system delay. Handle infinite delay case (e.g., assign large penalty).
objective = gp.LinExpr()
for p in Fee_options:
    cost = option_delays[p]
    if cost == float('inf'):
        cost = 1e12 # Assign large finite cost for infeasible/non-dissipating scenarios
    objective += y[p] * cost

model.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    chosen_fee = -1.0
    for p in Fee_options:
        if y[p].X > 0.9:
            chosen_fee = p
            break

    if chosen_fee >= 0:
         print(f"Optimal Fee: ${chosen_fee:.2f}")
         # Handle displaying infinite delay if that was the "optimal" outcome
         min_delay_val = model.objVal
         if min_delay_val >= 1e11: # Check if the large penalty was chosen
              print(f" Minimum Total System Delay: Infinite (or very large due to non-dissipating queues)")
         else:
              print(f" Minimum Total System Delay: {model.objVal:.2f} container-hours")
    else:
         print("Error: No fee selected.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- System Delay Calculation per Fee Option ---
 Fee=$0.00: AltFlow=1268, MainFlow=4321 -> MainDelay=5839.63, AltDelay=184.10 => Total=6023.72
 Fee=$1.00: AltFlow=1113, MainFlow=4476 -> MainDelay=7008.51, AltDelay=161.64 => Total=7170.15
 Fee=$2.00: AltFlow=958, MainFlow=4630 -> MainDelay=8426.17, AltDelay=139.18 => Total=8565.35
 Fee=$3.00: AltFlow=804, MainFlow=4785 -> MainDelay=10181.48, AltDelay=116.72 => Total=10298.19
 Fee=$4.00: AltFlow=649, MainFlow=4939 -> MainDelay=12411.36, AltDelay=94.26 => Total=12505.62
 Fee=$5.00: AltFlow=494, MainFlow=5094 -> MainDelay=15338.39, AltDelay=71.80 => Total=15410.19
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 6 columns and 6 nonzeros
Model fingerprint: 0x45914d15
Variable types: 0 continuous, 6 integer (6 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [6e+03, 2e+04]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 6023.7225191
Presolve removed 1 rows and 6 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 1: 6023.72 

Optimal solution found (tolerance 1.00e-04)
Best objective 6.023722519131e+03, best bound 6.023722519131e+03, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Fee: $0.00
 Minimum Total System Delay: 6023.72 container-hours



================================================================================



--- Problem 149 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
In a busy container port, the port authority faces the challenge of coordinating crane operations across three distinct berths to minimize total ship waiting time. Each berth serves a specific number of containers: Berth 1 handles 2,827 containers, Berth 2 serves 2,519, and Berth 3 accommodates 437. The port authority must allocate crane operation times for each berth within strict bounds—no less than 25 minutes and no more than 94 minutes—while ensuring the sum of all crane operation times matches the fixed shift time of 94 minutes. The core dilemma is determining the optimal distribution of crane operation times to minimize the cumulative waiting time experienced by ships across all berths, where waiting time is proportional to the product of the number of containers and the corresponding idle time (shift time minus crane operation time).
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - \( t_i \): Continuous variable representing the crane operation time (in minutes) allocated to berth \( i \) (\( i = 1, 2, 3 \)), with bounds \( 25 \leq t_i \leq 94 \).  

   **2. Parameters:**  
   - \( \text{container_coeffs} = [2827, 2519, 437] \): Number of containers for each berth.  
   - \( \text{shift_time} = 94 \): Total fixed shift time (minutes).  
   - \( \text{lb_time} = 25 \), \( \text{ub_time} = 94 \): Lower/upper bounds for crane operation times.  

   **3. Objective Function:**  
   Minimize the total waiting time:  
   \[
   \text{Minimize: } \sum_{i=1}^3 \text{container_coeffs}[i] \times (\text{shift_time} - t_i)
   \]  

   **4. Constraints:**  
   - **Total shift time:** The sum of crane operation times must equal the shift time:  
     \[
     t_1 + t_2 + t_3 = 94
     \]  
   - **Variable bounds:** \( 25 \leq t_i \leq 94 \) for all \( i \).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_berths = 3
lb_time = 25          # Lower bound for crane operation time
ub_time = 94          # Upper bound for crane operation time
shift_time = 94       # Total shift time (set equal to ub_time)
container_coeffs = [2827, 2519, 437] # Number of containers per berth
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(container_coeffs) != num_berths:
    print("Error: container_coeffs length mismatch with num_berths")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: container_coeffs length"
    # raise ValueError("container_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_berths}-Berth Crane Scheduling", env=env)

        # --- Decision variables (dynamic based on num_berths) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_berths, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for berth i is proportional to containers * idle_time = containers * (shift_time - crane_operation_time[i])
        model.setObjective(gp.quicksum(container_coeffs[i] * (shift_time - t_vars[i]) for i in range(num_berths)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of crane operation times must equal the shift time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_berths)) == shift_time, "TotalShift")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_berths)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal crane operation times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_berths):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 345314.00
------------------------------
Optimal crane operation times (minutes):
  t1: 44.00, t2: 25.00, t3: 25.00


```

================================================================================



--- Problem 150 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
In a busy port, the operations team is tasked with optimizing the berthing schedule for two types of vessels: container ships and bulk carriers. The port handles an average of 643.24 container ship arrivals and 465.39 bulk carrier arrivals per day. Each berth can handle up to 1542.05 vessel arrivals per day, and the port operates with approximately 1.85 berths. The berthing cycle must account for lost time—4.24 hours per phase—due to docking and undocking procedures.

The goal is to determine the optimal cycle length (bounded between 63.31 and 112.87 hours) and berthing time allocation for each type of vessel (with a minimum berthing time of 19.56 hours) to maximize the total port capacity. The challenge lies in balancing the conflicting demands: longer cycles can increase throughput but may lead to excessive delays, while shorter cycles might not fully utilize the available berthing time. The core question is: *What combination of cycle length and phase-specific berthing times will yield the highest possible vessel throughput under these constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**
- `C`: Cycle length (hours), bounded between `C_min` and `C_max`.
- `g_CS`: Berthing time for the container ships (hours), with a lower bound of `g_min_time`.
- `g_BC`: Berthing time for the bulk carriers (hours), with a lower bound of `g_min_time`.
- `lambda_g_CS`: Fraction of the cycle allocated to the container ships (unitless, bounded [0, 1]).
- `lambda_g_BC`: Fraction of the cycle allocated to the bulk carriers (unitless, bounded [0, 1]).
- `Cap_CS`: Capacity of the container ships (vessels/day).
- `Cap_BC`: Capacity of the bulk carriers (vessels/day).

**2. Parameters:**
- `lambda_CS_d`: Container ship arrival rate (643.24 vessels/day).
- `lambda_BC_d`: Bulk carrier arrival rate (465.39 vessels/day).
- `S_port_berth_d`: Saturation flow rate per berth (1542.05 vessels/day/berth).
- `N_berths`: Effective number of berths (1.85).
- `L_lost_time_per_phase`: Lost time per phase (4.24 hours).
- `C_min`: Minimum cycle length (63.31 hours).
- `C_max`: Maximum cycle length (112.87 hours).
- `g_min_time`: Minimum berthing time (19.56 hours).

**3. Objective Function:**
Maximize the total port capacity:  
`Maximize: Cap_CS + Cap_BC`.

**4. Constraints:**
- Cycle composition: `C = g_CS + g_BC + 2 * L_lost_time_per_phase`.
- Phase time fractions:  
  `lambda_g_CS * C = g_CS`,  
  `lambda_g_BC * C = g_BC`.
- Capacity calculations:  
  `Cap_CS = N_berths * S_port_berth_d * lambda_g_CS`,  
  `Cap_BC = N_berths * S_port_berth_d * lambda_g_BC`.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
lambda_CS_d = 643.2402272165319  # vessels/day
lambda_BC_d = 465.3900872363426  # vessels/day
S_port_berth_d = 1542.0485932716665  # vessels/day/berth
N_berths = 1.8513810112543765
L_lost_time_per_phase = 4.23673194995336  # hours
C_min = 63.305358272112606  # hours
C_max = 112.86501276801725  # hours
g_min_time = 19.55625309765116  # hours

# --- Gurobi Model ---
model = gp.Model("PortBerthingSchedule")

# Decision Variables
C = model.addVar(name="CycleLength", lb=C_min, ub=C_max)
g_CS = model.addVar(name="Berthing_CS", lb=g_min_time)
g_BC = model.addVar(name="Berthing_BC", lb=g_min_time)

# Intermediate Variables
lambda_g_CS = model.addVar(name="lambda_g_CS", lb=0.0, ub=1.0)
lambda_g_BC = model.addVar(name="lambda_g_BC", lb=0.0, ub=1.0)
Cap_CS = model.addVar(name="Capacity_CS", lb=0.0)
Cap_BC = model.addVar(name="Capacity_BC", lb=0.0)

# Constraints
model.addConstr(C == g_CS + g_BC + 2 * L_lost_time_per_phase, name="CycleComposition")
model.addQConstr(lambda_g_CS * C == g_CS, name="CalcLambdaCS")
model.addQConstr(lambda_g_BC * C == g_BC, name="CalcLambdaBC")
model.addConstr(Cap_CS == N_berths * S_port_berth_d * lambda_g_CS, name="CalcCapacityCS")
model.addConstr(Cap_BC == N_berths * S_port_berth_d * lambda_g_BC, name="CalcCapacityBC")

# Objective
model.setObjective(Cap_CS + Cap_BC, GRB.MAXIMIZE)

# Optimize
model.Params.NonConvex = 2
model.optimize()

# Output
if model.status == GRB.OPTIMAL:
    print("\n--- Port Berthing Schedule Results ---")
    print(f"Optimal Cycle Length: {C.X:.2f} hours")
    print(f"Container Ship Berthing Time: {g_CS.X:.2f} hours")
    print(f"Bulk Carrier Berthing Time: {g_BC.X:.2f} hours")
    print(f"Container Ship Capacity: {Cap_CS.X:.2f} vessels/day")
    print(f"Bulk Carrier Capacity: {Cap_BC.X:.2f} vessels/day")
    print(f"Total Throughput: {model.objVal:.2f} vessels/day")
else:
    print(f"Model status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 3 rows, 7 columns and 7 nonzeros
Model fingerprint: 0x48c64984
Model has 2 quadratic constraints
Coefficient statistics:
  Matrix range     [1e+00, 3e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [1e+00, 1e+02]
  RHS range        [8e+00, 8e+00]
Presolve removed 2 rows and 2 columns

Continuous model is non-convex -- solving as a MIP

Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolved: 9 rows, 6 columns, 27 nonzeros
Presolved model has 2 bilinear constraint(s)
Variable types: 6 continuous, 0 integer (0 binary)
Found heuristic solution: objective 2640.5832908

Root relaxation: objective 3.237663e+03, 3 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0 3237.66341    0    2 2640.58329 3237.66341  22.6%     -    0s
     0     0 3040.37198    0    2 2640.58329 3040.37198  15.1%     -    0s
     0     2 3040.37198    0    2 2640.58329 3040.37198  15.1%     -    0s

Explored 79 nodes (50 simplex iterations) in 0.03 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 2640.58 

Optimal solution found (tolerance 1.00e-04)
Best objective 2.640583290788e+03, best bound 2.640583290788e+03, gap 0.0000%

--- Port Berthing Schedule Results ---
Optimal Cycle Length: 112.87 hours
Container Ship Berthing Time: 52.20 hours
Bulk Carrier Berthing Time: 52.20 hours
Container Ship Capacity: 1320.29 vessels/day
Bulk Carrier Capacity: 1320.29 vessels/day
Total Throughput: 2640.58 vessels/day



================================================================================



--- Problem 151 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
A port authority is tasked with managing the berthing of ships at a busy harbor. The harbor manager must decide how many berths to allocate to minimize total operational costs while adhering to practical constraints. Each berth incurs a fixed maintenance cost of $47, regardless of the number of ships it handles. Fuel consumption for tugs and other auxiliary services is a critical factor: the services burn 0.192 liters of fuel per kilometer, with fuel priced at $2.21 per liter. The total fuel cost for the entire distance is calculated at $2,364.31, a constant expense regardless of the number of berths. The port has a maximum of 15 berths available but seeks to balance fixed costs against the efficiency of distributing the distance across multiple berths. The core challenge is to determine the optimal number of berths to allocate—neither too few (incurring high per-berth maintenance) nor too many (unnecessarily increasing fixed costs)—to achieve the lowest possible total cost.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n`: Integer variable representing the number of berths to use (1 ≤ `n` ≤ 15).  
   - **2. Parameters:**  
     - `fixed_cost_per_berth = 47` ($ per berth).  
     - `total_fuel_cost = 2364.31` ($, constant for the entire distance).  
     - `max_berths = 15` (upper bound on `n`).  
   - **3. Objective Function:**  
     Minimize the sum of fixed costs and fuel costs:  
     ```  
     Minimize: n * fixed_cost_per_berth + total_fuel_cost  
     ```  
   - **4. Constraints:**  
     - Bounds on `n`: `1 ≤ n ≤ 15` (enforced via variable definition).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_distance_km = 5572
fuel_consumption_rate_L_per_km = 0.192
fuel_cost_per_L = 2.21
fixed_cost_per_berth = 47
max_berths = 15

# Calculated total fuel cost (constant)
total_fuel_cost = 2364.31
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m30 = gp.Model("PORT_FUEL_MINIMIZE_IP", env=env)

    # --- Decision Variables ---
    # Integer: Number of berths to use
    # Ensure lb=1 so division in output works
    n = m30.addVar(vtype=GRB.INTEGER, name="num_berths_used", lb=1, ub=max_berths)

    # --- Objective Function ---
    # Minimize total fixed cost + total fuel cost
    total_fixed_cost_expr = n * fixed_cost_per_berth
    m30.setObjective(total_fixed_cost_expr + total_fuel_cost, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraints on n are handled by variable bounds (lb=1, ub=max_berths)
    # No other constraints in this simple model

    # --- Optimization ---
    m30.optimize()

    # --- Store results ---
    results_dict['status'] = m30.status
    if m30.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m30.ObjVal
        results_dict['n_sol'] = n.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- PORT_FUEL_MINIMIZE: Fuel Minimization for Berths (IP) ---")
    if m30.status == GRB.OPTIMAL:
        opt_n = int(round(results_dict.get('n_sol', 1))) # Round and ensure integer >= 1
        opt_fixed_cost = opt_n * fixed_cost_per_berth
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Optimal Number of Berths to Use: {opt_n} (Max allowed: {max_berths})")
        print(f"Resulting Fixed Maintenance Cost: ${opt_fixed_cost:.2f} (Cost/Berth: ${fixed_cost_per_berth})")
        print(f"Total Fuel Cost (Constant): ${total_fuel_cost:.2f}")
        print(f"Minimum Total Cost: ${obj_val_print:.2f}")
        # Avoid division by zero if opt_n somehow becomes 0 (lb=1 should prevent)
        if opt_n > 0:
             print(f"Distance per berth: {total_distance_km / opt_n:.1f} km (Total: {total_distance_km} km)")
        else:
             print("Cannot calculate distance per berth (0 berths).")


    elif m30.status == GRB.INFEASIBLE:
         # Should not happen with lb=1 and ub >= lb
         print(f"Optimization Status: Infeasible. Check variable bounds (lb=1, ub={max_berths}).")
    elif m30.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         # Should be very fast, but include handling just in case
         if m30.ObjVal is not None and abs(m30.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m30.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m30.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- PORT_FUEL_MINIMIZE: Fuel Minimization for Berths (IP) ---
Optimization Status: Optimal
Optimal Number of Berths to Use: 1 (Max allowed: 15)
Resulting Fixed Maintenance Cost: $47.00 (Cost/Berth: $47)
Total Fuel Cost (Constant): $2364.31
Minimum Total Cost: $2411.31
Distance per berth: 5572.0 km (Total: 5572 km)


```

================================================================================



--- Problem 152 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
In a busy port, ships need to be scheduled for berthing at different docks. The port has three primary docks—A, B, and C—each with distinct characteristics. Dock A offers the shortest free-flow service time (0.267 hours) but has the highest capacity (4328.43 ships/hour). Dock B is slightly slower (0.339 hours) with a moderate capacity (2770.29 ships/hour), while Dock C is the slowest in free-flow conditions (0.399 hours) and has the lowest capacity (2294.34 ships/hour). The Bureau of Public Roads (BPR) function models congestion effects, with parameters α = 0.148 and β = 3.933, reflecting how service time worsens as the number of ships approaches the dock's capacity.

Under normal conditions, all three docks are available, and the total demand is 7406.59 ships. However, during a maintenance period, Dock A becomes unavailable, forcing all ships onto Docks B and C. The central question is: *How does the closure of Dock A redistribute the ship flows across the remaining docks, and what is the resulting increase in total port service time?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[d]`: Flow of ships (in ships/h) on dock `d`, where `d ∈ available_docks` (either `['A', 'B', 'C']` or `['B', 'C']`).  

   **2. Parameters:**  
   - `t0[d]`: Free-flow service time (hours) for dock `d` (e.g., `t0['A'] = 0.2666`).  
   - `capacity[d]`: Maximum flow capacity (ships/h) for dock `d` (e.g., `capacity['A'] = 4328.43`).  
   - `bpr_alpha`, `bpr_beta`: BPR function parameters (0.148, 3.933).  
   - `total_demand`: Total ship demand (7406.59 ships/h).  

   **3. Objective Function:**  
   Minimize the Beckmann transformation of service times:  
   ```
   Minimize: sum(t0[d] * x[d] + (t0[d] * α / ((β + 1) * capacity[d]^β)) * x[d]^2 for all d)
   ```  
   This approximates the user equilibrium condition where no ship can reduce its service time by switching docks.  

   **4. Constraints:**  
   - **Demand Conservation:** `sum(x[d] for all d) = total_demand`.  
   - **Non-Negativity:** `x[d] ≥ 0` for all docks.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
docks_normal = ['A', 'B', 'C']
docks_closure = ['B', 'C']  # Dock A is closed

t0 = {'A': 0.2665944356908834, 'B': 0.3386548678353698, 'C': 0.3985938806846665}  # hours
capacity = {'A': 4328.43304077957, 'B': 2770.2899100418495, 'C': 2294.343068698431}  # ships/h
bpr_alpha = 0.14791162245785264
bpr_beta = 3.932909777070248
total_demand = 7406.587328731002

# --- Function to solve UE ---
def solve_user_equilibrium(available_docks, t0_dict, capacity_dict, demand):
    m = gp.Model("UserEquilibrium")
    m.Params.NonConvex = 2

    # Decision Variables: Flow on each available dock
    x = m.addVars(available_docks, name="flow", lb=0.0)

    # Constraints
    m.addConstr(gp.quicksum(x[i] for i in available_docks) == demand, name="DemandConservation")

    # Objective Function (Beckmann transformation)
    objective = gp.LinExpr()
    for i in available_docks:
        objective += t0_dict[i] * x[i]
        if capacity_dict[i] > 1e-6:
            coef = (t0_dict[i] * bpr_alpha) / ((bpr_beta + 1.0) * (capacity_dict[i] ** bpr_beta))
            # Using quadratic approximation for demonstration
            objective += coef * x[i] * x[i]

    m.setObjective(objective, GRB.MINIMIZE)
    m.optimize()

    flows = {p: x[p].X for p in available_docks}
    times = {}
    total_delay = 0
    for p in available_docks:
        flow = flows[p]
        t_act = t0_dict[p] * (1 + bpr_alpha * (flow / capacity_dict[p])**bpr_beta) if capacity_dict[p]>0 else float('inf')
        times[p] = t_act
        total_delay += flow * t_act

    return flows, times, total_delay

# --- Analysis ---
print("--- Normal Conditions (A, B, C available) ---")
flows_norm, times_norm, delay_norm = solve_user_equilibrium(docks_normal, t0, capacity, total_demand)
print(f"Flows: {flows_norm}")
print(f"Times: {times_norm}")
print(f"Total Port Service Time: {delay_norm}")

print("\n--- Maintenance Period (B, C available) ---")
flows_closure, times_closure, delay_closure = solve_user_equilibrium(docks_closure, t0, capacity, total_demand)
print(f"Flows: {flows_closure}")
print(f"Times: {times_closure}")
print(f"Total Port Service Time: {delay_closure}")

delay_increase = delay_closure - delay_norm
print(f"\n--- Impact of Maintenance ---")
print(f"Increase in Total Port Service Time: {delay_increase:.2f} ship-hours")
```
Answer:
--- Normal Conditions (A, B, C available) ---
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 1 rows, 3 columns and 3 nonzeros
Model fingerprint: 0x76568454
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [3e-01, 4e-01]
  Bounds range     [0e+00, 0e+00]
  RHS range        [7e+03, 7e+03]
Presolve removed 1 rows and 3 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    1.9745550e+03   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  1.974554969e+03
Flows: {'A': 7406.587328731002, 'B': 0.0, 'C': 0.0}
Times: {'A': 0.5926952265950746, 'B': 0.3386548678353698, 'C': 0.3985938806846665}
Total Port Service Time: 4389.8489550984295

--- Maintenance Period (B, C available) ---
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 1 rows, 2 columns and 2 nonzeros
Model fingerprint: 0x6538a74a
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [3e-01, 4e-01]
  Bounds range     [0e+00, 0e+00]
  RHS range        [7e+03, 7e+03]
Presolve removed 1 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    2.5082769e+03   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  2.508276853e+03
Flows: {'B': 7406.587328731002, 'C': 0.0}
Times: {'B': 2.7346038935934014, 'C': 0.3985938806846665}
Total Port Service Time: 20254.08254738735

--- Impact of Maintenance ---
Increase in Total Port Service Time: 15864.23 ship-hours



================================================================================



--- Problem 153 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently managing its limited depot space to accommodate incoming delivery trucks. Five trucks, labeled 1 through 5, arrive at staggered times: Truck 1 at 5 hours, Truck 2 at 9 hours, Truck 3 at 14 hours, Truck 4 at 19 hours, and Truck 5 at 23 hours. Each truck requires a specific processing time once it reaches the depot: 6 hours for Trucks 1 and 2, 5 hours for Truck 3, 8 hours for Truck 4, and 4 hours for Truck 5. The hub has only two depots available, and the goal is to assign each truck to a depot and schedule their start times such that no two trucks occupy the same depot simultaneously. The critical objective is to minimize the total time taken to process all trucks, known as the makespan, ensuring the hub operates as efficiently as possible. The central question is: What is the optimal assignment and scheduling of trucks to depots to achieve the shortest possible completion time for all operations?
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `assign(i, j)`: Binary variable indicating whether truck `i` is assigned to depot `j` (1 if assigned, 0 otherwise).
   - `start_time(i)`: Continuous variable representing the start time of truck `i`.
   - `completion_time(i)`: Continuous variable representing the completion time of truck `i`.
   - `precedes(i, k, j)`: Binary variable indicating whether truck `i` precedes truck `k` on depot `j` (1 if `i` precedes `k`, 0 otherwise).
   - `makespan`: Continuous variable representing the total completion time of all trucks.

**2. Parameters:**
   - `trucks`: List of trucks [1, 2, 3, 4, 5].
   - `depots`: List of depots [1, 2].
   - `arrival_times`: Dictionary mapping trucks to their arrival times {1: 5, 2: 9, 3: 14, 4: 19, 5: 23}.
   - `processing_times`: Dictionary mapping trucks to their processing times {1: 6, 2: 6, 3: 5, 4: 8, 5: 4}.
   - `H`: A large constant (100) used for big-M constraints.

**3. Objective Function:**
   - Minimize `makespan`, the maximum completion time across all trucks.

**4. Constraints:**
   - **Assignment:** Each truck must be assigned to exactly one depot: `sum(assign(i, j) for j in depots) = 1` for all `i` in trucks.
   - **Arrival Time:** A truck cannot start processing before its arrival time: `start_time(i) >= arrival_times[i]` for all `i` in trucks.
   - **Completion Time:** The completion time of a truck is its start time plus its processing time: `completion_time(i) = start_time(i) + processing_times[i]` for all `i` in trucks.
   - **Non-overlapping:** For each depot, if two trucks `i` and `k` are assigned to it, one must precede the other: 
     - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.
     - If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.
     - `assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))` to enforce precedence if both trucks are assigned to the same depot.
   - **Makespan Definition:** The makespan is the maximum completion time of all trucks: `makespan >= completion_time(i)` for all `i` in trucks.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2]
arrival_times = {1: 5, 2: 9, 3: 14, 4: 19, 5: 23}
processing_times = {1: 6, 2: 6, 3: 5, 4: 8, 5: 4} # Using base processing times
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_57_TRUCKS") # Renamed model

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (using base proc time)
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Assignment and Scheduling:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.2f}, Completion Time: {completion_time[i].x:.2f}")
    print(f"Total Makespan: {makespan.x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
34.0000
Optimal Assignment and Scheduling:
Truck 1 is assigned to Depot 2
Start Time: 5.00, Completion Time: 11.00
Truck 2 is assigned to Depot 2
Start Time: 11.00, Completion Time: 17.00
Truck 3 is assigned to Depot 2
Start Time: 17.00, Completion Time: 22.00
Truck 4 is assigned to Depot 2
Start Time: 22.00, Completion Time: 30.00
Truck 5 is assigned to Depot 2
Start Time: 30.00, Completion Time: 34.00
Total Makespan: 34.00


```

================================================================================



--- Problem 154 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling the arrival and processing of trucks at its depots to minimize the number of active depots while adhering to strict scheduling constraints. Ten trucks, labeled 1 through 10, arrive at staggered times—ranging from Truck 1 at hour 5 to Truck 10 at hour 23—each requiring varying processing durations (e.g., Truck 1 needs 5 hours, Truck 2 needs 7). Only two depots are available, and the logistics manager must assign trucks to depots such that no two trucks overlap in usage of the same depot. The primary goal is to determine the minimal number of depots needed to service all trucks without delays, ensuring each truck starts only after its arrival and completes processing uninterrupted. The question at hand: *What is the smallest number of depots required to accommodate all ten trucks under these constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary (1 if truck *i* is assigned to depot *j*).  
     - `start_time(i)`: Continuous, ≥0 (when truck *i* begins processing).  
     - `completion_time(i)`: Continuous, ≥0 (when truck *i* finishes).  
     - `precedes(i, k, j)`: Binary (1 if truck *i* is scheduled before truck *k* on depot *j*).  
     - `depot_used(j)`: Binary (1 if depot *j* is utilized).  

   - **2. Parameters:**  
     - `arrival_times[i]`: Truck *i*'s arrival hour (e.g., Truck 1: 5).  
     - `processing_times[i]`: Truck *i*'s processing duration (e.g., Truck 1: 5).  
     - `H=100`: A large constant for linearization.  

   - **3. Objective Function:**  
     Minimize total depots used:  
     ```  
     Minimize: sum(depot_used[j] for j in depots)  
     ```  

   - **4. Constraints:**  
     - Each truck assigned to exactly one depot:  
       `sum(assign(i, j) for j in depots) = 1` for all trucks *i*.  
     - Start time ≥ arrival time:  
       `start_time[i] ≥ arrival_times[i]` for all *i*.  
     - Completion time = start time + processing time:  
       `completion_time[i] = start_time[i] + processing_times[i]`.  
     - No overlapping assignments on the same depot (via precedence variables).  
     - Depot activation: `assign(i, j) ≤ depot_used[j]` for all *i, j*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
depots = [1, 2]
arrival_times = {1: 5, 2: 8, 3: 9, 4: 11, 5: 12, 6: 15, 7: 16, 8: 18, 9: 19, 10: 23}
processing_times = {1: 5, 2: 7, 3: 5, 4: 6, 5: 3, 6: 4, 7: 5, 8: 8, 9: 5, 10: 7}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM_MIN_DEPOTS")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    depot_used = m.addVars(depots, vtype=GRB.BINARY, name="DepotUsed") # Objective var

    # --- Objective Function ---
    m.setObjective(gp.quicksum(depot_used[j] for j in depots), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Link DepotUsed to assignments
    m.addConstrs((assign[i, j] <= depot_used[j] for i in trucks for j in depots), name="link_used_depot")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{int(round(obj_val_print))}") # Number of depots
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.2f}")
                print(f"  Completion Time: {completion_time[i].x:.2f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
1
Optimal Solution Found:
Truck 1 is assigned to Depot 2
  Start Time: 5.00
  Completion Time: 10.00
Truck 2 is assigned to Depot 2
  Start Time: 10.00
  Completion Time: 17.00
Truck 3 is assigned to Depot 2
  Start Time: 17.00
  Completion Time: 22.00
Truck 4 is assigned to Depot 2
  Start Time: 22.00
  Completion Time: 28.00
Truck 5 is assigned to Depot 2
  Start Time: 28.00
  Completion Time: 31.00
Truck 6 is assigned to Depot 2
  Start Time: 31.00
  Completion Time: 35.00
Truck 7 is assigned to Depot 2
  Start Time: 35.00
  Completion Time: 40.00
Truck 8 is assigned to Depot 2
  Start Time: 40.00
  Completion Time: 48.00
Truck 9 is assigned to Depot 2
  Start Time: 48.00
  Completion Time: 53.00
Truck 10 is assigned to Depot 2
  Start Time: 53.00
  Completion Time: 60.00


```

================================================================================



--- Problem 155 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A regional truck rental company operates two depots, A and B, facing an imbalance in vehicle availability and customer demand. Depot A currently has 39 trucks on hand but anticipates demand for 53 vehicles, while Depot B has 78 trucks but expects demand for only 63. To address this mismatch, the company can relocate trucks between depots, but each move incurs a cost: $10 per truck moved from A to B and $37 per truck moved from B to A. The challenge is to determine the optimal number of trucks to move in each direction to meet demand at both depots while minimizing the total relocation cost. The solution must ensure that no more trucks are moved than are available at each depot and that the net movement of vehicles satisfies the demand constraints at both sites.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `move_AB`: Integer, number of trucks moved from A to B (≥0).  
     - `move_BA`: Integer, number of trucks moved from B to A (≥0).  
   - **2. Parameters:**  
     - `available_A = 39`, `available_B = 78`: Initial truck counts.  
     - `demand_A = 53`, `demand_B = 63`: Required truck counts post-relocation.  
     - `cost_AB = 10`, `cost_BA = 37`: Per-truck relocation costs.  
   - **3. Objective Function:**  
     Minimize total cost: `10 * move_AB + 37 * move_BA`.  
   - **4. Constraints:**  
     - Demand at A: `39 - move_AB + move_BA ≥ 53`.  
     - Demand at B: `78 + move_AB - move_BA ≥ 63`.  
     - Supply limits: `move_AB ≤ 39`, `move_BA ≤ 78`.  

**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
available_A = 39
available_B = 78
demand_A = 53
demand_B = 63
cost_AB = 10
cost_BA = 37
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("TRUCK_RELOCATION", env=env)

    # --- Decision Variables ---
    # move_AB: number of trucks moved from A to B
    move_AB = m.addVar(vtype=GRB.INTEGER, lb=0, name="move_AB")
    # move_BA: number of trucks moved from B to A
    move_BA = m.addVar(vtype=GRB.INTEGER, lb=0, name="move_BA")

    # --- Objective Function: Minimize total relocation cost ---
    m.setObjective(cost_AB * move_AB + cost_BA * move_BA, GRB.MINIMIZE)

    # --- Constraints ---
    # Final number of trucks at A must meet demand
    m.addConstr(available_A - move_AB + move_BA >= demand_A, "DemandA")

    # Final number of trucks at B must meet demand
    m.addConstr(available_B + move_AB - move_BA >= demand_B, "DemandB")

    # Cannot move more trucks than available
    m.addConstr(move_AB <= available_A, "SupplyA")
    m.addConstr(move_BA <= available_B, "SupplyB")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['move_AB_sol'] = move_AB.X # Not needed for output
        # results_dict['move_BA_sol'] = move_BA.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible. Demand cannot be met.") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# --- Supplemental Code Block ---
if m.Status == GRB.OPTIMAL:
    print(f"Optimal number of trucks moved from A to B: {move_AB.X:.0f}")
    print(f"Optimal number of trucks moved from B to A: {move_BA.X:.0f}")
```
Answer:
Optimal objective value: 518.00
Optimal number of trucks moved from A to B: -0
Optimal number of trucks moved from B to A: 14


```

================================================================================



--- Problem 156 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port is divided into three berths, each experiencing varying ship arrival rates and berth-related disruptions. During disruptions, the capacity of the main berth is reduced, forcing port managers to divert ships to alternative berths. The challenge is to determine the optimal proportion of ships to divert for each berth, balancing the trade-off between queue delays at the congested main berth and the additional travel time to alternative berths.  

Key parameters include:  
- **Main berth capacities:** Normal (3620, 5150, 4141 ships/h) and reduced (1655, 2913, 1510 ships/h) due to disruptions.  
- **Alternative berth capacities:** 1800, 1599, and 1693 ships/h for berths 1–3.  
- **Arrival rates:** 3777, 4953, and 4304 ships/h, reflecting demand.  
- **Disruption durations:** 0.93, 0.83, and 1.10 hours.  
- **Additional travel times to alternatives:** 0.30, 0.13, and 0.32 hours.  

The optimization seeks to minimize total delay by selecting from predefined diversion ratios (10%, 30%, 50%, 70%) for each berth, ensuring no berth exceeds its capacity. The core question: *What diversion strategy minimizes total delay across all berths while respecting capacity constraints?*  
**

---

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable \( y(i, k) \): 1 if diversion option \( k \) (e.g., 30%) is selected for berth \( i \), else 0.  

**2. Parameters:**  
- \( \text{capacities\_main\_normal}[i] \), \( \text{capacities\_main\_reduced}[i] \): Main berth capacities.  
- \( \text{capacities\_alt}[i] \): Alternative berth capacity.  
- \( \text{arrival\_rates}[i] \): Ship demand.  
- \( \text{disruption\_durations}[i] \), \( \text{alt\_berth\_extra\_times}[i] \): Time penalties.  
- \( \text{diversion\_options} = [0.1, 0.3, 0.5, 0.7] \): Available diversion ratios.  
- \( \text{berth\_option\_delays}[i][k] \): Precomputed delay for option \( k \) in berth \( i \).  

**3. Objective Function:**  
Minimize total delay:  
\[ \text{Minimize: } \sum_{i=1}^3 \sum_{k=1}^4 y(i, k) \cdot \text{berth\_option\_delays}[i][k] \]  

**4. Constraints:**  
- **Feasibility:** Only feasible diversion options (not exceeding capacities) are allowed:  
  \[ y(i, k) = 0 \quad \text{if option } k \text{ is infeasible for berth } i. \]  
- **Single selection:** Exactly one option per berth:  
  \[ \sum_{k=1}^4 y(i, k) = 1 \quad \forall i \in \{1, 2, 3\}. \]  
**

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 3
capacities_main_normal = [3620, 5150, 4141]  # ships/h
capacities_main_reduced = [1655, 2913, 1510]  # ships/h
capacities_alt = [1800, 1599, 1693]  # ships/h
arrival_rates = [3777, 4953, 4304]  # ships/h
disruption_durations = [0.9330461579827886, 0.8250631208788675, 1.098534206732835]  # h
alt_berth_extra_times = [0.29866300999440404, 0.13341351408153534, 0.315244673689121]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option and Berth ---
berth_option_delays = {}
berth_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_option_delays[i] = {}
    berth_option_feasible[i] = {}

    for k in range(num_options):
        p_k = diversion_options[k]
        flow_alt_k = arrival_rates[i] * p_k
        flow_main_k = arrival_rates[i] * (1 - p_k)

        # 1. Check Alternative Berth Capacity Feasibility
        if flow_alt_k > capacities_alt[i] + EPSILON:
            berth_option_feasible[i][k] = False
            berth_option_delays[i][k] = LARGE_DELAY
            continue

        berth_option_feasible[i][k] = True

        # 2. Calculate Alternative Berth Delay
        delay_alt_k = flow_alt_k * disruption_durations[i] * alt_berth_extra_times[i]

        # 3. Calculate Main Berth Queue Delay
        delay_queue_main_k = 0
        max_queue_main_k = 0

        if flow_main_k > capacities_main_reduced[i] + EPSILON:
            max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * disruption_durations[i]
            if flow_main_k >= capacities_main_normal[i] - EPSILON:
                delay_queue_main_k = LARGE_DELAY
            else:
                dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                if dissipation_rate_k < EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                    total_influence_time_k = disruption_durations[i] + dissipation_time_main_k
                    delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

        # 4. Calculate Total Delay for this option
        total_delay_k = delay_alt_k + delay_queue_main_k
        berth_option_delays[i][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    feasible_indices = [k for k in range(num_options) if berth_option_feasible[i][k]]
    if not feasible_indices:
        exit()

    m.addConstr(gp.quicksum(y[i,k] for k in feasible_indices) == 1, name="SelectOneFeasibleOption_Berth{0}".format(i))

    for k in range(num_options):
        if not berth_option_feasible[i][k]:
            m.addConstr(y[i,k] == 0, name="ForbidInfeasibleOption_Berth{0}_Option{1}".format(i,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,k] * berth_option_delays[i][k]
        for i in range(NUM_BERTHS)
        for k in range(num_options)
        if berth_option_feasible[i][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Diversion Strategy:")
    for i in range(NUM_BERTHS):
        for k in range(num_options):
            if y[i,k].X > 0.5:
                print("Berth {0}: Option {1} ({2:.0f}%)".format(
                    i+1, k, diversion_options[k]*100
                ))
                break
```
Answer:
Optimal Diversion Strategy:
Berth 1: Option 1 (30%)
Berth 2: Option 1 (30%)
Berth 3: Option 1 (30%)



================================================================================



--- Problem 157 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
In a busy maritime port, container ships from a major origin point (Node A) face a critical berthing challenge. During peak hours, 2,307 container units per hour flood the system, requiring strategic routing to avoid congestion. The network consists of three key segments:  
- **A→B** (Capacity: 2,466 container units/hr): A high-capacity main channel prone to overuse.  
- **A→C** (Capacity: 968 container units/hr) and **C→B** (Capacity: 927 container units/hr): An alternate route via Node C, offering relief but with tighter constraints.  

The core dilemma: *How can port managers distribute flows across these routes to minimize congestion on A→B while respecting all segment capacities?* The solution must ensure no container unit is left unassigned (total flow = 2,307 container units/hr) and avoid overloading the alternate path (A→C→B), where the bottleneck is the C→B segment’s strict 927 container units/hr limit.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `f_AB`: Flow (container units/hr) from A→B.  
     - `f_AC`: Flow (container units/hr) from A→C.  
     - `f_CB`: Flow (container units/hr) from C→B (must equal `f_AC`).  
     - `overflow_AB`: Excess flow beyond A→B’s capacity (minimized).  

   - **2. Parameters:**  
     - `total_flow_originating_A = 2,307` (container units/hr).  
     - Segment capacities: `AB=2,466`, `AC=968`, `CB=927` (container units/hr).  

   - **3. Objective Function:**  
     Minimize `overflow_AB` (excess flow on A→B).  

   - **4. Constraints:**  
     - Flow conservation at A: `f_AB + f_AC = 2,307`.  
     - Flow balance at C: `f_AC = f_CB`.  
     - A→B overflow definition: `f_AB ≤ 2,466 + overflow_AB`.  
     - Capacity limits: `f_AC ≤ 968`, `f_CB ≤ 927`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_flow_originating_A = 2307 # container units/hr
capacity = {'AB': 2466, 'AC': 968, 'CB': 927} # Dict segment: capacity (container units/hr)
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m33 = gp.Model("MARITIME_BERTHING_LP", env=env)

    # --- Decision Variables ---
    # Flows on each segment
    f_AB = m33.addVar(name="flow_A_B", lb=0)
    f_AC = m33.addVar(name="flow_A_C", lb=0)
    f_CB = m33.addVar(name="flow_C_B", lb=0)
    # Overflow variable for the congested link AB
    overflow_AB = m33.addVar(name="overflow_A_B", lb=0)

    # --- Objective Function ---
    # Minimize the overflow on segment A->B
    m33.setObjective(overflow_AB, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Total flow conservation leaving node A
    m33.addConstr(f_AB + f_AC == total_flow_originating_A, name="flow_out_A")

    # Constraint 2: Flow conservation at node C
    m33.addConstr(f_AC == f_CB, name="flow_at_C")

    # Constraint 3: Calculate overflow for A->B link
    # overflow = max(0, f_AB - capacity_AB)
    cap_ab = capacity.get('AB', 0) # Get capacity safely
    m33.addConstr(f_AB <= cap_ab + overflow_AB, name="overflow_calc")

    # Constraint 4: Capacity constraint for A->C link
    cap_ac = capacity.get('AC', 0)
    m33.addConstr(f_AC <= cap_ac, name="capacity_AC")

    # Constraint 5: Capacity constraint for C->B link
    cap_cb = capacity.get('CB', 0)
    m33.addConstr(f_CB <= cap_cb, name="capacity_CB")

    # --- Optimization ---
    m33.optimize()

    # --- Store results ---
    results_dict['status'] = m33.status
    if m33.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m33.ObjVal # = overflow_AB.X
        results_dict['f_AB_sol'] = f_AB.X
        results_dict['f_AC_sol'] = f_AC.X
        results_dict['f_CB_sol'] = f_CB.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 33: Maritime Berthing Rerouting (LP) ---") # Original problem number
    if m33.status == GRB.OPTIMAL:
        overflow_sol = results_dict.get('obj_val', 'N/A')
        f_ab_sol = results_dict.get('f_AB_sol', 'N/A')
        f_ac_sol = results_dict.get('f_AC_sol', 'N/A')
        f_cb_sol = results_dict.get('f_CB_sol', 'N/A')
        cap_ab_print = capacity.get('AB', 'N/A')
        cap_ac_print = capacity.get('AC', 'N/A')
        cap_cb_print = capacity.get('CB', 'N/A')

        print(f"Optimization Status: Optimal")
        # Format numerical output
        print(f"Minimum Overflow on A->B: {float(overflow_sol):.1f} container units/hr")
        print("Optimal Flow Distribution:")
        print(f"  Flow A -> B: {float(f_ab_sol):.1f} (Capacity: {cap_ab_print})")
        print(f"  Flow A -> C: {float(f_ac_sol):.1f} (Capacity: {cap_ac_print})")
        print(f"  Flow C -> B: {float(f_cb_sol):.1f} (Capacity: {cap_cb_print})")
        # Check total flow matches original
        total_flow_out = float(f_ab_sol) + float(f_ac_sol) if isinstance(f_ab_sol, (int, float)) and isinstance(f_ac_sol, (int, float)) else 'N/A'
        print(f"Total Flow from A: {total_flow_out:.1f} (Initial: {total_flow_originating_A})")

    elif m33.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible. Check capacities vs total flow.")
         print(f"Total Flow: {total_flow_originating_A}, Capacity AC+CB path: {capacity.get('AC', 0) + capacity.get('CB', 0)}?") # Simple check example
    else:
        print(f"Optimization Status: {m33.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2


```
Answer:
--- Problem 33: Maritime Berthing Rerouting (LP) ---
Optimization Status: Optimal
Minimum Overflow on A->B: 0.0 container units/hr
Optimal Flow Distribution:
  Flow A -> B: 1380.0 (Capacity: 2466)
  Flow A -> C: 927.0 (Capacity: 968)
  Flow C -> B: 927.0 (Capacity: 927)
Total Flow from A: 2307.0 (Initial: 2307)



================================================================================



--- Problem 158 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port management system faces a critical challenge during an incident that reduces the capacity of the main berthing area. Over four consecutive 30-minute time periods, ships arrive at varying rates—peaking at 4,033 ships per hour in the final period. The main berthing area’s capacity drops from 4,214 to 1,850 ships per hour due to the incident, which lasts approximately 1.56 hours. An alternative berthing area is available but has a limited capacity of 1,194 ships per hour and adds an extra 0.29 hours of berthing time. Port managers must dynamically decide the optimal fraction of ships to divert (10%, 30%, 50%, or 70%) in each period to minimize total delay, balancing congestion on the main berthing area against overflow and added berthing time on the alternative. The goal is to find the best diversion strategy that avoids infeasible flows (exceeding either berthing area’s capacity) while minimizing the cumulative delay across all ships.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Binary variables \( y(t, k) \) for each time period \( t \) (1 to 4) and diversion option \( k \) (0 to 3, representing 10%, 30%, 50%, 70%). \( y(t, k) = 1 \) if option \( k \) is chosen in period \( t \), else 0.  
   - **2. Parameters:**  
     - Arrival rates: [3,046, 3,272, 2,597, 4,033] ships/h for periods 1–4.  
     - Capacities: Main (normal: 4,214, reduced: 1,850 ships/h), alternative: 1,194 ships/h.  
     - Diversion options: [0.1, 0.3, 0.5, 0.7].  
     - Precomputed delays \( \text{period\_option\_delays}[t][k] \) for feasible (capacity-compliant) combinations.  
   - **3. Objective Function:**  
     Minimize total delay: \( \sum_{t=1}^4 \sum_{k=0}^3 y(t, k) \cdot \text{delay}(t, k) \).  
   - **4. Constraints:**  
     - Exactly one feasible diversion option per period: \( \sum_{k \in \text{feasible}} y(t, k) = 1 \) for all \( t \).  
     - Infeasible options forced to 0: \( y(t, k) = 0 \) if flow exceeds capacity.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_TIME_PERIODS = 4
TIME_PERIOD_LENGTH = 0.5  # h
capacity_main_normal = 4214  # ships/h
capacity_main_reduced = 1850  # ships/h
capacity_alt = 1194  # ships/h
arrival_rates = [3046, 3272, 2597, 4033]  # ships/h
incident_duration = 1.562452493836986  # h
alt_berth_extra_time = 0.29479730879148297  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option and Time Period ---
period_option_delays = {}
period_option_feasible = {}

for t in range(NUM_TIME_PERIODS):
    period_option_delays[t] = {}
    period_option_feasible[t] = {}

    for k in range(num_options):
        p_k = diversion_options[k]
        flow_alt_k = arrival_rates[t] * p_k
        flow_main_k = arrival_rates[t] * (1 - p_k)

        # 1. Check Alternative Berth Capacity Feasibility
        if flow_alt_k > capacity_alt + EPSILON:
            period_option_feasible[t][k] = False
            period_option_delays[t][k] = LARGE_DELAY
            continue

        period_option_feasible[t][k] = True

        # 2. Calculate Alternative Berth Delay
        delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_time

        # 3. Calculate Main Berth Queue Delay
        delay_queue_main_k = 0
        max_queue_main_k = 0

        if flow_main_k > capacity_main_reduced + EPSILON:
            max_queue_main_k = (flow_main_k - capacity_main_reduced) * TIME_PERIOD_LENGTH
            if flow_main_k >= capacity_main_normal - EPSILON:
                delay_queue_main_k = LARGE_DELAY
            else:
                dissipation_rate_k = capacity_main_normal - flow_main_k
                if dissipation_rate_k < EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                    total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                    delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

        # 4. Calculate Total Delay for this option
        total_delay_k = delay_alt_k + delay_queue_main_k
        period_option_delays[t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for t in range(NUM_TIME_PERIODS):
    feasible_indices = [k for k in range(num_options) if period_option_feasible[t][k]]
    if not feasible_indices:
        exit()

    m.addConstr(gp.quicksum(y[t,k] for k in feasible_indices) == 1, name="SelectOneFeasibleOption_Period{0}".format(t))

    for k in range(num_options):
        if not period_option_feasible[t][k]:
            m.addConstr(y[t,k] == 0, name="ForbidInfeasibleOption_Period{0}_Option{1}".format(t,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[t,k] * period_option_delays[t][k]
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if period_option_feasible[t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Dynamic Diversion Strategy:")
    for t in range(NUM_TIME_PERIODS):
        for k in range(num_options):
            if y[t,k].X > 0.5:
                print("Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                    t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                ))
                break
```
Answer:
Optimal Dynamic Diversion Strategy:
Period 1 (0.0-0.5h): Option 1 (30%)
Period 2 (0.5-1.0h): Option 1 (30%)
Period 3 (1.0-1.5h): Option 1 (30%)
Period 4 (1.5-2.0h): Option 0 (10%)



================================================================================



--- Problem 159 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
In a busy port, a terminal manager faces the challenge of efficiently scheduling 22 uniquely colored containers for loading onto ships. Each container has a specific weight and is labeled with one of 12 distinct colors: 'A', 'G', 'H', 'I', 'J', 'L', 'M', 'N', 'Q', 'R', 'U', 'V', 'T', or 'X'. The ship's hold has a strict weight limit of 75 units, and to simplify unloading at the destination, no hold can contain containers from more than two different colors. The manager must determine the minimal number of holds required to load all containers while adhering to these constraints.

The containers vary significantly in weight, from a lightweight 9-unit container to a hefty 67-unit one. Some colors, like 'J' and 'A', appear multiple times, while others, such as 'X' and 'R', are unique to single containers. The challenge lies not only in balancing weight distribution but also in strategically grouping containers by color to minimize the total number of holds used.

The core question is: **What is the smallest number of holds needed to load all containers without exceeding weight limits or violating the two-color rule?**

---

**Modeling Process:**
**1. Decision Variables:**
- Binary variable `x[i, j]`: Indicates whether container `i` is assigned to hold `j` (1 if yes, 0 otherwise).
- Binary variable `y[j]`: Indicates whether hold `j` is used (1 if yes, 0 otherwise).
- Binary variable `z[c, j]`: Indicates whether color `c` is present in hold `j` (1 if yes, 0 otherwise).

**2. Parameters:**
- `containers[i]`: Weight of container `i` (given as [54, 39, ..., 59]).
- `colors[i]`: Color of container `i` (given as ['J', 'Q', ..., 'A']).
- `capacity`: Maximum weight per hold (75 units).
- `unique_colors_list`: List of distinct colors (e.g., ['A', 'G', ..., 'X']).

**3. Objective Function:**
Minimize the total number of holds used:
```
Minimize: sum(y[j] for all j)
```

**4. Constraints:**
- **Container Assignment:** Each container must be placed in exactly one hold:
  `sum(x[i, j] for all j) = 1` for every container `i`.
- **Hold Capacity:** The total weight in a hold cannot exceed its capacity:
  `sum(containers[i] * x[i, j] for all i) <= capacity * y[j]` for every hold `j`.
- **Color Linking:** If any container of color `c` is in hold `j`, `z[c, j]` must be 1:
  `x[i, j] <= z[colors[i], j]` for every container `i` and hold `j`.
- **Color Limit:** Each used hold can have at most two distinct colors:
  `sum(z[c, j] for all c) <= 2 * y[j]` for every hold `j`.

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
containers = [54, 39, 45, 47, 62, 55, 58, 31, 46, 65, 63, 26, 48, 47, 60, 28, 67, 25, 41, 9, 37, 59]      # Weights of containers
colors = ['J', 'Q', 'L', 'A', 'I', 'V', 'N', 'U', 'H', 'J', 'J', 'V', 'A', 'H', 'R', 'I', 'X', 'G', 'M', 'U', 'T', 'A']    # Colors of containers
capacity = 75         # Hold capacity
num_containers = 22       # len(containers) - derived correctly below
num_holds = num_containers      # Maximum holds (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(containers) != len(colors) or len(containers) != num_containers:
    print("Error: Data inconsistency (containers/colors/num_containers length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_colors_list = sorted(list(set(colors))) # Get unique colors deterministically
container_indices_by_color = {color: [i for i, c in enumerate(colors) if c == color] for color in unique_colors_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Color-Constrained Container Loading", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_containers, num_holds, vtype=GRB.BINARY, name="x")  # x[i,j] -> container i in hold j
        y = model.addVars(num_holds, vtype=GRB.BINARY, name="y")              # y[j] -> whether hold j is used
        # z[c,j] -> whether color c is PRESENT in hold j (Use unique_colors_list for keys)
        z = model.addVars(unique_colors_list, num_holds, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of holds used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each container must be assigned to exactly one hold ---
        for i in range(num_containers):
            model.addConstr(x.sum(i, '*') == 1, name=f"Container_{i}_Assignment")

        # --- Constraint 2: Hold capacity constraint ---
        for j in range(num_holds):
            model.addConstr(gp.quicksum(containers[i] * x[i, j] for i in range(num_containers)) <= capacity * y[j], name=f"Hold_{j}_Capacity")

        # --- Constraint 3: Color constraint (at most 2 *different* colors per hold) ---

        # Part 3a: Link x (container in hold) and z (color in hold).
        for j in range(num_holds):
            for color in unique_colors_list:
                indices_of_this_color = container_indices_by_color.get(color, []) # Use .get for safety

                if not indices_of_this_color:
                    # If no containers of this color exist, z[color, j] must be 0.
                    model.addConstr(z[color, j] == 0, name=f"NoContainers_{color}_Hold_{j}")
                    continue

                # If any container 'i' of this 'color' is placed in hold 'j' (x[i,j]=1),
                # then the presence indicator for that 'color' in hold 'j' (z[color,j]) must be 1.
                for i in indices_of_this_color:
                    model.addConstr(x[i, j] <= z[color, j], name=f"Link_x{i}_z{color}_Hold{j}")

                # Ensure z[color, j] is 0 if no containers of that color are in the hold.
                # This helps tighten the formulation.
                model.addConstr(z[color, j] <= gp.quicksum(x[i, j] for i in indices_of_this_color), name=f"Link_z{color}_SumX_Hold{j}")


        # Part 3b: Limit the number of distinct colors (sum of z[c,j] for hold j) to 2 for USED holds.
        for j in range(num_holds):
            # sum(z[c,j] for c in unique_colors_list) gives the count of distinct colors in hold j.
            # This sum must be <= 2 *IF* the hold is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Colors_Hold_{j}")

        # --- Solve ---
        print("Solving CCLP instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_holds = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of holds used: {optimal_holds}")
    print("-" * 30)

    hold_details = []
    printed_hold_count = 0
    for j_sol in range(num_holds): # Iterate through all potential hold indices
        try:
             # Check if this hold was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_hold_count += 1
                 assigned_container_indices = [i for i in range(num_containers) if x[i, j_sol].X > 0.5]
                 assigned_container_weights = [containers[i] for i in assigned_container_indices]
                 assigned_container_colors = [colors[i] for i in assigned_container_indices]
                 distinct_colors_in_hold = sorted(list(set(assigned_container_colors))) # Sort for consistent output
                 hold_load = sum(assigned_container_weights)

                 print(f"Hold {printed_hold_count} (Internal Index {j_sol}):")
                 print(f"  Containers (indices): {assigned_container_indices}")
                 # print(f"  Containers (weights): {assigned_container_weights}") # Optional details
                 # print(f"  Containers (colors):  {assigned_container_colors}") # Optional details
                 print(f"  Distinct Colors: {distinct_colors_in_hold} (Count: {len(distinct_colors_in_hold)})")
                 print(f"  Total weight:    {hold_load} / {capacity}")
                 print("-" * 10)

                 hold_data = {
                     'hold_index_internal': j_sol,
                     'hold_index_printed': printed_hold_count,
                     'container_indices': assigned_container_indices,
                     'distinct_colors': distinct_colors_in_hold,
                     'load': hold_load
                 }
                 hold_details.append(hold_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for hold index {j_sol}: {e_print}")


    results_dict['hold_details'] = hold_details # Store details

    # Final sanity check
    if printed_hold_count != optimal_holds:
         print(f"Warning: Number of printed used holds ({printed_hold_count}) does not match objective value ({optimal_holds}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# The provided code already prints the optimal number of holds and detailed information for each hold.
# No additional print statements are necessary.
```
Answer:
Solving CCLP instance...
------------------------------

Optimal solution found.
Optimal number of holds used: 17
------------------------------
Hold 1 (Internal Index 0):
  Containers (indices): [10]
  Distinct Colors: ['J'] (Count: 1)
  Total weight:    63 / 75
----------
Hold 2 (Internal Index 1):
  Containers (indices): [4]
  Distinct Colors: ['I'] (Count: 1)
  Total weight:    62 / 75
----------
Hold 3 (Internal Index 2):
  Containers (indices): [2, 15]
  Distinct Colors: ['I', 'L'] (Count: 2)
  Total weight:    73 / 75
----------
Hold 4 (Internal Index 3):
  Containers (indices): [0]
  Distinct Colors: ['J'] (Count: 1)
  Total weight:    54 / 75
----------
Hold 5 (Internal Index 4):
  Containers (indices): [14]
  Distinct Colors: ['R'] (Count: 1)
  Total weight:    60 / 75
----------
Hold 6 (Internal Index 5):
  Containers (indices): [16]
  Distinct Colors: ['X'] (Count: 1)
  Total weight:    67 / 75
----------
Hold 7 (Internal Index 6):
  Containers (indices): [8, 17]
  Distinct Colors: ['G', 'H'] (Count: 2)
  Total weight:    71 / 75
----------
Hold 8 (Internal Index 7):
  Containers (indices): [13]
  Distinct Colors: ['H'] (Count: 1)
  Total weight:    47 / 75
----------
Hold 9 (Internal Index 9):
  Containers (indices): [3]
  Distinct Colors: ['A'] (Count: 1)
  Total weight:    47 / 75
----------
Hold 10 (Internal Index 12):
  Containers (indices): [12]
  Distinct Colors: ['A'] (Count: 1)
  Total weight:    48 / 75
----------
Hold 11 (Internal Index 13):
  Containers (indices): [5]
  Distinct Colors: ['V'] (Count: 1)
  Total weight:    55 / 75
----------
Hold 12 (Internal Index 14):
  Containers (indices): [7, 20]
  Distinct Colors: ['T', 'U'] (Count: 2)
  Total weight:    68 / 75
----------
Hold 13 (Internal Index 15):
  Containers (indices): [19, 21]
  Distinct Colors: ['A', 'U'] (Count: 2)
  Total weight:    68 / 75
----------
Hold 14 (Internal Index 18):
  Containers (indices): [6]
  Distinct Colors: ['N'] (Count: 1)
  Total weight:    58 / 75
----------
Hold 15 (Internal Index 19):
  Containers (indices): [9]
  Distinct Colors: ['J'] (Count: 1)
  Total weight:    65 / 75
----------
Hold 16 (Internal Index 20):
  Containers (indices): [18]
  Distinct Colors: ['M'] (Count: 1)
  Total weight:    41 / 75
----------
Hold 17 (Internal Index 21):
  Containers (indices): [1, 11]
  Distinct Colors: ['Q', 'V'] (Count: 2)
  Total weight:    65 / 75
----------


```

================================================================================



--- Problem 160 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling 10 delivery trucks at 3 available depots, each with unique arrival times and processing requirements. Truck 1 arrives at 4:00, needing 8 hours to unload, while Truck 2 arrives at 6:00 with a 4-hour processing window. The remaining trucks follow similarly staggered schedules, with Truck 10 arriving at 28:00 and requiring 5 hours. The hub manager must assign each truck to exactly one depot, ensuring no two trucks scheduled at the same depot overlap in time. The primary goal is to minimize the total operational duration (makespan)—the time when the last truck departs—to maximize depot utilization and reduce congestion. The central question: What is the optimal depot assignment and scheduling sequence to achieve the shortest possible makespan while respecting arrival times and processing constraints?

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- `assign(i, j)`: Binary (0/1) indicating whether truck `i` is assigned to depot `j`.  
- `start_time(i)`: Continuous, non-negative variable for the start time of truck `i`.  
- `completion_time(i)`: Continuous, non-negative variable for the completion time of truck `i` (derived as `start_time(i) + processing_times[i]`).  
- `precedes(i, k, j)`: Binary (0/1) indicating if truck `i` precedes truck `k` at depot `j`.  
- `makespan`: Continuous variable representing the latest completion time across all trucks.  

**2. Parameters:**  
- `trucks`: 1 to 10.  
- `depots`: 1 to 3.  
- `arrival_times[i]`: Exact arrival times for each truck (e.g., Truck 1: 4, Truck 2: 6).  
- `processing_times[i]`: Processing durations (e.g., Truck 1: 8, Truck 2: 4).  
- `H = 200`: A sufficiently large constant ("Big M") for linearization.  

**3. Objective Function:**  
Minimize `makespan` (the latest completion time among all trucks).  

**4. Constraints:**  
- **Assignment:** Each truck `i` must be assigned to exactly one depot: `sum(assign(i, j) for j in depots) = 1`.  
- **Arrival Time:** Start time of truck `i` cannot precede its arrival: `start_time(i) >= arrival_times[i]`.  
- **Completion Time:** `completion_time(i) = start_time(i) + processing_times[i]`.  
- **Non-Overlapping:** For each depot `j`, if trucks `i` and `k` (`i < k`) are assigned to `j`, either `i` precedes `k` (`start_time(k) >= completion_time(i)`) or vice versa.  
- **Makespan Definition:** `makespan >= completion_time(i)` for all trucks `i`.  

---

**

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
depots = [1, 2, 3]
arrival_times = {1: 4, 2: 6, 3: 9, 4: 11, 5: 13, 6: 16, 7: 19, 8: 23, 9: 27, 10: 28}
processing_times = {1: 8, 2: 4, 3: 5, 4: 4, 5: 8, 6: 9, 7: 4, 8: 10, 9: 9, 10: 5}
H = 200 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")
        if m.SolCount > 0 and abs(m.ObjVal) < GRB.INFINITY :
             print(f"{m.ObjVal:.4f}")
        elif m.status != GRB.INFEASIBLE and m.status != GRB.UNBOUNDED:
             print("No feasible solution found.")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the assignment of trucks to depots and their start and completion times
if m.status == GRB.OPTIMAL:
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}, Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
70.0000
Truck 1 is assigned to Depot 1, Start Time: 4.0000, Completion Time: 12.0000
Truck 2 is assigned to Depot 1, Start Time: 12.0000, Completion Time: 16.0000
Truck 3 is assigned to Depot 1, Start Time: 20.0000, Completion Time: 25.0000
Truck 4 is assigned to Depot 1, Start Time: 16.0000, Completion Time: 20.0000
Truck 5 is assigned to Depot 1, Start Time: 39.0000, Completion Time: 47.0000
Truck 6 is assigned to Depot 1, Start Time: 47.0000, Completion Time: 56.0000
Truck 7 is assigned to Depot 1, Start Time: 25.0000, Completion Time: 29.0000
Truck 8 is assigned to Depot 1, Start Time: 29.0000, Completion Time: 39.0000
Truck 9 is assigned to Depot 1, Start Time: 61.0000, Completion Time: 70.0000
Truck 10 is assigned to Depot 1, Start Time: 56.0000, Completion Time: 61.0000


```

================================================================================



--- Problem 161 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A busy port terminal operates with limited berths, facing the daily challenge of efficiently serving a high volume of cargo ships. The terminal has **2 container berths**, each capable of servicing **10 container ships per hour**, and **1 bulk cargo berth**, handling **7 bulk cargo ships per hour**. Over a **15-hour operating window**, the terminal experiences a steady influx of **132 container ships and 24 bulk cargo ships per hour**. However, the berths’ service capacities and the actual ship demand create a bottleneck—while the terminal could theoretically serve all arriving ships, the berths’ throughput limits the number that can be serviced. The manager must determine the **maximum number of container and bulk cargo ships** that can be realistically served without exceeding either the berths’ capacity or the actual demand. The goal is to **maximize the total ships served** while respecting these constraints, ensuring optimal resource utilization without overpromising service.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `served_container`: Continuous variable representing the number of container ships served.  
   - `served_bulk`: Continuous variable representing the number of bulk cargo ships served.  

   **2. Parameters:**  
   - `num_container_berths = 2`: Number of container berths.  
   - `num_bulk_berths = 1`: Number of bulk cargo berths.  
   - `service_rate_container = 10`: Container ships served per berth per hour.  
   - `service_rate_bulk = 7`: Bulk cargo ships served per berth per hour.  
   - `arrival_rate_container = 132`: Container ships arriving per hour.  
   - `arrival_rate_bulk = 24`: Bulk cargo ships arriving per hour.  
   - `hours_open = 15`: Operating hours per day.  

   **3. Objective Function:**  
   Maximize the total ships served:  
   \[
   \text{Maximize: } \text{served\_container} + \text{served\_bulk}
   \]  

   **4. Constraints:**  
   - **Container berth capacity:**  
     \[
     \text{served\_container} \leq \text{num\_container\_berths} \times \text{service\_rate\_container} \times \text{hours\_open}
     \]  
   - **Bulk berth capacity:**  
     \[
     \text{served\_bulk} \leq \text{num\_bulk\_berths} \times \text{service\_rate\_bulk} \times \text{hours\_open}
     \]  
   - **Container demand limit:**  
     \[
     \text{served\_container} \leq \text{arrival\_rate\_container} \times \text{hours\_open}
     \]  
   - **Bulk demand limit:**  
     \[
     \text{served\_bulk} \leq \text{arrival\_rate\_bulk} \times \text{hours\_open}
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
num_container_berths = 2; num_bulk_berths = 1
service_rate_container = 10; service_rate_bulk = 7
arrival_rate_container = 132; arrival_rate_bulk = 24; hours_open = 15
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m5 = gp.Model("Port_Terminal_Berth_Allocation_LP", env=env)
    # Vars
    served_container = m5.addVar(name="served_container_ships", lb=0)
    served_bulk = m5.addVar(name="served_bulk_cargo_ships", lb=0)
    # Objective
    m5.setObjective(served_container + served_bulk, sense=GRB.MAXIMIZE)
    # Constraints
    m5.addConstr(served_container <= num_container_berths * service_rate_container * hours_open, "container_capacity")
    m5.addConstr(served_bulk <= num_bulk_berths * service_rate_bulk * hours_open, "bulk_capacity")
    m5.addConstr(served_container <= arrival_rate_container * hours_open, "container_demand")
    m5.addConstr(served_bulk <= arrival_rate_bulk * hours_open, "bulk_demand")
    # Optimize
    m5.optimize()
    # Store results
    results_dict['status'] = m5.status
    if m5.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m5.objVal
        results_dict['served_container_opt'] = served_container.X; results_dict['served_bulk_opt'] = served_bulk.X
    # Output Results
    print("--- Problem 5: Port Terminal Berth Allocation (LP) ---")
    if m5.status == GRB.OPTIMAL:
        sc = results_dict.get('served_container_opt', 0); sb = results_dict.get('served_bulk_opt', 0)
        demand_c = arrival_rate_container * hours_open; demand_b = arrival_rate_bulk * hours_open
        cap_c = num_container_berths * service_rate_container * hours_open; cap_b = num_bulk_berths * service_rate_bulk * hours_open
        print(f"Optimization Status: Optimal")
        print(f"Maximum container ships served in {hours_open} hours: {sc:.0f} (Demand: {demand_c}, Capacity: {cap_c})")
        print(f"Maximum bulk cargo ships served in {hours_open} hours: {sb:.0f} (Demand: {demand_b}, Capacity: {cap_b})")
        print(f"Total ships served: {m5.objVal:.0f}")
    else: print(f"Optimization Status: {m5.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_TERMINAL
```
Answer:
--- Problem 5: Port Terminal Berth Allocation (LP) ---
Optimization Status: Optimal
Maximum container ships served in 15 hours: 300 (Demand: 1980, Capacity: 300)
Maximum bulk cargo ships served in 15 hours: 105 (Demand: 360, Capacity: 105)
Total ships served: 405



================================================================================



--- Problem 162 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
A port manager is tasked with optimizing the berthing time for two ships at a busy port to minimize total waiting time. The port operates with a fixed cycle time of 80 minutes, and each ship must be allocated a berthing time between 34 and 80 minutes, ensuring smooth operations while adhering to the strict cycle constraint. The waiting time experienced by each ship is directly influenced by the non-berthing time—the portion of the cycle when the berth is not available for that ship. Higher traffic volumes, represented by flow coefficients of 272 and 2236 ship arrivals per hour for the two ships, amplify the impact of non-berthing time on overall waiting time. The challenge is to determine the optimal berthing time allocation for each ship that minimizes the cumulative waiting time across all ships, given these constraints.

**Modeling Process:**
- **1. Decision Variables:**  
     - Let \( t_i \) represent the berthing time (in minutes) allocated to ship \( i \), where \( i \in \{1, 2\} \).  
     - Each \( t_i \) is a continuous variable bounded between 34 and 80 minutes.  

   - **2. Parameters:**  
     - \( \text{flow_coeff}_i \): Traffic flow coefficient for ship \( i \) (272 for ship 1, 2236 for ship 2).  
     - \( \text{cycle_time} \): Total cycle time (80 minutes).  
     - \( \text{lb_time}, \text{ub_time} \): Lower and upper bounds for berthing times (34 and 80 minutes, respectively).  

   - **3. Objective Function:**  
     Minimize the total waiting time, calculated as:  
     \[
     \text{Minimize: } \sum_{i=1}^{2} \text{flow_coeff}_i \times (\text{cycle_time} - t_i)
     \]  

   - **4. Constraints:**  
     - The sum of berthing times must equal the cycle time:  
       \[
       t_1 + t_2 = 80
       \]  
     - Bounds on berthing times:  
       \[
       34 \leq t_i \leq 80 \quad \text{for } i \in \{1, 2\}
       \]  

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_ships = 2
lb_time = 34          # Lower bound for berthing time
ub_time = 80          # Upper bound for berthing time
cycle_time = 80   # Total cycle time (set equal to ub_time)
flow_coeffs = [272, 2236] # Traffic flow coefficients per ship
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_ships:
    print("Error: flow_coeffs length mismatch with num_ships")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_ships}-Ship Berthing Time", env=env)

        # --- Decision variables (dynamic based on num_ships) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_ships, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for ship i is proportional to flow * non-berthing_time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_ships)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_ships)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_ships)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_ships):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 88536.00
------------------------------
Optimal berthing times (minutes):
  t1: 34.00, t2: 46.00


```

================================================================================



--- Problem 163 ---
**Difficulty:** easy
**Category:** MIP

**Problem Description:**
A logistics company operates a single delivery truck (Truck 1) with a capacity of 47.45 units to serve a small network consisting of a depot (Node 0) and one customer location (Node 1). The customer has a demand of 29 units, which must be fulfilled without exceeding the truck's capacity. The travel distance between the depot and the customer is 39 units, forming a symmetric distance matrix where moving from Node 0 to Node 1 (or vice versa) incurs the same cost. The challenge is to determine the most efficient route for the truck—starting and ending at the depot—while ensuring the customer's demand is met and the total travel distance is minimized. The key question is: *What is the shortest possible route that delivers the required goods and returns to the depot without violating capacity constraints?*

**Modeling Process:**
- **1. Decision Variables:**  
     - Binary variable `x[i, j, k]`: Equals 1 if truck `k` travels directly from node `i` to node `j`; 0 otherwise.  
     - Continuous variable `u[i]`: Auxiliary variable for subtour elimination (MTZ constraint), ensuring node sequencing.  
   - **2. Parameters:**  
     - `N = 2`: Total nodes (depot: 0, customer: 1).  
     - `K = 1`: Number of trucks.  
     - `Q = [47.45]`: Truck capacity.  
     - `q = [0, 29]`: Demand at nodes (0 for depot, 29 for customer).  
     - `d[i][j]`: Distance matrix (e.g., `d[0][1] = 39`).  
   - **3. Objective Function:**  
     Minimize total distance:  
     \[
     \text{Minimize: } \sum_{k=0}^{K-1} \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} d[i][j] \cdot x[i, j, k] \quad \text{(for } i \neq j\text{)}
     \]  
   - **4. Constraints:**  
     - **Visit Once:** Customer (Node 1) must be visited exactly once.  
     - **Flow Conservation:** Inflow equals outflow for each node and truck.  
     - **Depot Departure/Return:** Truck must leave and return to the depot (Node 0).  
     - **Capacity:** Total demand on the route ≤ truck capacity (47.45).  
     - **Subtour Elimination (MTZ):** Prevents disjoint cycles (not triggered here as `N = 2`).

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 2
K = 1
Q = [47.45]
q = [0, 29]
d = [
    [0, 39],
    [39, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Truck Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for truck {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for truck {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 78.00

Route for truck 1 (Capacity: 47.45):
0 -> 1 -> 0
Route Load: 29 / 47.45


```

================================================================================



--- Problem 164 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy container terminal is facing the challenge of balancing operational costs against the continuous flow of incoming trucks. With 950 trucks arriving per hour, the terminal manager must decide how many of the 11 available truck unloading bays to open to handle this demand efficiently. Each open bay can process up to 119 trucks per hour, but comes with a fixed cost of $71 per hour. The goal is to minimize the total cost of operating the bays while ensuring the combined capacity of the open bays meets or exceeds the incoming truck demand. The stakes are high: opening too few bays risks congestion and delays, while opening too many inflates costs unnecessarily. The critical question is: *What is the minimum-cost combination of bays to open that can fully accommodate the arriving trucks?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[j]`: Binary variable for each bay `j` (where `j` ranges from 0 to 10).  
     - `x[j] = 1` if bay `j` is open, `0` otherwise.  

   **2. Parameters:**  
   - `num_bays = 11`: Total available truck unloading bays.  
   - `trucks_arriving = 950`: Trucks arriving per hour (demand).  
   - `bay_capacity = 119`: Maximum trucks a single bay can process per hour.  
   - `cost_per_bay = 71`: Cost ($) per hour to operate one bay.  

   **3. Objective Function:**  
   Minimize the total cost of opening bays:  
   \[
   \text{Minimize: } \sum_{j=0}^{10} (cost\_per\_bay \cdot x[j])
   \]  

   **4. Constraints:**  
   - **Capacity Requirement:** The total capacity of open bays must meet or exceed demand:  
     \[
     \sum_{j=0}^{10} (x[j] \cdot bay\_capacity) \geq trucks\_arriving
     \]  
   - **Binary Variables:** Each `x[j]` must be 0 or 1.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_bays = 11
trucks_arriving = 950
bay_capacity = 119
cost_per_bay = 71
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("TRUCK_BAY_OPENING", env=env)

    # --- Decision Variables ---
    # x[j] = 1 if bay j is open, 0 otherwise
    x = m.addVars(num_bays, vtype=GRB.BINARY, name="x")

    # --- Objective Function: Minimize total cost ---
    m.setObjective(gp.quicksum(cost_per_bay * x[j] for j in range(num_bays)), GRB.MINIMIZE)

    # --- Constraints ---
    # Total processing capacity must meet the demand
    m.addConstr(gp.quicksum(x[j] * bay_capacity for j in range(num_bays)) >= trucks_arriving, "CapacityConstraint")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status # Note: Status, not status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        results_dict['x_sol'] = m.getAttr('X', x) # Store variable values

    # --- Output Results ---
    print(f"--- TRUCK_BAY_OPENING Results ---")
    if m.Status == GRB.OPTIMAL:
        x_sol = results_dict.get('x_sol', {})
        open_bays = [j for j in range(num_bays) if x_sol.get(j, 0) > 0.5]
        num_open = len(open_bays)
        total_capacity_provided = num_open * bay_capacity

        print(f"Optimization Status: Optimal")
        print(f"Minimum Total Cost: {results_dict.get('obj_val', 'N/A'):.2f}")
        print(f"Number of Bays to Open: {num_open} / {num_bays}")
        # print(f"Indices of Open Bays: {open_bays}") # Optional: list indices
        print(f"Total Capacity Provided: {total_capacity_provided} trucks/hr")
        print(f"Trucks Arriving (Demand): {trucks_arriving} trucks/hr")
        print(f"Capacity per Bay: {bay_capacity}, Cost per Bay: {cost_per_bay}")

    elif m.Status == GRB.INFEASIBLE:
        print(f"Optimization Status: Infeasible")
        print(f"Demand ({trucks_arriving}) may exceed max possible capacity ({num_bays * bay_capacity}).")
    elif m.Status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m.ObjVal is not None and abs(m.ObjVal) < float('inf'):
              print(f"Best Objective Found: {m.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m.Status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- TRUCK_BAY_OPENING Results ---
Optimization Status: Optimal
Minimum Total Cost: 568.00
Number of Bays to Open: 8 / 11
Total Capacity Provided: 952 trucks/hr
Trucks Arriving (Demand): 950 trucks/hr
Capacity per Bay: 119, Cost per Bay: 71


```

================================================================================



--- Problem 165 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy trucking terminal, a critical scheduling challenge arises: four delivery trucks must be serviced at a single depot, each with strict arrival times, processing requirements, and deadlines. Truck 1 arrives at time 1, needing 5 hours to unload, and must depart by time 8 to avoid delays. Truck 2 arrives at time 6, requires 5 hours, and has a deadline of 17. Truck 3, arriving at 11, demands 8 hours of processing and must finish by 36, while Truck 4 arrives at 16, takes 7 hours, and faces a deadline of 33. The terminal manager’s goal is to sequence these trucks to minimize total tardiness—the cumulative time by which any truck misses its deadline. With only one depot available, the challenge is to orchestrate the schedule so that no two trucks overlap, all start after their arrival, and the sum of delays is as small as possible. The question is: What is the optimal unloading sequence that achieves this?
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign[i, j]`: Binary (1 if truck *i* is assigned to depot *j*, else 0).  
     - `start_time[i]`: Continuous (when truck *i* begins processing).  
     - `completion_time[i]`: Continuous (when truck *i* finishes).  
     - `precedes[i, k, j]`: Binary (1 if truck *i* is scheduled before truck *k* at depot *j*).  
     - `tardiness[i]`: Continuous (delay of truck *i* beyond its deadline).  

   - **2. Parameters:**  
     - `arrival_times[i]`: Truck arrival times (1, 6, 11, 16).  
     - `processing_times[i]`: Unloading durations (5, 5, 8, 7).  
     - `due_times[i]`: Deadlines (8, 17, 36, 33).  
     - `H`: Large constant (100) for precedence constraints.  

   - **3. Objective Function:**  
     Minimize total tardiness:  
     `Minimize: sum(tardiness[i] for all trucks i)`.  

   - **4. Constraints:**  
     - **Assignment:** Each truck must use the depot (`assign[i, j] = 1`).  
     - **Arrival:** Start time ≥ arrival time for each truck.  
     - **Completion:** `completion_time[i] = start_time[i] + processing_times[i]`.  
     - **Non-overlapping:** For truck pairs *(i, k)*, enforce `precedes[i, k, j]` or `precedes[k, i, j]` to prevent overlap.  
     - **Tardiness:** `tardiness[i] ≥ completion_time[i] - due_times[i]` (zero if early).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4]
depots = [1] # Should be [1]
arrival_times = {1: 1, 2: 6, 3: 11, 4: 16}
processing_times = {1: 5, 2: 5, 3: 8, 4: 7}
due_times = {1: 8, 2: 17, 3: 36, 4: 33}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_54_MIN_TARDINESS")

    if not trucks or not depots or len(depots)!=1: raise ValueError("Invalid trucks/depots")
    the_depot = depots[0]

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")
    tardiness = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="tardiness")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(tardiness[i] for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_depot] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping
    j = the_depot
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= 1, name=f"force_precedence_{i}_{k}_{j}")
                m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")
    # 5. Tardiness definition
    m.addConstrs((tardiness[i] >= completion_time[i] - due_times.get(i, 0) for i in trucks), name="tardiness_calc")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Unloading Sequence and Details:")
    for i in trucks:
        print(f"Truck {i}: Start Time = {start_time[i].x:.2f}, Completion Time = {completion_time[i].x:.2f}, Tardiness = {tardiness[i].x:.2f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
0.0000
Optimal Unloading Sequence and Details:
Truck 1: Start Time = 1.00, Completion Time = 6.00, Tardiness = 0.00
Truck 2: Start Time = 6.00, Completion Time = 11.00, Tardiness = 0.00
Truck 3: Start Time = 11.00, Completion Time = 19.00, Tardiness = 0.00
Truck 4: Start Time = 19.00, Completion Time = 26.00, Tardiness = 0.00


```

================================================================================



--- Problem 166 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
At a busy maritime port, the management is tasked with efficiently processing incoming ships—small and large vessels—while managing limited dock resources. With only 14 docks available, the goal is to maximize the total number of ships processed per hour. Each small ship dock requires 2 workers and can handle up to 21 small ships per hour, while each large ship dock demands 3 workers and processes a maximum of 17 large ships per hour. On this particular shift, 238 small ships and 85 large ships are expected to arrive. The critical question is: *How should workers be allocated between small and large ship docks to process as many ships as possible without exceeding worker availability or ship arrival counts?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y_small_ship`: Integer number of small ship docks to open.  
     - `y_large_ship`: Integer number of large ship docks to open.  
     - `z_small_ship`: Continuous number of small ships processed (≤ arrivals or capacity).  
     - `z_large_ship`: Continuous number of large ships processed (≤ arrivals or capacity).  

   - **2. Parameters:**  
     - `total_workers = 14` (available workers).  
     - `workers_per_small_ship_dock = 2`, `workers_per_large_ship_dock = 3` (workers per dock type).  
     - `capacity_small_ship_dock = 21`, `capacity_large_ship_dock = 17` (hourly throughput per dock).  
     - `arriving_small_ships = 238`, `arriving_large_ships = 85` (ship arrivals).  

   - **3. Objective Function:**  
     Maximize total ships processed:  
     `Maximize: z_small_ship + z_large_ship`.  

   - **4. Constraints:**  
     - Worker limit: `2*y_small_ship + 3*y_large_ship ≤ 14`.  
     - Capacity limits:  
       `z_small_ship ≤ 21*y_small_ship`, `z_large_ship ≤ 17*y_large_ship`.  
     - Arrival limits:  
       `z_small_ship ≤ 238`, `z_large_ship ≤ 85`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_workers = 14
workers_per_small_ship_dock = 2
workers_per_large_ship_dock = 3
capacity_small_ship_dock = 21 # ships per hour
capacity_large_ship_dock = 17 # ships per hour
arriving_small_ships = 238
arriving_large_ships = 85
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("MARITIME_PORT_ALLOC", env=env)

    # --- Decision Variables ---
    # y_small_ship: number of small ship docks to open
    y_small_ship = m.addVar(vtype=GRB.INTEGER, lb=0, name="y_small_ship")
    # y_large_ship: number of large ship docks to open
    y_large_ship = m.addVar(vtype=GRB.INTEGER, lb=0, name="y_large_ship")
    # z_small_ship: number of small ships processed
    z_small_ship = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="z_small_ship")
    # z_large_ship: number of large ships processed
    z_large_ship = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="z_large_ship")

    # --- Objective Function: Maximize total ships processed ---
    m.setObjective(z_small_ship + z_large_ship, GRB.MAXIMIZE)

    # --- Constraints ---
    # Worker availability constraint
    # Ensure worker counts are positive before adding constraint
    if workers_per_small_ship_dock > 0 and workers_per_large_ship_dock > 0:
        m.addConstr(workers_per_small_ship_dock * y_small_ship + workers_per_large_ship_dock * y_large_ship <= total_workers, "WorkerLimit")
    elif workers_per_small_ship_dock > 0:
         m.addConstr(workers_per_small_ship_dock * y_small_ship <= total_workers, "WorkerLimit")
    elif workers_per_large_ship_dock > 0:
         m.addConstr(workers_per_large_ship_dock * y_large_ship <= total_workers, "WorkerLimit")

    # Processed ships cannot exceed capacity
    m.addConstr(z_small_ship <= capacity_small_ship_dock * y_small_ship, "SmallShipCapacity")
    m.addConstr(z_large_ship <= capacity_large_ship_dock * y_large_ship, "LargeShipCapacity")

    # Processed ships cannot exceed arrivals
    m.addConstr(z_small_ship <= arriving_small_ships, "SmallShipArrivals")
    m.addConstr(z_large_ship <= arriving_large_ships, "LargeShipArrivals")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['y_small_ship_sol'] = y_small_ship.X # Not needed for output
        # results_dict['y_large_ship_sol'] = y_large_ship.X # Not needed for output
        # results_dict['z_small_ship_sol'] = z_small_ship.X # Not needed for output
        # results_dict['z_large_ship_sol'] = z_large_ship.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Objective is total ships, potentially float if z variables are float
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# --- Supplemental Code Block to Ensure All Key Outputs are Printed ---
if m.Status == GRB.OPTIMAL:
    print(f"Optimal objective value: {obj_val_print:.2f}")
    print(f"Number of small ship docks to open: {y_small_ship.X}")
    print(f"Number of large ship docks to open: {y_large_ship.X}")
    print(f"Number of small ships processed: {z_small_ship.X}")
    print(f"Number of large ships processed: {z_large_ship.X}")
```
Answer:
Optimal objective value: 147.00
Optimal objective value: 147.00
Number of small ship docks to open: 7.0
Number of large ship docks to open: -0.0
Number of small ships processed: 147.0
Number of large ships processed: 0.0


```

================================================================================



--- Problem 167 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy urban intersection, traffic engineers are tasked with optimizing signal timing to maximize vehicle throughput while adhering to strict operational constraints. The intersection handles two primary traffic flows: North-South (NS) with an hourly arrival rate of 750 vehicles and East-West (EW) with 480 vehicles. Each lane has a saturation flow rate of 1400 vehicles per hour, and the intersection operates with approximately 2.1 lanes. Lost time per signal phase—due to driver reaction and acceleration delays—amounts to 4.5 seconds. The signal cycle must stay within a tight window: no shorter than 70 seconds and no longer than 115 seconds, with each green phase lasting at least 19 seconds.

The core challenge is to allocate green time between the NS and EW directions to maximize total hourly capacity without violating cycle length or minimum green time rules. The solution must balance competing demands: longer green phases increase directional capacity but risk excessive cycle lengths, while shorter phases may bottleneck traffic. The engineers seek the optimal split—how many seconds should each direction receive to achieve the highest combined throughput?
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `C`: Cycle length (seconds), bounded between `C_min` and `C_max`.  
   - `g_NS`, `g_EW`: Green times (seconds) for NS and EW directions, each ≥ `g_min_time`.  
   - `lambda_g_NS`, `lambda_g_EW`: Fraction of cycle allocated to NS/EW green times (unitless, 0–1).  
   - `Cap_NS`, `Cap_EW`: Hourly capacities (vehicles/hour) for NS and EW flows.  

   **2. Parameters:**  
   - `lambda_NS_h`, `lambda_EW_h`: Hourly vehicle arrival rates (750, 480 veh/h).  
   - `S_fog_lane_h`: Saturation flow per lane (1400 veh/h/lane).  
   - `N_lanes`: Effective number of lanes (2.1).  
   - `L_lost_time_per_phase`: Lost time per phase (4.5 s).  
   - `C_min`, `C_max`: Cycle length bounds (70 s, 115 s).  
   - `g_min_time`: Minimum green time (19 s).  

   **3. Objective Function:**  
   Maximize total hourly throughput:  
   `Maximize: Cap_NS + Cap_EW`.  

   **4. Constraints:**  
   - Cycle composition: `C = g_NS + g_EW + 2 * L_lost_time_per_phase`.  
   - Green time fractions: `lambda_g_NS * C = g_NS`, `lambda_g_EW * C = g_EW`.  
   - Capacity calculations:  
     `Cap_NS = N_lanes * S_fog_lane_h * lambda_g_NS`,  
     `Cap_EW = N_lanes * S_fog_lane_h * lambda_g_EW`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
lambda_NS_h = 750  # veh/h
lambda_EW_h = 480  # veh/h
S_fog_lane_h = 1400  # veh/h/lane
N_lanes = 2.1
L_lost_time_per_phase = 4.5  # s
C_min = 70  # s
C_max = 115  # s
g_min_time = 19  # s

# --- Gurobi Model ---
model = gp.Model("SignalTiming")

# Decision Variables
C = model.addVar(name="CycleLength", lb=C_min, ub=C_max)
g_NS = model.addVar(name="Green_NS", lb=g_min_time)
g_EW = model.addVar(name="Green_EW", lb=g_min_time)

# Intermediate Variables
lambda_g_NS = model.addVar(name="lambda_g_NS", lb=0.0, ub=1.0)
lambda_g_EW = model.addVar(name="lambda_g_EW", lb=0.0, ub=1.0)
Cap_NS = model.addVar(name="Capacity_NS", lb=0.0)
Cap_EW = model.addVar(name="Capacity_EW", lb=0.0)

# Constraints
model.addConstr(C == g_NS + g_EW + 2 * L_lost_time_per_phase, name="CycleComposition")
model.addQConstr(lambda_g_NS * C == g_NS, name="CalcLambdaNS")
model.addQConstr(lambda_g_EW * C == g_EW, name="CalcLambdaEW")
model.addConstr(Cap_NS == N_lanes * S_fog_lane_h * lambda_g_NS, name="CalcCapacityNS")
model.addConstr(Cap_EW == N_lanes * S_fog_lane_h * lambda_g_EW, name="CalcCapacityEW")

# Objective
model.setObjective(Cap_NS + Cap_EW, GRB.MAXIMIZE)

# Optimize
model.Params.NonConvex = 2
model.optimize()

# Output
if model.status == GRB.OPTIMAL:
    print("\n--- Signal Timing Results ---")
    print(f"Optimal Cycle Length: {C.X:.2f} s")
    print(f"North-South Green Time: {g_NS.X:.2f} s")
    print(f"East-West Green Time: {g_EW.X:.2f} s")
    print(f"North-South Capacity: {Cap_NS.X:.2f} veh/h")
    print(f"East-West Capacity: {Cap_EW.X:.2f} veh/h")
    print(f"Total Throughput: {model.objVal:.2f} veh/h")
else:
    print(f"Model status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 3 rows, 7 columns and 7 nonzeros
Model fingerprint: 0x99b0c9ee
Model has 2 quadratic constraints
Coefficient statistics:
  Matrix range     [1e+00, 3e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [1e+00, 1e+02]
  RHS range        [9e+00, 9e+00]
Presolve removed 2 rows and 2 columns

Continuous model is non-convex -- solving as a MIP

Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolved: 9 rows, 6 columns, 27 nonzeros
Presolved model has 2 bilinear constraint(s)
Variable types: 6 continuous, 0 integer (0 binary)
Found heuristic solution: objective 2709.9130435

Root relaxation: objective 3.242087e+03, 3 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0 3242.08696    0    2 2709.91304 3242.08696  19.6%     -    0s
     0     0 3069.79160    0    2 2709.91304 3069.79160  13.3%     -    0s
     0     2 3069.79160    0    2 2709.91304 3069.79160  13.3%     -    0s

Explored 67 nodes (39 simplex iterations) in 0.02 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 2709.91 

Optimal solution found (tolerance 1.00e-04)
Best objective 2.709913043477e+03, best bound 2.709913043477e+03, gap 0.0000%

--- Signal Timing Results ---
Optimal Cycle Length: 115.00 s
North-South Green Time: 53.00 s
East-West Green Time: 53.00 s
North-South Capacity: 1354.96 veh/h
East-West Capacity: 1354.96 veh/h
Total Throughput: 2709.91 veh/h



================================================================================



--- Problem 168 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port authority faces the critical challenge of minimizing delays caused by two separate ship berthing incidents, labeled A and B, occurring at different times. Incident A occurs immediately at the start of operations (0 minutes), while Incident B occurs 19 minutes later. Two tugboats, T1 and T2, are available for dispatch, each with varying travel times to the incidents. For example, Tugboat T1 takes 22 minutes to reach Incident A and 26 minutes to reach Incident B, while Tugboat T2 takes 17 minutes to Incident A and 24 minutes to Incident B.

Once an incident is cleared, the port must account for the time it takes for the queue of waiting ships to dissipate. Each incident has a clearance time (58 minutes for A, 45 minutes for B) and distinct traffic flow characteristics. The normal capacity of Berth A is 3946 ships per hour (65.77 ships/min), while Berth B handles 3147 ships per hour (52.45 ships/min). During incidents, these capacities drop to 2053 ships/hr (34.22 ships/min) for A and 1674 ships/hr (27.90 ships/min) for B. Meanwhile, ships continue arriving at rates of 2405 ships/hr (40.08 ships/min) for A and 2092 ships/hr (34.87 ships/min) for B, leading to queue formation if not managed efficiently.

The core optimization challenge is determining the optimal assignment and sequencing of tugboats to incidents to minimize the total delay experienced by ships. This involves calculating the delay caused by queue buildup before clearance begins, during clearance, and the additional time for queues to dissipate afterward. The port authority must ensure that each incident is assigned exactly one tugboat (either directly or after servicing another incident) while respecting travel and clearance times.

**Key Question:** What is the optimal dispatch sequence for the two tugboats to minimize the total traffic delay across both incidents?  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- Binary `assign_first(k, i)`: 1 if tugboat `k` is assigned directly to incident `i` as its first task, else 0.  
- Binary `sequence(k, j, i)`: 1 if tugboat `k` serves incident `i` immediately after incident `j`, else 0.  
- Continuous `start_clear(i)`: Time when clearance begins at incident `i`.  
- Continuous `end_clear(i)`: Time when clearance ends at incident `i`.  
- Auxiliary variables for queue calculations (`queue_at_start_clear(i)`, `queue_at_clear_end(i)`, `dissipation_time(i)`, etc.).

**2. Parameters:**  
- `time_occur[i]`: Incident occurrence time (A: 0, B: 19).  
- `travel_time_base(k, i)`: Tugboat `k`’s travel time to incident `i` (e.g., T1→A: 22).  
- `travel_time_inter(j, i)`: Travel time between incidents (e.g., A→B: 16).  
- `clearance_time[i]`: Time to clear incident `i` (A: 58, B: 45).  
- Traffic flow rates (`cap_normal`, `cap_reduced`, `arrival_rate`).  
- `growth_rate_before[i]`: Queue growth rate before clearance (arrival_rate - cap_reduced).  
- `dissipation_rate[i]`: Queue dissipation rate after clearance (cap_normal - arrival_rate).

**3. Objective Function:**  
Minimize total delay, computed as:  
- **Delay before clearance**:  
  `0.5 * growth_rate_before[i] * (start_clear[i] - time_occur[i])^2`  
- **Delay during clearance**:  
  `0.5 * (queue_at_start_clear[i] + queue_at_clear_end[i]) * clearance_time[i]`  
- **Delay after clearance (if dissipating)**:  
  `0.5 * (queue_at_clear_end[i]^2) / dissipation_rate[i]`  
- **Penalty for non-dissipating queues**:  
  `10000 * queue_at_clear_end[i]` (if dissipation_rate ≤ 0).

**4. Constraints:**  
- **Assignment**: Each incident must be assigned to exactly one tugboat (directly or after another incident).  
- **Tugboat logic**: A tugboat can be assigned to at most one first incident.  
- **Sequence logic**: If a tugboat serves incident `i` after `j`, it must have served `j` first.  
- **Timing**: Start times must account for travel and prior tasks.  
- **Queue dynamics**: Queue sizes are calculated based on growth and dissipation rates.  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
incidents = ['A', 'B']
tugboats = ['T1', 'T2']

# Times in minutes from simulation start
time_occur = {'A': 0, 'B': 19}
travel_time_base = {('T1', 'A'): 22, ('T1', 'B'): 26, ('T2', 'A'): 17, ('T2', 'B'): 24}
travel_time_inter = {('A', 'B'): 16, ('B', 'A'): 19, ('A', 'A'): 0, ('B', 'B'): 0}
clearance_time = {'A': 58, 'B': 45}

# Capacities and Arrival rates (ships per minute)
cap_normal = {'A': 3946/60, 'B': 3147/60} # ships/min
cap_reduced = {'A': 2053/60, 'B': 1674/60} # ships/min
arrival_rate = {'A': 2405/60, 'B': 2092/60} # ships/min

M = 10000
EPSILON = 1e-6

# Pre-calculate rates
growth_rate_before = {}
dissipation_rate = {}
can_dissipate = {}
inv_dissipation_rate = {}
non_dissipating_penalty = 10000

for i in incidents:
    growth_rate_before[i] = max(0, arrival_rate[i] - cap_reduced[i])
    dissipation_rate[i] = cap_normal[i] - arrival_rate[i]
    can_dissipate[i] = dissipation_rate[i] > EPSILON
    if not can_dissipate[i]:
        inv_dissipation_rate[i] = 0
    else:
        inv_dissipation_rate[i] = 1.0 / dissipation_rate[i]

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("IncidentResourceAllocation", env=env)

# --- Decision Variables ---
assign_first = m.addVars(tugboats, incidents, vtype=GRB.BINARY, name="assign_first")
sequence = m.addVars(tugboats, incidents, incidents, vtype=GRB.BINARY, name="sequence")

# Timing variables
start_clear = m.addVars(incidents, name="start_clear", lb=0.0)
end_clear = m.addVars(incidents, name="end_clear", lb=0.0)

# Queue and Delay related variables
queue_start_clear_time_diff = m.addVars(incidents, name="queue_start_clear_time_diff", lb=0.0)
queue_at_start_clear = m.addVars(incidents, name="queue_at_start_clear", lb=0.0)
aux_q_start = m.addVars(incidents, name="aux_q_start", lb=-GRB.INFINITY)
queue_at_clear_end = m.addVars(incidents, name="queue_at_clear_end", lb=0.0)
aux_q_end = m.addVars(incidents, name="aux_q_end", lb=-GRB.INFINITY)
dissipation_time = m.addVars(incidents, name="dissipation_time", lb=0.0)

# --- Constraints ---
for i in incidents:
    m.addConstr(gp.quicksum(assign_first[k, i] for k in tugboats) +
                gp.quicksum(sequence[k, j, i] for k in tugboats for j in incidents if i != j) == 1,
                name="AssignIncident_{0}".format(i))

for k in tugboats:
    m.addConstr(gp.quicksum(assign_first[k, i] for i in incidents) <= 1, name="TugboatStart_{0}".format(k))

for k in tugboats:
    for i in incidents:
        tugboat_served_i = assign_first[k, i] + gp.quicksum(sequence[k, l, i] for l in incidents if l != i)
        m.addConstr(gp.quicksum(sequence[k, i, j] for j in incidents if i != j) <= tugboat_served_i,
                    name="SequenceLogic_{0}_{1}".format(k, i))
        m.addConstr(sequence[k,i,i] == 0, name="NoSelfLoop_{0}_{1}".format(k, i))
        for j in incidents:
             if i != j:
                  m.addConstr(sequence[k,i,j] + sequence[k,j,i] <= 1, name="NoImmediateLoop_{0}_{1}_{2}".format(k, i, j))

for k in tugboats:
    for i in incidents:
        m.addConstr(start_clear[i] >= time_occur[i] + travel_time_base[k, i] - M * (1 - assign_first[k, i]),
                    name="StartTimeFirst_{0}_{1}".format(k, i))
        for j in incidents:
            if i != j:
                m.addConstr(start_clear[i] >= end_clear[j] + travel_time_inter[j, i] - M * (1 - sequence[k, j, i]),
                            name="StartTimeFollow_{0}_{1}_{2}".format(k, j, i))

for i in incidents:
    m.addConstr(end_clear[i] == start_clear[i] + clearance_time[i], name="EndClearTime_{0}".format(i))
    m.addConstr(start_clear[i] >= time_occur[i], name="StartAfterOccur_{0}".format(i))

for i in incidents:
    m.addConstr(queue_start_clear_time_diff[i] >= start_clear[i] - time_occur[i], name="CalcTimeDiff_{0}".format(i))
    m.addConstr(aux_q_start[i] == growth_rate_before[i] * queue_start_clear_time_diff[i], name="CalcAuxQStart_{0}".format(i))
    m.addGenConstrMax(queue_at_start_clear[i], [aux_q_start[i]], 0.0, name="SetQStartMax_{0}".format(i))
    queue_growth_during_clearance = growth_rate_before[i] * clearance_time[i]
    m.addConstr(aux_q_end[i] == queue_at_start_clear[i] + queue_growth_during_clearance, name="CalcAuxQEnd_{0}".format(i))
    m.addGenConstrMax(queue_at_clear_end[i], [aux_q_end[i]], 0.0, name="SetQEndMax_{0}".format(i))
    if can_dissipate[i]:
         m.addConstr(dissipation_time[i] == queue_at_clear_end[i] * inv_dissipation_rate[i], name="CalcDissipationTime_{0}".format(i))
    else:
         m.addConstr(dissipation_time[i] == 0, name="SetDissipationTimeZero_{0}".format(i))

# --- Objective Function ---
objective = gp.QuadExpr()
for i in incidents:
    delay_before = 0.5 * growth_rate_before[i] * queue_start_clear_time_diff[i] * queue_start_clear_time_diff[i]
    objective += delay_before
    delay_during = 0.5 * (queue_at_start_clear[i] + queue_at_clear_end[i]) * clearance_time[i]
    objective += delay_during
    if can_dissipate[i]:
        delay_dissipation = 0.5 * inv_dissipation_rate[i] * queue_at_clear_end[i] * queue_at_clear_end[i]
        objective += delay_dissipation
    else:
        objective += non_dissipating_penalty * queue_at_clear_end[i]

m.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("{0:.2f}".format(m.objVal))
elif m.status == GRB.INFEASIBLE:
    print("Infeasible")
elif m.status == GRB.UNBOUNDED:
    print("Unbounded")
```
Answer:
44785.68



================================================================================



--- Problem 169 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A maritime company operates a ship that must visit multiple ports in a single tour before returning to its starting point. The ship starts and ends at a central port (node 0) and must visit three additional ports (nodes 1, 2, and 3) exactly once. The travel times between each pair of nodes are asymmetric, meaning the time from port A to port B may differ from the time from port B to port A. For instance, traveling from node 0 to node 1 takes 28 minutes, while the reverse trip takes the same time. However, the trip from node 0 to node 2 takes 13 minutes, but returning from node 2 to node 0 also takes 13 minutes. The challenge is to determine the most efficient route that minimizes the total travel time while ensuring the ship visits every port exactly once and returns to the central port.  

   The operational constraints are strict: the ship must leave each port exactly once (no revisits) and must enter each port exactly once (no skips). Additionally, to prevent subtours—smaller loops that don’t cover all nodes—the model uses Miller-Tucker-Zemlin (MTZ) constraints. These constraints enforce a logical ordering of visits, ensuring the route forms a single continuous loop. The key question is: *What is the fastest possible route for the ship to deliver to all ports and return to the central port?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x(i, j)`: Binary variable indicating whether the ship travels directly from port `i` to port `j` (1 if yes, 0 otherwise).  
   - `u(i)`: Continuous variable representing the order in which port `i` is visited (used for subtour elimination).  

   **2. Parameters:**  
   - `dist(i, j)`: Travel time (in minutes) between ports `i` and `j`. Example values: `dist(0, 1) = 28`, `dist(2, 3) = 9`.  
   - `num_ports = 4`: Total number of ports (including the central port).  

   **3. Objective Function:**  
   Minimize the total travel time:  
   `Minimize: sum(x(i, j) * dist(i, j) for all valid (i, j) where i ≠ j)`.  

   **4. Constraints:**  
   - **Leave each port once:** For each port `i`, `sum(x(i, j) for all j ≠ i) = 1`.  
   - **Enter each port once:** For each port `i`, `sum(x(j, i) for all j ≠ i) = 1`.  
   - **MTZ subtour elimination:** For all `i ≠ j` (excluding the central port), `u(i) - u(j) + num_ports * x(i, j) ≤ num_ports - 1`.  
   - **Variable bounds:** `x(i, j)` binary; `u(i) ≥ 0` (with `u(0) = 0` implicitly).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import itertools; import math
# Params
num_ports = 4; ports = [0, 1, 2, 3]; dist = {(0, 1): 28, (0, 2): 13, (0, 3): 12, (1, 0): 28, (1, 2): 9, (1, 3): 18, (2, 0): 13, (2, 1): 9, (2, 3): 9, (3, 0): 12, (3, 1): 18, (3, 2): 9}
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m17 = gp.Model("Ship_Port_TSP_MIP", env=env)
    # Check if dist keys are valid tuples
    valid_keys = [(i,j) for i in ports for j in ports if i != j]
    # Vars
    x = m17.addVars(valid_keys, vtype=GRB.BINARY, name="travel") # Use valid_keys
    u = m17.addVars(ports, vtype=GRB.CONTINUOUS, name="order", lb=0.0)
    # Objective
    m17.setObjective(gp.quicksum(x[i, j] * dist.get((i,j), 9999) for i, j in valid_keys), sense=GRB.MINIMIZE) # Use .get
    # Constraints
    m17.addConstrs((gp.quicksum(x[i, j] for j in ports if i != j) == 1 for i in ports), name="leave_port")
    m17.addConstrs((gp.quicksum(x[j, i] for j in ports if i != j) == 1 for i in ports), name="enter_port")
    # MTZ Subtour Elimination
    for i in ports:
        for j in ports:
            if i != j and i != 0 and j != 0 and (i,j) in valid_keys: # Check key exists
                 m17.addConstr(u[i] - u[j] + num_ports * x[i, j] <= num_ports - 1, name=f"MTZ_{i}_{j}")
    # Optimize
    m17.optimize()
    # Store results
    results_dict['status'] = m17.status
    if m17.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m17.objVal; results_dict['x_sol'] = m17.getAttr('X', x)
    # Output Results
    print("--- Problem 17: Multi-Stop Ship Port Routing (TSP Variation) (MIP) ---")
    if m17.status == GRB.OPTIMAL:
        print(f"Optimization Status: Optimal"); print(f"Minimum Total Travel Time: {m17.objVal:.1f} minutes"); print("Optimal Route:")
        x_sol = results_dict.get('x_sol', {})
        current_port = 0; route = [0]; visited_count=0
        while len(route) < num_ports and visited_count < num_ports + 2:
            next_port = -1
            for j in ports:
                if current_port != j and x_sol.get((current_port, j), 0) > 0.5: next_port = j; break
            if next_port != -1: route.append(next_port); current_port = next_port
            else: break # No next port found
            visited_count += 1
        if current_port != 0: route.append(0) # Add return if not already there
        if len(route) == num_ports + 1: print(f"  {' -> '.join(map(str, route))}")
        else: print(f"  Error: Could not reconstruct full route. Found: {' -> '.join(map(str, route))}")
    else: print(f"Optimization Status: {m17.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of SHIP_PORT_TSP
```
Answer:
--- Problem 17: Multi-Stop Ship Port Routing (TSP Variation) (MIP) ---
Optimization Status: Optimal
Minimum Total Travel Time: 52.0 minutes
Optimal Route:
  0 -> 2 -> 1 -> 3 -> 0



================================================================================



--- Problem 170 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port with three critical berths is experiencing recurring delays due to varying ship arrival rates and limited berth capacities. Port managers must dynamically allocate ships to alternative berths during these high-traffic periods to minimize total delay. Each berth has distinct characteristics: normal and reduced capacities (e.g., Berth 1 handles 4,841 TEUs/hour normally but drops to 3,139 TEUs/hour during peak times), alternative berth capacities (e.g., 1,216 TEUs/hour for Berth 1), and varying arrival rates across four 30-minute time periods (e.g., Berth 1 sees 4,602 TEUs/hour in Period 1). Allocation options (10%, 30%, 50%, or 70% of traffic) incur delays from extra travel time on alternatives or queuing on the main berth if demand exceeds reduced capacity. The challenge is to assign the optimal allocation ratio to each berth and time period, balancing alternative berth congestion and main berth queues, while avoiding infeasible flows that would overwhelm either berth.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Binary variable \( y(i, t, k) \) equals 1 if Berth \( i \) in Period \( t \) uses Allocation Option \( k \) (else 0).  
   - **2. Parameters:**  
     - \( \text{arrival_rates}[i][t] \): TEUs/hour arriving at Berth \( i \) in Period \( t \).  
     - \( \text{capacities_main_normal}[i], \text{capacities_main_reduced}[i] \): Normal/reduced main berth capacities (TEUs/h).  
     - \( \text{capacities_alt}[i] \): Alternative berth capacity (TEUs/h).  
     - \( \text{alt_berth_extra_times}[i] \): Additional travel time (hours) for alternative berths.  
     - \( \text{allocation_options}[k] \): Fraction of traffic allocated (e.g., 0.1 for 10%).  
     - Precomputed \( \text{berth_period_option_delays}[i][t][k] \): Total delay (TEU-hours) for choosing Option \( k \) in Berth \( i \), Period \( t \).  
   - **3. Objective Function:**  
     Minimize total delay:  
     \( \text{Minimize: } \sum_{i,t,k} y(i,t,k) \cdot \text{berth_period_option_delays}[i][t][k] \).  
   - **4. Constraints:**  
     - **Feasibility:** For each Berth \( i \) and Period \( t \), exactly one feasible allocation option must be selected.  
     - **Infeasibility Enforcement:** \( y(i,t,k) = 0 \) if Option \( k \) exceeds alternative berth capacity or causes unbounded main berth queuing.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 3
NUM_TIME_PERIODS = 4
TIME_PERIOD_LENGTH = 0.5  # h
capacities_main_normal = [4841, 3051, 4153]  # TEUs/h
capacities_main_reduced = [3139, 1946, 2589]  # TEUs/h
capacities_alt = [1216, 951, 1654]  # TEUs/h
arrival_rates = [[4602, 3596, 2706, 2796], [4693, 3179, 3487, 4553], [4324, 4658, 4037, 2378]]  # TEUs/h
peak_durations = [1.5791411162722158, 1.0785418676618976, 1.9520627881456512]  # h
alt_berth_extra_times = [0.290842799649716, 0.11998092983912602, 0.3218355512646276]  # h
allocation_options = [0.1, 0.3, 0.5, 0.7]  # Available allocation ratios
num_options = len(allocation_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = allocation_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_AllocationStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Allocation Strategy:")
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, allocation_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Allocation Strategy:

Berth 1:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)

Berth 2:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)

Berth 3:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 0 (10%)



================================================================================



--- Problem 171 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A busy truck depot operates with a limited number of loading docks, each dedicated to either small or large trucks. The depot manager faces the challenge of maximizing the number of trucks served during an 8-hour operational window, given the constraints of dock capacity and customer demand.

The depot has 2 docks for small trucks, each capable of servicing 15 trucks per hour, and 2 docks for large trucks, each handling 10 trucks per hour. During peak hours, the arrival rates are 120 small trucks and 40 large trucks per hour. The manager must determine how many trucks of each type can realistically be served without exceeding the docks' operational limits or the actual customer demand.

The core question is: *What is the maximum total number of small and large trucks the depot can serve in 8 hours, given the dock capacities and arrival rates?* The solution must balance the depot's service capabilities against the fluctuating but predictable demand.
**

**Modeling Process:**
**
**1. Decision Variables:**
- `served_small`: Number of small trucks served (continuous, ≥ 0).
- `served_large`: Number of large trucks served (continuous, ≥ 0).

**2. Parameters:**
- `num_small_docks = 2`: Number of small truck docks.
- `num_large_docks = 2`: Number of large truck docks.
- `service_rate_small = 15`: Small trucks served per dock per hour.
- `service_rate_large = 10`: Large trucks served per dock per hour.
- `arrival_rate_small = 120`: Small truck arrivals per hour.
- `arrival_rate_large = 40`: Large truck arrivals per hour.
- `hours_open = 8`: Operational hours.

**3. Objective Function:**
- Maximize the total trucks served:  
  `Maximize: served_small + served_large`.

**4. Constraints:**
- **Small truck dock capacity**:  
  `served_small ≤ num_small_docks * service_rate_small * hours_open`.
- **Large truck dock capacity**:  
  `served_large ≤ num_large_docks * service_rate_large * hours_open`.
- **Small truck demand**:  
  `served_small ≤ arrival_rate_small * hours_open`.
- **Large truck demand**:  
  `served_large ≤ arrival_rate_large * hours_open`.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
num_small_docks = 2; num_large_docks = 2
service_rate_small = 15; service_rate_large = 10
arrival_rate_small = 120; arrival_rate_large = 40; hours_open = 8
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m5 = gp.Model("Truck_Depot_Dock_Allocation_LP", env=env)
    # Vars
    served_small = m5.addVar(name="served_small_trucks", lb=0)
    served_large = m5.addVar(name="served_large_trucks", lb=0)
    # Objective
    m5.setObjective(served_small + served_large, sense=GRB.MAXIMIZE)
    # Constraints
    m5.addConstr(served_small <= num_small_docks * service_rate_small * hours_open, "small_capacity")
    m5.addConstr(served_large <= num_large_docks * service_rate_large * hours_open, "large_capacity")
    m5.addConstr(served_small <= arrival_rate_small * hours_open, "small_demand")
    m5.addConstr(served_large <= arrival_rate_large * hours_open, "large_demand")
    # Optimize
    m5.optimize()
    # Store results
    results_dict['status'] = m5.status
    if m5.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m5.objVal
        results_dict['served_small_opt'] = served_small.X; results_dict['served_large_opt'] = served_large.X
    # Output Results
    print("--- Problem 5: Truck Depot Dock Allocation (LP) ---")
    if m5.status == GRB.OPTIMAL:
        ss = results_dict.get('served_small_opt', 0); sl = results_dict.get('served_large_opt', 0)
        demand_s = arrival_rate_small * hours_open; demand_l = arrival_rate_large * hours_open
        cap_s = num_small_docks * service_rate_small * hours_open; cap_l = num_large_docks * service_rate_large * hours_open
        print(f"Optimization Status: Optimal")
        print(f"Maximum small trucks served in {hours_open} hours: {ss:.0f} (Demand: {demand_s}, Capacity: {cap_s})")
        print(f"Maximum large trucks served in {hours_open} hours: {sl:.0f} (Demand: {demand_l}, Capacity: {cap_l})")
        print(f"Total trucks served: {m5.objVal:.0f}")
    else: print(f"Optimization Status: {m5.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of TRUCK_DEPOT
```
Answer:
--- Problem 5: Truck Depot Dock Allocation (LP) ---
Optimization Status: Optimal
Maximum small trucks served in 8 hours: 240 (Demand: 960, Capacity: 240)
Maximum large trucks served in 8 hours: 160 (Demand: 320, Capacity: 160)
Total trucks served: 400



================================================================================



--- Problem 172 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy trucking depot, eight trucks arrive at varying times, each requiring a loading dock for unloading and processing. The depot has only two docks available, creating a complex scheduling challenge. Trucks 6 and 8 require additional security checks, adding 0.9 hours to their base processing times. The arrival times range from Truck 1 at 4 hours to Truck 8 at 25 hours, with processing times varying from 4 to 8 hours (plus security delays where applicable). The depot manager must assign each truck to a dock and schedule their start times to ensure no overlaps, while minimizing the total time taken to process all trucks (the *makespan*). The core question is: **What is the optimal dock assignment and scheduling sequence to complete all operations as quickly as possible?**
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to dock *j*, else 0).  
   - `start_time(i)`: Continuous variable for when truck *i* begins processing.  
   - `completion_time(i)`: Continuous variable for when truck *i* finishes.  
   - `precedes(i, k, j)`: Binary variable (1 if truck *i* is scheduled before truck *k* on dock *j*).  
   - `makespan`: Continuous variable representing the latest completion time across all trucks.  

   **2. Parameters:**  
   - `trucks`: [1, 2, ..., 8].  
   - `docks`: [1, 2].  
   - `arrival_times`: {1:4, 2:7, ..., 8:25}.  
   - `processing_times`: Base times plus 0.9 for trucks 6 and 8 (e.g., {1:7, 6:6.9, ...}).  
   - `H=100`: A large constant for linearization.  

   **3. Objective Function:**  
   Minimize `makespan` (latest completion time).  

   **4. Constraints:**  
   - Each truck assigned to exactly one dock: `sum(assign(i, j) for all j) = 1` for all *i*.  
   - Start time ≥ arrival time: `start_time(i) ≥ arrival_times(i)` for all *i*.  
   - Completion time definition: `completion_time(i) = start_time(i) + processing_times(i)`.  
   - Non-overlapping on docks: If `precedes(i, k, j) = 1`, then `start_time(k) ≥ completion_time(i)`.  
   - Makespan bounds: `makespan ≥ completion_time(i)` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7, 8]
docks = [1, 2]
arrival_times = {1: 4, 2: 7, 3: 12, 4: 14, 5: 15, 6: 19, 7: 22, 8: 25}
base_processing_times = {1: 7, 2: 6, 3: 5, 4: 5, 5: 8, 6: 6, 7: 4, 8: 7}
type_X_trucks = [6, 8] # Trucks needing security check
security_check_time = 0.9
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Data Prep ---
    processing_times = {}
    for i in trucks:
        if i in type_X_trucks:
            processing_times[i] = base_processing_times.get(i, 0) + security_check_time
        else:
            processing_times[i] = base_processing_times.get(i, 0)

    # --- Model Creation ---
    m = gp.Model("DOCKING_PROBLEM_38_SECURITY_CHECK")

    if not trucks or not docks: raise ValueError("Empty trucks or docks")

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (using effective processing time)
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in docks:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in docks:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Dock {j}")
                print(f"  Start Time: {start_time[i].x:.4f}")
                print(f"  Completion Time: {completion_time[i].x:.4f}")
    print(f"Total Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
53.8000
Optimal Solution Found:
Truck 1 is assigned to Dock 2
  Start Time: 4.0000
  Completion Time: 11.0000
Truck 2 is assigned to Dock 2
  Start Time: 11.0000
  Completion Time: 17.0000
Truck 3 is assigned to Dock 2
  Start Time: 17.0000
  Completion Time: 22.0000
Truck 4 is assigned to Dock 2
  Start Time: 22.0000
  Completion Time: 27.0000
Truck 5 is assigned to Dock 2
  Start Time: 27.0000
  Completion Time: 35.0000
Truck 6 is assigned to Dock 2
  Start Time: 35.0000
  Completion Time: 41.9000
Truck 7 is assigned to Dock 2
  Start Time: 41.9000
  Completion Time: 45.9000
Truck 8 is assigned to Dock 2
  Start Time: 45.9000
  Completion Time: 53.8000
Total Makespan: 53.8000


```

================================================================================



--- Problem 173 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
In a busy port, a maritime logistics manager is tasked with efficiently assigning 13 irregularly shaped containers to standardized berths to minimize the use of space and reduce operational costs. Each container has unique dimensions, ranging from small (2x18 units) to large (81x40 units), and must be placed within berths measuring 83x91 units without overlapping. The manager must determine the optimal arrangement—assigning each container to a berth, positioning it precisely, and ensuring no two containers in the same berth collide—while using as few berths as possible. The stakes are high: inefficient packing could lead to wasted space, increased handling expenses, and delayed ship departures. The core question is: *What is the minimal number of berths required to pack all containers, and where should each container be placed within those berths to avoid overlap?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[i, j]`: Binary variable indicating if container *i* is assigned to berth *j*.  
     - `y[j]`: Binary variable indicating if berth *j* is used.  
     - `px[i, j]`, `py[i, j]`: Continuous variables for the bottom-left coordinates of container *i* in berth *j*.  
     - `left[i, k, j]`, `right[i, k, j]`, `below[i, k, j]`, `above[i, k, j]`: Binary variables enforcing non-overlapping conditions for containers *i* and *k* in berth *j*.  

   - **2. Parameters:**  
     - `containers`: List of container dimensions (e.g., (75, 25) for container 0).  
     - `berth_size`: (83, 91) units.  
     - `num_containers = 13`, `num_berths = 13` (worst-case upper bound).  
     - Big-M values: `M_w = 83`, `M_h = 91` (berth dimensions).  

   - **3. Objective Function:**  
     Minimize the total number of berths used:  
     \[
     \text{Minimize: } \sum_{j} y[j]
     \]  

   - **4. Constraints:**  
     - **Assignment:** Each container *i* must be in exactly one berth:  
       \[
       \sum_{j} x[i, j] = 1 \quad \forall i
       \]  
     - **Berth Boundaries:** Container *i* in berth *j* must fit within the berth:  
       \[
       px[i, j] + \text{container}_i\text{ width} \leq 83 + 83(1 - x[i, j]) \quad \forall i, j
       \]  
       (Analogous for height.)  
     - **Non-Overlapping:** For containers *i* and *k* in the same berth *j*, enforce at least one spatial relation (left/right/below/above):  
       \[
       \text{left}[i, k, j] + \text{right}[i, k, j] + \text{below}[i, k, j] + \text{above}[i, k, j] \geq x[i, j] + x[k, j] - 1 \quad \forall i < k, j
       \]  
     - **Berth Activation:** Berth *j* is used if any container is assigned to it:  
       \[
       x[i, j] \leq y[j] \quad \forall i, j
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
containers = [(75, 25), (2, 34), (66, 67), (12, 51), (24, 16), (81, 40), (25, 58), (45, 48), (2, 18), (80, 57), (79, 85), (77, 70), (10, 42)]  # (width, height) of containers
berth_size = (83, 91)  # (width, height) of each berth
num_containers = 13 # len(containers)
# Maximum berths needed (worst case: one container per berth)
# Can sometimes be reduced with lower bounds, but num_containers is safe
num_berths = num_containers
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using berth dimensions is common and valid)
M_w = berth_size[0]
M_h = berth_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Berth Packing", env=env)

# --- Decision Variables ---
# x[i,j]: container i assigned to berth j
x = model.addVars(num_containers, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of container i if in berth j
px = model.addVars(num_containers, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_containers, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of containers *within the same berth*
left  = model.addVars(num_containers, num_containers, num_berths, vtype=GRB.BINARY, name="left")
right = model.addVars(num_containers, num_containers, num_berths, vtype=GRB.BINARY, name="right")
below = model.addVars(num_containers, num_containers, num_berths, vtype=GRB.BINARY, name="below")
above = model.addVars(num_containers, num_containers, num_berths, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_berths))

# --- Constraints ---

# 1. Each container must be assigned to exactly one berth
for i in range(num_containers):
    model.addConstr(x.sum(i, '*') == 1, name=f"Container_{i}_Assignment")

# 2. Container placement constraints within berth boundaries (Big-M formulation)
for j in range(num_berths):
    for i in range(num_containers):
        container_w, container_h = containers[i] # Get dimensions for container i

        # Position variables must be 0 if container i is not in berth j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Container's right edge <= berth width IF container is placed in berth (x[i,j]=1)
        model.addConstr(px[i, j] + container_w <= berth_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Container's top edge <= berth height IF container is placed in berth (x[i,j]=1)
        model.addConstr(py[i, j] + container_h <= berth_size[1] + M_h * (1 - x[i, j]), name=f"Height_Limit_{i}_{j}")

# 3. Non-overlapping constraints for containers within the same berth
for j in range(num_berths):
    for i in range(num_containers):
        for k in range(i + 1, num_containers): # Iterate over distinct pairs (i < k)
            container_i_w, container_i_h = containers[i]
            container_k_w, container_k_h = containers[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => container i is to the left of container k
            model.addConstr(px[i, j] + container_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => container i is to the right of container k (k is left of i)
            model.addConstr(px[k, j] + container_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => container i is below container k
            model.addConstr(py[i, j] + container_i_h <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => container i is above container k (k is below i)
            model.addConstr(py[k, j] + container_k_h <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH container i and container k are in berth j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link container assignment to berth usage: If any container i is in berth j, then berth j must be used (y[j]=1)
#    This can be done per container or aggregated. Per container is often tighter.
for j in range(num_berths):
    for i in range(num_containers):
        model.addConstr(x[i, j] <= y[j], name=f"Container_Berth_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_containers * y[j], name=f"Berth_Activation_{j}")


# --- Solve ---
print("Solving 2DBP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of berths used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    berth_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_berths):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Berth {j_sol + 1} (Used):")
            containers_in_berth_info = []
            for i_sol in range(num_containers):
                if x[i_sol, j_sol].X > 0.5:
                    container_data = {
                        "id": i_sol,
                        "dims": containers[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    containers_in_berth_info.append(container_data)
                    print(f"  Container {container_data['id']} {container_data['dims']} at {container_data['pos']}")
            berth_details.append({'berth_index': j_sol, 'containers': containers_in_berth_info})
            print("-" * 10)
    results_dict['berth_details'] = berth_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 2DBP instance...
Gurobi Error code 10010: Model too large for size-limited license; visit https://gurobi.com/unrestricted for more information

Optimization finished with status: -1. No optimal solution found.


```

================================================================================



--- Problem 174 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
A busy container terminal is facing the challenge of balancing operational costs against the need to efficiently process incoming trucks. With 161 trucks arriving per hour and each gate capable of handling up to 102 trucks hourly, the terminal manager must decide how many of the 9 available gates to open to meet demand while minimizing costs. Each gate opened incurs a fixed cost of $29, whether it operates at full capacity or not. The core dilemma is determining the minimal number of gates to activate—ensuring the combined capacity covers the incoming traffic—without overspending on unnecessary infrastructure. The question is: *What is the cheapest way to open enough gates to handle the hourly truck influx?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[j]`: Binary variable for each gate `j` (where `j = 0, 1, ..., 8`), where `x[j] = 1` if gate `j` is open, and `0` otherwise.  
   - **2. Parameters:**  
     - `num_gates = 9`: Total available gates.  
     - `trucks_arriving = 161`: Hourly demand (trucks/hr).  
     - `gate_capacity = 102`: Maximum trucks a single gate can process per hour.  
     - `cost_per_gate = 29`: Fixed cost ($) to open one gate.  
   - **3. Objective Function:**  
     - Minimize the total cost:  
       $$\text{Minimize: } \sum_{j=0}^{8} (29 \cdot x[j])$$  
   - **4. Constraints:**  
     - **Capacity requirement:** The total open gates’ capacity must meet or exceed demand:  
       $$\sum_{j=0}^{8} (102 \cdot x[j]) \geq 161$$  
     - **Binary variables:** Each `x[j]` must be 0 or 1.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_gates = 9
trucks_arriving = 161
gate_capacity = 102
cost_per_gate = 29
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("GATE_OPENING", env=env)

    # --- Decision Variables ---
    # x[j] = 1 if gate j is open, 0 otherwise
    x = m.addVars(num_gates, vtype=GRB.BINARY, name="x")

    # --- Objective Function: Minimize total cost ---
    m.setObjective(gp.quicksum(cost_per_gate * x[j] for j in range(num_gates)), GRB.MINIMIZE)

    # --- Constraints ---
    # Total processing capacity must meet the demand
    m.addConstr(gp.quicksum(x[j] * gate_capacity for j in range(num_gates)) >= trucks_arriving, "CapacityConstraint")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status # Note: Status, not status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        results_dict['x_sol'] = m.getAttr('X', x) # Store variable values

    # --- Output Results ---
    print(f"--- GATE_OPENING Results ---")
    if m.Status == GRB.OPTIMAL:
        x_sol = results_dict.get('x_sol', {})
        open_gates = [j for j in range(num_gates) if x_sol.get(j, 0) > 0.5]
        num_open = len(open_gates)
        total_capacity_provided = num_open * gate_capacity

        print(f"Optimization Status: Optimal")
        print(f"Minimum Total Cost: {results_dict.get('obj_val', 'N/A'):.2f}")
        print(f"Number of Gates to Open: {num_open} / {num_gates}")
        # print(f"Indices of Open Gates: {open_gates}") # Optional: list indices
        print(f"Total Capacity Provided: {total_capacity_provided} trucks/hr")
        print(f"Trucks Arriving (Demand): {trucks_arriving} trucks/hr")
        print(f"Capacity per Gate: {gate_capacity}, Cost per Gate: {cost_per_gate}")

    elif m.Status == GRB.INFEASIBLE:
        print(f"Optimization Status: Infeasible")
        print(f"Demand ({trucks_arriving}) may exceed max possible capacity ({num_gates * gate_capacity}).")
    elif m.Status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m.ObjVal is not None and abs(m.ObjVal) < float('inf'):
              print(f"Best Objective Found: {m.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m.Status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- GATE_OPENING Results ---
Optimization Status: Optimal
Minimum Total Cost: 58.00
Number of Gates to Open: 2 / 9
Total Capacity Provided: 204 trucks/hr
Trucks Arriving (Demand): 161 trucks/hr
Capacity per Gate: 102, Cost per Gate: 29


```

================================================================================



--- Problem 175 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port faces the daily challenge of maximizing revenue while balancing two distinct customer segments: container ships and bulk carriers. The port has a finite capacity of 310 berthing spots, which can be utilized for a total of 2,852 spot-hours over a 9.2-hour operating period. Container ship reservations, priced at $30 per vessel, typically occupy a spot for 4.4 hours, while bulk carriers, paying $36 per vessel, stay for an average of 4.0 hours. The port must accommodate at least 27 container ship reservations due to contractual obligations, but demand for container ship berthing could reach up to 120 vessels. Meanwhile, bulk carrier demand peaks at 214 vessels. The port manager must strategically allocate berths between these two segments to maximize daily revenue without exceeding the total spot-hour capacity or violating demand constraints. The core question is: How many container ship reservations and bulk carriers should the port accept to achieve the highest possible daily revenue while adhering to all operational limits?
**

**Modeling Process:**
**
**1. Decision Variables:**
- `x_container`: Integer number of container ship reservations to accept (≥ 0).
- `x_bulk`: Integer number of bulk carriers to accept (≥ 0).

**2. Parameters:**
- `total_spots = 310`: Total physical berthing spots available.
- `op_hours = 9.2`: Operating hours per day.
- `total_spot_hours = 2852.0`: Total spot-hour capacity (spots × hours).
- `container_price = 30`: Revenue per container ship reservation ($).
- `container_stay = 4.4`: Average duration of container ship berthing (hours).
- `container_max_demand = 120`: Maximum potential container ship reservations.
- `container_min_required = 27`: Minimum required container ship reservations.
- `bulk_revenue_per_vessel = 36.00`: Revenue per bulk carrier ($).
- `bulk_stay = 4.0`: Average duration of bulk carrier berthing (hours).
- `bulk_max_demand = 214`: Maximum potential bulk carriers.

**3. Objective Function:**
Maximize total daily revenue:  
`Maximize: container_price * x_container + bulk_revenue_per_vessel * x_bulk`.

**4. Constraints:**
- Spot-hour capacity: `x_container * container_stay + x_bulk * bulk_stay ≤ total_spot_hours`.
- Container ship demand upper bound: `x_container ≤ container_max_demand`.
- Container ship minimum requirement: `x_container ≥ container_min_required`.
- Bulk carrier demand upper bound: `x_bulk ≤ bulk_max_demand`.
- Physical spot limit (container): `x_container ≤ total_spots`.
- Non-negativity and integer: `x_container, x_bulk ≥ 0 and integer`.

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_spots = 310
op_hours = 9.2
total_spot_hours = 2852.0
container_price = 30
container_stay = 4.4
container_max_demand = 120
container_min_required = 27
bulk_rate = 9
bulk_stay = 4.0
bulk_revenue_per_vessel = 36.00
bulk_max_demand = 214
# --- End Parameters ---

GUROBI_TIME_LIMIT = 45

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m27 = gp.Model("PORT_REVENUE_MGT_MIP", env=env)

    # --- Decision Variables ---
    # Integer: Number of container ship reservations and bulk carriers accepted
    x_container = m27.addVar(vtype=GRB.INTEGER, name="num_container_reservations", lb=0)
    x_bulk = m27.addVar(vtype=GRB.INTEGER, name="num_bulk_carriers", lb=0)

    # --- Objective Function ---
    # Maximize total daily revenue
    m27.setObjective(container_price * x_container + bulk_revenue_per_vessel * x_bulk, sense=GRB.MAXIMIZE)

    # --- Constraints ---
    # Constraint 1: Total spot-hour usage capacity
    m27.addConstr(x_container * container_stay + x_bulk * bulk_stay <= total_spot_hours, name="spot_hour_capacity")

    # Constraint 2: Container ship demand upper bound
    m27.addConstr(x_container <= container_max_demand, name="container_demand_max")

    # Constraint 3: Container ship minimum requirement
    m27.addConstr(x_container >= container_min_required, name="container_demand_min")

    # Constraint 4: Bulk carrier demand upper bound
    m27.addConstr(x_bulk <= bulk_max_demand, name="bulk_demand_max")

    # Constraint 5: Physical spot limit (optional, but good check)
    m27.addConstr(x_container <= total_spots, name="container_spot_limit")
    # Physical limit for bulk is trickier, rely on spot hours

    # --- Optimization ---
    m27.optimize()

    # --- Store results ---
    results_dict['status'] = m27.status
    if m27.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m27.ObjVal
        results_dict['x_container_sol'] = x_container.X
        results_dict['x_bulk_sol'] = x_bulk.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- PORT_REVENUE_MGT: Port Revenue Management (MIP) ---")
    if m27.status == GRB.OPTIMAL:
        opt_container = int(round(results_dict.get('x_container_sol', 0))) # Round and convert to int
        opt_bulk = int(round(results_dict.get('x_bulk_sol', 0)))
        spot_hours_used = opt_container * container_stay + opt_bulk * bulk_stay
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Maximum Total Daily Revenue: ${obj_val_print:.2f}")
        print(f"Optimal number of Container Ship Reservations: {opt_container} (Demand: {container_min_required}-{container_max_demand})")
        print(f"Optimal number of Bulk Carriers: {opt_bulk} (Demand: {bulk_max_demand})")
        print(f"Total Spot-Hours Used: {spot_hours_used:.1f} / {total_spot_hours:.1f}")
        # Calculate breakdown based on optimal integer values
        revenue_container = opt_container * container_price
        revenue_bulk = opt_bulk * bulk_revenue_per_vessel
        print(f"Revenue Breakdown: Container=${revenue_container:.2f}, Bulk=${revenue_bulk:.2f}")

    elif m27.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible.")
         print(f"Check constraints: Min Container Required ({container_min_required}) vs Max Demand ({container_max_demand}), Spot Hours ({total_spot_hours:.1f}), Spots ({total_spots}).")
         print(f"Min container requires {container_min_required * container_stay:.1f} spot-hours.")

    elif m27.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         # Try to get objective if available (MIPs might have feasible before timeout)
         if m27.ObjVal is not None and abs(m27.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m27.ObjVal:.2f} (Solution may be suboptimal or non-integer)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m27.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- PORT_REVENUE_MGT: Port Revenue Management (MIP) ---
Optimization Status: Optimal
Maximum Total Daily Revenue: $11304.00
Optimal number of Container Ship Reservations: 120 (Demand: 27-120)
Optimal number of Bulk Carriers: 214 (Demand: 214)
Total Spot-Hours Used: 1384.0 / 2852.0
Revenue Breakdown: Container=$3600.00, Bulk=$7704.00


```

================================================================================



--- Problem 176 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A fleet of nine delivery trucks (T1 through T9) arrives at a distribution center equipped with two distinct loading docks. Dock 1 can handle 26.5 tons per hour, while Dock 2 operates at a faster rate of 57.7 tons per hour. Each truck has a specific cargo load (ranging from 22 tons for T3 to 76 tons for T8), and the loading duration for each truck-dock combination is precomputed based on these loads and dock handling rates. For instance, T1 takes approximately 2.19 hours at Dock 1 but only 1.01 hours at Dock 2 due to the latter’s higher capacity.

The center manager faces a tactical challenge: assign each truck to exactly one dock such that the **total loading time across all trucks is minimized**. This optimization is critical to reduce idle time, maximize dock utilization, and ensure the fleet is ready for its next delivery as quickly as possible. The question is: *What is the optimal assignment of trucks to docks to achieve the shortest cumulative loading time?*  

---

**

Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable \( x(t, d) \) equals 1 if truck \( t \) (e.g., T1, T2) is assigned to dock \( d \) (1 or 2), and 0 otherwise.  

   - **2. Parameters:**  
     - \( \text{load_duration}(t, d) \): Precomputed time (hours) for truck \( t \) at dock \( d \) (e.g., 2.1887 for T1 at Dock 1).  
     - Trucks: T1–T9; Docks: {1, 2}.  

   - **3. Objective Function:**  
     - Minimize the sum of loading times:  
       \[
       \text{Minimize: } \sum_{t \in \text{trucks}} \sum_{d \in \text{docks}} x(t, d) \cdot \text{load_duration}(t, d)
       \]  

   - **4. Constraints:**  
     - Each truck must be assigned to exactly one dock:  
       \[
       \sum_{d \in \text{docks}} x(t, d) = 1 \quad \forall t \in \text{trucks}
       \]  

---

**

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError, tupledict; import sys; import traceback; import math

# --- Parameters ---
trucks = ['T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9']
docks = [1, 2]
cargo_tons = {'T1': 58, 'T2': 39, 'T3': 22, 'T4': 54, 'T5': 34, 'T6': 54, 'T7': 52, 'T8': 76, 'T9': 31} # For context
capacity_tons_per_hour = {1: 26.5, 2: 57.7}     # For context
# Calculated load durations (truck, dock): duration_in_hours
load_duration = {('T1', 1): 2.188679245283019, ('T1', 2): 1.0051993067590987, ('T2', 1): 1.471698113207547, ('T2', 2): 0.6759098786828422, ('T3', 1): 0.8301886792452831, ('T3', 2): 0.38128249566724437, ('T4', 1): 2.0377358490566038, ('T4', 2): 0.9358752166377816, ('T5', 1): 1.2830188679245282, ('T5', 2): 0.5892547660311959, ('T6', 1): 2.0377358490566038, ('T6', 2): 0.9358752166377816, ('T7', 1): 1.9622641509433962, ('T7', 2): 0.901213171577123, ('T8', 1): 2.8679245283018866, ('T8', 2): 1.317157712305026, ('T9', 1): 1.169811320754717, ('T9', 2): 0.537261698440208}
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("TRUCK_LOADING_ASSIGN_SUM_Sum", env=env)

    # --- Input Validation ---
    if not trucks or not docks: raise ValueError("Empty trucks or docks list")
    if any(t == float('inf') for t in load_duration.values()):
         print("Warning: Some dock has zero capacity or invalid duration.")

    # --- Decision Variables ---
    # x[i, j] = 1 if truck i is assigned to dock j
    # Use tupledict for easier handling of potentially invalid pairs
    assign_keys = tupledict({(t, d): 1 for t, d in load_duration if load_duration[t,d] != float('inf')})
    if not assign_keys: raise ValueError("No valid truck-dock assignments possible.")
    x = m.addVars(assign_keys.keys(), vtype=GRB.BINARY, name="x")

    # --- Objective Function: Minimize the sum of loading times ---
    # Use tupledict prod method
    m.setObjective(x.prod(load_duration), GRB.MINIMIZE)

    # --- Constraints ---
    # Each truck must be assigned to exactly one dock
    # Use tupledict sum method
    for t in trucks:
        m.addConstr(x.sum(t, '*') == 1, f"TruckAssignment_{t}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is sum of durations in hours
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show more precision
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.") # Matches example
    else: # Other statuses
        print("No optimal solution found.") # Matches example

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code to print the optimal assignment of trucks to docks
if m.Status == GRB.OPTIMAL:
    for t in trucks:
        for d in docks:
            if x[t, d].X > 0.5:  # If the variable is 1 (or close to 1 due to numerical precision)
                print(f"Truck {t} is assigned to Dock {d}")
```
Answer:
Optimal objective value: 7.2790
Truck T1 is assigned to Dock 2
Truck T2 is assigned to Dock 2
Truck T3 is assigned to Dock 2
Truck T4 is assigned to Dock 2
Truck T5 is assigned to Dock 2
Truck T6 is assigned to Dock 2
Truck T7 is assigned to Dock 2
Truck T8 is assigned to Dock 2
Truck T9 is assigned to Dock 2


```

================================================================================



--- Problem 177 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A fleet of five delivery trucks—T1, T2, T3, T4, and T5—arrives at a logistics depot equipped with two distinct loading docks: Dock 1 and Dock 2. Each dock has different loading rates: Dock 1 operates at 27.0 units per hour, while Dock 2 provides a faster 53.3 units per hour. The trucks have varying cargo demands: T1 requires 24 units, T2 needs 72 units, T3 demands 77 units, T4 has a smaller requirement of 33 units, and T5 must load 55 units. The loading durations for each truck-dock combination are precomputed based on these demands and loading rates. For instance, T1 takes approximately 0.89 hours on Dock 1 but only 0.45 hours on Dock 2, highlighting the trade-off between dock speed and assignment efficiency.  

The depot manager faces the challenge of assigning each truck to exactly one dock to minimize the total loading time across the fleet. This optimization ensures efficient use of resources, reducing idle time and maximizing throughput. The core question is: *How should the trucks be assigned to the docks to achieve the shortest possible cumulative loading time for the entire fleet?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( x_{t,d} \) be a binary variable where:  
       \( x_{t,d} = 1 \) if truck \( t \) is assigned to dock \( d \), and \( 0 \) otherwise.  
       Here, \( t \in \{T1, T2, T3, T4, T5\} \) and \( d \in \{1, 2\} \).  

   - **2. Parameters:**  
     - \( \text{load\_duration}_{t,d} \): Precomputed time (in hours) for truck \( t \) to load on dock \( d \).  
       Example: \( \text{load\_duration}_{T1,1} = 0.8889 \), \( \text{load\_duration}_{T1,2} = 0.4503 \).  

   - **3. Objective Function:**  
     - Minimize the total loading time:  
       \( \text{Minimize: } \sum_{t, d} x_{t,d} \cdot \text{load\_duration}_{t,d} \).  

   - **4. Constraints:**  
     - Each truck must be assigned to exactly one dock:  
       \( \sum_{d} x_{t,d} = 1 \) for all \( t \).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError, tupledict; import sys; import traceback; import math

# --- Parameters ---
trucks = ['T1', 'T2', 'T3', 'T4', 'T5']
docks = [1, 2]
demand_units = {'T1': 24, 'T2': 72, 'T3': 77, 'T4': 33, 'T5': 55} # For context
rate_units_per_hour = {1: 27.0, 2: 53.3}     # For context
# Calculated load durations (truck, dock): duration_in_hours
load_duration = {('T1', 1): 0.8888888888888888, ('T1', 2): 0.45028142589118203, ('T2', 1): 2.6666666666666665, ('T2', 2): 1.350844277673546, ('T3', 1): 2.8518518518518516, ('T3', 2): 1.4446529080675423, ('T4', 1): 1.2222222222222223, ('T4', 2): 0.6191369606003753, ('T5', 1): 2.037037037037037, ('T5', 2): 1.0318949343339587}
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("TRUCK_LOADING_ASSIGN_SUM_Sum", env=env)

    # --- Input Validation ---
    if not trucks or not docks: raise ValueError("Empty trucks or docks list")
    if any(t == float('inf') for t in load_duration.values()):
         print("Warning: Some dock has zero rate or invalid duration.")

    # --- Decision Variables ---
    # x[i, j] = 1 if truck i is assigned to dock j
    # Use tupledict for easier handling of potentially invalid pairs
    assign_keys = tupledict({(t, d): 1 for t, d in load_duration if load_duration[t,d] != float('inf')})
    if not assign_keys: raise ValueError("No valid truck-dock assignments possible.")
    x = m.addVars(assign_keys.keys(), vtype=GRB.BINARY, name="x")

    # --- Objective Function: Minimize the sum of loading times ---
    # Use tupledict prod method
    m.setObjective(x.prod(load_duration), GRB.MINIMIZE)

    # --- Constraints ---
    # Each truck must be assigned to exactly one dock
    # Use tupledict sum method
    for t in trucks:
        m.addConstr(x.sum(t, '*') == 1, f"TruckAssignment_{t}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is sum of durations in hours
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show more precision
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.") # Matches example
    else: # Other statuses
        print("No optimal solution found.") # Matches example

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code to print the assignment of trucks to docks
if m.Status == GRB.OPTIMAL:
    for t in trucks:
        for d in docks:
            if x[t, d].X > 0.5:
                print(f"Truck {t} is assigned to Dock {d}")
```
Answer:
Optimal objective value: 4.8968
Truck T1 is assigned to Dock 2
Truck T2 is assigned to Dock 2
Truck T3 is assigned to Dock 2
Truck T4 is assigned to Dock 2
Truck T5 is assigned to Dock 2


```

================================================================================



--- Problem 178 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port terminal is experiencing significant delays in the berthing of ships, leading to increased waiting times and operational inefficiencies. The terminal operates with three distinct berths, each handling a specific flow of ships with varying arrival rates. Port managers need to allocate berthing times to these berths within a fixed 39-hour cycle, ensuring the total berthing time across all berths matches the cycle duration. Each berth must adhere to strict operational bounds: no less than 8 hours and no more than 39 hours of berthing time. The delay experienced by ships in each berth is directly tied to the non-berthing time (cycle time minus berthing time) and the ship arrival rate, which quantifies the volume of ships. For this terminal, the arrival rates are 935, 1660, and 1830 for berths 1, 2, and 3, respectively. The core question is: *How should the 39-hour cycle be divided among the three berths to minimize the total delay experienced by all ships?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Let \( t_i \) represent the berthing time (in hours) allocated to berth \( i \), where \( i \in \{1, 2, 3\} \). Each \( t_i \) is a continuous variable bounded between 8 and 39 hours.  
   - **2. Parameters:**  
     - \( \text{arrival_rates} = [935, 1660, 1830] \): Ship arrival rates for each berth.  
     - \( \text{cycle_time} = 39 \): Total fixed cycle time (hours).  
     - \( \text{lb_time} = 8 \), \( \text{ub_time} = 39 \): Lower and upper bounds for berthing times.  
   - **3. Objective Function:**  
     Minimize the total delay:  
     \[
     \text{Minimize: } \sum_{i=1}^{3} \text{arrival_rates}_i \times (\text{cycle_time} - t_i)
     \]  
   - **4. Constraints:**  
     - The sum of berthing times must equal the cycle time:  
       \[
       t_1 + t_2 + t_3 = 39
       \]  
     - Bounds on berthing times:  
       \[
       8 \leq t_i \leq 39 \quad \text{for } i \in \{1, 2, 3\}
       \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_berths = 3
lb_time = 8          # Lower bound for berthing time
ub_time = 39          # Upper bound for berthing time
cycle_time = 39   # Total cycle time (set equal to ub_time)
arrival_rates = [935, 1660, 1830] # Ship arrival rates per berth
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_rates) != num_berths:
    print("Error: arrival_rates length mismatch with num_berths")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_rates length"
    # raise ValueError("arrival_rates length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_berths}-Berth Berthing Time Allocation", env=env)

        # --- Decision variables (dynamic based on num_berths) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_berths, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for berth i is proportional to arrival_rate * non-berthing_time = arrival_rate * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_rates[i] * (cycle_time - t_vars[i]) for i in range(num_berths)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_berths)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_berths)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_berths):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total delay: 109725.00
------------------------------
Optimal berthing times (hours):
  t1: 8.00, t2: 8.00, t3: 23.00


```

================================================================================



--- Problem 179 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port with three critical berths is experiencing recurring disruptions, each reducing the capacity of the affected berths. Port managers must dynamically divert ships to alternative berths during these disruptions to minimize total delay. Each berth has distinct characteristics: normal and reduced capacities (e.g., Berth 1 handles 3,857 TEU/h normally but drops to 1,589 TEU/h during disruptions), alternative berth capacities (1,486–1,321 TEU/h), and disruption durations (0.78–1.30 hours). Ships diverted to alternatives face extra handling times (0.19–0.32 hours), while queues form if berth demand exceeds reduced capacity. Over four 30-minute periods, arrival rates fluctuate (e.g., Berth 3 peaks at 4,611 TEU/h in Period 3). Managers can choose from four diversion ratios (10%, 30%, 50%, or 70%) per berth and period, but must ensure alternative flows do not exceed capacities. The challenge: *What diversion strategy minimizes total delay across all berths and time periods while respecting these constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Binary variables `y(i,t,k)` indicate whether diversion option `k` (0–3) is selected for berth `i` (0–2) in time period `t` (0–3).  
   - **2. Parameters:**  
     - `capacities_main_normal[i]`, `capacities_main_reduced[i]`: Main berth capacities (TEU/h).  
     - `capacities_alt[i]`: Alternative berth capacities (TEU/h).  
     - `arrival_rates[i][t]`: Demand (TEU/h) for berth `i`, period `t`.  
     - `diversion_options[k]`: Available ratios (0.1, 0.3, 0.5, 0.7).  
     - `berth_period_option_delays[i][t][k]`: Precomputed delay for choosing option `k` (sum of alternative berth delay and main berth queue delay).  
   - **3. Objective Function:**  
     Minimize total delay:  
     `Minimize: sum(y(i,t,k) * berth_period_option_delays[i][t][k] for all i,t,k where feasible)`.  
   - **4. Constraints:**  
     - **Feasibility:** For each berth `i` and period `t`, exactly one feasible diversion option must be selected (`sum(y(i,t,k) for feasible k) = 1`).  
     - **Infeasibility:** Force `y(i,t,k) = 0` if option `k` exceeds alternative capacity.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 3
NUM_TIME_PERIODS = 4
TIME_PERIOD_LENGTH = 0.5  # h
capacities_main_normal = [3857, 5174, 3043]  # TEU/h
capacities_main_reduced = [1589, 2656, 1009]  # TEU/h
capacities_alt = [1486, 1420, 1321]  # TEU/h
arrival_rates = [[2812, 2918, 3488, 4501], [2331, 2259, 2758, 3767], [4041, 4079, 4611, 2778]]  # TEU/h
disruption_durations = [0.7782812763560937, 1.3015835000938047, 1.2636845509267447]  # h
alt_berth_extra_times = [0.3040559222296962, 0.31857166817321964, 0.19038186520694667]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:

Berth 1:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)

Berth 2:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 1 (30%)

Berth 3:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 1 (30%)



================================================================================



--- Problem 180 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port management team faces a sudden closure of one of the three berths due to an unexpected maintenance issue, reducing the main berthing capacity from three berths to two. The incident lasts exactly one hour, divided into four 15-minute periods. During each period, ships arrive at fluctuating rates: 2,132 ships/hour in period 1, escalating to 5,137 ships/hour by period 4. An alternative berth exists, but it adds 23 minutes (0.383 hours) to the berthing time and can handle up to 1,410 ships/hour. The team must dynamically reroute ships to minimize total delay, balancing between queue buildup on the main berths and the extra time penalty of using the alternative. Post-incident, traffic returns to a normal flow of 3,342 ships/hour, and the team must account for whether the remaining queue can dissipate efficiently given the restored capacity of 5,655 ships/hour (three berths at 1,885 ships/berth). The core challenge: *What is the optimal rerouting strategy across the four periods to minimize total delay, including both queueing delays during the incident and potential post-incident dissipation time?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `flow_alt[t]`: Ships rerouted to the alternative berth in period `t` (continuous, ≥0).  
     - `flow_main[t]`: Ships remaining on the main berths in period `t` (derived from flow conservation).  
     - `queue_length[t]`: Queue length (ships) at the end of period `t` (continuous, ≥0).  

   - **2. Parameters:**  
     - `arrival_rates[t]`: Ship arrival rates (2,132; 2,932; 3,836; 5,137 ships/hour).  
     - `capacity_main_reduced`: Main berths capacity during incident (2 berths × 1,885 = 3,770 ships/hour).  
     - `alt_berth_capacity`: Alternative berth capacity (1,410 ships/hour).  
     - `alt_berth_extra_time`: Delay per ship on alternative berth (0.383 hours).  
     - `dt`: Time period duration (0.25 hours).  

   - **3. Objective Function:**  
     Minimize total delay, combining:  
     - **Main berths delay**: Sum of trapezoidal areas under queue-length curves for each period (`0.5 × dt × Σ(queue[t-1] + queue[t])`).  
     - **Alternative berth delay**: `Σ(flow_alt[t] × dt × alt_berth_extra_time)`.  
     - **Post-incident dissipation penalty**: If the queue can dissipate (arrival_rate_post < capacity_main_normal), use `0.5 × (queue_at_clearance² / dissipation_rate)`; else, penalize residual queue with a large factor (1,000).  

   - **4. Constraints:**  
     - Flow conservation: `flow_main[t] + flow_alt[t] = arrival_rates[t]` for all `t`.  
     - Alternative berth capacity: `flow_alt[t] ≤ 1,410` for all `t`.  
     - Queue dynamics: `queue_length[t] = max(0, queue[t-1] + (flow_main[t] - 3,770) × dt)`.  
     - Post-incident dissipation: If applicable, `queue_at_clearance = (capacity_main_normal - arrival_rate_post) × dissipation_time`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
num_periods = 4
dt = 0.25 # h (15 minutes)
incident_duration_total = num_periods * dt # Should be 1.0 h
arrival_rates = {1: 2132, 2: 2932, 3: 3836, 4: 5137} # ships/h per period
arrival_rate_post = 3342 # ships/h after incident
capacity_per_berth = 1885
num_berths_normal = 3
num_berths_reduced = 2
alt_berth_capacity = 1410
alt_berth_extra_time = 0.38333333333333336 # h

capacity_main_reduced = num_berths_reduced * capacity_per_berth
capacity_main_normal = num_berths_normal * capacity_per_berth

periods = range(1, num_periods + 1) # Periods 1, 2, 3, 4

# --- Gurobi Model Setup ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.setParam('TimeLimit', 30)
env.start()
m = gp.Model("DynamicBerthRerouting_Silent", env=env)

# --- Decision Variables ---
flow_alt = m.addVars(periods, name="flow_alt", lb=0.0)

# --- Intermediate Variables ---
flow_main = m.addVars(periods, name="flow_main", lb=0.0)
queue_length = m.addVars(range(num_periods + 1), name="queue", lb=0.0)
queue_unconstrained = m.addVars(periods, name="queue_unconstrained", lb=-GRB.INFINITY)
delay_alt_total = m.addVar(name="delay_alt_total", lb=0.0)
queue_at_clearance = m.addVar(name="queue_at_clearance", lb=0.0)
delay_main_incident_total = m.addVar(name="delay_main_incident_total", lb=0.0)
dissipation_time = m.addVar(name="dissipation_time", lb=0.0)

# --- Constraints ---
m.addConstr(queue_length[0] == 0, name="InitialQueue")

for t in periods:
    m.addConstr(flow_main[t] + flow_alt[t] == arrival_rates[t], name="FlowConservation_P{0}".format(t))
    m.addConstr(flow_alt[t] <= alt_berth_capacity, name="AltCapacity_P{0}".format(t))

for t in periods:
    m.addConstr(queue_unconstrained[t] == queue_length[t-1] + (flow_main[t] - capacity_main_reduced) * dt,
                name="QueueCalcUnc_P{0}".format(t))
    m.addGenConstrMax(queue_length[t], [queue_unconstrained[t]], 0.0, name="QueueEvolution_P{0}".format(t))

m.addConstr(delay_alt_total == gp.quicksum(flow_alt[t] * dt * alt_berth_extra_time for t in periods),
            name="CalcAltTotalDelay")

m.addConstr(delay_main_incident_total == 0.5 * dt * gp.quicksum(queue_length[t-1] + queue_length[t] for t in periods),
            name="CalcMainIncidentDelay")

m.addConstr(queue_at_clearance == queue_length[num_periods], name="DefineQueueAtClearance")

# --- Objective Function ---
can_dissipate = arrival_rate_post < capacity_main_normal

if can_dissipate:
    dissipation_rate = capacity_main_normal - arrival_rate_post
    m.addConstr(queue_at_clearance == dissipation_rate * dissipation_time, name="CalcDissipationTime")
    obj = delay_main_incident_total + (0.5 / dissipation_rate) * queue_at_clearance * queue_at_clearance + delay_alt_total
    m.setObjective(obj, GRB.MINIMIZE)
else:
    penalty_factor_non_dissipating = 1000
    obj = delay_main_incident_total + delay_alt_total + penalty_factor_non_dissipating * queue_at_clearance
    m.setObjective(obj, GRB.MINIMIZE)
    m.addConstr(dissipation_time == 1e6, "DissipationTimePenalty")

# --- Optimize ---
m.optimize()

# --- Output Results ---
if m.status == GRB.OPTIMAL:
    for t in periods:
        print("{0:.2f}".format(flow_alt[t].X))
elif m.status == GRB.INFEASIBLE:
    print("Infeasible")
elif m.status == GRB.UNBOUNDED:
    print("Unbounded")
```
Answer:
0.00
0.00
66.00
0.00



================================================================================



--- Problem 181 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A port terminal must coordinate the berthing times for two distinct ships to minimize total waiting time. The terminal experiences heavy ship traffic, with Ship 1 handling a significantly higher volume (represented by a flow coefficient of 2453) compared to Ship 2 (flow coefficient of 132). Each ship’s berthing time must be carefully allocated within strict bounds: no less than 8 hours and no more than 31 hours per ship. The total cycle time—the sum of berthing times for both ships—is fixed at 31 hours, ensuring synchronization with other terminal operations. The challenge is to determine the exact berthing time allocation that minimizes the cumulative waiting time experienced by both ships, where waiting time is proportional to the non-berthing time (cycle time minus berthing time) weighted by the ship flow.  

**Core Question:** What is the optimal distribution of berthing times between the two ships to minimize total waiting time, given the ship flow disparities and strict timing constraints?  

---

**Modeling Process:**
**
**1. Decision Variables:**  
- \( t_i \): Continuous variable representing the berthing time (in hours) allocated to Ship \( i \), where \( i \in \{1, 2\} \).  
  - Bounds: \( 8 \leq t_i \leq 31 \).  

**2. Parameters:**  
- \( \text{flow_coeffs} = [2453, 132] \): Ship flow coefficients for Ship 1 and Ship 2, respectively.  
- \( \text{cycle_time} = 31 \): Total fixed cycle time (hours).  
- \( \text{lb_time} = 8 \), \( \text{ub_time} = 31 \): Lower/upper bounds for berthing times.  

**3. Objective Function:**  
Minimize the total waiting time:  
\[ \text{Minimize: } 2453 \cdot (31 - t_1) + 132 \cdot (31 - t_2). \]  

**4. Constraints:**  
- **Total cycle time:** The sum of berthing times must equal the cycle time:  
  \[ t_1 + t_2 = 31. \]  
- **Variable bounds:**  
  \[ 8 \leq t_1 \leq 31, \quad 8 \leq t_2 \leq 31. \]  

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_ships = 2
lb_time = 8          # Lower bound for berthing time
ub_time = 31          # Upper bound for berthing time
cycle_time = 31   # Total cycle time (set equal to ub_time)
flow_coeffs = [2453, 132] # Ship flow coefficients per ship
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_ships:
    print("Error: flow_coeffs length mismatch with num_ships")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_ships}-Ship Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_ships) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_ships, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for ship i is proportional to flow * non-berthing_time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_ships)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_ships)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_ships)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_ships):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 22660.00
------------------------------
Optimal berthing times (hours):
  t1: 23.00, t2: 8.00


```

================================================================================



--- Problem 182 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A port terminal must allocate berthing time between two competing ship arrivals to minimize total waiting time. Each berth serves a distinct ship, with Berth 1 handling 923 TEUs per hour and Berth 2 serving 2,143 TEUs per hour—a significantly heavier demand. The challenge lies in distributing the fixed 84-hour berthing cycle between these berths while adhering to strict operational limits: berthing times cannot fall below 38 hours or exceed 84 hours per berth. Waiting times accumulate proportionally to the non-berthing time (cycle time minus berthing time) multiplied by the TEU flow, making Berth 2’s higher flow particularly sensitive to insufficient berthing time. The optimization seeks the ideal split—balancing shorter berthing times for lighter flows against longer allocations for heavier flows—to minimize the cumulative waiting time experienced by all ships.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - \( t_i \): Continuous variable representing the berthing time (in hours) allocated to berth \( i \) (\( i = 1, 2 \)). Bounded between 38 and 84 hours.  
   - **2. Parameters:**  
     - \( \text{flow_coeffs} = [923, 2143] \): TEU flow rates (TEUs/hour) for berths 1 and 2.  
     - \( \text{cycle_time} = 84 \): Total fixed cycle time (hours).  
     - \( \text{lb_time} = 38 \), \( \text{ub_time} = 84 \): Lower/upper bounds for berthing times.  
   - **3. Objective Function:**  
     Minimize total waiting time:  
     \[
     \text{Minimize: } 923 \cdot (84 - t_1) + 2143 \cdot (84 - t_2)
     \]  
   - **4. Constraints:**  
     - Total berthing time must match the cycle time:  
       \[
       t_1 + t_2 = 84
       \]  
     - Bounds on berthing times:  
       \[
       38 \leq t_1 \leq 84, \quad 38 \leq t_2 \leq 84
       \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_berths = 2
lb_time = 38          # Lower bound for berthing time
ub_time = 84          # Upper bound for berthing time
cycle_time = 84   # Total cycle time (set equal to ub_time)
flow_coeffs = [923, 2143] # TEU flow coefficients per berth
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_berths:
    print("Error: flow_coeffs length mismatch with num_berths")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_berths}-Berth Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_berths) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_berths, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for berth i is proportional to flow * non-berthing_time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_berths)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_berths)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_berths)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_berths):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
Optimal total waiting time: 123892.00
------------------------------
Optimal berthing times (hours):
  t1: 38.00, t2: 46.00



================================================================================



--- Problem 183 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy trucking terminal faces the challenge of efficiently scheduling three delivery trucks (Truck 1, Truck 2, and Truck 3) to a single available loading dock. Each truck arrives at a specific time: Truck 1 at 3 hours, Truck 2 at 8 hours, and Truck 3 at 11 hours. Processing times vary, with Truck 1 requiring 5 hours, while Trucks 2 and 3 each need 3 hours. Delays are costly—waiting costs per hour are $127 for Truck 1, $148 for Truck 2, and $85 for Truck 3. Additionally, servicing each truck at the loading dock incurs hourly costs: $61 for Truck 1, $60 for Truck 2, and $47 for Truck 3.  

   The terminal aims to minimize a weighted combination of two competing objectives: the total operational time (makespan) and the total cost (waiting + service costs). The weights are carefully balanced, with 72% priority given to minimizing the makespan and 28% to reducing costs. The core question is: *How should the trucks be assigned and sequenced at the loading dock to achieve the optimal trade-off between speed and cost efficiency?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `assign(i, j)`: 1 if truck *i* is assigned to loading dock *j*, else 0.  
   - Continuous variable `start_time(i)`: When truck *i* begins processing.  
   - Continuous variable `completion_time(i)`: When truck *i* finishes (start time + processing time).  
   - Binary variable `precedes(i, k, j)`: 1 if truck *i* is processed before truck *k* on loading dock *j*, else 0.  
   - Continuous variable `makespan`: Latest completion time across all trucks.  

   **2. Parameters:**  
   - `arrival_times[i]`: Arrival time of truck *i* (e.g., Truck 1: 3).  
   - `processing_times[i]`: Processing duration (e.g., Truck 1: 5).  
   - `waiting_costs[i]`: Cost per hour of delay (e.g., Truck 1: $127).  
   - `service_costs[(i, j)]`: Hourly servicing cost (e.g., Truck 1 at Loading Dock 1: $61).  
   - Weights: `alpha = 0.72` (makespan), `beta = 0.28` (total cost).  

   **3. Objective Function:**  
   Minimize:  
   `0.72 * makespan + 0.28 * (total_waiting_cost + total_service_cost)`,  
   where:  
   - `total_waiting_cost = sum(waiting_costs[i] * (start_time[i] - arrival_times[i]))`  
   - `total_service_cost = sum(service_costs[(i, j)] * processing_times[i] * assign[i, j])`.  

   **4. Constraints:**  
   - Each truck must be assigned to exactly one loading dock: `sum(assign[i, j] for j in loading_docks) = 1` for all *i*.  
   - Start time cannot precede arrival: `start_time[i] >= arrival_times[i]` for all *i*.  
   - Completion time definition: `completion_time[i] = start_time[i] + processing_times[i]`.  
   - Non-overlapping scheduling: For each loading dock *j*, if truck *i* precedes *k*, then `start_time[k] >= completion_time[i]`.  
   - Makespan definition: `makespan >= completion_time[i]` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
loading_docks = [1]
arrival_times = {1: 3, 2: 8, 3: 11}
processing_times = {1: 5, 2: 3, 3: 3}
waiting_costs = {1: 127, 2: 148, 3: 85} # Cost per hour waiting
service_costs = {(1, 1): 61, (2, 1): 60, (3, 1): 47} # Cost rate per hour servicing {(truck, loading_dock): cost}
alpha = 0.72 # Weight for Makespan
beta = 0.28  # Weight for Total Cost
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("LOADING_DOCK_PROBLEM_16_WEIGHTED_OBJ")

    if not trucks or not loading_docks: raise ValueError("Empty trucks or loading docks")

    # --- Decision Variables ---
    assign = m.addVars(trucks, loading_docks, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in loading_docks],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    waiting_cost_expr = gp.quicksum(waiting_costs.get(i, 0) * (start_time[i] - arrival_times.get(i, 0)) for i in trucks)
    service_cost_expr = gp.quicksum(service_costs.get((i,j), 0) * processing_times.get(i, 0) * assign[i,j]
                                   for i in trucks for j in loading_docks)
    total_cost = waiting_cost_expr + service_cost_expr
    m.setObjective(alpha * makespan + beta * total_cost, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in loading_docks:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Weighted objective
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal Objective Value: {m.objVal:.4f}")
    for i in trucks:
        for j in loading_docks:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Loading Dock {j}")
                print(f"Start Time for Truck {i}: {start_time[i].x:.4f}")
                print(f"Completion Time for Truck {i}: {completion_time[i].x:.4f}")
    print(f"Makespan: {makespan.x:.4f}")
    print(f"Total Waiting Cost: {waiting_cost_expr.getValue():.4f}")
    print(f"Total Service Cost: {service_cost_expr.getValue():.4f}")
    print(f"Total Cost: {total_cost.getValue():.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
185.3600
Optimal Objective Value: 185.3600
Truck 1 is assigned to Loading Dock 1
Start Time for Truck 1: 3.0000
Completion Time for Truck 1: 8.0000
Truck 2 is assigned to Loading Dock 1
Start Time for Truck 2: 8.0000
Completion Time for Truck 2: 11.0000
Truck 3 is assigned to Loading Dock 1
Start Time for Truck 3: 11.0000
Completion Time for Truck 3: 14.0000
Makespan: 14.0000
Total Waiting Cost: 0.0000
Total Service Cost: 626.0000
Total Cost: 626.0000


```

================================================================================



--- Problem 184 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
A logistics company is tasked with loading a set of 8 packages with varying weights (11, 39, 53, 97, 41, 45, 82, and 19 units) onto a selection of 6 available trucks, each with distinct capacities and costs. The trucks have capacities and costs as follows: (99, \$1), (98, \$18), (99, \$100), (99, \$78), (99, \$30), and (99, \$72). The challenge is to assign each package to exactly one truck while respecting the truck capacities and ensuring that the total cost of the trucks used is minimized. The problem is further complicated by the requirement that a truck must be "activated" (i.e., incur its cost) if any package is placed in it. The goal is to find the most cost-effective way to load all packages without exceeding truck capacities, balancing the trade-off between truck costs and their available space.

**Modeling Process:**
- **1. Decision Variables:**  
     - Binary variable `x[i, j]` indicates whether package `i` is assigned to truck `j` (1 if assigned, 0 otherwise).  
     - Binary variable `y[j]` indicates whether truck `j` is used (1 if used, 0 otherwise).  
   - **2. Parameters:**  
     - `packages[i]`: Weight of package `i` (given as [11, 39, 53, 97, 41, 45, 82, 19]).  
     - `trucks[j]`: Tuple of (capacity, cost) for truck `j` (given as [(99, 1), (98, 18), (99, 100), (99, 78), (99, 30), (99, 72)]).  
   - **3. Objective Function:**  
     - Minimize the total cost: `Minimize sum(y[j] * trucks[j][1] for all j)`.  
   - **4. Constraints:**  
     - **Package Assignment:** Each package must be assigned to exactly one truck: `sum(x[i, j] for all j) = 1` for every package `i`.  
     - **Truck Capacity:** The total weight of packages in truck `j` must not exceed its capacity: `sum(packages[i] * x[i, j] for all i) <= trucks[j][0] * y[j]` for every truck `j`.  
     - **Linking Constraint:** If a package is assigned to truck `j`, the truck must be used: `x[i, j] <= y[j]` for every package `i` and truck `j`.

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys # Make sys available inside exec if needed, e.g. for print traceback
import traceback

# --- Data Definition (Embedded) ---
packages = [11, 39, 53, 97, 41, 45, 82, 19]      # Package weights
trucks = [(99, 1), (98, 18), (99, 100), (99, 78), (99, 30), (99, 72)]        # List of (Capacity, Cost) tuples
num_packages = 8       # len(packages)
num_trucks = 6         # len(trucks)
# --- End Data Definition ---

# Time limit (passed from outer scope via globals if needed, or hardcoded)
GUROBI_TIME_LIMIT = 60

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Keep output clean for saving
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Cost-Sensitive Truck Loading", env=env)

    # --- Decision Variables ---
    x = model.addVars(num_packages, num_trucks, vtype=GRB.BINARY, name="x")
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")

    # --- Objective: Minimize total cost ---
    model.setObjective(gp.quicksum(y[j] * trucks[j][1] for j in range(num_trucks)), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Each package assignment
    for i in range(num_packages):
        model.addConstr(x.sum(i, '*') == 1, name=f"Package_{i}_Assignment")

    # 2. Truck capacity
    for j in range(num_trucks):
        truck_capacity = trucks[j][0]
        if truck_capacity < 0: truck_capacity = 0
        model.addConstr(gp.quicksum(packages[i] * x[i, j] for i in range(num_packages)) <= truck_capacity * y[j], name=f"Truck_{j}_Capacity")

    # 3. Linking package to truck usage
    for i in range(num_packages):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Package_{i}_Triggers_Truck_{j}")

    # --- Solve ---
    # print("Solving CS-TLP instance...") # Comment out or keep for debug inside output
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal

    # --- Output results (This will be captured) ---
    # This logic needs to be *inside* the template now
    if model.status == GRB.OPTIMAL:
        print(f"Minimum cost: ${model.objVal:.2f}") # Use model.objVal directly
        print("-" * 30) # Add separator for clarity
        printed_truck_count = 0
        for j in range(num_trucks):
            # Use try-except for safety when accessing .X
            try:
                 if y[j].x > 0.5:
                     printed_truck_count += 1
                     truck_capacity_out, truck_cost_out = trucks[j]
                     assigned_packages = [i for i in range(num_packages) if x[i, j].x > 0.5]
                     truck_load_out = sum(packages[i] for i in assigned_packages)
                     # Format output exactly as desired for the log file
                     print(f"Truck {printed_truck_count} (Type Index {j}, Capacity: {truck_capacity_out}, Cost: ${truck_cost_out:.2f}):")
                     print(f"  Load: {truck_load_out} / {truck_capacity_out}")
                     print(f"  Packages (indices): {sorted(assigned_packages)}") # Sort for consistency
                     print("-" * 10) # Separator between trucks
            except AttributeError:
                 pass # Ignore trucks not used or if .X attribute missing
    elif model.status == GRB.TIME_LIMIT:
        print("\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: ${model.ObjVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {model.status}")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}") # Print errors to captured output
    results_dict['status'] = -1 # Use dict to signal error type to main loop
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:") # Print errors
    traceback.print_exc(file=sys.stdout) # Print traceback to captured stdout
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Minimum cost: $121.00
------------------------------
Truck 1 (Type Index 0, Capacity: 99, Cost: $1.00):
  Load: 97 / 99
  Packages (indices): [3]
----------
Truck 2 (Type Index 1, Capacity: 98, Cost: $18.00):
  Load: 93 / 98
  Packages (indices): [0, 6]
----------
Truck 3 (Type Index 4, Capacity: 99, Cost: $30.00):
  Load: 98 / 99
  Packages (indices): [2, 5]
----------
Truck 4 (Type Index 5, Capacity: 99, Cost: $72.00):
  Load: 99 / 99
  Packages (indices): [1, 4, 7]
----------


```

================================================================================



--- Problem 185 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A busy port faces a critical ship berthing challenge: balancing the flow of ships entering from a channel with the limited capacity of the downstream berthing area. The upstream channel already carries a heavy flow of 2,567.59 ships per hour (ships/h), while the channel demand stands at 715.69 ships/h. However, the downstream berthing area can handle a maximum of only 2,867.08 ships/h before congestion worsens. The goal is to determine the optimal channel entry rate—the number of ships allowed to enter the channel per hour—to maximize channel throughput without exceeding the berthing area's capacity. This decision directly impacts port efficiency: too high an entry rate risks gridlock in the berthing area, while too low a rate causes unnecessary delays in the channel. The optimization must account for the interplay between these flows, ensuring the combined upstream and channel volumes do not breach the bottleneck’s limit.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `r_channel`: The channel entry rate (ships/h), bounded between 0 and the channel demand (715.69 ships/h).  
     - `lambda_berth_downstream`: The resulting flow in the downstream berthing area (ships/h), a non-negative continuous variable.  
   - **2. Parameters:**  
     - `C_berth_congested_h = 2867.08`: Downstream berthing area capacity (ships/h).  
     - `lambda_channel_demand_h = 715.69`: Maximum channel demand (ships/h).  
     - `lambda_channel_upstream_h = 2567.59`: Upstream channel flow (ships/h).  
   - **3. Objective Function:**  
     Maximize the channel entry rate:  
     `Maximize: r_channel`.  
   - **4. Constraints:**  
     - Downstream flow calculation: `lambda_berth_downstream = lambda_channel_upstream_h + r_channel`.  
     - Capacity limit: `lambda_berth_downstream <= C_berth_congested_h`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
C_berth_congested_h = 2867.083686617963
lambda_channel_demand_h = 715.6918948785441
lambda_channel_upstream_h = 2567.5908817547306

# --- Gurobi Model ---
model = gp.Model("ChannelEntryRateDownstreamCongestion")

# --- Decision Variables ---
r_channel = model.addVar(name="ChannelRate", lb=0.0, ub=lambda_channel_demand_h)
lambda_berth_downstream = model.addVar(name="BerthFlowDownstream", lb=0.0)

# --- Constraints ---
model.addConstr(lambda_berth_downstream == lambda_channel_upstream_h + r_channel, name="DownstreamFlowCalc")
model.addConstr(lambda_berth_downstream <= C_berth_congested_h, name="DownstreamCapacityLimit")

# --- Objective Function ---
model.setObjective(r_channel, GRB.MAXIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    print(f"Optimal Channel Entry Rate: {r_channel.X:.2f} ships/h")
    print(f"  (Channel Demand was: {lambda_channel_demand_h:.0f} ships/h)")
    print(f"Resulting Downstream Berthing Area Flow: {lambda_berth_downstream.X:.2f} ships/h")
    print(f"  (Downstream Capacity Limit: {C_berth_congested_h:.0f} ships/h)")
    channel_queue_growth = lambda_channel_demand_h - r_channel.X
    print(f"Implied Queue Growth Rate in Channel: {channel_queue_growth:.2f} ships/h")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
    if lambda_channel_upstream_h > C_berth_congested_h:
         print(f"  Reason: Upstream channel flow ({lambda_channel_upstream_h}) already exceeds downstream capacity ({C_berth_congested_h}).")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 2 rows, 2 columns and 3 nonzeros
Model fingerprint: 0xecc74de8
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [7e+02, 7e+02]
  RHS range        [3e+03, 3e+03]
Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    2.9949280e+02   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  2.994928049e+02

--- Optimization Results ---
Optimization Status: Optimal
Optimal Channel Entry Rate: 299.49 ships/h
  (Channel Demand was: 716 ships/h)
Resulting Downstream Berthing Area Flow: 2867.08 ships/h
  (Downstream Capacity Limit: 2867 ships/h)
Implied Queue Growth Rate in Channel: 416.20 ships/h



================================================================================



--- Problem 186 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
A logistics company is tasked with optimizing the delivery route for a single truck serving two customer locations from a central depot. The truck has a strict capacity limit of 70.25 units, and each customer has a specific demand: Customer 1 requires 36 units, and Customer 2 requires 30 units. The distances between locations are precisely known: the depot (Node 0) is 100 units from Customer 1 (Node 1), 44 units from Customer 2 (Node 2), and the two customers are 41 units apart. The challenge is to design a route that minimizes the total travel distance while ensuring the truck does not exceed its capacity and each customer is visited exactly once. The solution must also guarantee the truck returns to the depot, forming a closed loop.

The core question is: **What is the most efficient route for the truck to serve all customers without violating capacity constraints, and what is the minimum total distance required?**

---

**Modeling Process:**
**1. Decision Variables:**  
   - Binary variables `x[i, j, k]` indicate whether the truck `k` travels directly from location `i` to `j` (1 if yes, 0 otherwise).  
   - Continuous variables `u[i]` enforce subtour elimination (Miller-Tucker-Zemlin constraints) for customer nodes `i`.  

   **2. Parameters:**  
   - `N = 3`: Total nodes (depot + 2 customers).  
   - `K = 1`: Single truck.  
   - `Q = [70.25]`: Truck capacity.  
   - `q = [0, 36, 30]`: Demands (depot has 0 demand).  
   - `d[i][j]`: Distance matrix (e.g., `d[0][1] = 100`).  

   **3. Objective Function:**  
   Minimize total distance:  
   \[
   \text{Minimize: } \sum_{k=0}^{K-1} \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} d[i][j] \cdot x[i, j, k] \quad \text{(for } i \neq j\text{)}
   \]  

   **4. Constraints:**  
   - **Visit each customer once:** For each customer `i`, the sum of incoming/outgoing edges equals 1.  
   - **Flow conservation:** For each node and truck, incoming edges equal outgoing edges.  
   - **Depot departure/return:** The truck leaves and returns to the depot exactly once.  
   - **Capacity:** Total demand on the route ≤ 70.25.  
   - **Subtour elimination:** For `i ≠ j`, `u[i] - u[j] + (N-1) \cdot x[i, j, k] ≤ N-2`.  

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 3
K = 1
Q = [70.25]
q = [0, 36, 30]
d = [
    [0, 100, 44],
    [100, 0, 41],
    [44, 41, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Vehicle Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for vehicle {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for vehicle {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 185.00

Route for vehicle 1 (Capacity: 70.25):
0 -> 2 -> 1 -> 0
Route Load: 66 / 70.25


```

================================================================================



--- Problem 187 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
In a busy logistics hub, a critical scheduling challenge arises: seven trucks, each arriving at distinct times, must be efficiently assigned to a single available depot. The logistics manager faces the daunting task of minimizing the total operational time (makespan) while ensuring no two trucks occupy the depot simultaneously. Truck arrivals are staggered—Truck 1 arrives at time 1, Truck 2 at time 5, and so on, with the last arrival (Truck 7) at time 25. Each truck requires a specific processing duration: Truck 1 needs 8 hours, Truck 2 takes 7 hours, and the shortest tasks (Trucks 4, 5, and 7) require just 3 hours. The core question is: *What is the optimal depot schedule that ensures all trucks are serviced as early as possible without overlaps, and what is the minimal total time (makespan) to complete all operations?*

**Modeling Process:**
- **1. Decision Variables:**  
     - `assign[i, j]`: Binary variable (1 if truck *i* is assigned to depot *j*, else 0).  
     - `start_time[i]`: Continuous variable for the depot start time of truck *i*.  
     - `completion_time[i]`: Continuous variable for the depot end time of truck *i* (start time + processing time).  
     - `precedes[i, k, j]`: Binary variable (1 if truck *i* is scheduled before truck *k* on depot *j*, else 0).  
     - `makespan`: Continuous variable representing the total completion time of all trucks.  

   - **2. Parameters:**  
     - `trucks`: [1, 2, 3, 4, 5, 6, 7].  
     - `depots`: [1].  
     - `arrival_times`: {1:1, 2:5, 3:7, 4:10, 5:15, 6:20, 7:25}.  
     - `processing_times`: {1:8, 2:7, 3:6, 4:3, 5:3, 6:6, 7:3}.  
     - `H`: A large constant (100) for logical constraints.  

   - **3. Objective Function:**  
     Minimize `makespan` (the latest completion time among all trucks).  

   - **4. Constraints:**  
     1. **Assignment**: Each truck must be assigned to exactly one depot.  
        - For each truck *i*: `sum(assign[i, j] for j in depots) = 1`.  
     2. **Arrival Time**: A truck cannot start before its arrival time.  
        - For each truck *i*: `start_time[i] >= arrival_times[i]`.  
     3. **Completion Time**: The end time is the start time plus processing time.  
        - For each truck *i*: `completion_time[i] = start_time[i] + processing_times[i]`.  
     4. **Non-Overlapping**: If two trucks *i* and *k* share a depot, one must precede the other.  
        - For each pair *i < k* and depot *j*:  
          - If `precedes[i, k, j] = 1`, then `start_time[k] >= completion_time[i]`.  
          - Else, `start_time[i] >= completion_time[k]`.  
     5. **Makespan Definition**: The makespan is the maximum completion time across all trucks.  
        - For each truck *i*: `makespan >= completion_time[i]`.

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7]
depots = [1]
arrival_times = {1: 1, 2: 5, 3: 7, 4: 10, 5: 15, 6: 20, 7: 25}
processing_times = {1: 8, 2: 7, 3: 6, 4: 3, 5: 3, 6: 6, 7: 3} # Using base processing times
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_14_CRANE_IGNORE") # Renamed model

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (using base proc time)
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Schedule:")
    for i in trucks:
        print(f"Truck {i}: Start Time = {start_time[i].x:.2f}, Completion Time = {completion_time[i].x:.2f}")
    print(f"Minimal Makespan: {makespan.x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
37.0000
Optimal Schedule:
Truck 1: Start Time = 1.00, Completion Time = 9.00
Truck 2: Start Time = 15.00, Completion Time = 22.00
Truck 3: Start Time = 9.00, Completion Time = 15.00
Truck 4: Start Time = 22.00, Completion Time = 25.00
Truck 5: Start Time = 25.00, Completion Time = 28.00
Truck 6: Start Time = 31.00, Completion Time = 37.00
Truck 7: Start Time = 28.00, Completion Time = 31.00
Minimal Makespan: 37.00


```

================================================================================



--- Problem 188 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
In a busy port, a critical logistics challenge arises at the main dock where three berths, B1, B2, and B3, are used to handle incoming and outgoing cargo. During peak hours, 1,749 containers per hour arrive at berth B1, which need to be transported to berth B2 either directly via route B1B2 or indirectly through berth B3 via routes B1B3 and B3B2. The capacities of these segments are tightly constrained: B1B2 can handle up to 1,812 containers/hour, B1B3 up to 815, and B3B2 up to 1,046. The primary concern is congestion on the direct B1B2 link—if demand exceeds capacity, overflow occurs, leading to delays and inefficiencies. The goal is to strategically reroute container traffic to minimize overflow on B1B2 while respecting all segment capacities. The central question is: *How should the container flow be distributed between the direct and indirect paths to eliminate overflow entirely?*

**Modeling Process:**
- **1. Decision Variables:**  
     - `f_B1B2`: Flow (containers/hr) from B1 to B2 (direct).  
     - `f_B1B3`: Flow (containers/hr) from B1 to B3 (indirect path start).  
     - `f_B3B2`: Flow (containers/hr) from B3 to B2 (indirect path end).  
     - `overflow_B1B2`: Excess flow (containers/hr) beyond B1B2’s capacity (non-negative).  

   - **2. Parameters:**  
     - `total_flow_originating_B1 = 1,749` (containers/hr).  
     - Segment capacities: `B1B2 = 1,812`, `B1B3 = 815`, `B3B2 = 1,046` (containers/hr).  

   - **3. Objective Function:**  
     Minimize `overflow_B1B2` to avoid congestion on B1B2.  

   - **4. Constraints:**  
     - **Flow conservation at B1:** `f_B1B2 + f_B1B3 = 1,749`.  
     - **Flow balance at B3:** `f_B1B3 = f_B3B2` (all traffic entering B3 must proceed to B2).  
     - **B1B2 overflow definition:** `f_B1B2 ≤ capacity_B1B2 + overflow_B1B2`.  
     - **B1B3 capacity:** `f_B1B3 ≤ 815`.  
     - **B3B2 capacity:** `f_B3B2 ≤ 1,046`.  

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_flow_originating_B1 = 1749 # containers/hr
capacity = {'B1B2': 1812, 'B1B3': 815, 'B3B2': 1046} # Dict segment: capacity (containers/hr)
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m33 = gp.Model("CONTAINER_REROUTING_LP", env=env)

    # --- Decision Variables ---
    # Flows on each segment
    f_B1B2 = m33.addVar(name="flow_B1_B2", lb=0)
    f_B1B3 = m33.addVar(name="flow_B1_B3", lb=0)
    f_B3B2 = m33.addVar(name="flow_B3_B2", lb=0)
    # Overflow variable for the congested link B1B2
    overflow_B1B2 = m33.addVar(name="overflow_B1_B2", lb=0)

    # --- Objective Function ---
    # Minimize the overflow on segment B1->B2
    m33.setObjective(overflow_B1B2, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Total flow conservation leaving node B1
    m33.addConstr(f_B1B2 + f_B1B3 == total_flow_originating_B1, name="flow_out_B1")

    # Constraint 2: Flow conservation at node B3
    m33.addConstr(f_B1B3 == f_B3B2, name="flow_at_B3")

    # Constraint 3: Calculate overflow for B1->B2 link
    # overflow = max(0, f_B1B2 - capacity_B1B2)
    cap_b1b2 = capacity.get('B1B2', 0) # Get capacity safely
    m33.addConstr(f_B1B2 <= cap_b1b2 + overflow_B1B2, name="overflow_calc")

    # Constraint 4: Capacity constraint for B1->B3 link
    cap_b1b3 = capacity.get('B1B3', 0)
    m33.addConstr(f_B1B3 <= cap_b1b3, name="capacity_B1B3")

    # Constraint 5: Capacity constraint for B3->B2 link
    cap_b3b2 = capacity.get('B3B2', 0)
    m33.addConstr(f_B3B2 <= cap_b3b2, name="capacity_B3B2")

    # --- Optimization ---
    m33.optimize()

    # --- Store results ---
    results_dict['status'] = m33.status
    if m33.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m33.ObjVal # = overflow_B1B2.X
        results_dict['f_B1B2_sol'] = f_B1B2.X
        results_dict['f_B1B3_sol'] = f_B1B3.X
        results_dict['f_B3B2_sol'] = f_B3B2.X

    # --- Output Results ---
    print(f"--- Problem 33: Container Flow Rerouting (LP) ---") # Original problem number
    if m33.status == GRB.OPTIMAL:
        overflow_sol = results_dict.get('obj_val', 'N/A')
        f_b1b2_sol = results_dict.get('f_B1B2_sol', 'N/A')
        f_b1b3_sol = results_dict.get('f_B1B3_sol', 'N/A')
        f_b3b2_sol = results_dict.get('f_B3B2_sol', 'N/A')
        cap_b1b2_print = capacity.get('B1B2', 'N/A')
        cap_b1b3_print = capacity.get('B1B3', 'N/A')
        cap_b3b2_print = capacity.get('B3B2', 'N/A')

        print(f"Optimization Status: Optimal")
        # Format numerical output
        print(f"Minimum Overflow on B1->B2: {float(overflow_sol):.1f} containers/hr")
        print("Optimal Flow Distribution:")
        print(f"  Flow B1 -> B2: {float(f_b1b2_sol):.1f} (Capacity: {cap_b1b2_print})")
        print(f"  Flow B1 -> B3: {float(f_b1b3_sol):.1f} (Capacity: {cap_b1b3_print})")
        print(f"  Flow B3 -> B2: {float(f_b3b2_sol):.1f} (Capacity: {cap_b3b2_print})")
        # Check total flow matches original
        total_flow_out = float(f_b1b2_sol) + float(f_b1b3_sol) if isinstance(f_b1b2_sol, (int, float)) and isinstance(f_b1b3_sol, (int, float)) else 'N/A'
        print(f"Total Flow from B1: {total_flow_out:.1f} (Initial: {total_flow_originating_B1})")

    elif m33.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible. Check capacities vs total flow.")
         print(f"Total Flow: {total_flow_originating_B1}, Capacity B1B3+B3B2 path: {capacity.get('B1B3', 0) + capacity.get('B3B2', 0)}?") # Simple check example
    else:
        print(f"Optimization Status: {m33.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2


```
Answer:
--- Problem 33: Container Flow Rerouting (LP) ---
Optimization Status: Optimal
Minimum Overflow on B1->B2: 0.0 containers/hr
Optimal Flow Distribution:
  Flow B1 -> B2: 934.0 (Capacity: 1812)
  Flow B1 -> B3: 815.0 (Capacity: 815)
  Flow B3 -> B2: 815.0 (Capacity: 1046)
Total Flow from B1: 1749.0 (Initial: 1749)



================================================================================



--- Problem 189 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
In a busy port, a critical scheduling challenge arises at a major container terminal where three key berths are used: Berth 1, Berth 2, and Berth 3. During peak hours, a total of 1,247 containers per hour need to be processed, requiring efficient routing to avoid congestion. The berths have strict capacity limits: Berth 1 can handle up to 1,011 containers/hour, Berth 2 up to 577 containers/hour, and Berth 3 up to 1,276 containers/hour. The primary bottleneck is Berth 1, where excess flow beyond its capacity would cause disruptive delays. To mitigate this, the terminal operators must dynamically reroute containers through the alternative path via Berth 2 and then to Berth 3 while minimizing any overflow on Berth 1. The core question is: *How should the container flow be distributed across these berths to ensure minimal congestion on Berth 1 while fully accommodating the total demand?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `f_B1`: Flow of containers to Berth 1 (continuous, ≥0).  
     - `f_B2`: Flow of containers to Berth 2 (continuous, ≥0).  
     - `f_B3`: Flow of containers from Berth 2 to Berth 3 (continuous, ≥0).  
     - `overflow_B1`: Excess containers beyond Berth 1’s capacity (continuous, ≥0).  

   - **2. Parameters:**  
     - Total flow of containers: 1,247 cont/hr.  
     - Capacities: `cap_B1 = 1011`, `cap_B2 = 577`, `cap_B3 = 1276` (all in cont/hr).  

   - **3. Objective Function:**  
     Minimize the overflow on Berth 1:  
     ```  
     Minimize: overflow_B1  
     ```  

   - **4. Constraints:**  
     - Flow conservation at the initial point: `f_B1 + f_B2 = 1247`.  
     - Flow conservation at Berth 2: `f_B2 = f_B3`.  
     - Overflow definition for Berth 1: `f_B1 ≤ cap_B1 + overflow_B1`.  
     - Capacity limits:  
       - `f_B2 ≤ cap_B2`.  
       - `f_B3 ≤ cap_B3`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_flow_containers = 1247 # cont/hr
capacity = {'B1': 1011, 'B2': 577, 'B3': 1276} # Dict berth: capacity (cont/hr)
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m33 = gp.Model("CONTAINER_REROUTING_LP", env=env)

    # --- Decision Variables ---
    # Flows on each segment
    f_B1 = m33.addVar(name="flow_B1", lb=0)
    f_B2 = m33.addVar(name="flow_B2", lb=0)
    f_B3 = m33.addVar(name="flow_B3", lb=0)
    # Overflow variable for the congested link B1
    overflow_B1 = m33.addVar(name="overflow_B1", lb=0)

    # --- Objective Function ---
    # Minimize the overflow on Berth 1
    m33.setObjective(overflow_B1, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Total flow conservation leaving the initial point
    m33.addConstr(f_B1 + f_B2 == total_flow_containers, name="flow_out_initial")

    # Constraint 2: Flow conservation at Berth 2
    m33.addConstr(f_B2 == f_B3, name="flow_at_B2")

    # Constraint 3: Calculate overflow for Berth 1
    # overflow = max(0, f_B1 - capacity_B1)
    cap_b1 = capacity.get('B1', 0) # Get capacity safely
    m33.addConstr(f_B1 <= cap_b1 + overflow_B1, name="overflow_calc")

    # Constraint 4: Capacity constraint for Berth 2
    cap_b2 = capacity.get('B2', 0)
    m33.addConstr(f_B2 <= cap_b2, name="capacity_B2")

    # Constraint 5: Capacity constraint for Berth 3
    cap_b3 = capacity.get('B3', 0)
    m33.addConstr(f_B3 <= cap_b3, name="capacity_B3")

    # --- Optimization ---
    m33.optimize()

    # --- Store results ---
    results_dict['status'] = m33.status
    if m33.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m33.ObjVal # = overflow_B1.X
        results_dict['f_B1_sol'] = f_B1.X
        results_dict['f_B2_sol'] = f_B2.X
        results_dict['f_B3_sol'] = f_B3.X

    # --- Output Results ---
    print(f"--- Problem 33: Container Flow Rerouting (LP) ---") # Original problem number
    if m33.status == GRB.OPTIMAL:
        overflow_sol = results_dict.get('obj_val', 'N/A')
        f_b1_sol = results_dict.get('f_B1_sol', 'N/A')
        f_b2_sol = results_dict.get('f_B2_sol', 'N/A')
        f_b3_sol = results_dict.get('f_B3_sol', 'N/A')
        cap_b1_print = capacity.get('B1', 'N/A')
        cap_b2_print = capacity.get('B2', 'N/A')
        cap_b3_print = capacity.get('B3', 'N/A')

        print(f"Optimization Status: Optimal")
        print(f"Minimum Overflow on B1: {float(overflow_sol):.1f} cont/hr")
        print("Optimal Flow Distribution:")
        print(f"  Flow to B1: {float(f_b1_sol):.1f} (Capacity: {cap_b1_print})")
        print(f"  Flow to B2: {float(f_b2_sol):.1f} (Capacity: {cap_b2_print})")
        print(f"  Flow from B2 to B3: {float(f_b3_sol):.1f} (Capacity: {cap_b3_print})")
        total_flow_out = float(f_b1_sol) + float(f_b2_sol) if isinstance(f_b1_sol, (int, float)) and isinstance(f_b2_sol, (int, float)) else 'N/A'
        print(f"Total Flow: {total_flow_out:.1f} (Initial: {total_flow_containers})")

    elif m33.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible. Check capacities vs total flow.")
         print(f"Total Flow: {total_flow_containers}, Capacity B2+B3 path: {capacity.get('B2', 0) + capacity.get('B3', 0)}?") # Simple check example
    else:
        print(f"Optimization Status: {m33.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 33: Container Flow Rerouting (LP) ---
Optimization Status: Optimal
Minimum Overflow on B1: 0.0 cont/hr
Optimal Flow Distribution:
  Flow to B1: 670.0 (Capacity: 1011)
  Flow to B2: 577.0 (Capacity: 577)
  Flow from B2 to B3: 577.0 (Capacity: 1276)
Total Flow: 1247.0 (Initial: 1247)


```

================================================================================



--- Problem 190 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port is managing the berthing of ships at two primary docks (Dock A and Dock B) during three distinct periods of the day: Morning, Midday, and Evening. The port has fixed berths for each dock—3 berths for Dock A and 3 for Dock B—along with a single reversible berth that can be allocated to either dock to alleviate congestion. The number of ship arrivals fluctuates significantly: in the Morning, Dock A handles 1,584 ships per hour while Dock B sees 1,857; Midday shifts to 2,226 for Dock A and 1,444 for Dock B; and Evening peaks for Dock A at 2,338, while Dock B drops to 611. Each berth can accommodate up to 1,058 ships per hour. The goal is to strategically assign the reversible berth in each period to minimize the worst-case congestion, measured as the maximum volume-to-capacity (V/C) ratio across all docks and time periods. This ensures balanced traffic flow and prevents bottlenecks during peak hours.

**Core Question:** How should the reversible berth be allocated during each period to minimize the highest congestion level experienced at the port?  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable `y[t]` for each period `t` (Morning, Midday, Evening):  
  - `y[t] = 1` if the reversible berth is assigned to Dock A in period `t`; `0` if assigned to Dock B.  
- Continuous variable `Max_VC_Ratio`: Represents the maximum V/C ratio across all periods and docks.  

**2. Parameters:**  
- `flows[t][d]`: Number of ship arrivals (ships/hour) for dock `d` (A or B) in period `t`.  
- `berth_capacity = 1,058`: Capacity per berth (ships/hour/berth).  
- `num_fixed_berths_A = 3`, `num_fixed_berths_B = 3`: Fixed berths for each dock.  
- `num_reversible_berths = 1`: Reversible berth to allocate.  

**3. Objective Function:**  
- Minimize `Max_VC_Ratio` (the worst-case congestion level).  

**4. Constraints:**  
- For each period `t`:  
  - Capacity for Dock A: `(3 + y[t]) * 1,058`.  
  - Capacity for Dock B: `(3 + (1 - y[t])) * 1,058`.  
  - `Max_VC_Ratio` must exceed or equal the V/C ratio for both docks:  
    - `Max_VC_Ratio * (capacity_A + 1e-6) ≥ flow_A` (avoids division by zero).  
    - `Max_VC_Ratio * (capacity_B + 1e-6) ≥ flow_B`.  

---

**

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
periods = ['Morning', 'Midday', 'Evening']
flows = {'Morning': {'A': 1584, 'B': 1857}, 'Midday': {'A': 2226, 'B': 1444}, 'Evening': {'A': 2338, 'B': 611}} # Dict period: {'A': flow, 'B': flow}
berth_capacity = 1058 # ships/h/berth
num_fixed_berths_A = 3
num_fixed_berths_B = 3
num_reversible_berths = 1
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("REVERSIBLE_BERTH_ASSIGN", env=env)

    # --- Input Validation ---
    if not periods: raise ValueError("Empty periods list")
    if berth_capacity <= 0: raise ValueError("Berth capacity must be positive")

    # --- Decision Variables ---
    # y[t] = 1 if reversible berth goes to A in period t, 0 if to B
    y = m.addVars(periods, vtype=GRB.BINARY, name="ReversibleBerthToA")
    # Max_VC_Ratio: the maximum V/C ratio across all periods and docks
    Max_VC_Ratio = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="Max_VC_Ratio") # V/C must be >= 0

    # --- Objective Function: Minimize the maximum V/C ratio ---
    m.setObjective(Max_VC_Ratio, GRB.MINIMIZE)

    # --- Constraints ---
    for t in periods:
        flow_A = flows.get(t, {}).get('A', 0)
        flow_B = flows.get(t, {}).get('B', 0)

        # Calculate capacity for each dock using linear expressions
        cap_A_expr = (num_fixed_berths_A + y[t]) * berth_capacity
        cap_B_expr = (num_fixed_berths_B + (num_reversible_berths - y[t])) * berth_capacity

        # Ensure capacity expressions are non-negative (should be true if inputs valid)
        # Add constraints linking Max_VC_Ratio to V/C for each dock/period
        # Max_VC_Ratio >= Flow / Capacity  <=>  Max_VC_Ratio * Capacity >= Flow
        # Use small epsilon for capacity to avoid potential division by zero if capacity=0 allowed
        epsilon = 1e-6
        m.addConstr(Max_VC_Ratio * (cap_A_expr + epsilon) >= flow_A, f"VC_A_{t}")
        m.addConstr(Max_VC_Ratio * (cap_B_expr + epsilon) >= flow_B, f"VC_B_{t}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['y_sol'] = m.getAttr('X', y) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is Max V/C ratio
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show precision
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the allocation of the reversible berth for each period
if m.Status == GRB.OPTIMAL:
    y_sol = m.getAttr('X', y)
    for t in periods:
        if y_sol[t] > 0.5:
            print(f"Reversible berth assigned to Dock A in {t}")
        else:
            print(f"Reversible berth assigned to Dock B in {t}")
```
Answer:
Optimal objective value: 0.5525
Reversible berth assigned to Dock B in Morning
Reversible berth assigned to Dock A in Midday
Reversible berth assigned to Dock A in Evening


```

================================================================================



--- Problem 191 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port is facing a critical scheduling challenge: optimizing the flow of 11 ships through a two-stage berthing process to minimize the total time taken to serve all ships. The first stage involves unloading, while the second stage handles loading. Each ship has distinct processing times at both stages—for instance, Ship 0 takes 48 minutes to unload and 22 minutes to complete loading, while Ship 10 requires only 16 minutes to unload but 67 minutes for loading. The port operates under strict sequencing rules: ships must proceed in a fixed order (0 to 10), and no stage can begin until the previous ship has finished at that stage. The core challenge is determining the optimal completion times for each ship at each stage to ensure the entire queue is processed as quickly as possible, minimizing the *makespan*—the time when the last ship exits the final stage.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `C[i, j]`: Continuous variable representing the completion time of ship `i` at stage `j` (where `i` ranges from 0 to 10 and `j` is 0 or 1).  

   **2. Parameters:**  
   - `process_times[i][j]`: Processing time of ship `i` at stage `j` (e.g., `process_times[0][0] = 48`).  
   - `num_stages = 2`: Fixed number of stages (unloading and loading).  

   **3. Objective Function:**  
   - Minimize `C[10, 1]` (completion time of the last ship at the final stage).  

   **4. Constraints:**  
   - **Stage 0 (Unloading) Sequencing:**  
     - First ship: `C[0, 0] >= process_times[0][0]`.  
     - Subsequent ships: `C[i, 0] >= C[i-1, 0] + process_times[i][0]` for `i = 1 to 10`.  
   - **Stage 1 (Loading) Sequencing:**  
     - First ship: `C[0, 1] >= C[0, 0] + process_times[0][1]`.  
     - Subsequent ships:  
       - Must finish Stage 0 first: `C[i, 1] >= C[i, 0] + process_times[i][1]`.  
       - Must wait for prior ship at Stage 1: `C[i, 1] >= C[i-1, 1] + process_times[i][1]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # List of ship indices [0, 1, ...]
# process_times[ship][stage], stage 0=Unloading, stage 1=Loading
process_times = [[48, 22], [38, 45], [38, 56], [81, 89], [28, 83], [16, 19], [55, 34], [70, 81], [84, 90], [76, 85], [16, 67]]
num_stages = 2 # Should be 2 based on original code
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTHING_FLOW_SHOP", env=env)

    # --- Basic Input Validation ---
    if not ships or num_stages <= 0 or not process_times or len(process_times) != len(ships):
        raise ValueError("Invalid input data for Port Berthing Flow Shop")
    if any(len(row) != num_stages for row in process_times):
         raise ValueError("Inconsistent number of stages in process_times")

    # --- Decision Variables ---
    # C[i, j]: Completion time of ship i at stage j
    C = m.addVars(ships, range(num_stages), vtype=GRB.CONTINUOUS, lb=0, name="C")

    # --- Objective Function: Minimize the makespan ---
    # Makespan is completion time of the last ship at the last stage
    last_ship_idx = ships[-1]
    last_stage_idx = num_stages - 1
    m.setObjective(C[last_ship_idx, last_stage_idx], GRB.MINIMIZE)

    # --- Constraints ---
    # Stage 0 completion times (assuming fixed sequence 0, 1, 2...)
    # First ship at stage 0
    m.addConstr(C[0, 0] >= process_times[0][0], "C0_0")
    # Subsequent ships at stage 0
    for i in range(1, len(ships)):
        m.addConstr(C[i, 0] >= C[i-1, 0] + process_times[i][0], f"C0_{i}")

    # Completion times for subsequent stages (j > 0)
    for j in range(1, num_stages):
        # First ship at stage j
        m.addConstr(C[0, j] >= C[0, j-1] + process_times[0][j], f"C{j}_0")
        # Subsequent ships at stage j
        for i in range(1, len(ships)):
            # Must complete stage j-1 first
            m.addConstr(C[i, j] >= C[i, j-1] + process_times[i][j], f"C{j}_{i}_StagePrev")
            # Must wait for previous ship to finish stage j
            m.addConstr(C[i, j] >= C[i-1, j] + process_times[i][j], f"C{j}_{i}_ShipPrev")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['C_sol'] = m.getAttr('X', C) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}") # Makespan
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block to print the completion times for each ship at each stage)
if m.Status == GRB.OPTIMAL:
    for i in ships:
        for j in range(num_stages):
            print(f"Completion time of ship {i} at stage {j}: {C[i, j].X:.2f}")
```
Answer:
Optimal objective value: 753.00
Completion time of ship 0 at stage 0: 48.00
Completion time of ship 0 at stage 1: 70.00
Completion time of ship 1 at stage 0: 86.00
Completion time of ship 1 at stage 1: 131.00
Completion time of ship 2 at stage 0: 124.00
Completion time of ship 2 at stage 1: 187.00
Completion time of ship 3 at stage 0: 205.00
Completion time of ship 3 at stage 1: 294.00
Completion time of ship 4 at stage 0: 233.00
Completion time of ship 4 at stage 1: 377.00
Completion time of ship 5 at stage 0: 249.00
Completion time of ship 5 at stage 1: 396.00
Completion time of ship 6 at stage 0: 304.00
Completion time of ship 6 at stage 1: 430.00
Completion time of ship 7 at stage 0: 374.00
Completion time of ship 7 at stage 1: 511.00
Completion time of ship 8 at stage 0: 458.00
Completion time of ship 8 at stage 1: 601.00
Completion time of ship 9 at stage 0: 534.00
Completion time of ship 9 at stage 1: 686.00
Completion time of ship 10 at stage 0: 550.00
Completion time of ship 10 at stage 1: 753.00


```

================================================================================



--- Problem 192 ---
**Difficulty:** easy
**Category:** LP

**Problem Description:**
**
A busy port faces a critical traffic management challenge: balancing the flow of trucks entering from a specific gate with the limited capacity of the internal road network. The upstream road already carries a heavy flow of 2,657.96 trucks per hour (trucks/h), while the gate has a potential demand of 684.48 trucks/h. However, the internal road network can only handle a maximum of 2,719.45 trucks/h before congestion worsens. The goal is to determine the optimal gate entry rate—the number of trucks allowed to enter the port per hour—that maximizes gate throughput without exceeding the internal road network capacity. This decision directly impacts traffic efficiency: setting the rate too high risks gridlock within the port, while setting it too low leads to growing queues at the gate. The core question is: *What is the highest gate entry rate that can be implemented without violating the internal road network capacity constraint, and what are the resulting flow dynamics?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `r_gate`: The gate entry rate (trucks/h), bounded between 0 and the gate demand (`lambda_gate_demand_h`).  
     - `lambda_road_internal`: The total flow rate on the internal road network downstream of the gate (trucks/h), must be non-negative.  

   - **2. Parameters:**  
     - `C_road_congested_h = 2719.45`: Internal road network capacity (trucks/h).  
     - `lambda_gate_demand_h = 684.48`: Maximum gate demand (trucks/h).  
     - `lambda_road_upstream_h = 2657.96`: Upstream road flow (trucks/h).  

   - **3. Objective Function:**  
     Maximize the gate entry rate:  
     `Maximize: r_gate`.  

   - **4. Constraints:**  
     - Internal road flow calculation:  
       `lambda_road_internal = lambda_road_upstream_h + r_gate`.  
     - Capacity limit:  
       `lambda_road_internal <= C_road_congested_h`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
C_road_congested_h = 2719.4523671253646
lambda_gate_demand_h = 684.4773059948135
lambda_road_upstream_h = 2657.9617180328073

# --- Gurobi Model ---
model = gp.Model("GateEntryRateInternalRoadCongestion")

# --- Decision Variables ---
r_gate = model.addVar(name="GateRate", lb=0.0, ub=lambda_gate_demand_h)
lambda_road_internal = model.addVar(name="InternalRoadFlow", lb=0.0)

# --- Constraints ---
model.addConstr(lambda_road_internal == lambda_road_upstream_h + r_gate, name="InternalRoadFlowCalc")
model.addConstr(lambda_road_internal <= C_road_congested_h, name="InternalRoadCapacityLimit")

# --- Objective Function ---
model.setObjective(r_gate, GRB.MAXIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    print(f"Optimal Gate Entry Rate: {r_gate.X:.2f} trucks/h")
    print(f"  (Gate Demand was: {lambda_gate_demand_h:.0f} trucks/h)")
    print(f"Resulting Internal Road Network Flow: {lambda_road_internal.X:.2f} trucks/h")
    print(f"  (Internal Road Capacity Limit: {C_road_congested_h:.0f} trucks/h)")
    gate_queue_growth = lambda_gate_demand_h - r_gate.X
    print(f"Implied Queue Growth Rate at Gate: {gate_queue_growth:.2f} trucks/h")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
    if lambda_road_upstream_h > C_road_congested_h:
         print(f"  Reason: Upstream road flow ({lambda_road_upstream_h}) already exceeds internal road capacity ({C_road_congested_h}).")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 2 rows, 2 columns and 3 nonzeros
Model fingerprint: 0x3ff4ff57
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [7e+02, 7e+02]
  RHS range        [3e+03, 3e+03]
Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    6.1490649e+01   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  6.149064909e+01

--- Optimization Results ---
Optimization Status: Optimal
Optimal Gate Entry Rate: 61.49 trucks/h
  (Gate Demand was: 684 trucks/h)
Resulting Internal Road Network Flow: 2719.45 trucks/h
  (Internal Road Capacity Limit: 2719 trucks/h)
Implied Queue Growth Rate at Gate: 622.99 trucks/h



================================================================================



--- Problem 193 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy inland logistics hub, eight trucks arrive at varying times, each requiring a depot for unloading and processing. The hub has only two depots available, creating a complex scheduling challenge to minimize the total time taken to service all trucks (known as the makespan). Trucks 1 and 2 are flagged for additional security checks, adding 1.8 hours to their base processing times. The arrival times and processing durations are tightly constrained: Truck 1 arrives at hour 2 and takes 3 hours (plus security), Truck 2 arrives at hour 3 with a 4-hour base time (plus security), and so on, with the last truck arriving at hour 15. The core challenge is to assign each truck to a depot and schedule their start times such that no two trucks occupy the same depot simultaneously, all trucks begin processing only after their arrival, and the total operational time is minimized. The hub manager must
**

**Modeling Process:**
**
**1. Decision Variables:**
- `assign(i, j)`: Binary variable (1 if truck `i` is assigned to depot `j`, 0 otherwise).
- `start_time(i)`: Continuous variable representing the start time of truck `i`.
- `completion_time(i)`: Continuous variable representing the completion time of truck `i`.
- `precedes(i, k, j)`: Binary variable (1 if truck `i` precedes truck `k` on depot `j`, 0 otherwise).
- `makespan`: Continuous variable representing the total time to complete all operations.

**2. Parameters:**
- `trucks = [1, 2, 3, 4, 5, 6, 7, 8]`: List of trucks.
- `depots = [1, 2]`: List of depots.
- `arrival_times`: Dictionary mapping trucks to their arrival times (e.g., `{1: 2, 2: 3, ...}`).
- `base_processing_times`: Dictionary mapping trucks to their base processing times (e.g., `{1: 3, 2: 4, ...}`).
- `type_X_trucks = [2, 1]`: Trucks requiring additional security checks.
- `security_check_time = 1.8`: Additional time for security checks.
- `H = 100`: A large constant (Big M) for logical constraints.

**3. Objective Function:**
- Minimize `makespan`.

**4. Constraints:**
- **Assignment:** Each truck must be assigned to exactly one depot: `sum(assign(i, j) for j in depots) = 1` for all `i` in trucks.
- **Arrival Time:** Trucks cannot start before their arrival time: `start_time(i) >= arrival_times[i]` for all `i` in trucks.
- **Completion Time:** The completion time of a truck is its start time plus its processing time (including security if applicable): `completion_time(i) = start_time(i) + processing_times[i]` for all `i` in trucks.
- **Non-Overlapping:** For each depot, if two trucks `i` and `k` are assigned to it, one must precede the other: 
  - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.
  - If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.
  - Logical linking: `assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))`.
- **Makespan Definition:** The makespan is the maximum completion time across all trucks: `makespan >= completion_time(i)` for all `i` in trucks.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7, 8]
depots = [1, 2]
arrival_times = {1: 2, 2: 3, 3: 8, 4: 9, 5: 10, 6: 12, 7: 14, 8: 15}
base_processing_times = {1: 3, 2: 4, 3: 8, 4: 8, 5: 8, 6: 6, 7: 7, 8: 3}
type_X_trucks = [2, 1] # Trucks needing security check
security_check_time = 1.8
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Data Prep ---
    processing_times = {}
    for i in trucks:
        if i in type_X_trucks:
            processing_times[i] = base_processing_times.get(i, 0) + security_check_time
        else:
            processing_times[i] = base_processing_times.get(i, 0)

    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_38_SECURITY_CHECK")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (using effective processing time)
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
    print(f"Total Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
52.6000
Optimal Solution Found:
Truck 1 assigned to Depot 2
Start Time: 2.0000, Completion Time: 6.8000
Truck 2 assigned to Depot 2
Start Time: 6.8000, Completion Time: 12.6000
Truck 3 assigned to Depot 2
Start Time: 33.6000, Completion Time: 41.6000
Truck 4 assigned to Depot 2
Start Time: 12.6000, Completion Time: 20.6000
Truck 5 assigned to Depot 2
Start Time: 41.6000, Completion Time: 49.6000
Truck 6 assigned to Depot 2
Start Time: 27.6000, Completion Time: 33.6000
Truck 7 assigned to Depot 2
Start Time: 20.6000, Completion Time: 27.6000
Truck 8 assigned to Depot 2
Start Time: 49.6000, Completion Time: 52.6000
Total Makespan: 52.6000


```

================================================================================



--- Problem 194 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
A major urban traffic disruption has occurred due to a protest, blocking a critical roadway and diverting thousands of vehicles per hour. Transportation planners must decide the most efficient rerouting strategy to minimize total delay for affected vehicles. The disruption is expected to last approximately 3.17 hours, and the affected traffic flow is estimated at 4,296 vehicles per hour. However, a portion of this demand (533 vehicles per hour) consists of local traffic that may be permitted to bypass the reroute if allowed by the chosen strategy.  

Two alternative routes are available:  
- **Alternative Route 1** has a base capacity of 2,628 vehicles per hour but imposes an additional delay of 0.142 hours per vehicle.  
- **Alternative Route 2** has a higher base capacity (2,986 vehicles per hour) but a slightly longer delay (0.185 hours per vehicle).  

A signal boost measure can increase the capacity of both routes by 11.67%, but deploying it incurs additional logistical costs. Four strategies are under consideration:  
1. **Force All Reroute, No Boost:** Divert all affected traffic (no local exceptions) without boosting signal capacity.  
2. **Force All Reroute, Boost:** Divert all traffic while applying the signal boost.  
3. **Allow Local, No Boost:** Permit local traffic to bypass rerouting, leaving only 3,763 vehicles to be rerouted, without boosting signals.  
4. **Allow Local, Boost:** Same as Strategy 3 but with signal boost enabled.  

The challenge is to select the strategy that minimizes the total rerouting delay in vehicle-hours, accounting for traffic flows, route capacities, and potential signal enhancements. Additionally, the weather forecast predicts light rain during the disruption, which might affect driver behavior, but this does not impact the optimization model or the decision-making process.

---

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable **y(s)** for each strategy **s** (1 to 4), where:  
  - **y(s) = 1** if strategy **s** is selected.  
  - **y(s) = 0** otherwise.  

**2. Parameters:**  
- **T_event_h = 3.171**: Duration of the disruption (hours).  
- **Lambda_affected = 4,296**: Total affected traffic flow (veh/h).  
- **Lambda_local_allowed = 533**: Local traffic exempt from rerouting (veh/h).  
- **C1_base, C2_base**: Base capacities of Alt Routes 1 and 2 (veh/h).  
- **T_extra1_h, T_extra2_h**: Additional delay per vehicle on Alt Routes 1 and 2 (hours).  
- **Signal_boost_factor = 1.1167**: Capacity multiplier if signal boost is applied.  

**3. Objective Function:**  
Minimize the total rerouting delay:  
\[
\text{Minimize: } \sum_{s=1}^{4} y(s) \cdot \text{strategy\_delays}[s]
\]  
where **strategy_delays[s]** is the precomputed delay for strategy **s** (in vehicle-hours).  

**4. Constraints:**  
- **Single Strategy Selection:** Exactly one strategy must be chosen:  
  \[
  y(1) + y(2) + y(3) + y(4) = 1
  \]  
- **Binary Variables:** All **y(s)** are binary (0 or 1).  

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
T_event_h = 3.1711930597838567
Lambda_affected = 4295.534808951246
Lambda_local_allowed = 532.7759393925526

# Alt Route 1
C1_base = 2628.0061518266925
T_extra1_h = 0.14200611382378284
# Alt Route 2
C2_base = 2986.0122471053737
T_extra2_h = 0.18480950113728892

Signal_boost_factor = 1.1167255796501687

# Define Strategies
strategies_def = {
    1: ("Force All Reroute, No Boost", False, False),
    2: ("Force All Reroute, Boost", False, True),
    3: ("Allow Local, No Boost", True, False),
    4: ("Allow Local, Boost", True, True),
}
strategy_ids = list(strategies_def.keys())

# --- Calculate delay for each strategy ---
strategy_delays = {}
print("--- Total Delay Calculation per Strategy ---")

for s_id in strategy_ids:
    desc, local_allowed, signal_boost = strategies_def[s_id]

    lambda_reroute = Lambda_affected
    if local_allowed:
        lambda_reroute = Lambda_affected - Lambda_local_allowed

    C1 = C1_base * Signal_boost_factor if signal_boost else C1_base
    C2 = C2_base * Signal_boost_factor if signal_boost else C2_base
    Total_Alt_Cap = C1 + C2

    total_delay_s = 0
    flow1 = 0
    flow2 = 0
    unserved = 0

    print(f" Strategy {s_id} ({desc}):")
    print(f"  Rerouted Demand = {lambda_reroute:.0f} veh/h")
    print(f"  Alt1 Cap = {C1:.0f}, Alt2 Cap = {C2:.0f}, Total Alt Cap = {Total_Alt_Cap:.0f}")

    if lambda_reroute > Total_Alt_Cap:
        print("  Warning: Rerouted demand exceeds total alternative capacity!")
        total_delay_s = float('inf')
        unserved = lambda_reroute - Total_Alt_Cap
        flow1 = C1
        flow2 = C2
    else:
        flow1 = min(lambda_reroute, C1)
        flow2 = min(lambda_reroute - flow1, C2)
        unserved = lambda_reroute - flow1 - flow2

        delay1 = flow1 * T_extra1_h
        delay2 = flow2 * T_extra2_h
        total_delay_s = (delay1 + delay2) * T_event_h

    strategy_delays[s_id] = total_delay_s
    print(f"  Flow Alt1 = {flow1:.0f}, Flow Alt2 = {flow2:.0f}, Unserved = {unserved:.0f}")
    print(f"  Estimated Total Rerouting Delay = {total_delay_s:.2f} veh-h")
    if local_allowed: print(f"  (Ignoring delay for {Lambda_local_allowed} veh/h local traffic)")

# --- Gurobi Model ---
model = gp.Model("ProtestReroutingStrategy")

# --- Decision Variables ---
y = model.addVars(strategy_ids, vtype=GRB.BINARY, name="ChooseStrategy")

# --- Constraints ---
model.addConstr(gp.quicksum(y[s] for s in strategy_ids) == 1, name="SelectOneStrategy")

# --- Objective Function ---
objective = gp.LinExpr()
for s_id in strategy_ids:
    delay = strategy_delays[s_id]
    if delay == float('inf'):
        delay = 1e12
    objective += y[s_id] * delay
model.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    chosen_strategy_id = -1
    for s_id in strategy_ids:
        if y[s_id].X > 0.9:
            chosen_strategy_id = s_id
            break

    if chosen_strategy_id != -1:
         desc, _, _ = strategies_def[chosen_strategy_id]
         print(f"Optimal Strategy: ID {chosen_strategy_id} ({desc})")
         min_delay_val = model.objVal
         if min_delay_val >= 1e11:
              print(f" Minimum Total Delay: Infeasible / Extremely Large (Demand exceeds capacity)")
         else:
              print(f" Minimum Total Rerouting Delay: {model.objVal:.2f} vehicle-hours")
    else:
         print("Error: No strategy selected.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- Total Delay Calculation per Strategy ---
 Strategy 1 (Force All Reroute, No Boost):
  Rerouted Demand = 4296 veh/h
  Alt1 Cap = 2628, Alt2 Cap = 2986, Total Alt Cap = 5614
  Flow Alt1 = 2628, Flow Alt2 = 1668, Unserved = 0
  Estimated Total Rerouting Delay = 2160.75 veh-h
 Strategy 2 (Force All Reroute, Boost):
  Rerouted Demand = 4296 veh/h
  Alt1 Cap = 2935, Alt2 Cap = 3335, Total Alt Cap = 6269
  Flow Alt1 = 2935, Flow Alt2 = 1361, Unserved = 0
  Estimated Total Rerouting Delay = 2119.11 veh-h
 Strategy 3 (Allow Local, No Boost):
  Rerouted Demand = 3763 veh/h
  Alt1 Cap = 2628, Alt2 Cap = 2986, Total Alt Cap = 5614
  Flow Alt1 = 2628, Flow Alt2 = 1135, Unserved = 0
  Estimated Total Rerouting Delay = 1848.51 veh-h
  (Ignoring delay for 532.7759393925526 veh/h local traffic)
 Strategy 4 (Allow Local, Boost):
  Rerouted Demand = 3763 veh/h
  Alt1 Cap = 2935, Alt2 Cap = 3335, Total Alt Cap = 6269
  Flow Alt1 = 2935, Flow Alt2 = 828, Unserved = 0
  Estimated Total Rerouting Delay = 1806.87 veh-h
  (Ignoring delay for 532.7759393925526 veh/h local traffic)
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 4 columns and 4 nonzeros
Model fingerprint: 0xb6e3351d
Variable types: 0 continuous, 4 integer (4 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [2e+03, 2e+03]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 2160.7497264
Presolve removed 1 rows and 4 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 2: 1806.87 2160.75 

Optimal solution found (tolerance 1.00e-04)
Best objective 1.806869215302e+03, best bound 1.806869215302e+03, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Strategy: ID 4 (Allow Local, Boost)
 Minimum Total Rerouting Delay: 1806.87 vehicle-hours



================================================================================



--- Problem 195 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
At a busy port, the harbor master is tasked with coordinating the berthing times for ships arriving from two different directions: East-West (EW) and North-South (NS). The port operates on a fixed cycle time of 166 minutes, during which each phase must account for berthing time, a 4-minute safety interval, and a 1-minute clearance period (totaling 5 minutes of "lost time" per phase). The minimum berthing time for either direction is set to 11 minutes to ensure safe operations and avoid congestion.  

The EW approach experiences an arrival flow of 338 ship arrivals per day against a saturation flow (maximum capacity) of 1,744 ship arrivals per day, while the NS direction sees heavier demand with 979 arrivals against a saturation flow of 1,664. To prioritize efficiency, the harbor master aims to allocate berthing times proportionally to the *degree of saturation* (arrival flow divided by saturation flow) for each direction. The core question is: *How should berthing times be split between EW and NS phases to maximize the weighted sum of berthing times, ensuring the total cycle time constraint is met?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `b_ew`: Continuous variable representing berthing time (minutes) for the EW phase, with a lower bound of 11.  
     - `b_ns`: Continuous variable representing berthing time (minutes) for the NS phase, with a lower bound of 11.  

   - **2. Parameters:**  
     - Cycle time: 166 minutes.  
     - Lost time per phase: 5 minutes (safety + clearance).  
     - EW arrival flow (`arr_flow_ew`): 338 ship arrivals/day.  
     - EW saturation flow (`sat_flow_ew`): 1,744 ship arrivals/day.  
     - NS arrival flow (`arr_flow_ns`): 979 ship arrivals/day.  
     - NS saturation flow (`sat_flow_ns`): 1,664 ship arrivals/day.  
     - Weights: `weight_ew = arr_flow_ew / sat_flow_ew`, `weight_ns = arr_flow_ns / sat_flow_ns`.  

   - **3. Objective Function:**  
     Maximize the weighted sum of berthing times:  
     ```  
     Maximize: weight_ew * b_ew + weight_ns * b_ns  
     ```  

   - **4. Constraints:**  
     - Total cycle time must equal 166 minutes:  
       ```  
       b_ew + lost_time_per_phase + b_ns + lost_time_per_phase = cycle_time  
       ```  
     - Non-negativity and minimum berthing time:  
       ```  
       b_ew >= 11, b_ns >= 11  
       ```  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cycle_time = 166
safety_time = 4
clearance_time = 1
min_berth = 11
sat_flow_ew = 1744
arr_flow_ew = 338
sat_flow_ns = 1664
arr_flow_ns = 979
lost_time_per_phase = 5 # safety + clearance
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTHING_TIMING", env=env)

    # --- Decision Variables ---
    # b_ew: berthing time for East-West phase (minutes)
    b_ew = m.addVar(lb=min_berth, vtype=GRB.CONTINUOUS, name="b_ew")
    # b_ns: berthing time for North-South phase (minutes)
    b_ns = m.addVar(lb=min_berth, vtype=GRB.CONTINUOUS, name="b_ns")

    # --- Objective Function: Maximize weighted berthing times ---
    # Weight by flow/saturation ratio (degree of saturation)
    # Avoid division by zero
    weight_ew = arr_flow_ew / sat_flow_ew if sat_flow_ew > 1e-6 else 0
    weight_ns = arr_flow_ns / sat_flow_ns if sat_flow_ns > 1e-6 else 0
    m.setObjective(weight_ew * b_ew + weight_ns * b_ns, GRB.MAXIMIZE)

    # --- Constraints ---
    # Cycle time constraint: sum of phase times must equal cycle time
    # Phase time = berthing + lost_time_per_phase
    m.addConstr(b_ew + lost_time_per_phase + b_ns + lost_time_per_phase == cycle_time, "CycleTimeConstraint")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['b_ew_sol'] = b_ew.X # Not needed for output
        # results_dict['b_ns_sol'] = b_ns.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Format objective value (weighted berthing time sum)
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show more decimals for weighted sum
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the decision variables
if m.Status == GRB.OPTIMAL:
    print(f"Optimal berthing time for EW: {b_ew.X:.4f} minutes")
    print(f"Optimal berthing time for NS: {b_ns.X:.4f} minutes")
```
Answer:
Optimal objective value: 87.4414
Optimal berthing time for EW: 11.0000 minutes
Optimal berthing time for NS: 145.0000 minutes


```

================================================================================



--- Problem 196 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port is managed by a three-phase berthing system, where each phase controls the flow of ships from a specific direction. The port managers face the challenge of minimizing total ship waiting time—a critical measure of congestion and operational efficiency—by carefully allocating berthing time to each phase. The total cycle time for the berthing system is fixed at 73 hours, and each phase must receive a berthing time between 22 and 73 hours. Ship traffic varies by phase, with coefficients of 2275, 1907, and 1313 ships per day, respectively, indicating the relative demand for each direction. The waiting time for ships in a phase increases with the non-berthing time they experience, which is simply the cycle time minus the berthing time allocated to that phase. The core question is: *How should the 73-hour cycle be divided among the three phases to minimize the total waiting time experienced by all ships?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `t_i`: Continuous variable representing the berthing time (in hours) allocated to phase `i`, where `i ∈ {1, 2, 3}`.  
   - Bounds: `22 ≤ t_i ≤ 73` for each phase.  

   **2. Parameters:**  
   - `flow_coeffs = [2275, 1907, 1313]`: Ship traffic flow coefficients (ships/day) for phases 1, 2, and 3.  
   - `cycle_time = 73`: Total fixed cycle time (hours).  
   - `lb_time = 22`, `ub_time = 73`: Lower and upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize the total waiting time, calculated as:  
   ```  
   Minimize: sum(flow_coeffs[i] * (cycle_time - t_i) for all phases i)  
   ```  

   **4. Constraints:**  
   - **Total cycle time:** The sum of berthing times must equal the cycle time:  
     ```  
     t_1 + t_2 + t_3 = 73  
     ```  
   - **Variable bounds:** Each `t_i` must lie within its specified range:  
     ```  
     22 ≤ t_i ≤ 73 for all i  
     ```  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 3
lb_time = 22          # Lower bound for berthing time
ub_time = 73          # Upper bound for berthing time
cycle_time = 73       # Total cycle time (set equal to ub_time)
flow_coeffs = [2275, 1907, 1313] # Ship traffic flow coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for phase i is proportional to flow * non-berthing_time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 264320.00
------------------------------
Optimal berthing times (hours):
  t1: 29.00, t2: 22.00, t3: 22.00


```

================================================================================



--- Problem 197 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy distribution center is tasked with efficiently managing the arrival and unloading of trucks to minimize both delays and operational costs. Five trucks (T1–T5) arrive at staggered times (T1 at 5 hours, T2 at 8 hours, etc.), each requiring varying processing times (4–8 hours) at one of three available depots (D1–D3). Delays are costly: each hour a truck waits before unloading incurs a penalty ($106–$137/hour, depending on the truck). Additionally, unloading a truck at a specific depot has its own cost rate ($43–$69/hour), reflecting differences in equipment or labor. The distribution center aims to balance two competing priorities: minimizing the total time to service all trucks (makespan) and reducing the combined costs of waiting and unloading. A weighted objective function (75% emphasis on makespan, 25% on costs) guides the optimization. The core question: *What depot assignment and scheduling sequence for the trucks achieve the optimal trade-off between speed and cost?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary `assign[i,j]`: 1 if truck *i* is assigned to depot *j*, else 0.  
     - Continuous `start_time[i]`: When truck *i* begins service.  
     - Continuous `completion_time[i]`: When truck *i* finishes (`start_time[i] + processing_time[i]`).  
     - Binary `precedes[i,k,j]`: 1 if truck *i* is serviced before truck *k* on depot *j*.  
     - Continuous `makespan`: Latest completion time across all trucks.  

   - **2. Parameters:**  
     - `arrival_times[i]`: Truck *i*'s arrival (e.g., T1: 5).  
     - `processing_times[i]`: Hours to service truck *i* (e.g., T1: 4).  
     - `waiting_costs[i]`: Cost/hour for truck *i* waiting (e.g., T1: $137).  
     - `service_costs[i,j]`: Cost/hour to service truck *i* at depot *j* (e.g., (T1,D1): $66).  
     - `alpha=0.75`, `beta=0.25`: Weights for makespan and total cost.  

   - **3. Objective Function:**  
     Minimize: `0.75 * makespan + 0.25 * (total_waiting_cost + total_service_cost)`, where:  
     - `total_waiting_cost = sum(waiting_costs[i] * (start_time[i] - arrival_times[i]))`  
     - `total_service_cost = sum(service_costs[i,j] * processing_times[i] * assign[i,j])`.  

   - **4. Constraints:**  
     - Each truck assigned to exactly one depot: `sum(assign[i,j] for j in depots) = 1` for all *i*.  
     - Start time ≥ arrival time: `start_time[i] ≥ arrival_times[i]` for all *i*.  
     - Non-overlapping at depots: For each depot *j*, if trucks *i* and *k* are assigned there, either `start_time[k] ≥ completion_time[i]` or vice versa (enforced via `precedes`).  
     - Makespan definition: `makespan ≥ completion_time[i]` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2, 3]
arrival_times = {1: 5, 2: 8, 3: 10, 4: 15, 5: 19}
processing_times = {1: 4, 2: 5, 3: 5, 4: 4, 5: 8}
waiting_costs = {1: 137, 2: 106, 3: 136, 4: 122, 5: 137} # Cost per hour waiting
service_costs = {(1, 1): 66, (1, 2): 43, (1, 3): 60, (2, 1): 49, (2, 2): 65, (2, 3): 52, (3, 1): 64, (3, 2): 60, (3, 3): 51, (4, 1): 66, (4, 2): 69, (4, 3): 61, (5, 1): 65, (5, 2): 44, (5, 3): 51} # Cost rate per hour servicing {(truck, depot): cost}
alpha = 0.75 # Weight for Makespan
beta = 0.25  # Weight for Total Cost
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_16_WEIGHTED_OBJ")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    waiting_cost_expr = gp.quicksum(waiting_costs.get(i, 0) * (start_time[i] - arrival_times.get(i, 0)) for i in trucks)
    service_cost_expr = gp.quicksum(service_costs.get((i,j), 0) * processing_times.get(i, 0) * assign[i,j]
                                   for i in trucks for j in depots)
    total_cost = waiting_cost_expr + service_cost_expr
    m.setObjective(alpha * makespan + beta * total_cost, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Weighted objective
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Print Missing Outputs ---

if m.status == GRB.OPTIMAL:
    print(f"Optimal Objective Value: {m.objVal:.4f}")
    
    # Print Depot Assignments
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
    
    # Print Start and Completion Times
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.2f}, Completion Time: {completion_time[i].x:.2f}")
    
    # Print Makespan
    print(f"Makespan: {makespan.x:.2f}")
    
    # Print Total Waiting Cost
    total_waiting_cost = sum(waiting_costs.get(i, 0) * (start_time[i].x - arrival_times.get(i, 0)) for i in trucks)
    print(f"Total Waiting Cost: {total_waiting_cost:.2f}")
    
    # Print Total Service Cost
    total_service_cost = sum(service_costs.get((i, j), 0) * processing_times.get(i, 0) * assign[i, j].x for i in trucks for j in depots)
    print(f"Total Service Cost: {total_service_cost:.2f}")
    
    # Print Total Cost
    total_cost = total_waiting_cost + total_service_cost
    print(f"Total Cost: {total_cost:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
761.7500
Optimal Objective Value: 761.7500
Truck 1 is assigned to Depot 2
Truck 2 is assigned to Depot 1
Truck 3 is assigned to Depot 3
Truck 4 is assigned to Depot 3
Truck 5 is assigned to Depot 2
Truck 1 - Start Time: 5.00, Completion Time: 9.00
Truck 2 - Start Time: 9.00, Completion Time: 14.00
Truck 3 - Start Time: 14.00, Completion Time: 19.00
Truck 4 - Start Time: 19.00, Completion Time: 23.00
Truck 5 - Start Time: 23.00, Completion Time: 31.00
Makespan: 31.00
Total Waiting Cost: 1686.00
Total Service Cost: 1268.00
Total Cost: 2954.00


```

================================================================================



--- Problem 198 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy container port is facing the challenge of efficiently assigning incoming ships to available berths across its three docks. Each dock has distinct characteristics: Dock 1 offers 142 total slots but currently has 12 empty spaces, Dock 2 has 120 slots with 7 vacancies, and Dock 3, with 113 slots, has 48 open spots. A wave of 54 ships is arriving, and the port must assign them to these docks while minimizing the cost of guidance—directing ships to Dock 1 costs $6 per ship, while Docks 2 and 3 each incur a higher cost of $15 per ship. The port’s goal is to allocate all arriving ships without exceeding the available slots on any dock, ensuring the total guidance cost is as low as possible. The critical question is: *How should the ships be distributed across the three docks to achieve this cost-minimizing objective?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `n[i]`: An integer variable representing the number of ships assigned to dock `i` (where `i` can be 1, 2, or 3).  

   **2. Parameters:**  
   - `empty_slots[i]`: The number of available slots on dock `i` (12 for Dock 1, 7 for Dock 2, 48 for Dock 3).  
   - `arriving_ships`: Total ships to assign (54).  
   - `guidance_cost[i]`: Cost per ship directed to dock `i` ($6 for Dock 1, $15 for Docks 2 and 3).  

   **3. Objective Function:**  
   Minimize the total guidance cost:  
   \[
   \text{Minimize: } 6 \cdot n[1] + 15 \cdot n[2] + 15 \cdot n[3]
   \]  

   **4. Constraints:**  
   - All ships must be assigned:  
     \[
     n[1] + n[2] + n[3] = 54
     \]  
   - Ships assigned to each dock cannot exceed its empty slots:  
     \[
     n[1] \leq 12, \quad n[2] \leq 7, \quad n[3] \leq 48
     \]  
   - Non-negativity and integer constraints for `n[i]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
docks = [1, 2, 3]
capacity = {1: 142, 2: 120, 3: 113} # For context
empty_slots = {1: 12, 2: 7, 3: 48}
arriving_ships = 54
guidance_cost = {1: 6, 2: 15, 3: 15} # Cost per ship guided to dock i
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_DOCK_GUIDANCE", env=env)

    # --- Input Validation ---
    if not docks: raise ValueError("Empty docks list")
    if arriving_ships < 0: raise ValueError("Arriving ships cannot be negative")
    if sum(empty_slots.get(i, 0) for i in docks) < arriving_ships:
        # This case should be prevented by generator, but double-check
        print("Warning: Total empty slots less than arriving ships, likely infeasible.")
        # raise ValueError("Total empty slots less than arriving ships")

    # --- Decision Variables ---
    # n[i]: number of ships assigned to dock i
    n = m.addVars(docks, vtype=GRB.INTEGER, lb=0, name="n")

    # --- Objective Function: Minimize total guidance cost ---
    m.setObjective(gp.quicksum(guidance_cost.get(i, 0) * n[i] for i in docks), GRB.MINIMIZE)

    # --- Constraints ---
    # Total number of assigned ships must equal arriving ships
    m.addConstr(gp.quicksum(n[i] for i in docks) == arriving_ships, "TotalShips")

    # Number of assigned ships cannot exceed empty slots on each dock
    m.addConstrs((n[i] <= empty_slots.get(i, 0) for i in docks), "DockCapacity")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_sol'] = m.getAttr('X', n) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible. Not enough total capacity for arriving ships.") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the number of ships assigned to each dock
if m.Status == GRB.OPTIMAL:
    for i in docks:
        print(f"Number of ships assigned to Dock {i}: {n[i].X}")
```
Answer:
Optimal objective value: 702.00
Number of ships assigned to Dock 1: 12.0
Number of ships assigned to Dock 2: 7.0
Number of ships assigned to Dock 3: 35.0


```

================================================================================



--- Problem 199 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling six delivery trucks (`1` to `6`) to a single loading dock (`1`), where each truck arrives at a specific time, requires a fixed processing duration, and has a strict deadline for completion. The hub manager must sequence the trucks to minimize total tardiness—the cumulative delay beyond their due times—while respecting arrival times and avoiding overlaps in dock usage.  

   Trucks arrive at staggered intervals: Truck `1` at time `4`, Truck `2` at `5`, and so on, with the latest arrival being Truck `6` at `15`. Processing times vary, from `4` units for Truck `1` to `8` units for Truck `3`. Deadlines range from `9` (Truck `1`) to `39` (Truck `6`). The core question: *What is the optimal schedule that minimizes total tardiness across all trucks, ensuring no two trucks occupy the dock simultaneously and each starts only after arrival?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary (1 if truck `i` is assigned to dock `j`; always `1` here).  
   - `start_time[i]`: Continuous, start time of truck `i`.  
   - `completion_time[i]`: Continuous, completion time of truck `i` (start + processing time).  
   - `precedes[i, k, j]`: Binary (1 if truck `i` precedes truck `k` on dock `j`).  
   - `tardiness[i]`: Continuous, delay of truck `i` (max(0, completion time − due time)).  

   **2. Parameters:**  
   - `arrival_times[i]`: Truck `i`’s arrival time (e.g., `arrival_times[1] = 4`).  
   - `processing_times[i]`: Truck `i`’s processing duration (e.g., `processing_times[3] = 8`).  
   - `due_times[i]`: Truck `i`’s deadline (e.g., `due_times[2] = 14`).  
   - `H = 100`: A large constant for logical constraints.  

   **3. Objective Function:**  
   Minimize total tardiness:  
   ```  
   Minimize: sum(tardiness[i] for all trucks i)  
   ```  

   **4. Constraints:**  
   - *Assignment*: Each truck `i` must use the dock (`assign[i, 1] = 1`).  
   - *Arrival time*: `start_time[i] ≥ arrival_times[i]`.  
   - *Completion time*: `completion_time[i] = start_time[i] + processing_times[i]`.  
   - *Non-overlapping*: For trucks `i` and `k` (`i < k`), either `i` precedes `k` (`start_time[k] ≥ completion_time[i]`) or vice versa.  
   - *Tardiness*: `tardiness[i] ≥ completion_time[i] − due_times[i]` (zero if early).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
docks = [1] # Should be [1]
arrival_times = {1: 4, 2: 5, 3: 7, 4: 8, 5: 12, 6: 15}
processing_times = {1: 4, 2: 6, 3: 8, 4: 5, 5: 4, 6: 5}
due_times = {1: 9, 2: 14, 3: 23, 4: 25, 5: 25, 6: 39}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DOCKING_PROBLEM_4_MIN_TARDINESS")

    if not trucks or not docks or len(docks)!=1: raise ValueError("Invalid trucks/docks")
    the_dock = docks[0]

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign") # Trivial but keep
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes")
    tardiness = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="tardiness")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(tardiness[i] for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_dock] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (on the single dock) using Indicators
    j = the_dock
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                # Link precedence var: if both assigned (always true), one must precede
                m.addConstr(precedes[i,k,j] + (1-precedes[i,k,j]) == 1, name=f"link_prec_{i}_{k}_{j}") # Enforce binary explicitly

    # 5. Tardiness definition
    m.addConstrs((tardiness[i] >= completion_time[i] - due_times.get(i, 0) for i in trucks), name="tardiness_calc")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Tardiness
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the start times, completion times, and tardiness for each truck
if m.status == GRB.OPTIMAL:
    for i in trucks:
        print(f"Truck {i}: Start Time = {start_time[i].x:.4f}, Completion Time = {completion_time[i].x:.4f}, Tardiness = {tardiness[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
7.0000
Truck 1: Start Time = 4.0000, Completion Time = 8.0000, Tardiness = 0.0000
Truck 2: Start Time = 8.0000, Completion Time = 14.0000, Tardiness = 0.0000
Truck 3: Start Time = 14.0000, Completion Time = 22.0000, Tardiness = 0.0000
Truck 4: Start Time = 26.0000, Completion Time = 31.0000, Tardiness = 6.0000
Truck 5: Start Time = 22.0000, Completion Time = 26.0000, Tardiness = 1.0000
Truck 6: Start Time = 31.0000, Completion Time = 36.0000, Tardiness = 0.0000


```

================================================================================



--- Problem 200 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
In a busy port, the operations team is tasked with optimizing the berthing schedule for ships to maximize the number of ships that can be processed per hour while adhering to safety and operational constraints. The port handles two primary ship flows: North-South (NS) with an arrival rate of 728.11 ships per hour and East-West (EW) with 498.36 ships per hour. Each direction has a shared saturation flow rate of 1,554.69 ships per hour per berth, with approximately 1.87 berths available. Lost time per berthing phase—due to docking and undocking—is fixed at 4.09 minutes. The berthing cycle must stay within strict bounds: no shorter than 65.77 minutes (to prevent excessive switching) and no longer than 117.60 minutes (to avoid unacceptable delays). Additionally, each berthing phase must last at least 19.44 minutes to ensure safe docking.

The core question is: *How should the cycle length and berthing times be allocated between the NS and EW directions to maximize total hourly throughput without violating these constraints?*

**Modeling Process:**
- **1. Decision Variables:**  
     - `C`: Cycle length (minutes), bounded between `C_min` (65.77) and `C_max` (117.60).  
     - `g_NS`, `g_EW`: Berthing times (minutes) for NS and EW, each ≥ `g_min_time` (19.44).  
     - `lambda_g_NS`, `lambda_g_EW`: Fraction of cycle allocated to NS/EW berthing times (unitless, [0, 1]).  
     - `Cap_NS`, `Cap_EW`: Hourly capacity (ships/hour) for NS and EW flows.  

   - **2. Parameters:**  
     - `lambda_NS_h`, `lambda_EW_h`: Arrival rates (ships/h).  
     - `S_fog_lane_h`: Saturation flow per berth (ships/h/berth).  
     - `N_lanes`: Effective number of berths (1.87).  
     - `L_lost_time_per_phase`: Lost time per phase (4.09 min).  

   - **3. Objective Function:**  
     Maximize total throughput:  
     ```  
     Maximize: Cap_NS + Cap_EW  
     ```  

   - **4. Constraints:**  
     - Cycle composition: `C = g_NS + g_EW + 2 * L_lost_time_per_phase`.  
     - Berthing time fractions: `lambda_g_NS * C = g_NS`, `lambda_g_EW * C = g_EW`.  
     - Capacity calculations:  
       `Cap_NS = N_lanes * S_fog_lane_h * lambda_g_NS`,  
       `Cap_EW = N_lanes * S_fog_lane_h * lambda_g_EW`.

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
lambda_NS_h = 728.106922301271  # ships/h
lambda_EW_h = 498.35611171785354  # ships/h
S_fog_lane_h = 1554.6868984063342  # ships/h/berth
N_lanes = 1.8651781848068227
L_lost_time_per_phase = 4.091640001055485  # min
C_min = 65.77362459046313  # min
C_max = 117.59658165125026  # min
g_min_time = 19.435665768320973  # min

# --- Gurobi Model ---
model = gp.Model("PortBerthingSchedule")

# Decision Variables
C = model.addVar(name="CycleLength", lb=C_min, ub=C_max)
g_NS = model.addVar(name="Berthing_NS", lb=g_min_time)
g_EW = model.addVar(name="Berthing_EW", lb=g_min_time)

# Intermediate Variables
lambda_g_NS = model.addVar(name="lambda_g_NS", lb=0.0, ub=1.0)
lambda_g_EW = model.addVar(name="lambda_g_EW", lb=0.0, ub=1.0)
Cap_NS = model.addVar(name="Capacity_NS", lb=0.0)
Cap_EW = model.addVar(name="Capacity_EW", lb=0.0)

# Constraints
model.addConstr(C == g_NS + g_EW + 2 * L_lost_time_per_phase, name="CycleComposition")
model.addQConstr(lambda_g_NS * C == g_NS, name="CalcLambdaNS")
model.addQConstr(lambda_g_EW * C == g_EW, name="CalcLambdaEW")
model.addConstr(Cap_NS == N_lanes * S_fog_lane_h * lambda_g_NS, name="CalcCapacityNS")
model.addConstr(Cap_EW == N_lanes * S_fog_lane_h * lambda_g_EW, name="CalcCapacityEW")

# Objective
model.setObjective(Cap_NS + Cap_EW, GRB.MAXIMIZE)

# Optimize
model.Params.NonConvex = 2
model.optimize()

# Output
if model.status == GRB.OPTIMAL:
    print("\n--- Port Berthing Schedule Results ---")
    print(f"Optimal Cycle Length: {C.X:.2f} min")
    print(f"North-South Berthing Time: {g_NS.X:.2f} min")
    print(f"East-West Berthing Time: {g_EW.X:.2f} min")
    print(f"North-South Capacity: {Cap_NS.X:.2f} ships/h")
    print(f"East-West Capacity: {Cap_EW.X:.2f} ships/h")
    print(f"Total Throughput: {model.objVal:.2f} ships/h")
else:
    print(f"Model status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 3 rows, 7 columns and 7 nonzeros
Model fingerprint: 0x3771596c
Model has 2 quadratic constraints
Coefficient statistics:
  Matrix range     [1e+00, 3e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [1e+00, 1e+02]
  RHS range        [8e+00, 8e+00]
Presolve removed 2 rows and 2 columns

Continuous model is non-convex -- solving as a MIP

Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolved: 9 rows, 6 columns, 27 nonzeros
Presolved model has 2 bilinear constraint(s)
Variable types: 6 continuous, 0 integer (0 binary)
Found heuristic solution: objective 2697.9797880

Root relaxation: objective 3.321821e+03, 3 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0 3321.82074    0    2 2697.97979 3321.82074  23.1%     -    0s
     0     0 3122.13883    0    2 2697.97979 3122.13883  15.7%     -    0s
     0     2 3122.13883    0    2 2697.97979 3122.13883  15.7%     -    0s

Explored 87 nodes (56 simplex iterations) in 0.02 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 2697.98 

Optimal solution found (tolerance 1.00e-04)
Best objective 2.697979787954e+03, best bound 2.697979787954e+03, gap 0.0000%

--- Port Berthing Schedule Results ---
Optimal Cycle Length: 117.60 min
North-South Berthing Time: 54.71 min
East-West Berthing Time: 54.71 min
North-South Capacity: 1348.99 ships/h
East-West Capacity: 1348.99 ships/h
Total Throughput: 2697.98 ships/h



================================================================================



--- Problem 201 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the operations team is tasked with coordinating the berthing times for three different types of ships to minimize the total waiting time. Each ship type has a specific number of arrivals: Ship Type 1 has 207 arrivals, Ship Type 2 has 2,383 arrivals, and Ship Type 3 has 568 arrivals. The berthing times for each ship type must be allocated within strict bounds—no less than 5 hours and no more than 22 hours—while ensuring the total cycle time (the sum of all berthing times) remains fixed at 22 hours. The core objective is to strategically distribute these berthing times to minimize the cumulative waiting time experienced by all ships, where the waiting time for each ship type is proportional to its arrival volume multiplied by its non-berthing time (the cycle time minus its berthing time). The critical question is: *What is the optimal allocation of berthing times across the three ship types to achieve the smallest possible total waiting time?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Let \( t_i \) represent the berthing time (in hours) allocated to ship type \( i \), where \( i \in \{1, 2, 3\} \). Each \( t_i \) is a continuous variable bounded between 5 and 22 hours.  

   **2. Parameters:**  
   - \( \text{arrival_coeffs} = [207, 2383, 568] \): Arrival coefficients for each ship type.  
   - \( \text{cycle_time} = 22 \): Total fixed cycle time (hours).  
   - \( \text{lb_time} = 5 \), \( \text{ub_time} = 22 \): Lower and upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize the total waiting time:  
   \[
   \text{Minimize: } \sum_{i=1}^{3} \text{arrival_coeffs}[i-1] \cdot (\text{cycle_time} - t_i)
   \]  

   **4. Constraints:**  
   - **Total cycle time:** The sum of berthing times must equal the cycle time:  
     \[
     t_1 + t_2 + t_3 = 22
     \]  
   - **Bounds on berthing times:**  
     \[
     5 \leq t_i \leq 22 \quad \text{for } i \in \{1, 2, 3\}
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_ship_types = 3
lb_time = 5          # Lower bound for berthing time
ub_time = 22          # Upper bound for berthing time
cycle_time = 22   # Total cycle time (set equal to ub_time)
arrival_coeffs = [207, 2383, 568] # Arrival coefficients per ship type
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_coeffs) != num_ship_types:
    print("Error: arrival_coeffs length mismatch with num_ship_types")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_coeffs length"
    # raise ValueError("arrival_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_ship_types}-Ship Type Berthing Time", env=env)

        # --- Decision variables (dynamic based on num_ship_types) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_ship_types, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for ship type i is proportional to arrival * non-berthing_time = arrival * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_ship_types)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_ship_types)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_ship_types)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_ship_types):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 37005.00
------------------------------
Optimal berthing times (hours):
  t1: 5.00, t2: 12.00, t3: 5.00


```

================================================================================



--- Problem 202 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy port terminal, often shrouded in dense fog, presents a critical challenge for maritime logistics. The terminal handles a steady stream of ships from two directions: north-south (NS) and east-west (EW). The arrival rates are 726.44 and 507.62 ships per hour, respectively. Each approach has a saturation flow rate of 1,598.81 ships per hour per berth, scaled by 2.17 berths to reflect real-world capacity. The traffic signal must balance the green time allocation while accounting for 4.24 seconds of lost time per phase—precious seconds wasted during transitions. Port managers face tight constraints: the cycle length must stay between 63.25 and 102.48 seconds, with each green phase lasting at least 20.20 seconds to ensure safe ship movements. The core dilemma? How to split the limited cycle time between NS and EW flows to maximize total throughput, ensuring the terminal clears as many ships as possible while fog reduces visibility and efficiency.
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `C`: Cycle length (seconds), bounded between `C_min` and `C_max`.  
- `g_NS`, `g_EW`: Green times (seconds) for NS and EW phases, each ≥ `g_min_time`.  
- `lambda_g_NS`, `lambda_g_EW`: Effective green ratios (fractions of `C` allocated to each phase).  
- `Cap_NS`, `Cap_EW`: Hourly capacities (ships/hour) for each approach.  

**2. Parameters:**  
- Arrival rates: `lambda_NS_h = 726.44`, `lambda_EW_h = 507.62` (ships/h).  
- Saturation flow: `S_fog_berth_h = 1,598.81` (ships/h/berth), scaled by `N_berths = 2.17`.  
- Lost time: `L_lost_time_per_phase = 4.24` seconds (applied twice per cycle).  
- Bounds: `C_min = 63.25`, `C_max = 102.48`; `g_min_time = 20.20` seconds.  

**3. Objective Function:**  
Maximize total throughput:  
`Maximize: Cap_NS + Cap_EW`  
where capacities are calculated as:  
`Cap_NS = S_fog_approach_h * lambda_g_NS`,  
`Cap_EW = S_fog_approach_h * lambda_g_EW`.  

**4. Constraints:**  
- **Cycle composition:** `C = g_NS + g_EW + 2 * L_lost_time_per_phase`.  
- **Green ratios:** `lambda_g_NS * C = g_NS`, `lambda_g_EW * C = g_EW` (quadratic).  
- **Capacity definitions:** As above.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
lambda_NS_h = 726.4422162460338  # ships/h
lambda_EW_h = 507.617070544283  # ships/h
S_fog_berth_h = 1598.814164232784  # ships/h/berth
N_berths = 2.167343748014387
L_lost_time_per_phase = 4.243794796888203  # s
C_min = 63.25050812639973  # s
C_max = 102.4823864579096  # s
g_min_time = 20.20110766893135  # s

S_fog_approach_h = N_berths * S_fog_berth_h

# --- Gurobi Model ---
model = gp.Model("FogSignalTiming")

# --- Decision Variables ---
C = model.addVar(name="CycleLength", lb=C_min, ub=C_max)
g_NS = model.addVar(name="Green_NS", lb=g_min_time) # Actual green time NS
g_EW = model.addVar(name="Green_EW", lb=g_min_time) # Actual green time EW

# --- Intermediate Variables ---
# Effective green ratios (lambda = g/C)
lambda_g_NS = model.addVar(name="lambda_g_NS", lb=0.0, ub=1.0) # g_NS / C
lambda_g_EW = model.addVar(name="lambda_g_EW", lb=0.0, ub=1.0) # g_EW / C
# Capacities
Cap_NS = model.addVar(name="Capacity_NS", lb=0.0)
Cap_EW = model.addVar(name="Capacity_EW", lb=0.0)

# --- Constraints ---
# 1. Cycle length composition (2 phases)
model.addConstr(C == g_NS + g_EW + 2 * L_lost_time_per_phase, name="CycleComposition")

# 2. Calculate effective green ratios (non-linear: lambda = g/C)
# lambda * C = g
model.addQConstr(lambda_g_NS * C == g_NS, name="CalcLambdaNS")
model.addQConstr(lambda_g_EW * C == g_EW, name="CalcLambdaEW")

# 3. Calculate approach capacities
# Cap = S * lambda_g
model.addConstr(Cap_NS == S_fog_approach_h * lambda_g_NS, name="CalcCapacityNS")
model.addConstr(Cap_EW == S_fog_approach_h * lambda_g_EW, name="CalcCapacityEW")

# --- Objective Function ---
# Maximize total throughput (sum of capacities)
model.setObjective(Cap_NS + Cap_EW, GRB.MAXIMIZE)

# --- Optimize ---
# Needs NonConvex capabilities due to quadratic constraints (g = lambda * C)
model.Params.NonConvex = 2
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL or model.status == GRB.SUBOPTIMAL:
    print(f"Optimization Status: {model.status}")
    print(f"Optimal Cycle Length (C): {C.X:.2f} s")
    print(f"Optimal Green Time NS (g_NS): {g_NS.X:.2f} s")
    print(f"Optimal Green Time EW (g_EW): {g_EW.X:.2f} s")
    print(f"  Total Green = {g_NS.X+g_EW.X:.2f}s, Lost Time = {2*L_lost_time_per_phase:.1f}s, Sum = {g_NS.X+g_EW.X+2*L_lost_time_per_phase:.2f}s (matches C)")
    print(f"Resulting Capacity NS: {Cap_NS.X:.2f} ships/h (Demand={lambda_NS_h})")
    print(f"Resulting Capacity EW: {Cap_EW.X:.2f} ships/h (Demand={lambda_EW_h})")
    print(f"Maximized Total Throughput: {model.objVal:.2f} ships/h")
    # Check if demand constraints were implicitly met
    if Cap_NS.X < lambda_NS_h: print("  Warning: NS Demand exceeds capacity.")
    if Cap_EW.X < lambda_EW_h: print("  Warning: EW Demand exceeds capacity.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
    model.computeIIS()
    model.write("model_iis.ilp")
    print("IIS written to model_iis.ilp")
elif model.status == GRB.INF_OR_UNBD:
     print("Optimization Status: Infeasible or Unbounded")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 3 rows, 7 columns and 7 nonzeros
Model fingerprint: 0xabee6cd3
Model has 2 quadratic constraints
Coefficient statistics:
  Matrix range     [1e+00, 3e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [1e+00, 1e+02]
  RHS range        [8e+00, 8e+00]
Presolve removed 2 rows and 2 columns

Continuous model is non-convex -- solving as a MIP

Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolved: 9 rows, 6 columns, 27 nonzeros
Presolved model has 2 bilinear constraint(s)
Variable types: 6 continuous, 0 integer (0 binary)
Found heuristic solution: objective 3178.1937410

Root relaxation: objective 3.745429e+03, 3 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0 3745.42864    0    2 3178.19374 3745.42864  17.8%     -    0s
     0     0 3526.78790    0    2 3178.19374 3526.78790  11.0%     -    0s
     0     2 3526.78790    0    2 3178.19374 3526.78790  11.0%     -    0s

Explored 55 nodes (34 simplex iterations) in 0.03 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 3178.19 

Optimal solution found (tolerance 1.00e-04)
Best objective 3.178193741049e+03, best bound 3.178193741049e+03, gap 0.0000%

--- Optimization Results ---
Optimization Status: 2
Optimal Cycle Length (C): 102.48 s
Optimal Green Time NS (g_NS): 47.00 s
Optimal Green Time EW (g_EW): 47.00 s
  Total Green = 93.99s, Lost Time = 8.5s, Sum = 102.48s (matches C)
Resulting Capacity NS: 1589.10 ships/h (Demand=726.4422162460338)
Resulting Capacity EW: 1589.10 ships/h (Demand=507.617070544283)
Maximized Total Throughput: 3178.19 ships/h



================================================================================



--- Problem 203 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy trucking terminal, two trucks—Truck 1 and Truck 2—arrive at different times, needing to unload their cargo at a single depot. Truck 1 arrives at 4 hours, while Truck 2 arrives later at 8 hours. The terminal management faces a critical scheduling challenge: assigning these trucks to the depot in a way that minimizes their total completion time, ensuring efficient use of limited resources. Each truck’s unloading time varies depending on the depot: Truck 1 takes 3 hours, and Truck 2 requires 7 hours. The goal is to sequence their operations without overlap, respecting arrival times and depot availability, to streamline terminal operations and reduce idle time. The central question is: *What is the optimal schedule that minimizes the combined completion time for both trucks?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary variable (1 if truck *i* is assigned to depot *j*, else 0).  
   - `start_time[i]`: Continuous variable for the start time of truck *i*.  
   - `completion_time[i]`: Continuous variable for the completion time of truck *i*.  
   - `precedes[i, k, j]`: Binary variable (1 if truck *i* is scheduled before truck *k* on depot *j*, else 0).  

   **2. Parameters:**  
   - `trucks = [1, 2]`, `depots = [1]`.  
   - `arrival_times = {1: 4, 2: 8}` (hours).  
   - `unloading_times = {(1, 1): 3, (2, 1): 7}` (hours per truck-depot pair).  
   - `H = 100`: A large constant (Big-M) for linearization.  

   **3. Objective Function:**  
   Minimize the sum of completion times:  
   `Minimize: completion_time[1] + completion_time[2]`.  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot:  
     `For each truck i: sum(assign[i, j] for j in depots) = 1`.  
   - **Arrival Time:** Start time cannot precede arrival:  
     `For each truck i: start_time[i] >= arrival_times[i]`.  
   - **Completion Time:** Defined as start time plus unloading time:  
     `For each truck i: completion_time[i] = start_time[i] + sum(unloading_times[i, j] * assign[i, j] for j in depots)`.  
   - **Non-Overlapping:** For trucks sharing a depot, enforce sequencing:  
     `If precedes[i, k, j] = 1, then start_time[k] >= completion_time[i]` (and vice versa for `precedes[i, k, j] = 0`).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2]
depots = [1]
arrival_times = {1: 4, 2: 8}
unloading_times = {(1, 1): 3, (2, 1): 7} # Dict {(truck, depot): time}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_8_DEPOT_PROC")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(completion_time[i] for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (depot dependent)
    m.addConstrs((completion_time[i] == start_time[i] + gp.quicksum(unloading_times.get((i,j), 0) * assign[i,j] for j in depots)
                  for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1-precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    for i in trucks:
        print(f"Truck {i} start time: {start_time[i].x:.4f}")
        print(f"Truck {i} completion time: {completion_time[i].x:.4f}")
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
    print(f"Objective value: {m.objVal:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
22.0000
Truck 1 start time: 4.0000
Truck 1 completion time: 7.0000
Truck 1 is assigned to Depot 1
Truck 2 start time: 8.0000
Truck 2 completion time: 15.0000
Truck 2 is assigned to Depot 1
Objective value: 22.0000


```

================================================================================



--- Problem 204 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port terminal operates with two types of berths: Automated Berthing (AB) and Manual Berthing (MB). The terminal has 3 AB berths and 3 MB berths, each with distinct processing times—13 minutes per ship for AB and 21 minutes for MB. Over a 210-minute period, a total of 181 ships arrive, with 66% (119 ships) equipped for AB and 34% (62 ships) requiring MB. The berths have capacity limits: AB berths can handle 48.46 ships per period, while MB berths can manage 30.00.  

The challenge is to balance ship assignments to minimize congestion, measured by the maximum volume-to-capacity (V/C) ratio across berths. AB ships can use either berth type, but MB ships are restricted to MB berths. The goal is to distribute AB ships between berth types such that neither berth type becomes disproportionately overloaded, ensuring smooth traffic flow.  

**Core Question:** What is the optimal distribution of AB ships between berth types to minimize the worst-case congestion (V/C ratio) across all berths?  

---
**

Modeling Process:
**
**1. Decision Variables:**  
- `n_ab_ab`: Integer, number of AB ships assigned to AB berths.  
- `n_ab_mb`: Integer, number of AB ships assigned to MB berths.  
- `n_mb_mb`: Integer, number of MB ships (fixed to 62, must use MB berths).  
- `MaxVC`: Continuous, represents the maximum V/C ratio across berths.  

**2. Parameters:**  
- `num_ab_ships = 119`, `num_mb_ships = 62`: Total AB/MB ships.  
- `cap_ab = 48.46`, `cap_mb = 30.00`: Capacities of AB/MB berths.  
- `epsilon = 1e-6`: Small constant to avoid division by zero.  

**3. Objective Function:**  
Minimize `MaxVC` (the worst-case V/C ratio).  

**4. Constraints:**  
- **Ship conservation:**  
  - AB ships: `n_ab_ab + n_ab_mb = 119`.  
  - MB ships: `n_mb_mb = 62`.  
- **V/C ratio bounds:**  
  - For AB berths: `MaxVC * (cap_ab + epsilon) >= n_ab_ab`.  
  - For MB berths: `MaxVC * (cap_mb + epsilon) >= n_ab_mb + n_mb_mb`.  
- **Non-negativity:** All variables >= 0.  

---

Corresponding Code:
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_ab_berths = 3
num_mb_berths = 3
time_ab_mins = 13
time_mb_mins = 21
period_mins = 210
total_arrivals = 181
pct_ab = 0.66
pct_mb = 0.34
# Calculated values
num_ab_ships = 119
num_mb_ships = 62
cap_ab = 48.46
cap_mb = 30.00
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTHING_BALANCING", env=env)

    # --- Decision Variables ---
    # n_ab_ab: Number of AB ships using AB berths
    n_ab_ab = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_ab_ab")
    # n_ab_mb: Number of AB ships using MB berths
    n_ab_mb = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_ab_mb")
    # n_mb_mb: Number of MB ships using MB berths (fixed by input)
    # This can be treated as data, but keep as variable for consistency if needed
    n_mb_mb = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_mb_mb")
    # MaxVC: Maximum V/C ratio across berth types
    MaxVC = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="MaxVC") # V/C >= 0

    # --- Objective Function: Minimize the maximum V/C ratio ---
    m.setObjective(MaxVC, GRB.MINIMIZE)

    # --- Constraints ---
    # Conservation of AB ships
    m.addConstr(n_ab_ab + n_ab_mb == num_ab_ships, "ABConserve")

    # Fix MB ships (must use MB berths)
    m.addConstr(n_mb_mb == num_mb_ships, "MBConserve")

    # Calculate flows
    flow_ab = n_ab_ab
    flow_mb = n_ab_mb + n_mb_mb

    # Max V/C calculation (using linear form MaxVC * Capacity >= Flow)
    # Use epsilon to avoid issues if capacity is exactly zero
    epsilon = 1e-6
    if cap_ab > 0:
        m.addConstr(MaxVC * (cap_ab + epsilon) >= flow_ab, "VC_AB")
    else:
         # If AB capacity is zero, no AB ships can use AB berths
         m.addConstr(n_ab_ab == 0, "ZeroCapAB")

    if cap_mb > 0:
        m.addConstr(MaxVC * (cap_mb + epsilon) >= flow_mb, "VC_MB")
    else:
        # If MB capacity is zero, no ships can use MB berths
        m.addConstr(n_ab_mb == 0, "ZeroCapMB_AB")
        m.addConstr(n_mb_mb == 0, "ZeroCapMB_MB") # Will likely make infeasible if num_mb > 0

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_ab_ab_sol'] = n_ab_ab.X # Not needed for output
        # results_dict['n_ab_mb_sol'] = n_ab_mb.X
        # results_dict['n_mb_mb_sol'] = n_mb_mb.X

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is Max V/C ratio
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show precision
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the decision variables and their values
if m.Status == GRB.OPTIMAL:
    print(f"Optimal objective value: {obj_val_print:.4f}")
    print(f"Number of AB ships assigned to AB berths (n_ab_ab): {n_ab_ab.X}")
    print(f"Number of AB ships assigned to MB berths (n_ab_mb): {n_ab_mb.X}")
    print(f"Number of MB ships assigned to MB berths (n_mb_mb): {n_mb_mb.X}")
```
Answer:
Optimal objective value: 2.3112
Optimal objective value: 2.3112
Number of AB ships assigned to AB berths (n_ab_ab): 112.0
Number of AB ships assigned to MB berths (n_ab_mb): 7.0
Number of MB ships assigned to MB berths (n_mb_mb): 62.0


```

================================================================================



--- Problem 205 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy port terminal must schedule three cargo ships (Ship 1, Ship 2, and Ship 3) to a single available berth while adhering to strict arrival times and a critical maintenance window. Ship 1 arrives at time 5, Ship 2 at time 10, and Ship 3 at time 12. Processing times vary: Ship 1 requires 7 units of time, Ship 2 needs 3, and Ship 3 takes 5. The berth is unavailable for maintenance between time 18 and 26, forcing ships to either finish before 18 or start after 26. Additionally, there is a new constraint that no ship can start processing within 2 hours of its arrival time due to unloading preparations. The terminal manager must determine the optimal schedule to minimize the total completion time (makespan) while respecting these constraints. The challenge lies in sequencing the ships efficiently—either processing them consecutively before maintenance or delaying some until after—to avoid costly overlaps and ensure the berth is used as productively as possible.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign[i, j]`: Binary, 1 if ship *i* is assigned to berth *j* (always 1 here, as there’s only one berth).  
     - `start_time[i]`: Continuous, when ship *i* begins processing.  
     - `completion_time[i]`: Continuous, when ship *i* finishes (`start_time[i] + processing_times[i]`).  
     - `precedes[i, k, j]`: Binary, 1 if ship *i* is scheduled before ship *k* on berth *j*.  
     - `b[i]`: Binary, 1 if ship *i* finishes before maintenance (else starts after).  
     - `makespan`: Continuous, the latest completion time across all ships.  

   - **2. Parameters:**  
     - `arrival_times[i]`: Ship *i*’s arrival (5, 10, 12).  
     - `processing_times[i]`: Ship *i*’s duration (7, 3, 5).  
     - `maint_start=18`, `maint_end=26`: Maintenance window bounds.  
     - `H=100`: A large constant for disjunctive constraints.  

   - **3. Objective Function:**  
     Minimize `makespan` (the latest completion time).  

   - **4. Constraints:**  
     - Each ship is assigned to the berth.  
     - Ships cannot start before arrival.  
     - Completion time = start time + processing time.  
     - Non-overlapping: If ship *i* precedes *k*, *k* starts after *i* finishes (and vice versa).  
     - Maintenance disjunction: For each ship, either `completion_time[i] ≤ 18` or `start_time[i] ≥ 26`.  
     - No ship can start processing within 2 hours of its arrival time.  
     - `makespan` is the maximum completion time.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3]
berths = [1] # Should be [1]
arrival_times = {1: 5, 2: 10, 3: 12}
processing_times = {1: 7, 2: 3, 3: 5}
maint_start = 18
maint_end = 26
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_6_MAINTENANCE")

    if not ships or not berths or len(berths)!=1: raise ValueError("Invalid ships/berths")
    the_berth = berths[0]

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in ships for k in ships if i < k for j in berths],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    b = m.addVars(ships, vtype=GRB.BINARY, name="maint_choice") # For disjunction

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_berth] == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping (using Indicators)
    j = the_berth
    for i in ships:
        for k in ships:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j])) # Link precedence if both assigned (always true here)

    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in ships), name="makespan_def")
    # 6. Maintenance window constraint
    for i in ships:
         m.addConstr(completion_time[i] <= maint_start + H * b[i], name=f"maint_before_{i}")
         m.addConstr(start_time[i] >= maint_end - H * (1 - b[i]), name=f"maint_after_{i}")

    # 7. New constraint: No ship can start processing within 2 hours of its arrival time
    m.addConstrs((start_time[i] >= arrival_times[i] + 2 for i in ships), name="unloading_preparation")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal makespan: {m.objVal:.4f}")
    for i in ships:
        print(f"Ship {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
31.0000
Optimal makespan: 31.0000
Ship 1 - Start Time: 7.0000, Completion Time: 14.0000
Ship 2 - Start Time: 15.0000, Completion Time: 18.0000
Ship 3 - Start Time: 26.0000, Completion Time: 31.0000


```

================================================================================



--- Problem 206 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A maritime logistics company operates a single ship (capacity: 95.3 units) to serve two ports from a central harbor (Node 0). The first port (Node 1) demands 39 units, while the second port (Node 2) requires 47 units. Travel distances are asymmetric: the harbor is 61 nautical miles from Port 1 and 87 nautical miles from Port 2, with Ports 1 and 2 separated by 46 nautical miles. The challenge is to design a route that starts and ends at the harbor, visits each port exactly once, respects the ship’s capacity, and minimizes total travel distance—a classic single-ship routing problem with capacity constraints. The stakes are high: inefficient routing could inflate fuel costs and delay deliveries in this tightly constrained operation.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary `x[i, j, k]`: 1 if ship `k` travels directly from node `i` to `j` (0 otherwise).  
     - Continuous `u[i]`: Auxiliary variable for subtour elimination (MTZ constraint), tracking visitation order for port node `i`.  
   - **2. Parameters:**  
     - `N=3` (harbor + 2 ports), `K=1` (ship), `Q[0]=95.3` (ship capacity).  
     - `q=[0, 39, 47]`: Demands (harbor has 0 demand).  
     - `d[i][j]`: Distance matrix (e.g., `d[0][1]=61`).  
   - **3. Objective Function:**  
     Minimize total distance: `sum(d[i][j] * x[i,j,0] for all i,j where i≠j)`.  
   - **4. Constraints:**  
     - **Visit each port once:** `sum(x[i,j,0] for all j≠i) = 1` for each port `i`.  
     - **Flow conservation:** Inflow equals outflow for each node and ship.  
     - **Harbor departure/return:** Ship leaves and returns to harbor exactly once.  
     - **Capacity:** Total demand on route ≤ 95.3.  
     - **Subtour elimination (MTZ):** `u[i] - u[j] + 2*x[i,j,0] ≤ 1` for all port pairs `i≠j`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 3
K = 1
Q = [95.3]
q = [0, 39, 47]
d = [
    [0, 61, 87],
    [61, 0, 46],
    [87, 46, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each port (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Ship Departure/Return from Harbor (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartHarbor_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnHarbor_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for ship {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for ship {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 194.00

Route for ship 1 (Capacity: 95.3):
0 -> 2 -> 1 -> 0
Route Load: 86 / 95.3


```

================================================================================



--- Problem 207 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy maritime port, a critical scheduling challenge arises: four ships (Ships 1, 2, 3, and 4) must be assigned to a single available berth for unloading and loading operations. Each ship arrives at a specific time—Ship 1 at 3 hours, Ship 2 at 8 hours, Ship 3 at 13 hours, and Ship 4 at 18 hours—and requires a distinct processing time to complete its operations (7, 7, 4, and 8 hours, respectively). The port manager faces the dual challenge of minimizing the total operational time (makespan) while ensuring that Ship 4, designated as the priority vessel due to a service-level agreement (SLA), begins its operations no later than 10.6 hours after its arrival. Additionally, the port manager has decided to enforce a new constraint: Ship 2 must start its operations no later than 15 hours after its arrival. The goal is to orchestrate the berthing schedule such that no two ships occupy the berth simultaneously, all ships are serviced, and both SLA constraints are strictly enforced. The central question is: *What is the optimal sequence of ship assignments to the berth that minimizes the total completion time while guaranteeing the timely service of both Ship 4 and Ship 2?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `assign(i, j)`: 1 if ship *i* is assigned to berth *j*, else 0.  
   - Continuous variable `start_time(i)`: Time when ship *i* begins processing.  
   - Continuous variable `completion_time(i)`: Time when ship *i* finishes processing.  
   - Binary variable `precedes(i, k, j)`: 1 if ship *i* is scheduled before ship *k* on berth *j*, else 0.  
   - Continuous variable `makespan`: Total time until the last ship departs.  

   **2. Parameters:**  
   - `ships`: [1, 2, 3, 4].  
   - `berths`: [1].  
   - `arrival_times`: {1: 3, 2: 8, 3: 13, 4: 18}.  
   - `processing_times`: {1: 7, 2: 7, 3: 4, 4: 8}.  
   - `sla_ship_4`: 4 (priority ship).  
   - `sla_max_wait_4`: 10.6 (max delay for Ship 4).  
   - `sla_ship_2`: 2 (additional priority ship).  
   - `sla_max_wait_2`: 15 (max delay for Ship 2).  

   **3. Objective Function:**  
   Minimize `makespan` (total operational time).  

   **4. Constraints:**  
   - Each ship is assigned to exactly one berth: `sum(assign(i, j) for j in berths) = 1` for all *i*.  
   - Start time cannot precede arrival: `start_time(i) >= arrival_times[i]` for all *i*.  
   - Completion time calculation: `completion_time(i) = start_time(i) + processing_times[i]` for all *i*.  
   - Non-overlapping on the berth: For each pair of ships (*i*, *k*) and berth *j*, enforce precedence logic using `precedes(i, k, j)` and `precedes(k, i, j)`.  
   - SLA constraint for Ship 4: `start_time(4) - arrival_times[4] <= 10.6`.  
   - SLA constraint for Ship 2: `start_time(2) - arrival_times[2] <= 15`.  
   - Makespan definition: `makespan >= completion_time(i)` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3, 4]
berths = [1]
arrival_times = {1: 3, 2: 8, 3: 13, 4: 18}
processing_times = {1: 7, 2: 7, 3: 4, 4: 8}
H = 100 # Big M
sla_ship_4 = 4
sla_max_wait_4 = 10.6
sla_ship_2 = 2
sla_max_wait_2 = 15
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_60_SLA")

    if not ships or not berths: raise ValueError("Empty ships or berths")
    if sla_ship_4 not in ships: raise ValueError("SLA ship 4 not in ships list")
    if sla_ship_2 not in ships: raise ValueError("SLA ship 2 not in ships list")

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(ships, ships, berths, vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in ships), name="makespan_def")
    # 6. SLA Constraint for Ship 4
    m.addConstr(start_time[sla_ship_4] - arrival_times.get(sla_ship_4, 0) <= sla_max_wait_4, name=f"SLA_ship_{sla_ship_4}")
    # 7. SLA Constraint for Ship 2
    m.addConstr(start_time[sla_ship_2] - arrival_times.get(sla_ship_2, 0) <= sla_max_wait_2, name=f"SLA_ship_{sla_ship_2}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Schedule:")
    for i in ships:
        print(f"Ship {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
    print(f"Total Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
29.0000
Optimal Schedule:
Ship 1 - Start Time: 3.0000, Completion Time: 10.0000
Ship 2 - Start Time: 10.0000, Completion Time: 17.0000
Ship 3 - Start Time: 17.0000, Completion Time: 21.0000
Ship 4 - Start Time: 21.0000, Completion Time: 29.0000
Total Makespan: 29.0000


```

================================================================================



--- Problem 208 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
In a busy maritime port, two distinct berthing areas—Berth A and Berth B—are facing an urgent need to evacuate ships due to an incoming storm. Berth A holds 356 ships, while Berth B contains 94, all needing to leave the port efficiently within a tight 29-minute window. The port has a single exit channel (Channel 1), which can process ships at a rate of 23 ships per minute, translating to a total capacity of 667 ships over the entire period. The challenge is to maximize the number of ships evacuated during this time, ensuring no berth exceeds its ship count and the channel’s capacity isn’t overwhelmed. The core question: *How should ships from each berth be directed to the exit channel to evacuate the maximum possible number of ships within the constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `f[i, j]`: Continuous, non-negative flow of ships from berth *i* (Berth_A or Berth_B) to exit channel *j* (Channel 1).  
   - **2. Parameters:**  
     - `berth_ships[i]`: Ships in berth *i* (Berth_A: 356, Berth_B: 94).  
     - `total_channel_capacity[j]`: Channel *j*’s total capacity (Channel 1: 667 ships).  
   - **3. Objective Function:**  
     - Maximize total evacuated ships:  
       `Maximize: sum(f[i, j] for all i, j)`.  
   - **4. Constraints:**  
     - *Berth Supply*: Flow from each berth ≤ its ship count:  
       `sum(f[i, j] for j in channels) ≤ berth_ships[i]` for each berth *i*.  
     - *Channel Capacity*: Flow into channel ≤ its capacity:  
       `sum(f[i, j] for i in berths) ≤ total_channel_capacity[j]` for channel *j*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
berths = ['Berth_A', 'Berth_B']
channels = [1]
berth_ships = {'Berth_A': 356, 'Berth_B': 94} # Dict berth: count
channel_capacity_rate = 23 # ships per minute per channel
time_period = 29 # minutes
total_channel_capacity = {1: 667} # Dict channel: capacity over period
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_EVACUATION", env=env)

    # --- Basic Input Validation ---
    if not berths or not channels:
        raise ValueError("Empty berths or channels list")

    # --- Decision Variables ---
    # f[i, j]: Number of ships flowing from berth i to channel j within the time period
    flow_keys = [(i, j) for i in berths for j in channels]
    f = m.addVars(flow_keys, vtype=GRB.CONTINUOUS, lb=0, name="flow")

    # --- Objective Function: Maximize total ships exiting ---
    m.setObjective(gp.quicksum(f[i, j] for i, j in flow_keys), GRB.MAXIMIZE)

    # --- Constraints ---
    # Flow out of a berth cannot exceed the number of ships in it
    m.addConstrs((gp.quicksum(f[i, j] for j in channels) <= berth_ships.get(i, 0) for i in berths), "BerthSupply")

    # Flow into a channel cannot exceed its capacity over the period
    m.addConstrs((gp.quicksum(f[i, j] for i in berths) <= total_channel_capacity.get(j, 0) for j in channels), "ChannelCapacity")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['f_sol'] = m.getAttr('X', f) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Objective is total ships, potentially float
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the flow of ships from each berth to the channel
if m.Status == GRB.OPTIMAL:
    for i in berths:
        for j in channels:
            print(f"Flow from {i} to Channel {j}: {f[i, j].X:.2f}")
```
Answer:
Optimal objective value: 450.00
Flow from Berth_A to Channel 1: 356.00
Flow from Berth_B to Channel 1: 94.00


```

================================================================================



--- Problem 209 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling three incoming trucks at a single loading dock to minimize operational costs. Each truck arrives at a specific time: Truck 1 at hour 3, Truck 2 at hour 5, and Truck 3 at hour 8. The handling times vary—Truck 1 requires 4 hours, Truck 2 takes 7 hours, and Truck 3 needs 4 hours. Waiting is costly: Trucks 1, 2, and 3 incur costs of $123, $141, and $143 per hour, respectively, for every hour they idle before docking. Additionally, servicing each truck at the loading dock comes with its own hourly cost: $51 for Truck 1, $53 for Truck 2, and $63 for Truck 3. The logistics manager must determine the optimal schedule—assigning trucks to the loading dock and sequencing their start times—to minimize the combined costs of waiting and servicing while ensuring no two trucks occupy the loading dock simultaneously. The core question is: *What is the most cost-effective loading schedule for these three trucks?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign[i, j]`: Binary variable (1 if truck *i* is assigned to loading dock *j*, else 0).  
     - `start_time[i]`: Continuous variable for the loading start time of truck *i*.  
     - `completion_time[i]`: Continuous variable for the departure time of truck *i* (start time + processing time).  
     - `precedes[i, k, j]`: Binary variable (1 if truck *i* loads before truck *k* on loading dock *j*).  

   - **2. Parameters:**  
     - `arrival_times[i]`: Arrival time of truck *i* (e.g., Truck 1: 3).  
     - `processing_times[i]`: Handling time of truck *i* (e.g., Truck 1: 4).  
     - `waiting_costs[i]`: Cost per hour of waiting for truck *i* (e.g., Truck 1: 123).  
     - `service_costs[i, j]`: Hourly servicing cost for truck *i* at loading dock *j* (e.g., Truck 1 at Loading Dock 1: 51).  
     - `H`: A large constant (100) for logical constraints.  

   - **3. Objective Function:**  
     Minimize:  
     ```
     sum(waiting_costs[i] * (start_time[i] - arrival_times[i]) for all trucks i)  
     + sum(service_costs[i, j] * processing_times[i] * assign[i, j] for all i, j)  
     ```  

   - **4. Constraints:**  
     - Each truck must load at exactly one loading dock: `sum(assign[i, j] for all j) = 1` for all *i*.  
     - Start time cannot precede arrival: `start_time[i] >= arrival_times[i]` for all *i*.  
     - Completion time definition: `completion_time[i] = start_time[i] + processing_times[i]` for all *i*.  
     - Non-overlapping assignments: If two trucks *i* and *k* use the same loading dock, one must precede the other (enforced via `precedes` and indicator constraints).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
loading_docks = [1]
arrival_times = {1: 3, 2: 5, 3: 8}
processing_times = {1: 4, 2: 7, 3: 4}
waiting_costs = {1: 123, 2: 141, 3: 143} # Cost per hour waiting
service_costs = {(1, 1): 51, (2, 1): 53, (3, 1): 63} # Cost rate per hour servicing {(truck, loading_dock): cost}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("LOADING_DOCK_PROBLEM_3_MIN_COST")

    if not trucks or not loading_docks: raise ValueError("Empty trucks or loading docks")

    # --- Decision Variables ---
    assign = m.addVars(trucks, loading_docks, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in loading_docks],
                         vtype=GRB.BINARY, name="precedes") # y[i,k,j] = 1 if i before k on j

    # --- Objective Function ---
    waiting_cost_expr = gp.quicksum(waiting_costs.get(i, 0) * (start_time[i] - arrival_times.get(i, 0)) for i in trucks)
    service_cost_expr = gp.quicksum(service_costs.get((i,j), 0) * processing_times.get(i, 0) * assign[i,j]
                                   for i in trucks for j in loading_docks)
    m.setObjective(waiting_cost_expr + service_cost_expr, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in loading_docks:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] -1 <= precedes[i,k,j] + (1-precedes[i,k,j])) # Link precedence if both assigned

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    for i in trucks:
        for j in loading_docks:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Loading Dock {j}")
                print(f"Start Time for Truck {i}: {start_time[i].x:.4f}")
                print(f"Completion Time for Truck {i}: {completion_time[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
1814.0000
Truck 1 is assigned to Loading Dock 1
Start Time for Truck 1: 3.0000
Completion Time for Truck 1: 7.0000
Truck 2 is assigned to Loading Dock 1
Start Time for Truck 2: 12.0000
Completion Time for Truck 2: 19.0000
Truck 3 is assigned to Loading Dock 1
Start Time for Truck 3: 8.0000
Completion Time for Truck 3: 12.0000


```

================================================================================



--- Problem 210 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy inland logistics hub, four delivery trucks—numbered 1 through 4—arrive at staggered times, each requiring immediate unloading at one of the available depots. The hub has three depots available, but the challenge lies in coordinating their use efficiently to minimize the total time taken to service all trucks (known as the *makespan*). Truck 1 arrives at time 1 and takes 3 hours to unload, Truck 2 arrives at time 3 and also requires 3 hours, Truck 3 arrives at time 5 with a 3-hour unloading window, and Truck 4, arriving much later at time 10, needs 5 hours to complete unloading. The logistics manager must assign each truck to exactly one depot while ensuring no two trucks scheduled to the same depot overlap in time. The critical question: *What is the shortest possible time needed to service all trucks, given these constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to depot *j*, 0 otherwise).  
     - `start_time(i)`: Continuous variable for the time truck *i* begins unloading.  
     - `completion_time(i)`: Continuous variable for the time truck *i* finishes (start_time(i) + processing_time(i)).  
     - `precedes(i, k, j)`: Binary variable (1 if truck *i* is scheduled before truck *k* on depot *j*, 0 otherwise).  
     - `makespan`: Continuous variable representing the total time to finish all jobs (max completion_time).  

   - **2. Parameters:**  
     - `arrival_times[i]`: Time truck *i* arrives (e.g., Truck 1: 1, Truck 4: 10).  
     - `processing_times[i]`: Duration to service truck *i* (e.g., Truck 1: 3, Truck 4: 5).  
     - `H = 100`: A large constant ("Big M") for precedence constraints.  

   - **3. Objective Function:**  
     Minimize `makespan` (the latest completion time across all trucks).  

   - **4. Constraints:**  
     - Each truck assigned to exactly one depot: `sum(assign(i, j) for all j) = 1` for all trucks *i*.  
     - Start time cannot precede arrival: `start_time(i) >= arrival_times[i]` for all *i*.  
     - Completion time definition: `completion_time(i) = start_time(i) + processing_times[i]`.  
     - Non-overlapping on depots: For each depot *j* and trucks *i*, *k* (with *i* ≠ *k*), enforce either `precedes(i, k, j)` or `precedes(k, i, j)` via indicator constraints.  
     - Makespan definition: `makespan >= completion_time(i)` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4]
depots = [1, 2, 3]
arrival_times = {1: 1, 2: 3, 3: 5, 4: 10}
processing_times = {1: 3, 2: 3, 3: 3, 4: 5}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_51_MIN_MAKESPAN")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times[i] for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times[i] for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the assignment of trucks to depots and their start and completion times
if m.status == GRB.OPTIMAL:
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
15.0000
Truck 1 is assigned to Depot 3
Start Time: 1.0000, Completion Time: 4.0000
Truck 2 is assigned to Depot 1
Start Time: 3.0000, Completion Time: 6.0000
Truck 3 is assigned to Depot 2
Start Time: 6.0000, Completion Time: 9.0000
Truck 4 is assigned to Depot 1
Start Time: 10.0000, Completion Time: 15.0000


```

================================================================================



--- Problem 211 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
A major port is experiencing recurring congestion due to incidents across four critical berthing areas. Each berthing area has distinct characteristics: normal and reduced capacities during incidents, alternative berthing options with additional waiting times, and varying arrival rates of ships over six 30-minute time periods. The challenge is to dynamically manage ship berthing by diverting ships to alternative berths during incidents, minimizing total delay while respecting capacity constraints.

The port authority has four diversion options (10%, 30%, 50%, or 70% of ships diverted) for each berthing area and time period. However, each option must be feasible: the diverted flow cannot exceed the alternative berth's capacity, and the remaining flow on the main berth must not cause excessive queuing. Delays are calculated as a combination of extra waiting time at alternative berths and queuing delays at the main berth, with infeasible options penalized heavily.

The core question is: *What is the optimal dynamic diversion strategy for each berthing area and time period to minimize the total delay across the entire port, given the fluctuating arrival rates and incident durations?* The solution must adapt to real-time conditions, balancing diversion ratios to avoid overwhelming either the main or alternative berths.

**Modeling Process:**
**
**1. Decision Variables:**
   - `y(i, t, k)`: Binary variable indicating whether diversion option `k` is selected for berthing area `i` in time period `t`.

**2. Parameters:**
   - `NUM_BERTHS = 4`: Number of berthing areas.
   - `NUM_TIME_PERIODS = 6`: Number of 30-minute time periods.
   - `TIME_PERIOD_LENGTH = 0.5`: Duration of each time period (hours).
   - `capacities_main_normal`: Normal capacity of main berth for each berthing area (ships/h).
   - `capacities_main_reduced`: Reduced capacity of main berth during incidents (ships/h).
   - `capacities_alt`: Capacity of alternative berths for each berthing area (ships/h).
   - `arrival_rates`: Ship arrival rates for each berthing area and time period (ships/h).
   - `incident_durations`: Duration of incidents for each berthing area (hours).
   - `alt_berth_extra_times`: Additional waiting time for alternative berths (hours).
   - `diversion_options = [0.1, 0.3, 0.5, 0.7]`: Available diversion ratios.
   - `berth_period_option_delays[i][t][k]`: Precomputed total delay for berthing area `i`, time `t`, and option `k`.
   - `berth_period_option_feasible[i][t][k]`: Boolean indicating feasibility of option `k` for berthing area `i` and time `t`.

**3. Objective Function:**
   - Minimize the total delay across all berthing areas and time periods:
     \[
     \text{Minimize: } \sum_{i=1}^{4} \sum_{t=1}^{6} \sum_{k=1}^{4} y(i,t,k) \cdot \text{berth\_period\_option\_delays}[i][t][k]
     \]

**4. Constraints:**
   - **Feasibility Selection:** For each berthing area `i` and time period `t`, exactly one feasible diversion option must be selected:
     \[
     \sum_{k \in \text{feasible\_indices}} y(i,t,k) = 1 \quad \forall i, t
     \]
   - **Infeasible Options:** Infeasible options are forced to zero:
     \[
     y(i,t,k) = 0 \quad \forall i, t, k \text{ where } \text{berth\_period\_option\_feasible}[i][t][k] \text{ is False}
     \]

**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 4
NUM_TIME_PERIODS = 6
TIME_PERIOD_LENGTH = 0.5  # h
capacities_main_normal = [5405, 3939, 4662, 4019]  # ships/h
capacities_main_reduced = [2104, 2186, 2675, 2654]  # ships/h
capacities_alt = [1428, 989, 1169, 1239]  # ships/h
arrival_rates = [[2759, 3632, 2633, 3759, 2272, 3905], [3236, 4772, 3648, 2552, 2983, 3560], [4015, 3140, 4193, 2734, 4144, 4632], [4486, 4943, 2330, 3932, 2201, 4406]]  # ships/h
incident_durations = [1.89066076502786, 0.8533727375484638, 0.9916995266429912, 1.8880341071210522]  # h
alt_berth_extra_times = [0.1984525811150219, 0.1377289069154421, 0.14057637100254095, 0.23498775131364502]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:

Berth 1:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 1 (30%)

Berth 2:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 0 (10%)

Berth 3:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)

Berth 4:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)



================================================================================



--- Problem 212 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A maritime port is tasked with efficiently scheduling a set of 11 ships to berths to minimize the number of berths used. Each ship has unique dimensions—ranging from a slender 80x2 unit rectangle to a bulky 93x42 unit panel—and must be placed without overlapping within berths measuring 95x65 units. The challenge is compounded by the need to arrange ships in a way that maximizes berth utilization while respecting strict placement rules: ships cannot protrude beyond berth boundaries, and their positions must avoid any overlap within the same berth. The port manager seeks an optimal scheduling configuration that uses the fewest berths possible, reducing both operational costs and congestion. The core question is: *What is the minimal number of berths required to schedule all ships, and where should each ship be placed within those berths?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable (1 if ship *i* is assigned to berth *j*, 0 otherwise).  
   - `y[j]`: Binary variable (1 if berth *j* is used, 0 otherwise).  
   - `px[i, j]`, `py[i, j]`: Continuous variables for the bottom-left coordinates of ship *i* in berth *j*.  
   - `left[i, k, j]`, `right[i, k, j]`, `below[i, k, j]`, `above[i, k, j]`: Binary variables enforcing non-overlapping conditions between ships *i* and *k* in berth *j*.  

   **2. Parameters:**  
   - `ships`: List of ship dimensions (e.g., (93, 42) for ship 0).  
   - `berth_size`: (95, 65) units (width, height).  
   - `num_ships = 11`, `num_berths = 11` (initial upper bound).  
   - `M_w = 95`, `M_h = 65` (Big-M values for linearization).  

   **3. Objective Function:**  
   Minimize the total number of berths used:  
   \[
   \text{Minimize: } \sum_{j=0}^{10} y[j]
   \]  

   **4. Constraints:**  
   - **Assignment:** Each ship *i* must be in exactly one berth:  
     \[
     \sum_{j=0}^{10} x[i, j] = 1 \quad \forall i \in \{0, \dots, 10\}
     \]  
   - **Berth Boundaries:** Ship *i* in berth *j* must fit within the berth:  
     \[
     px[i, j] + \text{ship}_i\text{.width} \leq 95 + 95(1 - x[i, j]) \quad \forall i, j
     \]  
     \[
     py[i, j] + \text{ship}_i\text{.height} \leq 65 + 65(1 - x[i, j]) \quad \forall i, j
     \]  
   - **Non-Overlapping:** For each berth *j*, ships *i* and *k* must not overlap (enforced via relative position variables):  
     \[
     \text{left}[i, k, j] + \text{right}[i, k, j] + \text{below}[i, k, j] + \text{above}[i, k, j] \geq x[i, j] + x[k, j] - 1 \quad \forall i < k, j
     \]  
   - **Berth Activation:** Berth *j* is marked used if any ship is assigned to it:  
     \[
     x[i, j] \leq y[j] \quad \forall i, j
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
ships = [(93, 42), (80, 2), (43, 23), (68, 16), (26, 5), (42, 30), (90, 64), (72, 7), (86, 6), (63, 9), (30, 32)]  # (width, height) of ships
berth_size = (95, 65)  # (width, height) of each berth
num_ships = 11 # len(ships)
# Maximum berths needed (worst case: one ship per berth)
# Can sometimes be reduced with lower bounds, but num_ships is safe
num_berths = num_ships
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using berth dimensions is common and valid)
M_w = berth_size[0]
M_h = berth_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Berth Scheduling", env=env)

# --- Decision Variables ---
# x[i,j]: ship i assigned to berth j
x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of ship i if in berth j
px = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of ships *within the same berth*
left  = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="left")
right = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="right")
below = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="below")
above = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_berths))

# --- Constraints ---

# 1. Each ship must be assigned to exactly one berth
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Ship placement constraints within berth boundaries (Big-M formulation)
for j in range(num_berths):
    for i in range(num_ships):
        ship_w, ship_h = ships[i] # Get dimensions for ship i

        # Position variables must be 0 if ship i is not in berth j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Ship's right edge <= berth width IF ship is placed in berth (x[i,j]=1)
        model.addConstr(px[i, j] + ship_w <= berth_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Ship's top edge <= berth height IF ship is placed in berth (x[i,j]=1)
        model.addConstr(py[i, j] + ship_h <= berth_size[1] + M_h * (1 - x[i, j]), name=f"Height_Limit_{i}_{j}")

# 3. Non-overlapping constraints for ships within the same berth
for j in range(num_berths):
    for i in range(num_ships):
        for k in range(i + 1, num_ships): # Iterate over distinct pairs (i < k)
            ship_i_w, ship_i_h = ships[i]
            ship_k_w, ship_k_h = ships[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => ship i is to the left of ship k
            model.addConstr(px[i, j] + ship_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => ship i is to the right of ship k (k is left of i)
            model.addConstr(px[k, j] + ship_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => ship i is below ship k
            model.addConstr(py[i, j] + ship_i_h <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => ship i is above ship k (k is below i)
            model.addConstr(py[k, j] + ship_k_h <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH ship i and ship k are in berth j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link ship assignment to berth usage: If any ship i is in berth j, then berth j must be used (y[j]=1)
#    This can be done per ship or aggregated. Per ship is often tighter.
for j in range(num_berths):
    for i in range(num_ships):
        model.addConstr(x[i, j] <= y[j], name=f"Ship_Berth_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_ships * y[j], name=f"Berth_Activation_{j}")


# --- Solve ---
print("Solving 2DBS instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of berths used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    berth_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_berths):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Berth {j_sol + 1} (Used):")
            ships_in_berth_info = []
            for i_sol in range(num_ships):
                if x[i_sol, j_sol].X > 0.5:
                    ship_data = {
                        "id": i_sol,
                        "dims": ships[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    ships_in_berth_info.append(ship_data)
                    print(f"  Ship {ship_data['id']} {ship_data['dims']} at {ship_data['pos']}")
            berth_details.append({'berth_index': j_sol, 'ships': ships_in_berth_info})
            print("-" * 10)
    results_dict['berth_details'] = berth_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 2DBS instance...
Gurobi Error code 10010: Model too large for size-limited license; visit https://gurobi.com/unrestricted for more information

Optimization finished with status: -1. No optimal solution found.


```

================================================================================



--- Problem 213 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
In a busy port, 78 container ships must be allocated between two berthing areas, A and B. Berthing Area A, which is a major commercial hub, can accommodate up to 52 ships at any given time, while Berthing Area B, a smaller terminal, has a lower capacity limit of 32 ships. The primary challenge is to minimize the number of ships assigned to Berthing Area B while ensuring all 78 ships are deployed and neither area exceeds its capacity. This optimization aims to prioritize efficient resource utilization, directing as many ships as possible to the higher-capacity Berthing Area A without overloading either zone. The central question is: *What is the smallest number of ships that must be assigned to Berthing Area B to meet all operational constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n_A`: Integer variable representing the number of ships assigned to Berthing Area A.  
     - `n_B`: Integer variable representing the number of ships assigned to Berthing Area B.  
   - **2. Parameters:**  
     - Total ships: 78.  
     - Capacity of Berthing Area A: 52.  
     - Capacity of Berthing Area B: 32.  
   - **3. Objective Function:**  
     - Minimize `n_B` (the number of ships in Berthing Area B).  
   - **4. Constraints:**  
     - **Total assignment:** `n_A + n_B = 78` (all ships must be assigned).  
     - **Berthing Area A capacity:** `n_A ≤ 52`.  
     - **Berthing Area B capacity:** `n_B ≤ 32`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_ships = 78
capacity_A = 52
capacity_B = 32
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("SHIP_BERTHING_MANAGEMENT", env=env)

    # --- Decision Variables ---
    # n_A: number of ships assigned to berthing area A
    n_A = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_A")
    # n_B: number of ships assigned to berthing area B
    n_B = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_B")

    # --- Objective Function: Minimize the number of ships in berthing area B ---
    m.setObjective(n_B, GRB.MINIMIZE)

    # --- Constraints ---
    # All ships must be assigned
    m.addConstr(n_A + n_B == total_ships, "TotalShips")

    # Capacity constraint for berthing area A
    m.addConstr(n_A <= capacity_A, "CapacityA")

    # Capacity constraint for berthing area B
    m.addConstr(n_B <= capacity_B, "CapacityB")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_A_sol'] = n_A.X # Not needed for output
        # results_dict['n_B_sol'] = n_B.X # Not needed for output (obj_val)

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is number of ships, should be integer
             print(f"Optimal objective value: {int(round(obj_val_print))}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block to print the number of ships assigned to each berthing area)
if m.Status == GRB.OPTIMAL:
    print(f"Number of ships assigned to Berthing Area A: {int(round(n_A.X))}")
    print(f"Number of ships assigned to Berthing Area B: {int(round(n_B.X))}")
```
Answer:
Optimal objective value: 26
Number of ships assigned to Berthing Area A: 52
Number of ships assigned to Berthing Area B: 26


```

================================================================================



--- Problem 214 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
A busy port sees heavy traffic from both north-south (NS) and east-west (EW) shipping lanes, with hourly vessel arrival rates of **734.0** and **524.1** vessels, respectively. The port has **2.06 berths** per approach, each capable of handling **1,493.9 vessels per hour per berth** under normal conditions. Port managers must determine the optimal allocation of berthing times to maximize throughput while adhering to strict operational constraints:  
- The **cycle length (C)**—the total time for both berthing phases—must stay between **68.7 and 116.2 hours**.  
- Each phase requires a **minimum berthing time (g_min)** of **19.9 hours** to allow safe vessel movement.  
- **Lost time** of **3.8 hours per phase** (totaling **7.6 hours per cycle**) accounts for loading and unloading delays.  

The challenge is to allocate berthing times (**g_NS**, **g_EW**) within these bounds to maximize total port capacity, ensuring neither approach exceeds its saturation flow. The solution must balance competing demands: longer berthing times boost throughput but risk exceeding cycle limits or starving one direction of capacity.  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- **C**: Cycle length (hours), bounded between `C_min` and `C_max`.  
- **g_NS**, **g_EW**: Berthing times (hours) for NS and EW phases, each ≥ `g_min_time`.  
- **λ_g_NS**, **λ_g_EW**: Effective berthing ratios (fractions of cycle time: `g_NS/C`, `g_EW/C`).  
- **Cap_NS**, **Cap_EW**: Hourly capacities (vessels/hour) for each approach.  

**2. Parameters:**  
- `lambda_NS_h`, `lambda_EW_h`: Hourly demand (vessels/hour).  
- `S_fog_approach_h`: Total saturation flow per approach = `N_lanes × S_fog_lane_h`.  
- `L_lost_time_per_phase`: Lost time per phase (hours).  

**3. Objective Function:**  
Maximize total throughput:  
`Maximize: Cap_NS + Cap_EW`  
where `Cap_NS = S_fog_approach_h × λ_g_NS` and `Cap_EW = S_fog_approach_h × λ_g_EW`.  

**4. Constraints:**  
- **Cycle composition**: `C = g_NS + g_EW + 2 × L_lost_time_per_phase`.  
- **Berthing ratio definitions**: `λ_g_NS × C = g_NS`, `λ_g_EW × C = g_EW` (quadratic constraints).  
- **Capacity definitions**: As in objective.  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
lambda_NS_h = 733.999807599555  # ves/h
lambda_EW_h = 524.140128804478  # ves/h
S_fog_lane_h = 1493.9063601084679  # ves/h/berth
N_lanes = 2.0606931185547177
L_lost_time_per_phase = 3.7925548111253202  # h
C_min = 68.74042443410144  # h
C_max = 116.19973927931284  # h
g_min_time = 19.891806644324912  # h

S_fog_approach_h = N_lanes * S_fog_lane_h

# --- Gurobi Model ---
model = gp.Model("PortBerthingTiming")

# --- Decision Variables ---
C = model.addVar(name="CycleLength", lb=C_min, ub=C_max)
g_NS = model.addVar(name="Berthing_NS", lb=g_min_time) # Actual berthing time NS
g_EW = model.addVar(name="Berthing_EW", lb=g_min_time) # Actual berthing time EW

# --- Intermediate Variables ---
# Effective berthing ratios (lambda = g/C)
lambda_g_NS = model.addVar(name="lambda_g_NS", lb=0.0, ub=1.0) # g_NS / C
lambda_g_EW = model.addVar(name="lambda_g_EW", lb=0.0, ub=1.0) # g_EW / C
# Capacities
Cap_NS = model.addVar(name="Capacity_NS", lb=0.0)
Cap_EW = model.addVar(name="Capacity_EW", lb=0.0)

# --- Constraints ---
# 1. Cycle length composition (2 phases)
model.addConstr(C == g_NS + g_EW + 2 * L_lost_time_per_phase, name="CycleComposition")

# 2. Calculate effective berthing ratios (non-linear: lambda = g/C)
# lambda * C = g
model.addQConstr(lambda_g_NS * C == g_NS, name="CalcLambdaNS")
model.addQConstr(lambda_g_EW * C == g_EW, name="CalcLambdaEW")

# 3. Calculate approach capacities
# Cap = S * lambda_g
model.addConstr(Cap_NS == S_fog_approach_h * lambda_g_NS, name="CalcCapacityNS")
model.addConstr(Cap_EW == S_fog_approach_h * lambda_g_EW, name="CalcCapacityEW")

# --- Objective Function ---
# Maximize total throughput (sum of capacities)
model.setObjective(Cap_NS + Cap_EW, GRB.MAXIMIZE)

# --- Optimize ---
# Needs NonConvex capabilities due to quadratic constraints (g = lambda * C)
model.Params.NonConvex = 2
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL or model.status == GRB.SUBOPTIMAL:
    print(f"Optimization Status: {model.status}")
    print(f"Optimal Cycle Length (C): {C.X:.2f} h")
    print(f"Optimal Berthing Time NS (g_NS): {g_NS.X:.2f} h")
    print(f"Optimal Berthing Time EW (g_EW): {g_EW.X:.2f} h")
    print(f"  Total Berthing = {g_NS.X+g_EW.X:.2f}h, Lost Time = {2*L_lost_time_per_phase:.1f}h, Sum = {g_NS.X+g_EW.X+2*L_lost_time_per_phase:.2f}h (matches C)")
    print(f"Resulting Capacity NS: {Cap_NS.X:.2f} ves/h (Demand={lambda_NS_h})")
    print(f"Resulting Capacity EW: {Cap_EW.X:.2f} ves/h (Demand={lambda_EW_h})")
    print(f"Maximized Total Throughput: {model.objVal:.2f} ves/h")
    # Check if demand constraints were implicitly met
    if Cap_NS.X < lambda_NS_h: print("  Warning: NS Demand exceeds capacity.")
    if Cap_EW.X < lambda_EW_h: print("  Warning: EW Demand exceeds capacity.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
    model.computeIIS()
    model.write("model_iis.ilp")
    print("IIS written to model_iis.ilp")
elif model.status == GRB.INF_OR_UNBD:
     print("Optimization Status: Infeasible or Unbounded")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 3 rows, 7 columns and 7 nonzeros
Model fingerprint: 0x3057ef84
Model has 2 quadratic constraints
Coefficient statistics:
  Matrix range     [1e+00, 3e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [1e+00, 1e+02]
  RHS range        [8e+00, 8e+00]
Presolve removed 2 rows and 2 columns

Continuous model is non-convex -- solving as a MIP

Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolved: 9 rows, 6 columns, 27 nonzeros
Presolved model has 2 bilinear constraint(s)
Variable types: 6 continuous, 0 integer (0 binary)
Found heuristic solution: objective 2877.5300599

Root relaxation: objective 3.473742e+03, 3 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0 3473.74184    0    2 2877.53006 3473.74184  20.7%     -    0s
     0     0 3287.40533    0    2 2877.53006 3287.40533  14.2%     -    0s
     0     2 3287.40533    0    2 2877.53006 3287.40533  14.2%     -    0s

Explored 89 nodes (53 simplex iterations) in 0.02 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 2877.53 

Optimal solution found (tolerance 1.00e-04)
Best objective 2.877530059910e+03, best bound 2.877530059910e+03, gap 0.0000%

--- Optimization Results ---
Optimization Status: 2
Optimal Cycle Length (C): 116.20 h
Optimal Berthing Time NS (g_NS): 54.31 h
Optimal Berthing Time EW (g_EW): 54.31 h
  Total Berthing = 108.61h, Lost Time = 7.6h, Sum = 116.20h (matches C)
Resulting Capacity NS: 1438.77 ves/h (Demand=733.999807599555)
Resulting Capacity EW: 1438.77 ves/h (Demand=524.140128804478)
Maximized Total Throughput: 2877.53 ves/h



================================================================================



--- Problem 215 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
At a busy port, maritime logistics managers need to decide the most efficient and cost-effective method for managing container ship unloading. The decision is between two options: a *dedicated crane phase*, where each ship has exclusive access to a crane, or a *shared crane phase*, where multiple ships share the same crane. The dedicated crane phase ensures faster unloading but comes at a fixed hourly cost of $79.00, reflecting the operational and maintenance costs. The shared crane phase, while cheaper to implement, risks delays due to conflicting schedules, estimated to incur a penalty of $130.00 per hour from ship waiting times and reduced throughput. The challenge is clear: **Which phase minimizes the total cost while balancing efficiency and operational smoothness?**
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y_dedicated`: Binary variable where `1` indicates selecting the dedicated crane phase, and `0` selects the shared crane phase.  
   - **2. Parameters:**  
     - `cost_dedicated_phase = 79`: Hourly cost of the dedicated crane phase.  
     - `cost_shared_delay = 130`: Hourly penalty for delays under the shared crane phase.  
   - **3. Objective Function:**  
     - Minimize total cost:  
       ```  
       Minimize: y_dedicated * cost_dedicated_phase + (1 - y_dedicated) * cost_shared_delay  
       ```  
   - **4. Constraints:**  
     - None (unconstrained binary choice).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cost_dedicated_phase = 79 # Proxy cost/hr
cost_shared_delay = 130 # Proxy penalty/hr
# --- End Parameters ---

GUROBI_TIME_LIMIT = 5

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m36 = gp.Model("CRANE_PHASE_DECISION_IP", env=env)

    # --- Decision Variables ---
    # Binary: y_dedicated = 1 if dedicated crane phase is chosen, 0 otherwise
    y_dedicated = m36.addVar(vtype=GRB.BINARY, name="use_dedicated_crane")

    # --- Objective Function ---
    # Minimize total cost = cost of chosen phase
    m36.setObjective(y_dedicated * cost_dedicated_phase + (1 - y_dedicated) * cost_shared_delay, sense=GRB.MINIMIZE)

    # --- Constraints: None ---

    # --- Optimization ---
    m36.optimize()

    # --- Store results ---
    results_dict['status'] = m36.status
    if m36.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m36.ObjVal
        results_dict['y_dedicated_sol'] = y_dedicated.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 36: Port Crane Phase Decision (IP) ---") # Original problem number
    if m36.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        use_dedicated = results_dict.get('y_dedicated_sol', 0) > 0.5

        print(f"Optimization Status: Optimal")
        print(f"Optimal Decision: {'Use Dedicated Crane Phase' if use_dedicated else 'Use Shared Crane Phase'}")
        print(f"  Cost of Dedicated Crane Phase: ${float(cost_dedicated_phase):.2f}")
        print(f"  Estimated Cost of Shared Crane Phase (due to delay): ${float(cost_shared_delay):.2f}")
        print(f"Minimum Estimated Cost: ${float(obj_val_print):.2f}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m36.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 36: Port Crane Phase Decision (IP) ---
Optimization Status: Optimal
Optimal Decision: Use Dedicated Crane Phase
  Cost of Dedicated Crane Phase: $79.00
  Estimated Cost of Shared Crane Phase (due to delay): $130.00
Minimum Estimated Cost: $79.00


```

================================================================================



--- Problem 216 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port management team faces the challenge of efficiently dispatching two tugboats, T1 and T2, to two separate ship berthing incidents, A and B, each occurring at distinct times (Incident A at 0 minutes, Incident B at 12 minutes). The goal is to minimize the total delay caused by these incidents, which reduce the berthing capacity and create growing queues of ships. Each incident has unique characteristics: Incident A takes 41 minutes to clear and has a higher arrival rate (44.92 ships per minute) compared to Incident B (30.72 ships per minute), which clears faster (23 minutes). The team must decide not only which tugboat to assign first to each incident but also the sequence in which tugboats move between incidents, considering travel times (e.g., T1 takes 22 minutes to reach either incident, while T2 takes 15 minutes to A and 23 minutes to B). The critical question is: *What is the optimal assignment and sequencing of tugboats to incidents to minimize the cumulative delay experienced by ships stuck in berthing queues?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary `assign_first(k, i)`: 1 if tugboat `k` is assigned first to incident `i`, else 0.  
     - Binary `sequence(k, i, j)`: 1 if tugboat `k` moves from incident `i` to `j`, else 0.  
     - Continuous `start_clear(i)`, `end_clear(i)`: Start and end times of clearance for incident `i`.  
     - Auxiliary variables (`queue_at_start_clear(i)`, `dissipation_time(i)`, etc.) model queue dynamics.  

   - **2. Parameters:**  
     - `time_occur(i)`: Incident occurrence times (A: 0, B: 12).  
     - `travel_time_base(k, i)`: Tugboat-to-incident travel times (e.g., T1 to A: 22).  
     - `travel_time_inter(i, j)`: Inter-incident travel times (e.g., A to B: 13).  
     - `clearance_time(i)`: Time to clear incident `i` (A: 41, B: 23).  
     - Queue growth/dissipation rates derived from arrival/capacity rates (e.g., Incident A’s queue grows at 44.92 – 29.83 = 15.09 ships/min before clearance).  

   - **3. Objective Function:**  
     Minimize total delay = sum of:  
     - Delay before clearance: `0.5 * growth_rate_before(i) * (start_clear(i) – time_occur(i))^2` for each incident.  
     - Delay during clearance: `0.5 * (queue_at_start_clear(i) + queue_at_clear_end(i)) * clearance_time(i)`.  
     - Post-clearance dissipation delay (if applicable): `0.5 * (queue_at_clear_end(i)^2) / dissipation_rate(i)`.  

   - **4. Constraints:**  
     - Each incident must be assigned exactly once (first or in sequence).  
     - Tugboats cannot be assigned to multiple first incidents.  
     - Sequence logic ensures tugboats follow valid paths (no self-loops).  
     - Timing constraints link tugboat assignments to clearance start/end times.  
     - Queue dynamics enforce non-negativity and dissipation logic.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
incidents = ['A', 'B']
tugboats = ['T1', 'T2']

# Times in minutes from simulation start
time_occur = {'A': 0, 'B': 12}
travel_time_base = {('T1', 'A'): 22, ('T1', 'B'): 22, ('T2', 'A'): 15, ('T2', 'B'): 23}
travel_time_inter = {('A', 'B'): 13, ('B', 'A'): 30, ('A', 'A'): 0, ('B', 'B'): 0}
clearance_time = {'A': 41, 'B': 23}

# Capacities and Arrival rates (ships per minute)
cap_normal = {'A': 3461/60, 'B': 2360/60} # ships/min
cap_reduced = {'A': 1790/60, 'B': 1126/60} # ships/min
arrival_rate = {'A': 2695/60, 'B': 1843/60} # ships/min

M = 10000
EPSILON = 1e-6

# Pre-calculate rates
growth_rate_before = {}
dissipation_rate = {}
can_dissipate = {}
inv_dissipation_rate = {}
non_dissipating_penalty = 10000

for i in incidents:
    growth_rate_before[i] = max(0, arrival_rate[i] - cap_reduced[i])
    dissipation_rate[i] = cap_normal[i] - arrival_rate[i]
    can_dissipate[i] = dissipation_rate[i] > EPSILON
    if not can_dissipate[i]:
        inv_dissipation_rate[i] = 0
    else:
        inv_dissipation_rate[i] = 1.0 / dissipation_rate[i]

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("BerthingResourceAllocation", env=env)

# --- Decision Variables ---
assign_first = m.addVars(tugboats, incidents, vtype=GRB.BINARY, name="assign_first")
sequence = m.addVars(tugboats, incidents, incidents, vtype=GRB.BINARY, name="sequence")

# Timing variables
start_clear = m.addVars(incidents, name="start_clear", lb=0.0)
end_clear = m.addVars(incidents, name="end_clear", lb=0.0)

# Queue and Delay related variables
queue_start_clear_time_diff = m.addVars(incidents, name="queue_start_clear_time_diff", lb=0.0)
queue_at_start_clear = m.addVars(incidents, name="queue_at_start_clear", lb=0.0)
aux_q_start = m.addVars(incidents, name="aux_q_start", lb=-GRB.INFINITY)
queue_at_clear_end = m.addVars(incidents, name="queue_at_clear_end", lb=0.0)
aux_q_end = m.addVars(incidents, name="aux_q_end", lb=-GRB.INFINITY)
dissipation_time = m.addVars(incidents, name="dissipation_time", lb=0.0)

# --- Constraints ---
for i in incidents:
    m.addConstr(gp.quicksum(assign_first[k, i] for k in tugboats) +
                gp.quicksum(sequence[k, j, i] for k in tugboats for j in incidents if i != j) == 1,
                name="AssignIncident_{0}".format(i))

for k in tugboats:
    m.addConstr(gp.quicksum(assign_first[k, i] for i in incidents) <= 1, name="TugboatStart_{0}".format(k))

for k in tugboats:
    for i in incidents:
        tugboat_served_i = assign_first[k, i] + gp.quicksum(sequence[k, l, i] for l in incidents if l != i)
        m.addConstr(gp.quicksum(sequence[k, i, j] for j in incidents if i != j) <= tugboat_served_i,
                    name="SequenceLogic_{0}_{1}".format(k, i))
        m.addConstr(sequence[k,i,i] == 0, name="NoSelfLoop_{0}_{1}".format(k, i))
        for j in incidents:
             if i != j:
                  m.addConstr(sequence[k,i,j] + sequence[k,j,i] <= 1, name="NoImmediateLoop_{0}_{1}_{2}".format(k, i, j))

for k in tugboats:
    for i in incidents:
        m.addConstr(start_clear[i] >= time_occur[i] + travel_time_base[k, i] - M * (1 - assign_first[k, i]),
                    name="StartTimeFirst_{0}_{1}".format(k, i))
        for j in incidents:
            if i != j:
                m.addConstr(start_clear[i] >= end_clear[j] + travel_time_inter[j, i] - M * (1 - sequence[k, j, i]),
                            name="StartTimeFollow_{0}_{1}_{2}".format(k, j, i))

for i in incidents:
    m.addConstr(end_clear[i] == start_clear[i] + clearance_time[i], name="EndClearTime_{0}".format(i))
    m.addConstr(start_clear[i] >= time_occur[i], name="StartAfterOccur_{0}".format(i))

for i in incidents:
    m.addConstr(queue_start_clear_time_diff[i] >= start_clear[i] - time_occur[i], name="CalcTimeDiff_{0}".format(i))
    m.addConstr(aux_q_start[i] == growth_rate_before[i] * queue_start_clear_time_diff[i], name="CalcAuxQStart_{0}".format(i))
    m.addGenConstrMax(queue_at_start_clear[i], [aux_q_start[i]], 0.0, name="SetQStartMax_{0}".format(i))
    queue_growth_during_clearance = growth_rate_before[i] * clearance_time[i]
    m.addConstr(aux_q_end[i] == queue_at_start_clear[i] + queue_growth_during_clearance, name="CalcAuxQEnd_{0}".format(i))
    m.addGenConstrMax(queue_at_clear_end[i], [aux_q_end[i]], 0.0, name="SetQEndMax_{0}".format(i))
    if can_dissipate[i]:
         m.addConstr(dissipation_time[i] == queue_at_clear_end[i] * inv_dissipation_rate[i], name="CalcDissipationTime_{0}".format(i))
    else:
         m.addConstr(dissipation_time[i] == 0, name="SetDissipationTimeZero_{0}".format(i))

# --- Objective Function ---
objective = gp.QuadExpr()
for i in incidents:
    delay_before = 0.5 * growth_rate_before[i] * queue_start_clear_time_diff[i] * queue_start_clear_time_diff[i]
    objective += delay_before
    delay_during = 0.5 * (queue_at_start_clear[i] + queue_at_clear_end[i]) * clearance_time[i]
    objective += delay_during
    if can_dissipate[i]:
        delay_dissipation = 0.5 * inv_dissipation_rate[i] * queue_at_clear_end[i] * queue_at_clear_end[i]
        objective += delay_dissipation
    else:
        objective += non_dissipating_penalty * queue_at_clear_end[i]

m.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("{0:.2f}".format(m.objVal))
elif m.status == GRB.INFEASIBLE:
    print("Infeasible")
elif m.status == GRB.UNBOUNDED:
    print("Unbounded")
```
Answer:
80472.39



================================================================================



--- Problem 217 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy maritime port, five ships arrive at varying times, each requiring a berth for unloading and processing. The port has two berths, each with specific capabilities: Berth 1 can only accommodate ships of type 'C', while Berth 2 is restricted to type 'B'. The ships' arrival times and processing durations are known—Ship 1 arrives at time 5 and takes 4 hours to process, Ship 2 arrives at time 6 and requires 7 hours, and so on. The challenge is to assign each ship to a compatible berth while minimizing the total waiting time (start time minus arrival time) across all ships. The port manager must ensure that no two ships assigned to the same berth overlap in their processing schedules and that each ship is assigned to exactly one berth. Additionally, due to recent weather conditions, the port manager must also consider a new constraint: no ship can start processing before 8 AM. The goal is to find the optimal assignment and scheduling that minimizes cumulative delays, ensuring efficient port operations.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable indicating whether ship `i` is assigned to berth `j`.  
   - `start_time(i)`: Continuous variable representing the start time of ship `i`.  
   - `completion_time(i)`: Continuous variable representing the completion time of ship `i`.  
   - `precedes(i, k, j)`: Binary variable indicating whether ship `i` precedes ship `k` at berth `j`.  

   **2. Parameters:**  
   - `ships`: [1, 2, 3, 4, 5]  
   - `berths`: [1, 2]  
   - `arrival_times`: {1: 5, 2: 6, 3: 8, 4: 12, 5: 17}  
   - `processing_times`: {1: 4, 2: 7, 3: 8, 4: 8, 5: 4}  
   - `ship_types`: {1: 'B', 2: 'C', 3: 'C', 4: 'B', 5: 'B'}  
   - `berth_capabilities`: {1: ['C'], 2: ['B']}  
   - `H`: 100 (a large constant for big-M constraints).  

   **3. Objective Function:**  
   Minimize the total waiting time:  
   `Minimize: sum(start_time[i] - arrival_times[i] for all ships i)`  

   **4. Constraints:**  
   - **Assignment:** Each ship must be assigned to exactly one berth:  
     `sum(assign(i, j) for all j) = 1` for each ship `i`.  
   - **Arrival Time:** A ship cannot start processing before its arrival time:  
     `start_time[i] >= arrival_times[i]` for each ship `i`.  
   - **Completion Time:** The completion time is the start time plus processing time:  
     `completion_time[i] = start_time[i] + processing_times[i]` for each ship `i`.  
   - **Non-Overlapping:** For any two ships assigned to the same berth, one must precede the other:  
     If `precedes(i, k, j) = 1`, then `start_time[k] >= completion_time[i]`.  
     If `precedes(i, k, j) = 0`, then `start_time[i] >= completion_time[k]`.  
   - **Compatibility:** Ships can only be assigned to compatible berths:  
     `assign(i, j) = 0` if ship `i`'s type is not in `berth_capabilities[j]`.  
   - **Start Time Constraint:** No ship can start processing before 8 AM:  
     `start_time[i] >= 8` for each ship `i`.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3, 4, 5]
berths = [1, 2]
arrival_times = {1: 5, 2: 6, 3: 8, 4: 12, 5: 17}
processing_times = {1: 4, 2: 7, 3: 8, 4: 8, 5: 4}
ship_types = {1: 'B', 2: 'C', 3: 'C', 4: 'B', 5: 'B'} # Dict {ship_id: type_str}
berth_capabilities = {1: ['C'], 2: ['B']} # Dict {berth_id: [list_of_types]}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_5_COMPATIBILITY")

    if not ships or not berths: raise ValueError("Empty ships or berths")

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in ships for k in ships if i < k for j in berths],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Compatibility Constraint
    for i in ships:
        ship_type = ship_types.get(i)
        if ship_type:
             for j in berths:
                 allowed_types = berth_capabilities.get(j, [])
                 if ship_type not in allowed_types:
                     m.addConstr(assign[i, j] == 0, name=f"compatibility_{i}_{j}")
        else: print(f"Warning: Ship type unknown for {i}")
    # 6. Start Time Constraint
    m.addConstrs((start_time[i] >= 8 for i in ships), name="start_time_constraint")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Assignment and Schedules:")
    for i in ships:
        for j in berths:
            if assign[i, j].x > 0.5:
                print(f"Ship {i} assigned to Berth {j}")
                print(f"  Start Time: {start_time[i].x:.2f}")
                print(f"  Completion Time: {completion_time[i].x:.2f}")
                print(f"  Waiting Time: {start_time[i].x - arrival_times[i]:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
45.0000
Optimal Assignment and Schedules:
Ship 1 assigned to Berth 2
  Start Time: 8.00
  Completion Time: 12.00
  Waiting Time: 3.00
Ship 2 assigned to Berth 1
  Start Time: 12.00
  Completion Time: 19.00
  Waiting Time: 6.00
Ship 3 assigned to Berth 1
  Start Time: 23.00
  Completion Time: 31.00
  Waiting Time: 15.00
Ship 4 assigned to Berth 2
  Start Time: 31.00
  Completion Time: 39.00
  Waiting Time: 19.00
Ship 5 assigned to Berth 2
  Start Time: 19.00
  Completion Time: 23.00
  Waiting Time: 2.00


```

================================================================================



--- Problem 218 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
At a busy port, the harbor master needs to optimize the allocation of crane time for loading and unloading containers from two major shipping lines: Line A and Line B. The cranes operate on a fixed 90-minute cycle, but not all of this time is usable for operations—each phase incurs a 5-minute lost time for setup and clearance, totaling 10 minutes per cycle. This leaves 80 minutes of effective crane time to allocate between the two lines.

Line A has a demand of 878.82 container moves per hour, with a saturation flow rate of 1722.42 container moves per hour per crane. Meanwhile, Line B handles 634.55 container moves per hour, with a slightly lower saturation flow of 1641.01 container moves per hour per crane. A critical constraint is imposed on Line B: its saturation level must not exceed 0.932 to ensure smooth operations and avoid congestion. Additionally, each phase must grant a minimum of 5 minutes of crane time to prevent impractical scheduling.

The core question is: *How should the 80 minutes of effective crane time be split between Line A and Line B to maximize the Line A crane time while respecting the Line B saturation limit and minimum crane time requirements?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `g_a`: Effective crane time allocated to Line A (minutes), ≥ 5.  
     - `g_b`: Effective crane time allocated to Line B (minutes), ≥ 5.  

   - **2. Parameters:**  
     - `cycle_length = 90`: Total crane cycle duration (minutes).  
     - `total_lost_time = 10`: Lost time per cycle (minutes).  
     - `effective_green_total = 80`: Usable crane time (minutes).  
     - `demand_a = 878.82`, `demand_b = 634.55`: Container move demand (moves/hr).  
     - `saturation_flow_a = 1722.42`, `saturation_flow_b = 1641.01`: Maximum flow rates (moves/hr/crane).  
     - `max_saturation_b = 0.932`: Line B saturation limit.  
     - `min_cranetime = 5`: Minimum crane time per phase (minutes).  

   - **3. Objective Function:**  
     Maximize the Line A crane time:  
     \[
     \text{Maximize: } g_{a}
     \]  

   - **4. Constraints:**  
     - Total crane time allocation:  
       \[
       g_{a} + g_{b} = 80
       \]  
     - Line B saturation limit (derived from demand and flow rate):  
       \[
       g_{b} \geq \frac{\text{demand}_{b} \times \text{cycle\_length}}{\text{saturation\_flow}_{b} \times \text{max\_saturation}_{b}}  
       \]  
     - Minimum crane times:  
       \[
       g_{a} \geq 5, \quad g_{b} \geq 5
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
cycle_length = 90  # minutes
lost_time_per_phase = 5  # minutes
total_lost_time = 2 * lost_time_per_phase
effective_green_total = cycle_length - total_lost_time

demand_a = 878.8211663461063  # moves/hr
saturation_flow_a = 1722.418478428493  # moves/hr/crane
demand_b = 634.5511859854522  # moves/hr
saturation_flow_b = 1641.0080803192513  # moves/hr/crane

max_saturation_b = 0.9322243753566468  # Service level constraint for Line B
min_cranetime = 5  # Minimum crane time per phase

# --- Model Creation ---
model = gp.Model("Crane_Time_Allocation_LP")

# --- Decision Variables ---
g_a = model.addVar(name="green_a", lb=min_cranetime)
g_b = model.addVar(name="green_b", lb=min_cranetime)

# --- Objective Function ---
model.setObjective(g_a, sense=GRB.MAXIMIZE)

# --- Constraints ---
# Total effective crane time equals available time in cycle
model.addConstr(g_a + g_b == effective_green_total, name="total_green_time")

# Line B saturation constraint
min_g_b_for_saturation = (demand_b * cycle_length) / (saturation_flow_b * max_saturation_b)
model.addConstr(g_b >= min_g_b_for_saturation, name="b_saturation_limit")

# --- Optimization ---
model.optimize()

# --- Output Results ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    print(f"Optimal Line A Effective Crane Time: {g_a.X:.2f} minutes")
    print(f"Optimal Line B Effective Crane Time: {g_b.X:.2f} minutes")

    # Calculate actual saturation levels achieved
    sat_a = (demand_a * cycle_length) / (saturation_flow_a * g_a.X) if g_a.X > 0 else float('inf')
    sat_b = (demand_b * cycle_length) / (saturation_flow_b * g_b.X) if g_b.X > 0 else float('inf')

    print(f"\nSaturation Analysis:")
    print(f"  Line A Saturation: {sat_a:.3f}")
    print(f"  Line B Saturation: {sat_b:.3f} (Constraint <= 0.9322243753566468)")

    print(f"\nTiming Summary:")
    print(f"  Total Cycle Length: 90 minutes")
    print(f"  Total Lost Time: {total_lost_time} minutes")
    print(f"  Total Effective Crane: {effective_green_total} minutes")
    print(f"  Minimum Required Line B Crane: {min_g_b_for_saturation:.2f} minutes")
elif model.status == GRB.INFEASIBLE:
    print(f"Optimization Status: Infeasible")
    print(f"Minimum required Line B crane time for saturation limit: {min_g_b_for_saturation:.2f} min")
    print(f"Minimum required Line A crane time: {min_cranetime:.2f} min")
    print(f"Total required minimum crane: {min_g_b_for_saturation + min_cranetime:.2f} min")
    print(f"Total available effective crane: {effective_green_total:.2f} min")
else:
    print(f"Optimization Status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 2 rows, 2 columns and 3 nonzeros
Model fingerprint: 0xbc937b4b
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [5e+00, 5e+00]
  RHS range        [4e+01, 8e+01]
Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    4.2668280e+01   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  4.266828036e+01

--- Optimization Results ---
Optimization Status: Optimal
Optimal Line A Effective Crane Time: 42.67 minutes
Optimal Line B Effective Crane Time: 37.33 minutes

Saturation Analysis:
  Line A Saturation: 1.076
  Line B Saturation: 0.932 (Constraint <= 0.9322243753566468)

Timing Summary:
  Total Cycle Length: 90 minutes
  Total Lost Time: 10 minutes
  Total Effective Crane: 80 minutes
  Minimum Required Line B Crane: 37.33 minutes



================================================================================



--- Problem 219 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A busy trucking company needs to efficiently schedule six incoming trucks (labeled 1 through 6) across three available depots. Each truck arrives at a specific time: Truck 1 at 2.9 hours, Truck 2 at 5.0 hours, and so on, with Truck 6 arriving at 17.3 hours. The processing times vary—Truck 1 requires 8 hours to unload, while Truck 3 and 4 need only 4 hours each. A critical operational rule mandates that no two trucks can start processing within 0.8 hours of each other, even if they are assigned to different depots. The company aims to minimize the total operational time (makespan)—the moment the last truck finishes unloading—while respecting arrival times, processing durations, and the strict start-time separation rule. The core question: *What is the optimal depot assignment and schedule that achieves the earliest possible completion time for all trucks?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary `assign[i, j]`: 1 if truck *i* is assigned to depot *j*, else 0.  
     - Continuous `start_time[i]`: When truck *i* begins processing.  
     - Continuous `completion_time[i]`: When truck *i* finishes (`start_time[i] + processing_times[i]`).  
     - Binary `precedes[i, k, j]`: 1 if truck *i* precedes truck *k* on depot *j*, else 0 (for overlap avoidance).  
     - Binary `z_start_sep[i, k]`: Auxiliary variable to enforce start-time separation between trucks *i* and *k*.  
     - Continuous `makespan`: Tracks the latest completion time across all trucks.  

   - **2. Parameters:**  
     - `arrival_times[i]`: Earliest possible start for truck *i* (e.g., 2.9 for Truck 1).  
     - `processing_times[i]`: Unloading duration (e.g., 8 for Truck 1).  
     - `min_start_gap = 0.8`: Minimum required gap between any two truck start times.  
     - `H = 100`: A large constant (Big-M) for linearizing disjunctive constraints.  

   - **3. Objective Function:**  
     Minimize `makespan` (the latest completion time among all trucks).  

   - **4. Constraints:**  
     - Each truck is assigned to exactly one depot: `sum(assign[i, j] for j in depots) = 1` for all *i*.  
     - Start time cannot precede arrival: `start_time[i] >= arrival_times[i]` for all *i*.  
     - Completion time definition: `completion_time[i] = start_time[i] + processing_times[i]`.  
     - Non-overlapping on the same depot: If `precedes[i, k, j] = 1`, then `start_time[k] >= completion_time[i]` (and vice versa if 0).  
     - Start-time separation: For any two trucks *i* and *k*, either `start_time[i] >= start_time[k] + 0.8` or `start_time[k] >= start_time[i] + 0.8` (enforced via `z_start_sep` and Big-M).  
     - Makespan definition: `makespan >= completion_time[i]` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
depots = [1, 2, 3]
arrival_times = {1: 2.9, 2: 5.0, 3: 9.4, 4: 12.1, 5: 14.3, 6: 17.3}
processing_times = {1: 8, 2: 6, 3: 4, 4: 4, 5: 7, 6: 7}
min_start_gap = 0.8
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_48_START_GAP")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    # Binary var for start separation disjunction
    z_start_sep = m.addVars([(i, k) for i in trucks for k in trucks if i < k],
                            vtype=GRB.BINARY, name="z_start_sep")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. Global Start Time Separation Constraint using Big-M
    for i in trucks:
        for k in trucks:
            if i < k:
                 m.addConstr(start_time[i] >= start_time[k] + min_start_gap - H * (1-z_start_sep[i,k]), name=f"start_gap1_{i}_{k}")
                 m.addConstr(start_time[k] >= start_time[i] + min_start_gap - H * z_start_sep[i,k], name=f"start_gap2_{i}_{k}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")
        if m.SolCount > 0 and abs(m.ObjVal) < GRB.INFINITY :
             print(f"{m.ObjVal:.4f}")
        elif m.status != GRB.INFEASIBLE and m.status != GRB.UNBOUNDED:
             print("No feasible solution found.")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the optimal depot assignment and schedule
if m.status == GRB.OPTIMAL:
    print(f"Optimal makespan: {m.objVal:.4f}")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start time for Truck {i}: {start_time[i].x:.4f}")
                print(f"Completion time for Truck {i}: {completion_time[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
38.9000
Optimal makespan: 38.9000
Truck 1 is assigned to Depot 1
Start time for Truck 1: 2.9000
Completion time for Truck 1: 10.9000
Truck 2 is assigned to Depot 1
Start time for Truck 2: 10.9000
Completion time for Truck 2: 16.9000
Truck 3 is assigned to Depot 1
Start time for Truck 3: 16.9000
Completion time for Truck 3: 20.9000
Truck 4 is assigned to Depot 1
Start time for Truck 4: 20.9000
Completion time for Truck 4: 24.9000
Truck 5 is assigned to Depot 1
Start time for Truck 5: 24.9000
Completion time for Truck 5: 31.9000
Truck 6 is assigned to Depot 1
Start time for Truck 6: 31.9000
Completion time for Truck 6: 38.9000


```

================================================================================



--- Problem 220 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
A logistics company operates a fleet of 2 trucks (with capacities 96 and 100 units, respectively) to deliver goods from a central depot (Node 0) to 4 customer locations (Nodes 1–4). Each customer has a specific demand: 39 units for Nodes 1 and 2, 59 for Node 3, and 51 for Node 4. The distances between nodes are asymmetric, with the depot strategically positioned to minimize travel time—for instance, Node 4 is just 3 units away, while Node 3 is 78 units distant. The challenge is to assign routes to the trucks such that:  
- Every customer is visited exactly once.  
- Trucks start and end at the depot.  
- No truck exceeds its capacity.  
- The total distance traveled is minimized.  

The operational stakes are high: inefficient routing could inflate fuel costs and delay deliveries. The key question is: *What is the most efficient route assignment that meets all constraints while minimizing total travel distance?*  

---

**Modeling Process:**
**1. Decision Variables:**  
- Binary variables `x[i, j, k]` indicate whether truck `k` travels directly from node `i` to node `j` (`1` if yes, `0` otherwise).  
- Continuous variables `u[i]` (for nodes 1–4) enforce subtour elimination via Miller-Tucker-Zemlin (MTZ) constraints.  

**2. Parameters:**  
- `N = 5` (nodes: depot + 4 customers).  
- `K = 2` (trucks).  
- `Q = [96, 100]` (truck capacities).  
- `q = [0, 39, 39, 59, 51]` (demands; depot has 0).  
- `d[i][j]` (distance matrix; e.g., `d[0][4] = 3`).  

**3. Objective Function:**  
Minimize total distance:  
```
Minimize: Σ (d[i][j] * x[i, j, k]) for all k, i, j where i ≠ j.
```  

**4. Constraints:**  
- **Visit each customer once:**  
  `Σ x[i, j, k] = 1` for all customers `i` (sum over trucks `k` and nodes `j`).  
- **Flow conservation:**  
  Inflow equals outflow for each node and truck.  
- **Depot departure/return:**  
  Each truck leaves/returns to the depot at most once.  
- **Capacity limits:**  
  `Σ q[j] * x[i, j, k] ≤ Q[k]` for each truck `k`.  
- **Subtour elimination (MTZ):**  
  `u[i] - u[j] + (N-1) * x[i, j, k] ≤ N-2` for all `i, j ≥ 1, i ≠ j`.  

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 5
K = 2
Q = [96, 100]
q = [0, 39, 39, 59, 51]
d = [
    [0, 56, 50, 78, 3],
    [56, 0, 97, 11, 15],
    [50, 97, 0, 94, 72],
    [78, 11, 94, 0, 84],
    [3, 15, 72, 84, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Truck Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for truck {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for truck {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 270.00

Route for truck 1 (Capacity: 96):
0 -> 4 -> 2 -> 0
Route Load: 90 / 96

Route for truck 2 (Capacity: 100):
0 -> 3 -> 1 -> 0
Route Load: 98 / 100


```

================================================================================



--- Problem 221 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
In a busy port, the harbor master is tasked with optimizing the allocation of crane operation times to minimize delays for cargo handling. The port operates with a fixed cycle time of 90 minutes, divided into three distinct crane operation phases. Each phase must allocate an operation time between a strict minimum of 28 minutes and a maximum of 90 minutes. The cargo volume varies significantly across phases, with coefficients of 388, 1710, and 2611 containers per hour, respectively, reflecting the differing volumes of cargo in each direction.

The core challenge lies in distributing the limited cycle time among the phases to minimize the total delay experienced by all cargo operations. Delay for each phase is calculated as the product of its cargo volume and the corresponding idle time (cycle time minus operation time). The harbor master must ensure that the sum of operation times across all phases exactly matches the 90-minute cycle, while adhering to the lower and upper bounds for each phase. The question is: *What is the optimal allocation of operation times to minimize the total delay across all cargo flows?*

**Modeling Process:**
**1. Decision Variables:**  
   - `t_i`: Continuous variable representing the operation time (in minutes) allocated to phase `i`, where `i ∈ {0, 1, 2}` (for 3 phases).  
   - Bounds: `28 ≤ t_i ≤ 90` for each phase.  

   **2. Parameters:**  
   - `cargo_coeffs = [388, 1710, 2611]`: Cargo volume coefficients (containers/hour) for phases 0, 1, and 2.  
   - `cycle_time = 90`: Total cycle time (minutes).  
   - `lb_time = 28`, `ub_time = 90`: Lower and upper bounds for operation times (minutes).  

   **3. Objective Function:**  
   Minimize the total delay:  
   `Minimize: sum(cargo_coeffs[i] * (cycle_time - t_i) for i in 0..2)`  

   **4. Constraints:**  
   - Total operation time must equal the cycle time:  
     `sum(t_i for i in 0..2) == cycle_time`  
   - Bounds on operation times:  
     `28 ≤ t_i ≤ 90` for each `i`.  

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 3
lb_time = 28          # Lower bound for operation time
ub_time = 90          # Upper bound for operation time
cycle_time = 90       # Total cycle time (set equal to ub_time)
cargo_coeffs = [388, 1710, 2611] # Cargo volume coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(cargo_coeffs) != num_phases:
    print("Error: cargo_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: cargo_coeffs length"
    # raise ValueError("cargo_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Crane Operation Timing", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for phase i is proportional to cargo * idle_time = cargo * (cycle_time - operation_time[i])
        model.setObjective(gp.quicksum(cargo_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of operation times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal operation times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total delay: 276292.00
------------------------------
Optimal operation times (minutes):
  t1: 28.00, t2: 28.00, t3: 34.00


```

================================================================================



--- Problem 222 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
In a busy port, the operations manager is tasked with efficiently scheduling 29 ships of varying sizes into the fewest number of berths possible. Each berth has a strict capacity limit of 42 units, and the goal is to minimize the total number of berths used while ensuring no berth exceeds its capacity. The ships, with sizes ranging from as small as 2 units to as large as 42 units, must be carefully allocated to avoid wasted space. The manager must decide not only which ships go together but also how to group them to maximize berth utilization. The core question is: *What is the most efficient way to schedule these ships into berths to minimize the total number of berths required while respecting the capacity constraints?*

**Modeling Process:**
- **1. Decision Variables:**
     - `x[i, j]`: Binary variable indicating whether ship `i` is assigned to berth `j` (1 if assigned, 0 otherwise).
     - `y[j]`: Binary variable indicating whether berth `j` is used (1 if used, 0 otherwise).
   - **2. Parameters:**
     - `ships`: List of ship sizes (e.g., [33, 28, ..., 34]).
     - `capacity`: Maximum size a berth can hold (42 units).
     - `num_ships`: Total number of ships (29).
     - `num_berths`: Maximum possible berths (29, one per ship in the worst case).
   - **3. Objective Function:**
     - Minimize the total number of berths used:
       `Minimize: sum(y[j] for all j)`
   - **4. Constraints:**
     - **Ship Assignment:** Each ship must be assigned to exactly one berth:
       `For each ship i: sum(x[i, j] for all j) = 1`
     - **Berth Capacity:** The total size in any used berth `j` must not exceed its capacity:
       `For each berth j: sum(ships[i] * x[i, j] for all i) <= capacity * y[j]`

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB

# --- Data Definition ---
ships = [33, 28, 18, 21, 2, 6, 19, 37, 9, 11, 34, 38, 16, 27, 34, 26, 25, 29, 3, 34, 10, 38, 28, 2, 15, 6, 42, 14, 34]      # Sizes of ships
capacity = 42           # Berth capacity
num_ships = 29     # len(ships)
num_berths = num_ships    # Maximum number of berths (worst case: one ship per berth)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Time limit
# env.setParam('TimeLimit', 30)
env.start()

# Create Model
model = Model("Berth Scheduling Problem", env=env)

# --- Decision Variables ---
# x[i,j]: ship i is assigned to berth j
x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")

# --- Objective: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)

# --- Constraints ---
# 1. Each ship must be assigned to exactly one berth
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Berth capacity constraint: sum of sizes in berth j <= capacity IF berth j is used (y[j]=1)
for j in range(num_berths):
    model.addConstr(gp.quicksum(ships[i] * x[i, j] for i in range(num_ships)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

# --- Solve ---
print("Solving Berth Scheduling instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print(f"\nOptimal number of berths used: {optimal_berths}")
    print("-" * 30)
    berth_details = []
    for j_sol in range(num_berths): # Loop through potential berths
        # Check if the berth variable y[j_sol] exists and is set to 1
        try:
            if y[j_sol].X > 0.5: # Check if berth j_sol is used
                # Find ships assigned to this berth j_sol
                assigned_ships_indices = [i for i in range(num_ships) if x[i, j_sol].X > 0.5]
                assigned_ships_sizes = [ships[i] for i in assigned_ships_indices]
                berth_load = sum(assigned_ships_sizes)
                print(f"Berth {j_sol + 1} (Load: {berth_load}/{capacity}): Ships (indices): {assigned_ships_indices}")
                # Optional: Print sizes too
                # print(f"  Sizes: {assigned_ships_sizes}")
                berth_details.append({'berth_index': j_sol, 'ship_indices': assigned_ships_indices, 'load': berth_load})
        except AttributeError:
            pass # Just skip if variable/attribute doesn't exist for unused berths/ships
    results_dict['berth_details'] = berth_details # Store details
    print("-" * 30)

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount to see if a feasible solution was found
     if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
     else: print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving Berth Scheduling instance...

Optimal number of berths used: 17
------------------------------
Berth 1 (Load: 40/42): Ships (indices): [7, 18]
Berth 4 (Load: 34/42): Ships (indices): [19]
Berth 7 (Load: 42/42): Ships (indices): [9, 17, 23]
Berth 8 (Load: 34/42): Ships (indices): [10]
Berth 9 (Load: 28/42): Ships (indices): [1]
Berth 12 (Load: 34/42): Ships (indices): [28]
Berth 14 (Load: 38/42): Ships (indices): [21]
Berth 17 (Load: 42/42): Ships (indices): [3, 4, 6]
Berth 18 (Load: 34/42): Ships (indices): [14]
Berth 21 (Load: 38/42): Ships (indices): [11]
Berth 22 (Load: 42/42): Ships (indices): [15, 20, 25]
Berth 23 (Load: 42/42): Ships (indices): [22, 27]
Berth 24 (Load: 42/42): Ships (indices): [0, 8]
Berth 26 (Load: 42/42): Ships (indices): [26]
Berth 27 (Load: 40/42): Ships (indices): [16, 24]
Berth 28 (Load: 27/42): Ships (indices): [13]
Berth 29 (Load: 40/42): Ships (indices): [2, 5, 12]
------------------------------


```

================================================================================



--- Problem 223 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
A port operator is tasked with scheduling crane operators across three distinct shifts to meet hourly demand while minimizing labor costs. The shifts begin at 6 AM, 2 PM, and 10 PM, each with specific staffing requirements: 9 operators for the 6 AM shift, 6 for the 2 PM shift, and 10 for the 10 PM shift. Each operator assigned to a shift incurs a fixed cost of $156, regardless of the shift timing. The challenge is to determine the minimum number of operators to schedule for each shift such that all demand is met, and the total daily staffing cost is as low as possible. The operator must ensure that the workforce is neither understaffed (violating demand constraints) nor overstaffed (unnecessarily increasing costs). The core question is: *What is the most cost-effective way to assign operators to shifts while fully covering the required staffing levels?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Let \( x_s \) represent the number of operators assigned to shift \( s \), where \( s \in \{1, 2, 3\} \) (corresponding to 6 AM, 2 PM, and 10 PM shifts). Each \( x_s \) is a non-negative integer.  

   **2. Parameters:**  
   - Shift requirements: \( \text{requirements} = \{1: 9, 2: 6, 3: 10\} \).  
   - Cost per operator per shift: \( \text{cost\_per\_operator\_shift} = 156 \).  

   **3. Objective Function:**  
   Minimize the total daily staffing cost:  
   \[
   \text{Minimize: } 156 \cdot (x_1 + x_2 + x_3)
   \]  

   **4. Constraints:**  
   - Meet staffing demand for each shift:  
     \[
     x_1 \geq 9, \quad x_2 \geq 6, \quad x_3 \geq 10
     \]  
   - Non-negativity and integrality:  
     \[
     x_1, x_2, x_3 \geq 0 \text{ and integer.}
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
requirements = {1: 9, 2: 6, 3: 10}
shift_starts = {1: '6am', 2: '2pm', 3: '10pm'} # Using the generated structure
cost_per_operator_shift = 156
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m31 = gp.Model("PORT_CRANE_SCHEDULING_IP", env=env)

    # --- Decision Variables ---
    # Integer: Number of operators starting each shift
    x = m31.addVars(shift_starts.keys(), vtype=GRB.INTEGER, name="operators_start_shift", lb=0)

    # --- Objective Function ---
    # Minimize total daily staffing cost
    m31.setObjective(gp.quicksum(x[s] * cost_per_operator_shift for s in shift_starts.keys()), sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Coverage constraints for each requirement period (assuming 1-to-1 mapping)
    for shift_id, req in requirements.items():
         if shift_id in x: # Check if variable exists for this shift
             m31.addConstr(x[shift_id] >= req, name=f"cover_shift{shift_id}")

    # --- Optimization ---
    m31.optimize()

    # --- Store results ---
    results_dict['status'] = m31.status
    if m31.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m31.ObjVal
        # results_dict['x_sol'] = m31.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m31.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Ensure obj_val_print is a number before formatting
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}") # Original example didn't show decimals, but objval can be float
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m31.status == GRB.INFEASIBLE:
        print("No optimal solution found.") # Matches example's else case
    elif m31.status == GRB.TIME_LIMIT:
        print("No optimal solution found.") # Matches example's else case
    else:
        print("No optimal solution found.") # Matches example's else case


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block to print the number of operators for each shift)
if m31.status == GRB.OPTIMAL:
    for shift_id in shift_starts.keys():
        print(f"Number of operators for {shift_starts[shift_id]} shift: {x[shift_id].X}")
```
Answer:
Optimal objective value: 3900.00
Number of operators for 6am shift: 9.0
Number of operators for 2pm shift: 6.0
Number of operators for 10pm shift: 10.0


```

================================================================================



--- Problem 224 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
In a busy port, ship captains must choose the most efficient berthing path to minimize their waiting and berthing times. Three primary berthing paths—A, B, and C—compete for ships, each with distinct characteristics. Path A offers the shortest free-flow berthing time (0.26 hours) but has the highest capacity (4,032 ships per hour). Path B is slightly slower (0.31 hours) with a moderate capacity (3,210 ships/h), while Path C is the slowest under free-flow conditions (0.41 hours) and has the lowest capacity (2,362 ships/h). The system must accommodate a total demand of 6,554 ships, distributed according to the principles of *user equilibrium*, where no captain can unilaterally reduce their berthing time by switching paths.  

The challenge intensifies when Path A suddenly closes—perhaps due to maintenance or an accident—forcing all traffic onto Paths B and C. The optimization task is twofold: (1) determine the equilibrium flow distribution and resulting berthing times under normal conditions, and (2) quantify the disruption caused by the closure, measured by the increase in total network berthing time. The Bureau of Public Roads (BPR) function models congestion effects, with parameters *α=0.16* and *β=4.11* amplifying delays as flows approach capacity.  

**Core Question:** *How does the closure of Path A redistribute ship flows, and what is the resulting economic impact in terms of additional berthing time endured by all captains?*  
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `x[p]`: Flow of ships (in ships/h) assigned to path `p` (where `p ∈ {A, B, C}` under normal conditions, or `p ∈ {B, C}` during closure).  

**2. Parameters:**  
- `t0[p]`: Free-flow berthing time (hours) for path `p` (e.g., `t0['A'] = 0.26`).  
- `capacity[p]`: Maximum flow capacity (ships/h) for path `p`.  
- `total_demand`: Total ships to berth (6,553.65 ships/h).  
- `bpr_alpha`, `bpr_beta`: BPR function parameters (0.16, 4.11).  

**3. Objective Function (Beckmann Transformation):**  
Minimize the sum of:  
- Free-flow berthing costs: `∑ (t0[p] * x[p])` for all paths `p`.  
- Congestion costs (quadratic approximation): `∑ (t0[p] * α * x[p]^(β+1)) / ((β+1) * capacity[p]^β)` for paths with non-zero capacity.  

**4. Constraints:**  
- **Demand Conservation:** `∑ x[p] = total_demand` (all ships must be assigned).  
- **Non-Negativity:** `x[p] ≥ 0` for all paths `p`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
paths_normal = ['A', 'B', 'C']
paths_closure = ['B', 'C']  # Path A is closed

t0 = {'A': 0.25755021880592927, 'B': 0.31239107241406866, 'C': 0.4118811845367649}  # hours
capacity = {'A': 4032.1720966799217, 'B': 3210.306694408867, 'C': 2362.3726100615454}  # ships/h
bpr_alpha = 0.15877312416432926
bpr_beta = 4.113532130383296
total_demand = 6553.654719850455

# --- Function to solve UE ---
def solve_user_equilibrium(available_paths, t0_dict, capacity_dict, demand):
    m = gp.Model("UserEquilibrium")
    m.Params.NonConvex = 2

    # Decision Variables: Flow on each available path
    x = m.addVars(available_paths, name="flow", lb=0.0)

    # Constraints
    m.addConstr(gp.quicksum(x[i] for i in available_paths) == demand, name="DemandConservation")

    # Objective Function (Beckmann transformation)
    objective = gp.LinExpr()
    for i in available_paths:
        objective += t0_dict[i] * x[i]
        if capacity_dict[i] > 1e-6:
            coef = (t0_dict[i] * bpr_alpha) / ((bpr_beta + 1.0) * (capacity_dict[i] ** bpr_beta))
            # Using quadratic approximation for demonstration
            objective += coef * x[i] * x[i]

    m.setObjective(objective, GRB.MINIMIZE)
    m.optimize()

    flows = {p: x[p].X for p in available_paths}
    times = {}
    total_delay = 0
    for p in available_paths:
        flow = flows[p]
        t_act = t0_dict[p] * (1 + bpr_alpha * (flow / capacity_dict[p])**bpr_beta) if capacity_dict[p]>0 else float('inf')
        times[p] = t_act
        total_delay += flow * t_act

    return flows, times, total_delay

# --- Analysis ---
print("--- Normal Conditions (A, B, C available) ---")
flows_norm, times_norm, delay_norm = solve_user_equilibrium(paths_normal, t0, capacity, total_demand)
print(f"Flows: {flows_norm}")
print(f"Times: {times_norm}")
print(f"Total Network Time: {delay_norm}")

print("\n--- Berth Closure (B, C available) ---")
flows_closure, times_closure, delay_closure = solve_user_equilibrium(paths_closure, t0, capacity, total_demand)
print(f"Flows: {flows_closure}")
print(f"Times: {times_closure}")
print(f"Total Network Time: {delay_closure}")

delay_increase = delay_closure - delay_norm
print(f"\n--- Impact of Closure ---")
print(f"Increase in Total Network Berthing Time: {delay_increase:.2f} ship-hours")
```
Answer:
--- Normal Conditions (A, B, C available) ---
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 1 rows, 3 columns and 3 nonzeros
Model fingerprint: 0xbcf99e35
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [3e-01, 4e-01]
  Bounds range     [0e+00, 0e+00]
  RHS range        [7e+03, 7e+03]
Presolve removed 1 rows and 3 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    1.6878952e+03   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  1.687895207e+03
Flows: {'A': 6553.654719850455, 'B': 0.0, 'C': 0.0}
Times: {'A': 0.559104764339554, 'B': 0.31239107241406866, 'C': 0.4118811845367649}
Total Network Time: 3664.1795777047946

--- Berth Closure (B, C available) ---
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 1 rows, 2 columns and 2 nonzeros
Model fingerprint: 0xf2e1f1fc
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [3e-01, 4e-01]
  Bounds range     [0e+00, 0e+00]
  RHS range        [7e+03, 7e+03]
Presolve removed 1 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    2.0473032e+03   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  2.047303226e+03
Flows: {'B': 6553.654719850455, 'C': 0.0}
Times: {'B': 1.2465301615388387, 'C': 0.4118811845367649}
Total Network Time: 8169.32827660496

--- Impact of Closure ---
Increase in Total Network Berthing Time: 4505.15 ship-hours



================================================================================



--- Problem 225 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port management team faces a critical challenge: mitigating delays caused by a temporary incident that reduces the capacity of the main berth. Over four consecutive 30-minute time periods, ships arrive at varying rates—peaking at 3,552 ships per hour during the third period. The main berth’s normal capacity (4,049 ships/h) drops to 2,795 ships/h due to the incident, which lasts approximately 37.5 minutes. An alternative berth is available but has a lower capacity (1,873 ships/h) and adds an extra 13 minutes of berthing time. To balance congestion, the team can divert fractions of arriving ships (10%, 30%, 50%, or 70%) to the alternative berth in each period, but only if the diverted flow doesn’t exceed the alternative’s capacity. The goal is to dynamically select diversion ratios across all periods to minimize the *total delay*—a combination of queueing delays at the main berth and added berthing time at the alternative. The core question: **What is the optimal diversion strategy for each time period to minimize the cumulative delay for all ships?**

---

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable `y(t, k)` for each time period `t` (1 to 4) and diversion option `k` (1 to 4, representing 10%, 30%, 50%, 70%).  
  - `y(t, k) = 1` if option `k` is chosen in period `t`; otherwise `0`.  

**2. Parameters:**  
- `arrival_rates[t]`: Ship arrival rate (ships/h) for period `t` (values: 2,445, 2,536, 3,552, 2,911).  
- `capacity_main_normal`, `capacity_main_reduced`, `capacity_alt`: Berth capacities (4,049, 2,795, 1,873 ships/h).  
- `alt_berth_extra_time`: Additional berthing time on the alternative berth (0.216 h).  
- `period_option_delays[t][k]`: Precomputed total delay (h·ships) for choosing option `k` in period `t`.  
- `period_option_feasible[t][k]`: Boolean indicating if option `k` is feasible (diverted flow ≤ `capacity_alt`).  

**3. Objective Function:**  
Minimize the sum of delays across all periods:  
```
Minimize: sum( y(t,k) * period_option_delays[t][k] ) for all t, k where feasible.
```  

**4. Constraints:**  
- **Single selection per period:** For each `t`, exactly one feasible option must be chosen:  
  `sum( y(t,k) for feasible k ) = 1`.  
- **Infeasible options forced to 0:** If `period_option_feasible[t][k] = False`, then `y(t,k) = 0`.  

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_TIME_PERIODS = 4
TIME_PERIOD_LENGTH = 0.5  # h
capacity_main_normal = 4049  # ships/h
capacity_main_reduced = 2795  # ships/h
capacity_alt = 1873  # ships/h
arrival_rates = [2445, 2536, 3552, 2911]  # ships/h
incident_duration = 0.6242438010596092  # h
alt_berth_extra_time = 0.21575367324620298  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option and Time Period ---
period_option_delays = {}
period_option_feasible = {}

for t in range(NUM_TIME_PERIODS):
    period_option_delays[t] = {}
    period_option_feasible[t] = {}

    for k in range(num_options):
        p_k = diversion_options[k]
        flow_alt_k = arrival_rates[t] * p_k
        flow_main_k = arrival_rates[t] * (1 - p_k)

        # 1. Check Alternative Berth Capacity Feasibility
        if flow_alt_k > capacity_alt + EPSILON:
            period_option_feasible[t][k] = False
            period_option_delays[t][k] = LARGE_DELAY
            continue

        period_option_feasible[t][k] = True

        # 2. Calculate Alternative Berth Delay
        delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_time

        # 3. Calculate Main Berth Queue Delay
        delay_queue_main_k = 0
        max_queue_main_k = 0

        if flow_main_k > capacity_main_reduced + EPSILON:
            max_queue_main_k = (flow_main_k - capacity_main_reduced) * TIME_PERIOD_LENGTH
            if flow_main_k >= capacity_main_normal - EPSILON:
                delay_queue_main_k = LARGE_DELAY
            else:
                dissipation_rate_k = capacity_main_normal - flow_main_k
                if dissipation_rate_k < EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                    total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                    delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

        # 4. Calculate Total Delay for this option
        total_delay_k = delay_alt_k + delay_queue_main_k
        period_option_delays[t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for t in range(NUM_TIME_PERIODS):
    feasible_indices = [k for k in range(num_options) if period_option_feasible[t][k]]
    if not feasible_indices:
        exit()

    m.addConstr(gp.quicksum(y[t,k] for k in feasible_indices) == 1, name="SelectOneFeasibleOption_Period{0}".format(t))

    for k in range(num_options):
        if not period_option_feasible[t][k]:
            m.addConstr(y[t,k] == 0, name="ForbidInfeasibleOption_Period{0}_Option{1}".format(t,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[t,k] * period_option_delays[t][k]
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if period_option_feasible[t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Dynamic Diversion Strategy:")
    for t in range(NUM_TIME_PERIODS):
        for k in range(num_options):
            if y[t,k].X > 0.5:
                print("Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                    t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                ))
                break
```
Answer:
Optimal Dynamic Diversion Strategy:
Period 1 (0.0-0.5h): Option 0 (10%)
Period 2 (0.5-1.0h): Option 0 (10%)
Period 3 (1.0-1.5h): Option 0 (10%)
Period 4 (1.5-2.0h): Option 0 (10%)



================================================================================



--- Problem 226 ---
**Difficulty:** hard
**Category:** LP

**Problem Description:**
**
A regional logistics company operates a central distribution hub that coordinates shipments between five suppliers (Src_A to Src_E) and six destinations (Dst_X to Dst_]). Each supplier has a fixed capacity, ranging from 192 to 447 units, while destinations have specific demand requirements, such as 310 units for Dst_X and 77 for Dst_]. The hub acts as an intermediary, consolidating shipments to minimize transportation costs. The cost structure is asymmetric: moving goods from suppliers to the hub varies from $4 (Src_D) to $15 (Src_E), while hub-to-destination costs range from $1 (Dst_\) to $15 (Dst_Y and Dst_[). The challenge is to determine the optimal flow of goods through the hub—balancing supply limits, meeting all demand, and ensuring the hub’s inflow equals outflow—while minimizing the total cost, which hinges on strategic allocation of high-volume routes to cheaper paths. Additionally, the company wants to ensure that no single supplier provides more than 50% of the total supply to any destination to maintain a balanced distribution.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `flow[(i, j)]`: Continuous non-negative variable representing units shipped from node *i* to *j*, where *i* is a supplier or hub, and *j* is the hub or a destination.  
   - **2. Parameters:**  
     - `supply[s]`: Maximum output from supplier *s* (e.g., Src_A: 192).  
     - `demand[d]`: Required intake at destination *d* (e.g., Dst_X: 310).  
     - `costs[(i, j)]`: Cost per unit shipped (e.g., (Src_D, Hub): $4).  
   - **3. Objective Function:**  
     - Minimize total cost:  
       \[
       \text{Minimize: } \sum_{(i,j)} \text{flow}[(i,j)] \times \text{costs}[(i,j)]
       \]  
   - **4. Constraints:**  
     - **Supply limits:** For each supplier *s*, flow to hub ≤ `supply[s]`.  
     - **Demand satisfaction:** For each destination *d*, flow from hub ≥ `demand[d]`.  
     - **Hub balance:** Total inflow to hub = total outflow from hub.  
     - **Balanced distribution:** No single supplier provides more than 50% of the total supply to any destination.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
sources = ['Src_A', 'Src_B', 'Src_C', 'Src_D', 'Src_E']
destinations = ['Dst_X', 'Dst_Y', 'Dst_Z', 'Dst_[', 'Dst_\\', 'Dst_]']
hub = 'Hub' # Use !r for repr() to keep quotes for the string
supply = {'Src_A': 192, 'Src_B': 291, 'Src_C': 260, 'Src_D': 248, 'Src_E': 447}
demand = {'Dst_X': 310, 'Dst_Y': 105, 'Dst_Z': 200, 'Dst_[': 197, 'Dst_\\': 265, 'Dst_]': 77}
costs = {('Src_A', 'Hub'): 8, ('Src_B', 'Hub'): 12, ('Src_C', 'Hub'): 14, ('Src_D', 'Hub'): 4, ('Src_E', 'Hub'): 15, ('Hub', 'Dst_X'): 2, ('Hub', 'Dst_Y'): 15, ('Hub', 'Dst_Z'): 6, ('Hub', 'Dst_['): 15, ('Hub', 'Dst_\\'): 1, ('Hub', 'Dst_]'): 14}
# --- End Parameters ---

GUROBI_TIME_LIMIT = 60

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi console output within exec
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m25 = gp.Model("Logistics_Hub_Flow_LP", env=env)

    # --- Decision Variables ---
    # Flow variables for each arc
    flow_keys = list(costs.keys()) # Explicitly get keys for var creation
    flow = m25.addVars(flow_keys, name="flow", lb=0) # LP variables default to continuous

    # --- Objective Function ---
    # Minimize total transportation cost
    m25.setObjective(gp.quicksum(flow[i, j] * costs[i, j] for i, j in flow_keys), sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Supply constraints at sources
    for s in sources:
        # Ensure the key exists before adding constraint
        arc_key = (s, hub)
        if arc_key in flow:
            # Use string concatenation for name to avoid f-string formatting issues here
            m25.addConstr(flow[arc_key] <= supply[s], name="supply_" + s)
        # No else needed, if arc doesn't exist, can't use it

    # Demand constraints at destinations
    for d in destinations:
         # Ensure the key exists before adding constraint
         arc_key = (hub, d)
         if arc_key in flow:
            # Use string concatenation for name
            m25.addConstr(flow[arc_key] >= demand[d], name="demand_" + d)
         # No else needed

    # Flow balance at the Hub (Inflow = Outflow)
    # Check if keys exist before summing
    inflow_keys_hub = [k for k in flow_keys if k[1] == hub and k[0] in sources]
    outflow_keys_hub = [k for k in flow_keys if k[0] == hub and k[1] in destinations]

    # Check if lists are non-empty before creating expressions that might be empty
    inflow_hub_expr = gp.quicksum(flow[k] for k in inflow_keys_hub) if inflow_keys_hub else 0
    outflow_hub_expr = gp.quicksum(flow[k] for k in outflow_keys_hub) if outflow_keys_hub else 0
    m25.addConstr(inflow_hub_expr == outflow_hub_expr, name="hub_balance")

    # Balanced distribution constraint
    for d in destinations:
        for s in sources:
            arc_key = (hub, d)
            if arc_key in flow:
                m25.addConstr(flow[arc_key] <= 0.5 * demand[d], name=f"balanced_distribution_{s}_{d}")

    # --- Optimization ---
    m25.optimize()

    # --- Store results ---
    results_dict['status'] = m25.status
    if m25.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m25.objVal
        # Store flow values, converting keys back to tuples if needed
        results_dict['flow_sol'] = {k: v for k, v in m25.getAttr('X', flow).items()}
        # Store expression values IF they are LinExpr (might be 0 if no flows)
        results_dict['inflow_val'] = inflow_hub_expr.getValue() if isinstance(inflow_hub_expr, gp.LinExpr) else inflow_hub_expr
        results_dict['outflow_val'] = outflow_hub_expr.getValue() if isinstance(outflow_hub_expr, gp.LinExpr) else outflow_hub_expr


    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print("--- Problem 25: Logistics Hub Truck Flow (LP) ---")
    if m25.status == GRB.OPTIMAL:
        flow_sol = results_dict.get('flow_sol', {}) # Get solution from dict
        print(f"Optimization Status: Optimal")
        # Use .get with a default for obj_val before formatting
        obj_val_print = results_dict.get('obj_val', 0) # Default to 0 if not found
        print(f"Minimum Total Transportation Cost: ${obj_val_print:.2f}")
        print("Optimal Flows:")
        total_supply_used_calc = 0
        total_demand_met_calc = 0
        # Use .items() for iterating through solution dictionary
        for (i, j), flow_val in flow_sol.items():
            if flow_val > 1e-6: # Print only non-negligible flows
                # Escape i, j, flow_val and braces for costs.get()
                print(f"  Flow from {i} to {j}: {flow_val:.1f} units (Cost/Unit: ${costs.get((i,j), 'N/A')})")
                if i in sources: total_supply_used_calc += flow_val
                if j in destinations: total_demand_met_calc += flow_val

        print("\nSummary:")
        # Use .get with defaults for calculated values before formatting
        inflow_print = results_dict.get('inflow_val', 0)
        outflow_print = results_dict.get('outflow_val', 0)
        # Ensure inflow/outflow values are numbers before formatting
        print(f"Total Flow In Hub: {float(inflow_print):.1f}")
        print(f"Total Flow Out Hub: {float(outflow_print):.1f}")
        # Re-calculate supply/demand usage from solution dict for detailed output
        for s in sources:
             flow_out = flow_sol.get((s, hub), 0)
             # Escape s, flow_out and braces for supply.get()
             print(f"  Supply from {s}: {flow_out:.1f} / {supply.get(s, 'N/A')}")
        for d in destinations:
             flow_in = flow_sol.get((hub, d), 0)
             # Escape d, flow_in and braces for demand.get()
             print(f"  Demand met for {d}: {flow_in:.1f} / {demand.get(d, 'N/A')}")

    elif m25.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible. Check if total supply >= total demand.")
         # Calculate totals directly from input params for this message
         # Escape braces for sum() values
         print(f"Total Supply Available: {sum(supply.values())}")
         print(f"Total Demand Required: {sum(demand.values())}")
    elif m25.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)") # Escape limit
         # If objective value exists (feasible solution found before limit), print it
         if m25.ObjVal is not None and abs(m25.ObjVal) < float('inf'):
              # Escape objval
              print(f"Best Objective Found: ${m25.ObjVal:.2f}")
         else:
              print("No feasible solution found within time limit.")
    else:
        # Handle other statuses like UNBOUNDED, INF_OR_UNBD etc.
        print(f"Optimization Status Code: {m25.status}") # Escape status

except GurobiError as e:
    # Escape errno and e message
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
except Exception as e:
    print(f"Python Error: {e}") # Escape error message
    print("--- Traceback ---")
    traceback.print_exc(file=sys.stdout)
    print("--- End Traceback ---")
    results_dict['status'] = -2 # Indicate Python execution error



# The code provided already prints all the necessary outputs, including the optimization status,
# total transportation cost, optimal flows, and a summary of supply and demand.
# No additional print statements are needed.
```
Answer:
--- Problem 25: Logistics Hub Truck Flow (LP) ---
Optimization Status: Infeasible. Check if total supply >= total demand.
Total Supply Available: 1438
Total Demand Required: 1154


```

================================================================================



--- Problem 227 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
A port operator faces the challenge of dynamically adjusting berthing fees across two distinct traffic periods—off-peak and peak—to maximize revenue while respecting infrastructure constraints. During off-peak hours, the base demand for berthing is 1,155 ships per hour, while peak hours see a significantly higher base demand of 3,198 ships per hour. The operator knows that demand is sensitive to fee changes: for every $1 increase in fees, demand drops by 62 ships per hour. The port has a fixed capacity of 3,996 ships per hour, meaning the actual flow of ships cannot exceed this limit, regardless of demand. Additionally, the operator cannot charge more than $15 per ship in any period.

The operator’s dilemma is to determine the optimal berthing fees for each period that will maximize total revenue, balancing the trade-off between higher fees (which reduce demand but increase per-ship revenue) and lower fees (which attract more ships but yield less revenue per ship). The solution must also ensure that the actual flow of ships never surpasses the port’s capacity or the demand for that period. The core question is: *What berthing fees should be set for off-peak and peak periods to achieve the highest possible total revenue, given these constraints?*

---

**Modeling Process:**
#### 1. **Decision Variables:**
   - `fee[p]`: The berthing fee (in dollars) for period `p` (where `p` is either 'off' or 'peak'). Bounded between 0 and 15.
   - `demand[p]`: The resulting demand (in ships per hour) for period `p`, calculated as a function of the base demand and fee sensitivity.
   - `flow[p]`: The actual flow of ships (in ships per hour) for period `p`, which is the minimum of demand and capacity.

#### 2. **Parameters:**
   - `base_demand = {'off': 1155, 'peak': 3198}`: Base demand (ships/hr) for each period.
   - `alpha = 62`: Fee sensitivity coefficient (demand drops by 62 ships/hr per $1 increase).
   - `capacity = 3996`: Maximum flow capacity (ships/hr) of the port.
   - `max_fee = 15`: Upper bound on berthing fee ($).

#### 3. **Objective Function:**
   - Maximize the total revenue across both periods:
     ```
     Maximize: sum(flow[p] * fee[p] for p in periods)
     ```

#### 4. **Constraints:**
   - **Demand Calculation:** For each period `p`, demand is linearly dependent on fee:
     ```
     demand[p] = base_demand[p] - alpha * fee[p]
     ```
   - **Flow Capacity:** The actual flow cannot exceed the port’s capacity:
     ```
     flow[p] <= capacity for each p
     ```
   - **Flow Demand:** The actual flow cannot exceed the demand:
     ```
     flow[p] <= demand[p] for each p
     ```
   - **Non-Negativity:** All variables (`fee`, `demand`, `flow`) are non-negative.

---

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 3996; base_demand = {'off': 1155, 'peak': 3198}; alpha = 62; max_fee = 15; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berthing_Fees_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berthing Fees (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of TOLL_PRICING
```
Answer:
--- Problem 18: Dynamic Berthing Fees (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $39399.13
  Period: Off
    Optimal Fee: $9.31 (Max: $15)
    Resulting Demand: 577.5 ships/hr (Base: 1155)
    Actual Flow (min(Demand, Capacity)): 577.5 ships/hr (Capacity: 3996)
    Revenue this period: $5379.13
  Period: Peak
    Optimal Fee: $15.00 (Max: $15)
    Resulting Demand: 2268.0 ships/hr (Base: 3198)
    Actual Flow (min(Demand, Capacity)): 2268.0 ships/hr (Capacity: 3996)
    Revenue this period: $34020.00
Total ships processed: 2845.5



================================================================================


--- Problem 228 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
A sudden traffic incident has disrupted the flow of vehicles on a major highway, reducing its capacity significantly. With over 4,000 vehicles arriving per hour, transportation planners must quickly decide how to reroute traffic to minimize total system delay. The main highway, normally handling 4,508 vehicles per hour, now operates at just 56% capacity (2,546 veh/h) due to the incident, which is expected to last 1.7 hours. An alternative route is available, but it has its own limitations—a maximum capacity of 2,120 veh/h and a baseline travel time of 21.2 minutes (0.35 hours) under free-flow conditions. 

The challenge lies in balancing the flow between these routes. Sending too many vehicles to the alternative route could congest it, increasing travel times due to the BPR (Bureau of Public Roads) formula, which models congestion effects with parameters α=0.138 and β=3.087. Meanwhile, overloading the main route could create queues that take time to dissipate after the incident clears. The goal is to find the optimal split of traffic flows that minimizes the total system delay, accounting for both the increased travel time on the alternative route and any queuing delays on the main route.

Additionally, there is a forecast of light rain during the incident, which may slightly affect visibility and driver behavior, but this does not impact the optimization model or the results.
**

**Modeling Process:**
**
**1. Decision Variables:**
- `flow_alt`: Continuous variable representing the flow of vehicles diverted to the alternative route (veh/h).
- `flow_main`: Continuous variable representing the flow of vehicles remaining on the main route (veh/h).

**2. Intermediate Variables:**
- `T_alt_actual`: Actual travel time on the alternative route, accounting for congestion (h).
- `vol_cap_ratio`: Ratio of flow to capacity on the alternative route.
- `vol_cap_pow_beta`: The BPR congestion term (vol_cap_ratio)^β.
- `max_queue_main`: Maximum queue length on the main route during the incident (vehicles).
- `dissipation_time_main`: Time required to clear the queue after the incident ends (h).
- `dissipation_rate_main`: Rate at which the queue dissipates (veh/h).

**3. Parameters:**
- `capacity_main_normal`: 4,508.66 veh/h (main route normal capacity).
- `capacity_main_reduced`: 2,546.48 veh/h (main route reduced capacity during incident).
- `capacity_alt`: 2,120.04 veh/h (alternative route capacity).
- `arrival_rate_total`: 4,029.68 veh/h (total incoming traffic flow).
- `incident_duration`: 1.7055 h (duration of the incident).
- `T0_alt`: 0.3536 h (free-flow travel time on alternative route).
- `bpr_alpha`: 0.1378 (BPR α parameter).
- `bpr_beta`: 3.0872 (BPR β parameter).

**4. Objective Function:**
Minimize the total system delay, composed of:
- The additional delay on the alternative route: `incident_duration * flow_alt * (T_alt_actual - T0_alt)`.
- The queuing delay on the main route: `0.5 * incident_duration * max_queue_main + 0.5 * max_queue_main * dissipation_time_main`.

**5. Constraints:**
- Flow conservation: `flow_main + flow_alt = arrival_rate_total`.
- Alternative route capacity: `flow_alt <= capacity_alt`.
- Volume-capacity ratio: `vol_cap_ratio = flow_alt / capacity_alt` and `vol_cap_ratio <= 1`.
- BPR travel time: `T_alt_actual = T0_alt * (1 + bpr_alpha * vol_cap_pow_beta)`.
- Queue growth: `max_queue_main = max(0, flow_main - capacity_main_reduced) * incident_duration`.
- Queue dissipation: `dissipation_time_main = max_queue_main / (capacity_main_normal - flow_main)`.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
capacity_main_normal = 4508.663826573686  # veh/h
capacity_main_reduced = 2546.476543177808  # veh/h
capacity_alt = 2120.040695077528  # veh/h
arrival_rate_total = 4029.675750492555  # veh/h
incident_duration = 1.7055000211447717  # h
T0_alt = 0.3535510371489885  # h
bpr_alpha = 0.1378095475472745
bpr_beta = 3.0871860390439063
EPSILON = 1e-6

# --- Gurobi Model ---
model = gp.Model("AccidentRerouting")

# Decision Variables
flow_alt = model.addVar(name="flow_alt", lb=0.0, ub=arrival_rate_total)
flow_main = model.addVar(name="flow_main", lb=0.0)

# Intermediate Variables
T_alt_actual = model.addVar(name="T_alt_actual", lb=T0_alt)
vol_cap_ratio = model.addVar(name="vol_cap_ratio", lb=0.0)
vol_cap_pow_beta = model.addVar(name="vol_cap_pow_beta", lb=0.0)
max_queue_main = model.addVar(name="max_queue_main", lb=0.0)
dissipation_time_main = model.addVar(name="dissipation_time_main", lb=0.0)
dissipation_rate_main = model.addVar(name="dissipation_rate_main", lb=EPSILON)

# Constraints
model.addConstr(flow_main + flow_alt == arrival_rate_total, name="FlowConservation")
model.addConstr(flow_alt <= capacity_alt, name="AltRouteCapacity")
model.addConstr(vol_cap_ratio <= 1.0, name="VolCapRatioLimit")
model.addConstr(vol_cap_ratio * capacity_alt == flow_alt, name="CalcVolCapRatio")
model.addGenConstrPow(vol_cap_ratio, vol_cap_pow_beta, bpr_beta, name="CalcPowerTerm")
model.addConstr(T_alt_actual == T0_alt * (1.0 + bpr_alpha * vol_cap_pow_beta), name="CalcActualAltTime")

# Queue calculations
queue_growth_rate = model.addVar(name="queue_growth_rate", lb=0.0)
aux_growth_input = model.addVar(name="aux_growth_input", lb=-GRB.INFINITY)
model.addConstr(aux_growth_input == flow_main - capacity_main_reduced, name="CalcAuxGrowthInput")
model.addGenConstrMax(queue_growth_rate, [aux_growth_input], 0.0, name="CalcQueueGrowthRate")
model.addConstr(max_queue_main == queue_growth_rate * incident_duration, name="CalcMaxQueue")

# Dissipation calculations
model.addConstr(dissipation_rate_main == capacity_main_normal - flow_main, name="CalcDissipationRate")
model.addQConstr(dissipation_time_main * dissipation_rate_main == max_queue_main, name="CalcDissipationTime")

# Objective
obj = gp.QuadExpr()
obj += incident_duration * flow_alt * T_alt_actual - incident_duration * T0_alt * flow_alt
obj += 0.5 * incident_duration * max_queue_main
obj += 0.5 * max_queue_main * dissipation_time_main
model.setObjective(obj, GRB.MINIMIZE)

# Optimize
model.Params.NonConvex = 2
model.optimize()

# Output
if model.status == GRB.OPTIMAL:
    print("\n--- Accident Rerouting Results ---")
    print(f"Optimal Total System Delay: {model.objVal:.2f} vehicle-hours")
    print(f"Flow to Alternative Route: {flow_alt.X:.2f} veh/h")
    print(f"Flow on Main Route: {flow_main.X:.2f} veh/h")
    print(f"Alternative Route Travel Time: {T_alt_actual.X * 60:.2f} min")
    print(f"Max Queue on Main Route: {max_queue_main.X:.2f} vehicles")
    print(f"Queue Dissipation Time: {dissipation_time_main.X:.2f} h")
else:
    print(f"Model status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 8 rows, 10 columns and 14 nonzeros
Model fingerprint: 0xca56f91b
Model has 2 quadratic objective terms
Model has 1 quadratic constraint
Model has 1 simple general constraint
  1 MAX
Model has 1 function constraint treated as nonlinear
  1 POW
Variable types: 10 continuous, 0 integer (0 binary)
Coefficient statistics:
  Matrix range     [5e-02, 2e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [6e-01, 9e-01]
  QObjective range [1e+00, 3e+00]
  Bounds range     [1e-06, 4e+03]
  RHS range        [4e-01, 5e+03]
Presolve removed 2 rows and 1 columns
Presolve time: 0.00s
Presolved: 20 rows, 13 columns, 45 nonzeros
Presolved model has 3 bilinear constraint(s)
Presolved model has 1 nonlinear constraint(s)

Solving non-convex MINLP

Variable types: 12 continuous, 1 integer (1 binary)
Found heuristic solution: objective 40.9092997

Root relaxation: objective 1.703582e+01, 4 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0   17.03582    0    2   40.90930   17.03582  58.4%     -    0s
     0     0   40.87685    0    2   40.90930   40.87685  0.08%     -    0s

Explored 1 nodes (6 simplex iterations) in 0.01 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 40.9093 

Optimal solution found (tolerance 1.00e-04)
Best objective 4.090929968751e+01, best bound 4.090929864525e+01, gap 0.0000%

--- Accident Rerouting Results ---
Optimal Total System Delay: 40.91 vehicle-hours
Flow to Alternative Route: 1483.20 veh/h
Flow on Main Route: 2546.48 veh/h
Alternative Route Travel Time: 22.18 min
Max Queue on Main Route: 0.00 vehicles
Queue Dissipation Time: 0.00 h



================================================================================



--- Problem 229 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A busy port terminal needs to optimize its daily revenue by efficiently scheduling two types of ships: short-term and long-term. The terminal has 128 berths available for 10 operating hours each day, providing a total of 1,280 berth-hours of capacity. Short-term ships pay $12 for a 2-hour stay, while long-term ships pay $86 for an 8-hour stay. The demand is high but limited: up to 53 short-term ships and 60 long-term ships may seek berths daily. However, the terminal must reserve at least 37 berths for short-term ships at any given time to ensure availability for quick turnaround customers. The manager must decide how many short-term and long-term ships to accept to maximize revenue without exceeding berth-hour capacity or violating the short-term reservation rule. The core question is: *What combination of short-term and long-term ships yields the highest possible daily revenue while adhering to all operational constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x_short_term`: Number of short-term ships to accept (continuous, ≥ 0).  
     - `x_long_term`: Number of long-term ships to accept (continuous, ≥ 0).  
   - **2. Parameters:**  
     - `revenue_per_short_term = $12`, `revenue_per_long_term = $86`.  
     - `short_term_stay = 2` hours, `long_term_stay = 8` hours.  
     - `total_berth_hours = 1,280` (128 berths × 10 hours).  
     - `max_short_term_demand = 53`, `max_long_term_demand = 60`.  
     - `max_berths_for_long_term = 91` (derived from reserving 37 berths for short-term ships).  
   - **3. Objective Function:**  
     Maximize total revenue:  
     `Maximize: 12 * x_short_term + 86 * x_long_term`.  
   - **4. Constraints:**  
     - Berth-hour capacity: `2 * x_short_term + 8 * x_long_term ≤ 1,280`.  
     - Short-term demand: `x_short_term ≤ 53`.  
     - Long-term demand: `x_long_term ≤ 60`.  
     - Long-term berth limit: `x_long_term ≤ 91` (to reserve 37 berths for short-term ships).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
total_berths = 128; op_hours = 10; short_term_rate = 12; short_term_stay = 2
long_term_rate = 86; long_term_stay = 8; max_short_term_demand = 53
max_long_term_demand = 60; min_berths_for_short_term = 37
# Derived Params (passed from generator)
revenue_per_short_term = 12; revenue_per_long_term = 86
total_berth_hours = 1280; max_berths_for_long_term = 91
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m19 = gp.Model("Port_Berthing_Price_Differentiation_LP", env=env)
    # Vars
    x_short_term = m19.addVar(name="num_short_term_ships", lb=0)
    x_long_term = m19.addVar(name="num_long_term_ships", lb=0)
    # Objective
    m19.setObjective(revenue_per_short_term * x_short_term + revenue_per_long_term * x_long_term, sense=GRB.MAXIMIZE)
    # Constraints
    m19.addConstr(x_short_term * short_term_stay + x_long_term * long_term_stay <= total_berth_hours, "berth_hour_capacity")
    m19.addConstr(x_short_term <= max_short_term_demand, "short_term_demand")
    m19.addConstr(x_long_term <= max_long_term_demand, "long_term_demand")
    # Ensure long-term ships don't use berths needed for min short-term requirement.
    # This constraint might need re-evaluation: it limits the *number* of long-term ships based on total berths,
    # not directly guaranteeing berth availability *at any given time* for short-term.
    # A simulation or more complex model might be needed for strict guarantee.
    # Keeping user's formulation:
    m19.addConstr(x_long_term <= max_berths_for_long_term, "long_term_berth_limit_for_short_term")
    # Optimize
    m19.optimize()
    # Store results
    results_dict['status'] = m19.status
    if m19.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m19.objVal; results_dict['xst_opt'] = x_short_term.X; results_dict['xlt_opt'] = x_long_term.X
    # Output Results
    print("--- Problem 19: Port Berthing Price Differentiation (LP) ---")
    if m19.status == GRB.OPTIMAL:
        xst = results_dict.get('xst_opt', 0); xlt = results_dict.get('xlt_opt', 0)
        berth_hours_used = xst * short_term_stay + xlt * long_term_stay
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Daily Revenue: ${m19.objVal:.2f}")
        print(f"Optimal number of Short-Term Ships to accept: {xst:.2f} (Demand: {max_short_term_demand})")
        print(f"Optimal number of Long-Term Ships to accept: {xlt:.2f} (Demand: {max_long_term_demand}, Max allowed by short-term min: {max_berths_for_long_term})")
        print(f"Total Berth-Hours Used: {berth_hours_used:.1f} / {total_berth_hours}")
    else: print(f"Optimization Status: {m19.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_BERTHING_PRICE
```
Answer:
--- Problem 19: Port Berthing Price Differentiation (LP) ---
Optimization Status: Optimal
Maximum Total Daily Revenue: $5796.00
Optimal number of Short-Term Ships to accept: 53.00 (Demand: 53)
Optimal number of Long-Term Ships to accept: 60.00 (Demand: 60, Max allowed by short-term min: 91)
Total Berth-Hours Used: 586.0 / 1280



================================================================================



--- Problem 230 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A logistics company operates a fleet of 7 trucks (with capacities 87, 88, 70, 40, 92, 25, and 24 units) to serve 7 customer locations from a central depot (node 0). Each customer has a specific demand (ranging from 6 to 83 units), and the distances between all pairs of nodes (depot + customers) are explicitly provided in a symmetric distance matrix. The challenge is to design routes for the trucks such that:  
- Every customer is visited exactly once.  
- Each truck starts and ends at the depot without exceeding its capacity.  
- The total distance traveled by all trucks is minimized.  

The company faces tight operational constraints, requiring careful balancing of truck utilization to avoid overloading while minimizing fuel costs. The key question is: *What is the most efficient set of routes that meets all demands while traveling the least total distance?*  

---
**

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variables `x[i, j, k]`: 1 if truck *k* travels directly from node *i* to node *j*, else 0.  
- Continuous variables `u[i]`: Subtour elimination variables (MTZ formulation) for customer nodes *i* (1 to 7).  

**2. Parameters:**  
- `N = 8`: Total nodes (depot + 7 customers).  
- `K = 7`: Number of trucks.  
- `Q[k]`: Capacity of truck *k* (e.g., 87, 88, ...).  
- `q[i]`: Demand at customer *i* (e.g., 6, 83, ...).  
- `d[i][j]`: Distance between nodes *i* and *j* (symmetric matrix).  

**3. Objective Function:**  
Minimize total distance:  
```
Minimize: sum(d[i][j] * x[i, j, k] for all i, j, k where i ≠ j)
```  

**4. Constraints:**  
- **Visit each customer once:**  
  `sum(x[i, j, k] for all j, k where i ≠ j) = 1` for each customer *i*.  
- **Flow conservation:**  
  `sum(x[i, j, k] for all j) = sum(x[j, i, k] for all j)` for each node *i* and truck *k*.  
- **Depot departure/return:**  
  Each truck *k* must leave and return to the depot (node 0) at most once.  
- **Capacity limits:**  
  `sum(q[j] * sum(x[i, j, k] for all i) for all j) ≤ Q[k]` for each truck *k*.  
- **Subtour elimination (MTZ):**  
  `u[i] - u[j] + (N-1) * x[i, j, k] ≤ N-2` for all customer pairs *i*, *j* (*i ≠ j*) and trucks *k*.  

---  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 8
K = 7
Q = [87, 88, 70, 40, 92, 25, 24]
q = [0, 6, 83, 73, 11, 25, 41, 41]
d = [
    [0, 92, 52, 55, 82, 65, 40, 50],
    [92, 0, 94, 17, 94, 87, 29, 79],
    [52, 94, 0, 32, 65, 93, 72, 8],
    [55, 17, 32, 0, 20, 57, 11, 98],
    [82, 94, 65, 20, 0, 69, 7, 18],
    [65, 87, 93, 57, 69, 0, 37, 12],
    [40, 29, 72, 11, 7, 37, 0, 38],
    [50, 79, 8, 98, 18, 12, 38, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Truck Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for truck {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for truck {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# The provided code already prints the total distance and routes for each truck.
# However, it does not print the decision variables x[i, j, k] which might be useful for a complete solution.
# Adding the following code to print the decision variables:

if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for truck {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for truck {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

    # Print decision variables x[i, j, k]
    print("\nDecision Variables (x[i, j, k]):")
    for k in range(K):
        for i in range(N):
            for j in range(N):
                if i != j and (i, j, k) in x and x[i, j, k].X > 0.5:
                    print(f"x[{i}, {j}, {k}] = 1 (Truck {k+1} travels from node {i} to node {j})")
else:
    print("\nModel is infeasible. No solution found.")
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 522.00

Route for truck 1 (Capacity: 87):
0 -> 5 -> 7 -> 0
Route Load: 66 / 87

Route for truck 2 (Capacity: 88):
0 -> 2 -> 0
Route Load: 83 / 88

Route for truck 3 (Capacity: 70):
0 -> 6 -> 0
Route Load: 41 / 70

Route for truck 5 (Capacity: 92):
0 -> 1 -> 3 -> 4 -> 0
Route Load: 90 / 92

Optimal solution found!
Total distance: 522.00

Route for truck 1 (Capacity: 87):
0 -> 5 -> 7 -> 0
Route Load: 66 / 87

Route for truck 2 (Capacity: 88):
0 -> 2 -> 0
Route Load: 83 / 88

Route for truck 3 (Capacity: 70):
0 -> 6 -> 0
Route Load: 41 / 70

Route for truck 5 (Capacity: 92):
0 -> 1 -> 3 -> 4 -> 0
Route Load: 90 / 92

Decision Variables (x[i, j, k]):
x[0, 5, 0] = 1 (Truck 1 travels from node 0 to node 5)
x[5, 7, 0] = 1 (Truck 1 travels from node 5 to node 7)
x[7, 0, 0] = 1 (Truck 1 travels from node 7 to node 0)
x[0, 2, 1] = 1 (Truck 2 travels from node 0 to node 2)
x[2, 0, 1] = 1 (Truck 2 travels from node 2 to node 0)
x[0, 6, 2] = 1 (Truck 3 travels from node 0 to node 6)
x[6, 0, 2] = 1 (Truck 3 travels from node 6 to node 0)
x[0, 1, 4] = 1 (Truck 5 travels from node 0 to node 1)
x[1, 3, 4] = 1 (Truck 5 travels from node 1 to node 3)
x[3, 4, 4] = 1 (Truck 5 travels from node 3 to node 4)
x[4, 0, 4] = 1 (Truck 5 travels from node 4 to node 0)


```

================================================================================



--- Problem 231 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy trucking depot is tasked with efficiently scheduling the unloading of incoming trucks to minimize their total time spent at the depot, a key factor in operational efficiency and customer satisfaction. Three trucks—labeled 1, 2, and 3—arrive at staggered times: Truck 1 arrives at hour 5, Truck 2 at hour 10, and Truck 3 at hour 13. Each truck requires a specific unloading time: 8 hours for Trucks 1 and 3, and 7 hours for Truck 2. With only one unloading bay available, the depot must carefully schedule the trucks to avoid overlaps while respecting their arrival times. The core question is: *What is the optimal unloading schedule that minimizes the cumulative time all trucks spend at the depot, from arrival to departure?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign[i, j]`: Binary variable (1 if truck *i* is assigned to unloading bay *j*, 0 otherwise).  
     - `start_time[i]`: Continuous variable representing the start time of truck *i* at its assigned unloading bay.  
     - `completion_time[i]`: Continuous variable representing the departure time of truck *i*.  
     - `precedes[i, k, j]`: Binary variable (1 if truck *i* is scheduled before truck *k* on unloading bay *j*, 0 otherwise).  

   - **2. Parameters:**  
     - `arrival_times[i]`: Arrival time of truck *i* (e.g., Truck 1 arrives at hour 5).  
     - `processing_times[i]`: Unloading duration for truck *i* (e.g., Truck 2 requires 7 hours).  
     - `H = 100`: A large constant ("Big M") for linearizing constraints.  

   - **3. Objective Function:**  
     Minimize the total time at the depot for all trucks:  
     `Minimize: sum(completion_time[i] - arrival_times[i] for all trucks i)`  

   - **4. Constraints:**  
     - **Assignment:** Each truck must be assigned to exactly one unloading bay.  
       `For each truck i: sum(assign[i, j] for all unloading bays j) = 1`  
     - **Arrival Time:** Trucks cannot start unloading before arrival.  
       `For each truck i: start_time[i] >= arrival_times[i]`  
     - **Completion Time:** Departure time equals start time plus unloading time.  
       `For each truck i: completion_time[i] = start_time[i] + processing_times[i]`  
     - **Non-Overlapping:** If two trucks *i* and *k* share an unloading bay, one must precede the other.  
       `For each unloading bay j and trucks i < k: precedes[i, k, j] = 1 → start_time[k] >= completion_time[i]`  
       `For each unloading bay j and trucks i < k: precedes[i, k, j] = 0 → start_time[i] >= completion_time[k]`  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
unloading_bays = [1]
arrival_times = {1: 5, 2: 10, 3: 13}
processing_times = {1: 8, 2: 7, 3: 8}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("UNLOADING_BAY_PROBLEM_11_MIN_TOTAL_TIME")

    if not trucks or not unloading_bays: raise ValueError("Empty trucks or unloading bays")

    # --- Decision Variables ---
    assign = m.addVars(trucks, unloading_bays, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in unloading_bays],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(completion_time[i] - arrival_times.get(i, 0) for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in unloading_bays:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Total time at the depot
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the detailed schedule and other key outputs
if m.status == GRB.OPTIMAL:
    print(f"Total time at the depot: {results_dict['obj_val']:.4f}")
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
else:
    print(f"Optimization ended with status {m.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
33.0000
Total time at the depot: 33.0000
Truck 1 - Start Time: 5.0000, Completion Time: 13.0000
Truck 2 - Start Time: 13.0000, Completion Time: 20.0000
Truck 3 - Start Time: 20.0000, Completion Time: 28.0000


```

================================================================================



--- Problem 232 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A major port is experiencing a sudden disruption due to a labor strike, affecting 3,991 container movements per hour. The port authority must quickly implement a rerouting strategy to minimize the total delay experienced by affected containers. Two alternative routes are available: Route 1 has a base capacity of 2,680 container movements per hour and adds an extra 0.121 hours of handling time, while Route 2 can handle 2,856 container movements per hour but imposes an additional 0.190 hours per container. A signal-boosting measure can increase both routes' capacities by 18.1%, but deploying it incurs additional operational costs.  

The authority is evaluating four strategies:  
- **Force All Reroute, No Boost:** Divert all affected containers to alternative routes without boosting signal capacity.  
- **Force All Reroute, Boost:** Divert all containers while boosting alternative route capacities.  
- **Allow Local, No Boost:** Permit 520 container movements per hour (local traffic) to bypass rerouting, reducing demand on alternatives.  
- **Allow Local, Boost:** Combine local traffic allowance with signal boosting.  

The core challenge is determining which strategy minimizes the total rerouting delay, accounting for varying demand, capacity constraints, and the trade-offs of signal boosting. The event duration is 3.045 hours, amplifying the impact of delays.  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable \( y(s) \) for each strategy \( s \) (1 if selected, 0 otherwise).  

**2. Parameters:**  
- \( \text{Lambda\_affected} = 3,991 \): Total affected demand (container movements/hour).  
- \( \text{Lambda\_local\_allowed} = 520 \): Local traffic exempt from rerouting (container movements/hour).  
- \( \text{C1\_base} = 2,680 \), \( \text{C2\_base} = 2,856 \): Base capacities of Routes 1 and 2 (container movements/hour).  
- \( \text{T\_extra1} = 0.121 \), \( \text{T\_extra2} = 0.190 \): Added delay per container (hours).  
- \( \text{Signal\_boost\_factor} = 1.181 \): Capacity multiplier if boosting is applied.  
- \( \text{T\_event} = 3.045 \): Duration of disruption (hours).  

**3. Objective Function:**  
Minimize total delay:  
\[ \text{minimize} \sum_{s} y(s) \cdot \text{delay}(s) \]  
where \( \text{delay}(s) \) is precomputed for each strategy based on rerouted demand and capacities.  

**4. Constraints:**  
- **Single Strategy Selection:** \( \sum_{s} y(s) = 1 \).  
- **Binary Variables:** \( y(s) \in \{0,1\} \) for all \( s \).  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
T_event_h = 3.045180307162833
Lambda_affected = 3990.611016979853
Lambda_local_allowed = 519.8156390420149

# Alt Route 1
C1_base = 2680.4093360684074
T_extra1_h = 0.12110700941498825
# Alt Route 2
C2_base = 2855.8295964631725
T_extra2_h = 0.1902595670728932

Signal_boost_factor = 1.180986312318471

# Define Strategies
strategies_def = {
    1: ("Force All Reroute, No Boost", False, False),
    2: ("Force All Reroute, Boost", False, True),
    3: ("Allow Local, No Boost", True, False),
    4: ("Allow Local, Boost", True, True),
}
strategy_ids = list(strategies_def.keys())

# --- Calculate delay for each strategy ---
strategy_delays = {}
print("--- Total Delay Calculation per Strategy ---")

for s_id in strategy_ids:
    desc, local_allowed, signal_boost = strategies_def[s_id]

    lambda_reroute = Lambda_affected
    if local_allowed:
        lambda_reroute = Lambda_affected - Lambda_local_allowed

    C1 = C1_base * Signal_boost_factor if signal_boost else C1_base
    C2 = C2_base * Signal_boost_factor if signal_boost else C2_base
    Total_Alt_Cap = C1 + C2

    total_delay_s = 0
    flow1 = 0
    flow2 = 0
    unserved = 0

    print(f" Strategy {s_id} ({desc}):")
    print(f"  Rerouted Demand = {lambda_reroute:.0f} container movements/hour")
    print(f"  Alt1 Cap = {C1:.0f}, Alt2 Cap = {C2:.0f}, Total Alt Cap = {Total_Alt_Cap:.0f}")

    if lambda_reroute > Total_Alt_Cap:
        print("  Warning: Rerouted demand exceeds total alternative capacity!")
        total_delay_s = float('inf')
        unserved = lambda_reroute - Total_Alt_Cap
        flow1 = C1
        flow2 = C2
    else:
        flow1 = min(lambda_reroute, C1)
        flow2 = min(lambda_reroute - flow1, C2)
        unserved = lambda_reroute - flow1 - flow2

        delay1 = flow1 * T_extra1_h
        delay2 = flow2 * T_extra2_h
        total_delay_s = (delay1 + delay2) * T_event_h

    strategy_delays[s_id] = total_delay_s
    print(f"  Flow Alt1 = {flow1:.0f}, Flow Alt2 = {flow2:.0f}, Unserved = {unserved:.0f}")
    print(f"  Estimated Total Rerouting Delay = {total_delay_s:.2f} container-movements-hour")
    if local_allowed: print(f"  (Ignoring delay for {Lambda_local_allowed} container movements/hour local traffic)")

# --- Gurobi Model ---
model = gp.Model("PortReroutingStrategy")

# --- Decision Variables ---
y = model.addVars(strategy_ids, vtype=GRB.BINARY, name="ChooseStrategy")

# --- Constraints ---
model.addConstr(gp.quicksum(y[s] for s in strategy_ids) == 1, name="SelectOneStrategy")

# --- Objective Function ---
objective = gp.LinExpr()
for s_id in strategy_ids:
    delay = strategy_delays[s_id]
    if delay == float('inf'):
        delay = 1e12
    objective += y[s_id] * delay
model.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    chosen_strategy_id = -1
    for s_id in strategy_ids:
        if y[s_id].X > 0.9:
            chosen_strategy_id = s_id
            break

    if chosen_strategy_id != -1:
         desc, _, _ = strategies_def[chosen_strategy_id]
         print(f"Optimal Strategy: ID {chosen_strategy_id} ({desc})")
         min_delay_val = model.objVal
         if min_delay_val >= 1e11:
              print(f" Minimum Total Delay: Infeasible / Extremely Large (Demand exceeds capacity)")
         else:
              print(f" Minimum Total Rerouting Delay: {model.objVal:.2f} container-movements-hour")
    else:
         print("Error: No strategy selected.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- Total Delay Calculation per Strategy ---
 Strategy 1 (Force All Reroute, No Boost):
  Rerouted Demand = 3991 container movements/hour
  Alt1 Cap = 2680, Alt2 Cap = 2856, Total Alt Cap = 5536
  Flow Alt1 = 2680, Flow Alt2 = 1310, Unserved = 0
  Estimated Total Rerouting Delay = 1747.61 container-movements-hour
 Strategy 2 (Force All Reroute, Boost):
  Rerouted Demand = 3991 container movements/hour
  Alt1 Cap = 3166, Alt2 Cap = 3373, Total Alt Cap = 6538
  Flow Alt1 = 3166, Flow Alt2 = 825, Unserved = 0
  Estimated Total Rerouting Delay = 1645.46 container-movements-hour
 Strategy 3 (Allow Local, No Boost):
  Rerouted Demand = 3471 container movements/hour
  Alt1 Cap = 2680, Alt2 Cap = 2856, Total Alt Cap = 5536
  Flow Alt1 = 2680, Flow Alt2 = 790, Unserved = 0
  Estimated Total Rerouting Delay = 1446.45 container-movements-hour
  (Ignoring delay for 519.8156390420149 container movements/hour local traffic)
 Strategy 4 (Allow Local, Boost):
  Rerouted Demand = 3471 container movements/hour
  Alt1 Cap = 3166, Alt2 Cap = 3373, Total Alt Cap = 6538
  Flow Alt1 = 3166, Flow Alt2 = 305, Unserved = 0
  Estimated Total Rerouting Delay = 1344.29 container-movements-hour
  (Ignoring delay for 519.8156390420149 container movements/hour local traffic)
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 4 columns and 4 nonzeros
Model fingerprint: 0x05915eaf
Variable types: 0 continuous, 4 integer (4 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [1e+03, 2e+03]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 1747.6130315
Presolve removed 1 rows and 4 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 2: 1344.29 1747.61 

Optimal solution found (tolerance 1.00e-04)
Best objective 1.344288012560e+03, best bound 1.344288012560e+03, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Strategy: ID 4 (Allow Local, Boost)
 Minimum Total Rerouting Delay: 1344.29 container-movements-hour



================================================================================



--- Problem 233 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A port terminal needs to allocate berthing times for three different ships to minimize the total waiting time. Each ship has a specific number of containers to unload, characterized by its volume: Ship 1 handles the heaviest load (1,889 containers), while Ships 2 and 3 serve slightly lighter loads (1,748 and 1,695 containers, respectively). The challenge lies in allocating the limited total berthing time of 68 hours among these ships. Berthing times cannot be shorter than 9 hours or exceed 68 hours for any ship, ensuring minimal service for each ship while preventing excessive congestion. The core question is: *How should the 68-hour berthing time be distributed across the three ships to minimize the cumulative waiting time experienced by all containers?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Let \( t_i \) represent the berthing time (in hours) allocated to ship \( i \), where \( i \in \{1, 2, 3\} \). Each \( t_i \) is a continuous variable bounded between 9 and 68.  
   - **2. Parameters:**  
     - \( \text{load_coeffs} = [1889, 1748, 1695] \): Container load coefficients for each ship.  
     - \( \text{total_berthing_time} = 68 \): Total fixed berthing time (hours).  
     - \( \text{min_berthing_time} = 9 \), \( \text{max_berthing_time} = 68 \): Lower/upper bounds for berthing times.  
   - **3. Objective Function:**  
     Minimize the total waiting time:  
     \[
     \text{Minimize: } \sum_{i=1}^{3} \text{load_coeffs}[i] \times (\text{total_berthing_time} - t_i)
     \]  
     (Waiting time for ship \( i \) is proportional to its load multiplied by its non-berthing time, \( \text{total_berthing_time} - t_i \)).  
   - **4. Constraints:**  
     - Total berthing times must equal the total berthing time:  
       \[
       t_1 + t_2 + t_3 = 68
       \]  
     - Bounds on berthing times:  
       \[
       9 \leq t_i \leq 68 \quad \forall i \in \{1, 2, 3\}
       \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_ships = 3
min_berthing_time = 9          # Lower bound for berthing time
max_berthing_time = 68          # Upper bound for berthing time
total_berthing_time = 68   # Total berthing time (set equal to max_berthing_time)
load_coeffs = [1889, 1748, 1695] # Container load coefficients per ship
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(load_coeffs) != num_ships:
    print("Error: load_coeffs length mismatch with num_ships")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: load_coeffs length"
    # raise ValueError("load_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_ships}-Ship Berthing Time Allocation", env=env)

        # --- Decision variables (dynamic based on num_ships) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_ships, lb=min_berthing_time, ub=max_berthing_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for ship i is proportional to load * non-berthing_time = load * (total_berthing_time - berthing_time[i])
        model.setObjective(gp.quicksum(load_coeffs[i] * (total_berthing_time - t_vars[i]) for i in range(num_ships)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the total berthing time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_ships)) == total_berthing_time, "TotalBerthingTime")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_ships)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_ships):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 237139.00
------------------------------
Optimal berthing times (hours):
  t1: 50.00, t2: 9.00, t3: 9.00


```

================================================================================



--- Problem 234 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling incoming trucks to minimize waiting costs, which increase significantly if delays exceed a critical threshold. Five trucks, numbered 1 through 5, arrive at staggered times: Truck 1 at 3 hours, Truck 2 at 7, Truck 3 at 11, Truck 4 at 12, and Truck 5 at 17. Each truck requires a specific processing time: Trucks 1, 2, and 3 need 5 hours each, Truck 4 demands 7 hours, and Truck 5 takes 6 hours. The hub has two depots available for servicing these trucks.

The cost of waiting is piecewise-linear: for the first hour of delay, the cost rate is \$45 per hour, but any additional waiting time incurs a steeper rate of \$81 per hour. The hub manager must assign each truck to a depot and schedule their start times to ensure no two trucks occupy the same depot simultaneously while minimizing the total waiting cost. The core question is: *How can the trucks be assigned and scheduled to depots to achieve the lowest possible total waiting cost, given the escalating penalty for prolonged delays?*
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `assign(i, j)`: Binary variable indicating whether truck `i` is assigned to depot `j`.
   - `start_time(i)`: Continuous variable representing the start time of truck `i`.
   - `completion_time(i)`: Continuous variable representing the completion time of truck `i` (derived as `start_time(i) + processing_time(i)`).
   - `precedes(i, k, j)`: Binary variable indicating whether truck `i` is scheduled before truck `k` at depot `j`.
   - `wait_part1(i)`: Continuous variable representing the waiting time of truck `i` up to the threshold (1 hour).
   - `wait_part2(i)`: Continuous variable representing the waiting time of truck `i` beyond the threshold.

**2. Parameters:**
   - `trucks`: [1, 2, 3, 4, 5]
   - `depots`: [1, 2]
   - `arrival_times`: {1: 3, 2: 7, 3: 11, 4: 12, 5: 17}
   - `processing_times`: {1: 5, 2: 5, 3: 5, 4: 7, 5: 6}
   - `wait_cost_rate1`: 45 (cost per hour for the first hour of waiting)
   - `wait_cost_rate2`: 81 (cost per hour for waiting beyond the first hour)
   - `wait_threshold`: 1 (hour)
   - `H`: 100 (a large constant for big-M constraints)

**3. Objective Function:**
   - Minimize the total waiting cost:  
     `Minimize: sum(wait_cost_rate1 * wait_part1(i) + wait_cost_rate2 * wait_part2(i) for all trucks i)`

**4. Constraints:**
   - **Assignment:** Each truck must be assigned to exactly one depot:  
     `For each truck i: sum(assign(i, j) for all depots j) = 1`
   - **Arrival Time:** A truck cannot start before its arrival time:  
     `For each truck i: start_time(i) >= arrival_time(i)`
   - **Completion Time:** The completion time is the start time plus processing time:  
     `For each truck i: completion_time(i) = start_time(i) + processing_time(i)`
   - **Non-Overlapping:** Trucks assigned to the same depot must not overlap:  
     `For each depot j and trucks i < k: precedes(i, k, j) = 1 implies start_time(k) >= completion_time(i)`  
     `For each depot j and trucks i < k: precedes(i, k, j) = 0 implies start_time(i) >= completion_time(k)`
   - **Wait Decomposition:** Total waiting time is split into parts below and above the threshold:  
     `For each truck i: start_time(i) - arrival_time(i) = wait_part1(i) + wait_part2(i)`

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2]
arrival_times = {1: 3, 2: 7, 3: 11, 4: 12, 5: 17}
processing_times = {1: 5, 2: 5, 3: 5, 4: 7, 5: 6}
wait_cost_rate1 = 45
wait_cost_rate2 = 81
wait_threshold = 1
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    wait_part1 = m.addVars(trucks, lb=0.0, ub=wait_threshold, vtype=GRB.CONTINUOUS, name="WaitPart1")
    wait_part2 = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="WaitPart2")

    # --- Objective Function ---
    total_wait_cost = gp.quicksum(wait_cost_rate1 * wait_part1[i] + wait_cost_rate2 * wait_part2[i] for i in trucks)
    m.setObjective(total_wait_cost, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Link waiting time parts
    m.addConstrs((start_time[i] - arrival_times.get(i, 0) == wait_part1[i] + wait_part2[i] for i in trucks), name="wait_decomposition")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
    for i in trucks:
        print(f"Truck {i} start time: {start_time[i].x:.4f}")
        print(f"Truck {i} completion time: {completion_time[i].x:.4f}")
        print(f"Truck {i} wait part 1: {wait_part1[i].x:.4f}")
        print(f"Truck {i} wait part 2: {wait_part2[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
1152.0000
Truck 1 is assigned to Depot 2
Truck 2 is assigned to Depot 2
Truck 3 is assigned to Depot 2
Truck 4 is assigned to Depot 2
Truck 5 is assigned to Depot 2
Truck 1 start time: 3.0000
Truck 1 completion time: 8.0000
Truck 1 wait part 1: 0.0000
Truck 1 wait part 2: 0.0000
Truck 2 start time: 8.0000
Truck 2 completion time: 13.0000
Truck 2 wait part 1: 1.0000
Truck 2 wait part 2: 0.0000
Truck 3 start time: 13.0000
Truck 3 completion time: 18.0000
Truck 3 wait part 1: 1.0000
Truck 3 wait part 2: 1.0000
Truck 4 start time: 24.0000
Truck 4 completion time: 31.0000
Truck 4 wait part 1: 1.0000
Truck 4 wait part 2: 11.0000
Truck 5 start time: 18.0000
Truck 5 completion time: 24.0000
Truck 5 wait part 1: 1.0000
Truck 5 wait part 2: 0.0000


```

================================================================================



--- Problem 235 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with loading a collection of 23 valuable items onto a limited number of trucks for delivery. Each item has a specific weight and value, and the trucks have a strict weight capacity of 71 units. The company can use up to 6 trucks, but their goal is not just to fit all items—they want to maximize the total value of the items loaded, even if some items are left out.  

   The items vary significantly in weight and value. For instance, one item weighs just 4 units but is worth 16, while another weighs 61 units and carries a high value of 98. The challenge is to strategically assign items to trucks so that no truck exceeds its weight limit, each item is placed on at most one truck, and the total value of the loaded items is as high as possible. The question is: *What is the optimal selection and assignment of items to trucks to achieve the highest possible total value without violating any constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable (0 or 1) indicating whether item `i` is placed on truck `j`.  
   - `y[j]`: Binary variable (0 or 1) indicating whether truck `j` is used.  

   **2. Parameters:**  
   - `items[i]`: A list of tuples where each tuple contains `(weight, value)` for item `i`.  
   - `truck_capacity = 71`: Maximum allowable weight per truck.  
   - `num_trucks = 6`: Maximum number of trucks available.  

   **3. Objective Function:**  
   Maximize the total value of loaded items:  
   ```
   Maximize: sum(items[i][1] * x[i, j] for all i, j)
   ```  

   **4. Constraints:**  
   - **Truck Weight Limit:** For each truck `j`, the total weight of assigned items must not exceed its capacity:  
     ```
     sum(items[i][0] * x[i, j] for all i) <= truck_capacity * y[j]
     ```  
   - **Item-Truck Link:** If an item `i` is placed on truck `j`, the truck must be marked as used:  
     ```
     x[i, j] <= y[j] for all i, j
     ```  
   - **Single Assignment:** Each item can be placed on at most one truck:  
     ```
     sum(x[i, j] for all j) <= 1 for all i
     ```  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Data Definition (Embedded) ---
items = [(57, 1), (4, 16), (53, 38), (11, 98), (8, 46), (51, 98), (43, 56), (55, 46), (22, 41), (34, 77), (29, 94), (48, 51), (55, 10), (14, 73), (55, 99), (46, 12), (61, 98), (49, 47), (7, 88), (61, 22), (60, 31), (31, 83), (57, 24)]          # List of (weight, value) tuples
truck_capacity = 71      # Maximum weight per truck
num_trucks = 6          # Maximum number of available trucks (parameter)
num_items = 23          # len(items) derived correctly
# --- End Data Definition ---

GUROBI_TIME_LIMIT = 60 # Time limit parameter

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi log in captured output
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Max-Value Truck Loading", env=env)

    # --- Decision variables ---
    x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")  # x[i, j] -> item i placed on truck j
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")  # y[j] -> truck j is used

    # --- Objective: Maximize total value of selected items ---
    # Sum over all items i and the truck j they are placed on
    model.setObjective(gp.quicksum(items[i][1] * x[i, j] for i in range(num_items) for j in range(num_trucks)), GRB.MAXIMIZE)

    # --- Constraint 1: Truck weight limit ---
    for j in range(num_trucks):
        model.addConstr(gp.quicksum(items[i][0] * x[i, j] for i in range(num_items)) <= truck_capacity * y[j], name=f"Truck_{j}_Weight")

    # --- Constraint 2: If an item is placed on a truck, that truck must be considered used ---
    # (This is often implied by C1 if capacity > 0, but good practice)
    for i in range(num_items):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Item_{i}_Triggers_Truck_{j}")

    # --- Constraint 3: Each item can be placed on at most one truck ---
    # (Items not placed contribute 0 to objective and constraints)
    for i in range(num_items):
        model.addConstr(x.sum(i, '*') <= 1, name=f"Item_{i}_AtMostOneTruck")

    # --- Solve the model ---
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal # Best solution found

    # --- Output results (for capture) ---
    if model.status == GRB.OPTIMAL:
        print(f"Optimal total value: {model.objVal:.2f}") # Format value
        print("-" * 30)
        printed_truck_count = 0
        for j in range(num_trucks):
            try:
                 if y[j].x > 0.5:  # Truck is used
                     printed_truck_count += 1
                     assigned_items = [i for i in range(num_items) if x[i, j].x > 0.5]
                     assigned_weights = [items[i][0] for i in assigned_items]
                     truck_load = sum(assigned_weights)
                     print(f"Truck {printed_truck_count} (Index {j}):")
                     print(f"  Load: {truck_load} / {truck_capacity}")
                     print(f"  Items (indices): {sorted(assigned_items)}")
                     # Optional: print item details
                     # print(f"  Items (w,v): {[items[i] for i in sorted(assigned_items)]}")
                     print("-" * 10)
            except AttributeError:
                 pass # Skip trucks not used or if .X missing
    elif model.status == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare if items fit capacity
    else:
        print(f"\nOptimization finished with status: {model.status}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total value: 967.00
------------------------------
Truck 1 (Index 0):
  Load: 70 / 71
  Items (indices): [8, 9, 13]
----------
Truck 2 (Index 1):
  Load: 65 / 71
  Items (indices): [1, 16]
----------
Truck 3 (Index 2):
  Load: 60 / 71
  Items (indices): [10, 21]
----------
Truck 4 (Index 3):
  Load: 50 / 71
  Items (indices): [6, 18]
----------
Truck 5 (Index 4):
  Load: 63 / 71
  Items (indices): [4, 14]
----------
Truck 6 (Index 5):
  Load: 62 / 71
  Items (indices): [3, 5]
----------


```

================================================================================



--- Problem 236 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy logistics hub, five trucks arrive at varying times, each requiring assignment to one of three available depots for unloading and processing. The logistics company faces the challenge of scheduling these trucks efficiently to minimize the total completion time across all vehicles, ensuring smooth operations and minimizing delays.  

   Truck arrivals are staggered: Truck 1 arrives at time 2, Truck 2 at time 6, Truck 3 at time 11, Truck 4 at time 12, and Truck 5 at time 14. Each truck’s processing time depends on the depot it’s assigned to—for example, Truck 1 takes 2 hours at Depot 1, 3 hours at Depot 2, and 4 hours at Depot 3. Similarly, Truck 2 requires 6, 11, or 5 hours depending on the depot. The company must adhere to strict rules: each truck must be assigned to exactly one depot, and no two trucks can occupy the same depot simultaneously.  

   The core question is: *How should the logistics company assign trucks to depots and schedule their start times to minimize the total completion time for all trucks while respecting arrival times and depot availability?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary variable (1 if truck *i* is assigned to depot *j*, 0 otherwise).  
   - `start_time[i]`: Continuous variable representing the start time of truck *i*.  
   - `completion_time[i]`: Continuous variable representing the completion time of truck *i*.  
   - `precedes[i, k, j]`: Binary variable (1 if truck *i* precedes truck *k* on depot *j*, 0 otherwise).  

   **2. Parameters:**  
   - `trucks = [1, 2, 3, 4, 5]`: List of trucks.  
   - `depots = [1, 2, 3]`: List of depots.  
   - `arrival_times[i]`: Arrival time of truck *i*.  
   - `processing_times[i, j]`: Time to process truck *i* at depot *j*.  
   - `H = 100`: A large constant (Big-M) for linearization.  

   **3. Objective Function:**  
   Minimize the sum of completion times for all trucks:  
   `Minimize: sum(completion_time[i] for i in trucks)`.  

   **4. Constraints:**  
   - **Assignment:** Each truck is assigned to exactly one depot:  
     `sum(assign[i, j] for j in depots) = 1` for all *i* in trucks.  
   - **Arrival Time:** Start time cannot precede arrival time:  
     `start_time[i] >= arrival_times[i]` for all *i* in trucks.  
   - **Completion Time:** Defined as start time plus processing time:  
     `completion_time[i] = start_time[i] + sum(processing_times[i, j] * assign[i, j] for j in depots)` for all *i* in trucks.  
   - **Non-Overlapping:** If two trucks *i* and *k* share a depot *j*, one must precede the other:  
     - If `precedes[i, k, j] = 1`, then `start_time[k] >= completion_time[i]`.  
     - If `precedes[i, k, j] = 0`, then `start_time[i] >= completion_time[k]`.  
     - Logical linking: `assign[i, j] + assign[k, j] - 1 <= precedes[i, k, j] + (1 - precedes[i, k, j])`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2, 3]
arrival_times = {1: 2, 2: 6, 3: 11, 4: 12, 5: 14}
processing_times = {(1, 1): 2, (1, 2): 3, (1, 3): 4, (2, 1): 6, (2, 2): 11, (2, 3): 5, (3, 1): 8, (3, 2): 4, (3, 3): 9, (4, 1): 6, (4, 2): 3, (4, 3): 5, (5, 1): 2, (5, 2): 2, (5, 3): 4} # Dict {(truck, depot): time}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_8_DEPOT_PROC")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(completion_time[i] for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (depot dependent)
    m.addConstrs((completion_time[i] == start_time[i] + gp.quicksum(processing_times.get((i,j), 0) * assign[i,j] for j in depots)
                  for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1-precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
67.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 1
Start Time: 2.0000, Completion Time: 4.0000
Truck 2 is assigned to Depot 3
Start Time: 6.0000, Completion Time: 11.0000
Truck 3 is assigned to Depot 2
Start Time: 11.0000, Completion Time: 15.0000
Truck 4 is assigned to Depot 2
Start Time: 17.0000, Completion Time: 20.0000
Truck 5 is assigned to Depot 1
Start Time: 15.0000, Completion Time: 17.0000


```

================================================================================



--- Problem 237 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
In a busy port, ship captains must choose between multiple berthing options to minimize their waiting time. The port has three primary berths—A, B, and C—each with distinct characteristics. Berth A offers the shortest free-flow waiting time (0.257 hours) but has the highest capacity (3799.04 ships/hour). Berth B is slightly slower (0.335 hours) with a moderate capacity (3231.79 ships/hour), while Berth C is the slowest in free-flow conditions (0.414 hours) and has the lowest capacity (2656.88 ships/hour). The Bureau of Public Roads (BPR) function models congestion, with parameters α = 0.1626 and β = 3.8913, reflecting how waiting time increases as the number of ships approaches the berth's capacity.

Under normal conditions, all three berths are available, and the total demand is 6924.25 ships. However, during a maintenance period, Berth A becomes unavailable, forcing all ships onto Berths B and C. The central question is: How do ship captains distribute themselves across the available berths to achieve user equilibrium—where no individual can reduce their waiting time by switching berths—and what is the resulting total port waiting time in both scenarios? The analysis also quantifies the impact of the maintenance by comparing the total delay between the two cases.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[p]`: Flow (ships/hour) on berth `p`, where `p` ∈ available berths (either `['A', 'B', 'C']` or `['B', 'C']`).  

   **2. Parameters:**  
   - `t0[p]`: Free-flow waiting time (hours) for berth `p`.  
   - `capacity[p]`: Maximum flow capacity (ships/hour) for berth `p`.  
   - `bpr_alpha` (α), `bpr_beta` (β): BPR function parameters.  
   - `total_demand`: Total ship demand (6924.25 ships).  

   **3. Objective Function:**  
   Minimize the Beckmann transformation of waiting time:  
   \[
   \text{Minimize: } \sum_{p} \left( t0[p] \cdot x[p] + \frac{t0[p] \cdot \alpha \cdot x[p]^2}{(β + 1) \cdot \text{capacity}[p]^β} \right)
   \]  
   (Quadratic approximation used for the BPR term.)  

   **4. Constraints:**  
   - Demand conservation: Total flow equals total demand:  
     \[
     \sum_{p} x[p] = \text{total\_demand}
     \]  
   - Non-negativity: `x[p] ≥ 0` for all berths `p`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
berths_normal = ['A', 'B', 'C']
berths_maintenance = ['B', 'C']  # Berth A is closed

t0 = {'A': 0.2573510481289847, 'B': 0.33491315278190337, 'C': 0.4137859351035294}  # hours
capacity = {'A': 3799.0399081465384, 'B': 3231.7890373015825, 'C': 2656.877131082089}  # ships/h
bpr_alpha = 0.16260050057601705
bpr_beta = 3.891300605017262
total_demand = 6924.24615103125

# --- Function to solve UE ---
def solve_user_equilibrium(available_berths, t0_dict, capacity_dict, demand):
    m = gp.Model("UserEquilibrium")
    m.Params.NonConvex = 2

    # Decision Variables: Flow on each available berth
    x = m.addVars(available_berths, name="flow", lb=0.0)

    # Constraints
    m.addConstr(gp.quicksum(x[i] for i in available_berths) == demand, name="DemandConservation")

    # Objective Function (Beckmann transformation)
    objective = gp.LinExpr()
    for i in available_berths:
        objective += t0_dict[i] * x[i]
        if capacity_dict[i] > 1e-6:
            coef = (t0_dict[i] * bpr_alpha) / ((bpr_beta + 1.0) * (capacity_dict[i] ** bpr_beta))
            # Using quadratic approximation for demonstration
            objective += coef * x[i] * x[i]

    m.setObjective(objective, GRB.MINIMIZE)
    m.optimize()

    flows = {p: x[p].X for p in available_berths}
    times = {}
    total_delay = 0
    for p in available_berths:
        flow = flows[p]
        t_act = t0_dict[p] * (1 + bpr_alpha * (flow / capacity_dict[p])**bpr_beta) if capacity_dict[p]>0 else float('inf')
        times[p] = t_act
        total_delay += flow * t_act

    return flows, times, total_delay

# --- Analysis ---
print("--- Normal Conditions (A, B, C available) ---")
flows_norm, times_norm, delay_norm = solve_user_equilibrium(berths_normal, t0, capacity, total_demand)
print(f"Flows: {flows_norm}")
print(f"Times: {times_norm}")
print(f"Total Port Waiting Time: {delay_norm}")

print("\n--- Maintenance Period (B, C available) ---")
flows_maintenance, times_maintenance, delay_maintenance = solve_user_equilibrium(berths_maintenance, t0, capacity, total_demand)
print(f"Flows: {flows_maintenance}")
print(f"Times: {times_maintenance}")
print(f"Total Port Waiting Time: {delay_maintenance}")

delay_increase = delay_maintenance - delay_norm
print(f"\n--- Impact of Maintenance ---")
print(f"Increase in Total Port Waiting Time: {delay_increase:.2f} ship-hours")
```
Answer:
--- Normal Conditions (A, B, C available) ---
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 1 rows, 3 columns and 3 nonzeros
Model fingerprint: 0x95505758
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [3e-01, 4e-01]
  Bounds range     [0e+00, 0e+00]
  RHS range        [7e+03, 7e+03]
Presolve removed 1 rows and 3 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    1.7819620e+03   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  1.781962004e+03
Flows: {'A': 6924.24615103125, 'B': 0.0, 'C': 0.0}
Times: {'A': 0.6899690678190135, 'B': 0.33491315278190337, 'C': 0.4137859351035294}
Total Port Waiting Time: 4777.515662176424

--- Maintenance Period (B, C available) ---
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 1 rows, 2 columns and 2 nonzeros
Model fingerprint: 0x28de2da2
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [3e-01, 4e-01]
  Bounds range     [0e+00, 0e+00]
  RHS range        [7e+03, 7e+03]
Presolve removed 1 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    2.3190211e+03   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  2.319021109e+03
Flows: {'B': 6924.24615103125, 'C': 0.0}
Times: {'B': 1.3912446397697056, 'C': 0.4137859351035294}
Total Port Waiting Time: 9633.320342068242

--- Impact of Maintenance ---
Increase in Total Port Waiting Time: 4855.80 ship-hours



================================================================================



--- Problem 238 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
A port is experiencing a temporary reduction in the capacity of one of its berths due to maintenance. The main berth, which normally handles 5,455 container moves per hour, now has a reduced capacity of 2,609 container moves per hour. An alternative berth can handle up to 2,040 container moves per hour. The total arrival rate of containers is 4,005 container moves per hour, and the maintenance is expected to last 1.52 hours. The challenge is to allocate the container moves between the main and alternative berths to minimize the total system delay. The alternative berth has a baseline handling time of 0.36 hours, but this time increases with congestion following the BPR function, with parameters α=0.16 and β=2.84. The system must account for queue formation on the main berth, where the number of container moves exceeds the reduced capacity, and subsequent dissipation once the maintenance is completed. The goal is to minimize the combined delay from rerouted container moves and queueing effects, balancing immediate congestion against longer-term recovery.
**

**Modeling Process:**
**
- **Decision Variables:**  
     - `flow_alt`: Container moves diverted to the alternative berth (container moves/h).  
     - `flow_main`: Container moves remaining on the main berth (container moves/h).  
     - Intermediate variables track handling time (`T_alt_actual`), queue dynamics (`max_queue_main`, `dissipation_time_main`), and congestion effects (`vol_cap_ratio`, `vol_cap_pow_beta`).  

   - **Parameters:**  
     - Capacities: `capacity_main_normal=5,455.62`, `capacity_main_reduced=2,608.90`, `capacity_alt=2,040.13` container moves/h.  
     - Total demand: `arrival_rate_total=4,004.99` container moves/h.  
     - Maintenance duration: `maintenance_duration=1.52` h.  
     - BPR function: `T0_alt=0.36` h, `α=0.16`, `β=2.84`.  

   - **Objective Function:**  
     Minimize total delay (container-hours):  
     ```  
     maintenance_duration * (flow_alt * (T_alt_actual - T0_alt))  
     + 0.5 * maintenance_duration * max_queue_main  
     + 0.5 * max_queue_main * dissipation_time_main  
     ```  

   - **Constraints:**  
     1. Flow conservation: `flow_main + flow_alt = arrival_rate_total`.  
     2. Alternative berth capacity: `flow_alt ≤ capacity_alt`.  
     3. Queue growth: `max_queue_main = max(0, flow_main - capacity_main_reduced) * maintenance_duration`.  
     4. Queue dissipation: `dissipation_time_main = max_queue_main / (capacity_main_normal - flow_main)`.  
     5. BPR handling time: `T_alt_actual = T0_alt * (1 + α * (flow_alt/capacity_alt)^β)`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
capacity_main_normal = 5455.618855627599  # container moves/h
capacity_main_reduced = 2608.9007697992565  # container moves/h
capacity_alt = 2040.1337933445143  # container moves/h
arrival_rate_total = 4004.9925044616375  # container moves/h
maintenance_duration = 1.5211933128853212  # h
T0_alt = 0.36227625072142466  # h
bpr_alpha = 0.1611764801893725
bpr_beta = 2.844820059483859
EPSILON = 1e-6

# --- Gurobi Model ---
model = gp.Model("BerthRerouting")

# Decision Variables
flow_alt = model.addVar(name="flow_alt", lb=0.0, ub=arrival_rate_total)
flow_main = model.addVar(name="flow_main", lb=0.0)

# Intermediate Variables
T_alt_actual = model.addVar(name="T_alt_actual", lb=T0_alt)
vol_cap_ratio = model.addVar(name="vol_cap_ratio", lb=0.0)
vol_cap_pow_beta = model.addVar(name="vol_cap_pow_beta", lb=0.0)
max_queue_main = model.addVar(name="max_queue_main", lb=0.0)
dissipation_time_main = model.addVar(name="dissipation_time_main", lb=0.0)
dissipation_rate_main = model.addVar(name="dissipation_rate_main", lb=EPSILON)

# Constraints
model.addConstr(flow_main + flow_alt == arrival_rate_total, name="FlowConservation")
model.addConstr(flow_alt <= capacity_alt, name="AltBerthCapacity")
model.addConstr(vol_cap_ratio <= 1.0, name="VolCapRatioLimit")
model.addConstr(vol_cap_ratio * capacity_alt == flow_alt, name="CalcVolCapRatio")
model.addGenConstrPow(vol_cap_ratio, vol_cap_pow_beta, bpr_beta, name="CalcPowerTerm")
model.addConstr(T_alt_actual == T0_alt * (1.0 + bpr_alpha * vol_cap_pow_beta), name="CalcActualAltTime")

# Queue calculations
queue_growth_rate = model.addVar(name="queue_growth_rate", lb=0.0)
aux_growth_input = model.addVar(name="aux_growth_input", lb=-GRB.INFINITY)
model.addConstr(aux_growth_input == flow_main - capacity_main_reduced, name="CalcAuxGrowthInput")
model.addGenConstrMax(queue_growth_rate, [aux_growth_input], 0.0, name="CalcQueueGrowthRate")
model.addConstr(max_queue_main == queue_growth_rate * maintenance_duration, name="CalcMaxQueue")

# Dissipation calculations
model.addConstr(dissipation_rate_main == capacity_main_normal - flow_main, name="CalcDissipationRate")
model.addQConstr(dissipation_time_main * dissipation_rate_main == max_queue_main, name="CalcDissipationTime")

# Objective
obj = gp.QuadExpr()
obj += maintenance_duration * flow_alt * T_alt_actual - maintenance_duration * T0_alt * flow_alt
obj += 0.5 * maintenance_duration * max_queue_main
obj += 0.5 * max_queue_main * dissipation_time_main
model.setObjective(obj, GRB.MINIMIZE)

# Optimize
model.Params.NonConvex = 2
model.optimize()

# Output
if model.status == GRB.OPTIMAL:
    print("\n--- Berth Rerouting Results ---")
    print(f"Optimal Total System Delay: {model.objVal:.2f} container-hours")
    print(f"Flow to Alternative Berth: {flow_alt.X:.2f} container moves/h")
    print(f"Flow on Main Berth: {flow_main.X:.2f} container moves/h")
    print(f"Alternative Berth Handling Time: {T_alt_actual.X * 60:.2f} min")
    print(f"Max Queue on Main Berth: {max_queue_main.X:.2f} containers")
    print(f"Queue Dissipation Time: {dissipation_time_main.X:.2f} h")
else:
    print(f"Model status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 8 rows, 10 columns and 14 nonzeros
Model fingerprint: 0x1c2ea104
Model has 2 quadratic objective terms
Model has 1 quadratic constraint
Model has 1 simple general constraint
  1 MAX
Model has 1 function constraint treated as nonlinear
  1 POW
Variable types: 10 continuous, 0 integer (0 binary)
Coefficient statistics:
  Matrix range     [6e-02, 2e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [6e-01, 8e-01]
  QObjective range [1e+00, 3e+00]
  Bounds range     [1e-06, 4e+03]
  RHS range        [4e-01, 5e+03]
Presolve removed 2 rows and 1 columns
Presolve time: 0.00s
Presolved: 20 rows, 13 columns, 45 nonzeros
Presolved model has 3 bilinear constraint(s)
Presolved model has 1 nonlinear constraint(s)

Solving non-convex MINLP

Variable types: 12 continuous, 1 integer (1 binary)
Found heuristic solution: objective 42.1474094

Root relaxation: objective 1.224651e+01, 5 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0   12.24651    0    2   42.14741   12.24651  70.9%     -    0s
     0     0   42.06742    0    2   42.14741   42.06742  0.19%     -    0s

Explored 1 nodes (7 simplex iterations) in 0.01 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 42.1474 

Optimal solution found (tolerance 1.00e-04)
Best objective 4.214740941340e+01, best bound 4.214740315643e+01, gap 0.0000%

--- Berth Rerouting Results ---
Optimal Total System Delay: 42.15 container-hours
Flow to Alternative Berth: 1396.09 container moves/h
Flow on Main Berth: 2608.90 container moves/h
Alternative Berth Handling Time: 22.93 min
Max Queue on Main Berth: 0.00 containers
Queue Dissipation Time: 0.00 h



================================================================================



--- Problem 239 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
At a busy seaport, the port authority faces the challenge of efficiently managing ship berthing to minimize delays while ensuring operational efficiency. The facility has two types of berths: those dedicated to container ships and those exclusively for bulk carriers. With limited resources, the goal is to determine the optimal number of berths to open to handle the daily influx of ships without unnecessary operational overhead.

The port has 4 container ship berths (each capable of processing 33 container ships per day) and 3 bulk carrier berths (each handling 50 bulk carriers per day). On this particular day, 86 container ships and 58 bulk carriers are expected to arrive. The critical question is: *What is the minimum number of berths to open while ensuring all arriving ships can be processed without exceeding the berths' capacities?* The solution must balance resource efficiency with the demand, avoiding underutilization or congestion.
**

**Modeling Process:**
**
**1. Decision Variables:**
- `open_container[i]`: Binary variable indicating whether container ship berth `i` is opened (1) or closed (0), for `i = 1, 2, 3, 4`.
- `open_bulk[j]`: Binary variable indicating whether bulk carrier berth `j` is opened (1) or closed (0), for `j = 1, 2, 3`.

**2. Parameters:**
- `num_container_berths = 4`: Total available container ship berths.
- `num_bulk_berths = 3`: Total available bulk carrier berths.
- `container_service_rate = 33`: Container ships processed per day per open container ship berth.
- `bulk_service_rate = 50`: Bulk carriers processed per day per open bulk carrier berth.
- `arrival_containers = 86`: Total container ships requiring processing.
- `arrival_bulks = 58`: Total bulk carriers requiring processing.

**3. Objective Function:**
- Minimize the total number of open berths:  
  `Minimize: sum(open_container[i] for all i) + sum(open_bulk[j] for all j)`.

**4. Constraints:**
- **Container capacity constraint:** The total capacity of open container ship berths must meet or exceed the arriving container ships:  
  `sum(open_container[i] * container_service_rate for all i) >= arrival_containers`.
- **Bulk capacity constraint:** The combined capacity of open container ship berths (for bulk carriers) and open bulk carrier berths must meet or exceed the arriving bulk carriers:  
  `sum(open_container[i] * bulk_service_rate for all i) + sum(open_bulk[j] * bulk_service_rate for all j) >= arrival_bulks`.
- **Binary constraints:** All decision variables are binary (0 or 1).
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
num_container_berths = 4; num_bulk_berths = 3
container_service_rate = 33; bulk_service_rate = 50
arrival_bulks = 58; arrival_containers = 86
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m8 = gp.Model("Seaport_Berth_MIP", env=env)
    # Vars
    open_container = m8.addVars(num_container_berths, vtype=GRB.BINARY, name="open_container_berth")
    open_bulk = m8.addVars(num_bulk_berths, vtype=GRB.BINARY, name="open_bulk_berth")
    # Objective
    m8.setObjective(gp.quicksum(open_container) + gp.quicksum(open_bulk), sense=GRB.MINIMIZE)
    # Constraints
    m8.addConstr(gp.quicksum(open_container[i] * container_service_rate for i in range(num_container_berths)) >= arrival_containers, "container_capacity")
    m8.addConstr(gp.quicksum(open_container[i] * bulk_service_rate for i in range(num_container_berths)) + gp.quicksum(open_bulk[j] * bulk_service_rate for j in range(num_bulk_berths)) >= arrival_bulks, "bulk_capacity")
    # Optimize
    m8.optimize()
    # Store results
    results_dict['status'] = m8.status
    if m8.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m8.objVal
        results_dict['open_container_opt'] = [open_container[i].X for i in range(num_container_berths)]
        results_dict['open_bulk_opt'] = [open_bulk[j].X for j in range(num_bulk_berths)]
    # Output Results
    print("--- Problem 8: Seaport Berthing (MIP) ---")
    if m8.status == GRB.OPTIMAL:
        oc_opt = results_dict.get('open_container_opt', []); ob_opt = results_dict.get('open_bulk_opt', [])
        num_open_container = sum(v > 0.5 for v in oc_opt); num_open_bulk = sum(v > 0.5 for v in ob_opt)
        print(f"Optimization Status: Optimal")
        print(f"Optimal number of container ship berths to open: {int(num_open_container)} / {num_container_berths}")
        print(f"Optimal number of bulk carrier berths to open: {int(num_open_bulk)} / {num_bulk_berths}")
        print(f"Minimum total open berths: {int(m8.objVal)}")
        container_cap = sum(v * container_service_rate for v in oc_opt)
        bulk_cap = sum(v * bulk_service_rate for v in oc_opt) + sum(v * bulk_service_rate for v in ob_opt)
        print(f"Total container ship capacity: {container_cap:.1f} >= {arrival_containers}")
        print(f"Total bulk carrier capacity: {bulk_cap:.1f} >= {arrival_bulks}")
    elif m8.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible")
    else: print(f"Optimization Status: {m8.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of SEAPORT_BERTHING
```
Answer:
--- Problem 8: Seaport Berthing (MIP) ---
Optimization Status: Optimal
Optimal number of container ship berths to open: 3 / 4
Optimal number of bulk carrier berths to open: 0 / 3
Minimum total open berths: 3
Total container ship capacity: 99.0 >= 86
Total bulk carrier capacity: 150.0 >= 58



================================================================================



--- Problem 240 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, maritime logistics coordinators face the challenge of coordinating berthing times for four distinct ships to minimize delays. Each ship has a specific cargo volume: 2,613 units for Ship 1, 2,342 units for Ship 2, 346 units for Ship 3, and 2,249 units for Ship 4. The coordinators must allocate berthing times within strict bounds—no less than 6 hours and no more than 32 hours per ship—while ensuring the total berthing time sums exactly to 32 hours. The core dilemma is balancing these allocations: longer berthing times reduce delays for their respective ships but may starve others, exacerbating congestion. The optimization task is to distribute the finite berthing time strategically, minimizing the total delay across all ships, where delay for each ship is calculated as its cargo volume multiplied by its non-berthing time (total cycle time minus berthing time).
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - \( t_i \): Continuous variable representing the berthing time (in hours) allocated to ship \( i \) (\( i = 1, 2, 3, 4 \)). Bounded between 6 and 32 hours.  

   **2. Parameters:**  
   - \( \text{cargo_volumes} = [2613, 2342, 346, 2249] \): Cargo volumes for each ship.  
   - \( \text{total_berthing_time} = 32 \): Fixed total berthing time (hours).  
   - \( \text{lb_time} = 6 \), \( \text{ub_time} = 32 \): Lower/upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize total delay:  
   \[
   \text{Minimize: } \sum_{i=1}^4 \text{cargo_volumes}[i-1] \times (\text{total_berthing_time} - t_i)
   \]  

   **4. Constraints:**  
   - Total berthing time must match the total berthing time:  
     \[
     \sum_{i=1}^4 t_i = 32
     \]  
   - Bounds on berthing times:  
     \[
     6 \leq t_i \leq 32 \quad \forall i \in \{1, 2, 3, 4\}
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_ships = 4
lb_time = 6          # Lower bound for berthing time
ub_time = 32         # Upper bound for berthing time
total_berthing_time = 32   # Total berthing time (set equal to ub_time)
cargo_volumes = [2613, 2342, 346, 2249] # Cargo volumes per ship
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(cargo_volumes) != num_ships:
    print("Error: cargo_volumes length mismatch with num_ships")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: cargo_volumes length"
    # raise ValueError("cargo_volumes length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_ships}-Ship Berthing Time", env=env)

        # --- Decision variables (dynamic based on num_ships) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_ships, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for ship i is proportional to cargo * non-berthing_time = cargo * (total_berthing_time - berthing_time[i])
        model.setObjective(gp.quicksum(cargo_volumes[i] * (total_berthing_time - t_vars[i]) for i in range(num_ships)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the total berthing time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_ships)) == total_berthing_time, "TotalBerthingTime")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_ships)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_ships):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total delay: 175396.00
------------------------------
Optimal berthing times (hours):
  t1: 14.00, t2: 6.00, t3: 6.00, t4: 6.00


```

================================================================================



--- Problem 241 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
A logistics company is tasked with loading a set of seven packages with varying weights (11, 2, 33, 70, 80, 34, and 60 units) onto a selection of six available trucks, each with distinct capacities and costs. The trucks have capacities and costs as follows: (92, \$82), (98, \$1), (81, \$78), (82, \$63), (81, \$68), and (90, \$46). The challenge is to assign each package to exactly one truck while respecting the truck capacities and ensuring that the total cost of the trucks used is minimized.  

The operational constraints are strict:  
- Every package must be placed in exactly one truck.  
- The total weight of packages assigned to a truck cannot exceed its capacity.  
- If any package is placed in a truck, the truck must be "activated," incurring its associated cost.  

The company seeks the most cost-efficient loading strategy—balancing the selection of cheaper trucks with their capacity limitations—to minimize the total expenditure while ensuring all packages are securely loaded. The core question is: **What is the optimal assignment of packages to trucks that achieves the lowest possible total cost?**

---

**Modeling Process:**
**
**1. Decision Variables:**  
- `x[i, j]`: Binary variable indicating whether package `i` is assigned to truck `j` (1 if assigned, 0 otherwise).  
- `y[j]`: Binary variable indicating whether truck `j` is used (1 if used, 0 otherwise).  

**2. Parameters:**  
- `packages = [11, 2, 33, 70, 80, 34, 60]`: Weights of the packages.  
- `trucks = [(92, 82), (98, 1), (81, 78), (82, 63), (81, 68), (90, 46)]`: List of tuples where each tuple represents (capacity, cost) for a truck.  

**3. Objective Function:**  
Minimize the total cost of used trucks:  
```
Minimize: sum(y[j] * trucks[j][1] for all j)
```  

**4. Constraints:**  
- **Package Assignment:** Each package must be assigned to exactly one truck:  
  ```
  For each package i: sum(x[i, j] for all j) = 1
  ```  
- **Truck Capacity:** The total weight of packages in a truck must not exceed its capacity (if the truck is used):  
  ```
  For each truck j: sum(packages[i] * x[i, j] for all i) <= trucks[j][0] * y[j]
  ```  
- **Linking Constraint:** A package can only be placed in a truck if the truck is used:  
  ```
  For each package i and truck j: x[i, j] <= y[j]
  ```  
---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys # Make sys available inside exec if needed, e.g. for print traceback
import traceback

# --- Data Definition (Embedded) ---
packages = [11, 2, 33, 70, 80, 34, 60]      # Package weights
trucks = [(92, 82), (98, 1), (81, 78), (82, 63), (81, 68), (90, 46)]        # List of (Capacity, Cost) tuples
num_packages = 7       # len(packages)
num_trucks = 6         # len(trucks)
# --- End Data Definition ---

# Time limit (passed from outer scope via globals if needed, or hardcoded)
GUROBI_TIME_LIMIT = 60

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Keep output clean for saving
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Cost-Sensitive Truck Loading", env=env)

    # --- Decision Variables ---
    x = model.addVars(num_packages, num_trucks, vtype=GRB.BINARY, name="x")
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")

    # --- Objective: Minimize total cost ---
    model.setObjective(gp.quicksum(y[j] * trucks[j][1] for j in range(num_trucks)), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Each package assignment
    for i in range(num_packages):
        model.addConstr(x.sum(i, '*') == 1, name=f"Package_{i}_Assignment")

    # 2. Truck capacity
    for j in range(num_trucks):
        truck_capacity = trucks[j][0]
        if truck_capacity < 0: truck_capacity = 0
        model.addConstr(gp.quicksum(packages[i] * x[i, j] for i in range(num_packages)) <= truck_capacity * y[j], name=f"Truck_{j}_Capacity")

    # 3. Linking package to truck usage
    for i in range(num_packages):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Package_{i}_Triggers_Truck_{j}")

    # --- Solve ---
    # print("Solving CS-TL instance...") # Comment out or keep for debug inside output
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal

    # --- Output results (This will be captured) ---
    # This logic needs to be *inside* the template now
    if model.status == GRB.OPTIMAL:
        print(f"Minimum cost: ${model.objVal:.2f}") # Use model.objVal directly
        print("-" * 30) # Add separator for clarity
        printed_truck_count = 0
        for j in range(num_trucks):
            # Use try-except for safety when accessing .X
            try:
                 if y[j].x > 0.5:
                     printed_truck_count += 1
                     truck_capacity_out, truck_cost_out = trucks[j]
                     assigned_packages = [i for i in range(num_packages) if x[i, j].x > 0.5]
                     truck_load_out = sum(packages[i] for i in assigned_packages)
                     # Format output exactly as desired for the log file
                     print(f"Truck {printed_truck_count} (Type Index {j}, Capacity: {truck_capacity_out}, Cost: ${truck_cost_out:.2f}):")
                     print(f"  Load: {truck_load_out} / {truck_capacity_out}")
                     print(f"  Packages (indices): {sorted(assigned_packages)}") # Sort for consistency
                     print("-" * 10) # Separator between trucks
            except AttributeError:
                 pass # Ignore trucks not used or if .X attribute missing
    elif model.status == GRB.TIME_LIMIT:
        print("\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: ${model.ObjVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {model.status}")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}") # Print errors to captured output
    results_dict['status'] = -1 # Use dict to signal error type to main loop
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:") # Print errors
    traceback.print_exc(file=sys.stdout) # Print traceback to captured stdout
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Minimum cost: $178.00
------------------------------
Truck 1 (Type Index 1, Capacity: 98, Cost: $1.00):
  Load: 94 / 98
  Packages (indices): [5, 6]
----------
Truck 2 (Type Index 3, Capacity: 82, Cost: $63.00):
  Load: 80 / 82
  Packages (indices): [4]
----------
Truck 3 (Type Index 4, Capacity: 81, Cost: $68.00):
  Load: 33 / 81
  Packages (indices): [2]
----------
Truck 4 (Type Index 5, Capacity: 90, Cost: $46.00):
  Load: 83 / 90
  Packages (indices): [0, 1, 3]
----------


```

================================================================================



--- Problem 242 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A port manager is tasked with maximizing revenue from two distinct customer segments: short-term and long-term cargo ships. The port has 30 berths available over a 4.1-hour time horizon, with a total capacity of 123.0 berth-hours. Short-term users occupy a berth for an average of 1.4 hours, paying $2.21 per hour, resulting in $3.09 revenue per user. The maximum potential demand for short-term users is 59. Long-term users, on the other hand, occupy a berth for a fixed 4.8 hours at a flat rate of $20.02 per stay, with a maximum demand of 10. The challenge is to determine how many users from each segment to accept—potentially fractional due to the linear programming formulation—to maximize total revenue while respecting berth-hour capacity and demand limits. The key question is: *What is the optimal mix of short-term and long-term users to maximize revenue without exceeding berth capacity or demand constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x_s`: Number of short-term users accepted (continuous, ≥ 0).  
     - `x_l`: Number of long-term users accepted (continuous, ≥ 0).  

   - **2. Parameters:**  
     - `short_stay_hr = 1.4` (hours per short-term user).  
     - `short_revenue = 3.09` (revenue per short-term user).  
     - `short_max_demand = 59` (maximum short-term demand).  
     - `long_stay_hr = 4.8` (hours per long-term user).  
     - `long_revenue = 20.02` (revenue per long-term user).  
     - `long_max_demand = 10` (maximum long-term demand).  
     - `total_berth_hours = 123.0` (total available berth-hours).  

   - **3. Objective Function:**  
     Maximize total revenue:  
     \[
     \text{Maximize: } 3.09 \cdot x_s + 20.02 \cdot x_l
     \]  

   - **4. Constraints:**  
     - Berth-hour capacity:  
       \[
       1.4 \cdot x_s + 4.8 \cdot x_l \leq 123.0
       \]  
     - Short-term demand limit:  
       \[
       x_s \leq 59
       \]  
     - Long-term demand limit:  
       \[
       x_l \leq 10
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_berths = 30
time_horizon_hr = 4.1
total_berth_hours = 123.0

# Short-term users
short_stay_hr = 1.4
short_rate_per_hr = 2.21
short_revenue = 3.09 # Calculated: rate * stay
short_max_demand = 59

# Long-term users
long_stay_hr = 4.8
long_revenue = 20.02 # Flat rate
long_max_demand = 10
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m32 = gp.Model("PORT_BERTH_ALLOC_LP", env=env)

    # --- Decision Variables ---
    # Number of short-term and long-term users accepted (LP allows fractional)
    x_s = m32.addVar(name="num_short_term", lb=0)
    x_l = m32.addVar(name="num_long_term", lb=0)

    # --- Objective Function ---
    # Maximize total revenue
    m32.setObjective(short_revenue * x_s + long_revenue * x_l, sense=GRB.MAXIMIZE)

    # --- Constraints ---
    # Constraint 1: Berth-hour capacity
    m32.addConstr(short_stay_hr * x_s + long_stay_hr * x_l <= total_berth_hours, name="berth_hour_capacity")

    # Constraint 2: Short-term demand limit
    m32.addConstr(x_s <= short_max_demand, name="short_demand")

    # Constraint 3: Long-term demand limit
    m32.addConstr(x_l <= long_max_demand, name="long_demand")

    # --- Optimization ---
    m32.optimize()

    # --- Store results ---
    results_dict['status'] = m32.status
    if m32.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m32.ObjVal
        results_dict['x_s_sol'] = x_s.X
        results_dict['x_l_sol'] = x_l.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- PORT_BERTH_ALLOC: Berth Allocation for Differing Durations (LP) ---")
    if m32.status == GRB.OPTIMAL:
        opt_s = results_dict.get('x_s_sol', 0)
        opt_l = results_dict.get('x_l_sol', 0)
        obj_val_print = results_dict.get('obj_val', 0)
        berth_hours_used = opt_s * short_stay_hr + opt_l * long_stay_hr

        print(f"Optimization Status: Optimal")
        print(f"Maximum Total Revenue: ${obj_val_print:.2f}")
        # LP solutions can be fractional, print with decimals
        print(f"Optimal Short-term Users Accepted: {opt_s:.2f} (Max Demand: {short_max_demand})")
        print(f"Optimal Long-term Users Accepted: {opt_l:.2f} (Max Demand: {long_max_demand})")
        print(f"Total Berth-Hours Used: {berth_hours_used:.1f} / {total_berth_hours:.1f}")
        # Calculate breakdown based on potentially fractional optimal values
        revenue_s = opt_s * short_revenue
        revenue_l = opt_l * long_revenue
        print(f"Revenue Breakdown: Short=${revenue_s:.2f}, Long=${revenue_l:.2f}")

    elif m32.status == GRB.INFEASIBLE:
         # Should be rare for this LP structure unless inputs are nonsensical (e.g., negative)
         print(f"Optimization Status: Infeasible.")
         print(f"Check input parameters for validity (e.g., non-negative demands/times/berths).")
    elif m32.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m32.ObjVal is not None and abs(m32.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m32.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m32.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- PORT_BERTH_ALLOC: Berth Allocation for Differing Durations (LP) ---
Optimization Status: Optimal
Maximum Total Revenue: $365.74
Optimal Short-term Users Accepted: 53.57 (Max Demand: 59)
Optimal Long-term Users Accepted: 10.00 (Max Demand: 10)
Total Berth-Hours Used: 123.0 / 123.0
Revenue Breakdown: Short=$165.54, Long=$200.20


```

================================================================================



--- Problem 243 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A maritime logistics company is tasked with efficiently scheduling 15 ships to berths in a port. Each ship has a unique length and width, ranging from small (1x2 units) to large (27x5 units), and the berths have fixed dimensions of 28x10 units. The challenge is to minimize the number of berths used while ensuring that no ships overlap and all ships fit entirely within their assigned berths. This problem mirrors real-world scenarios like ship berthing or container terminal management, where space is at a premium and operational costs depend on resource utilization. The key question is: *What is the minimal number of berths required to berth all ships without violating placement constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[i, j]`: Binary variable indicating whether ship `i` is assigned to berth `j`.  
     - `y[j]`: Binary variable indicating whether berth `j` is used.  
     - `px[i, j]`, `py[i, j]`: Continuous variables representing the bottom-left coordinates of ship `i` in berth `j`.  
     - `left[i, k, j]`, `right[i, k, j]`, `below[i, k, j]`, `above[i, k, j]`: Binary variables enforcing non-overlapping conditions for ships `i` and `k` in berth `j`.  

   - **2. Parameters:**  
     - `ships`: List of ship dimensions (e.g., `(25, 2)` for length 25, width 2).  
     - `berth_size`: Fixed berth dimensions (28x10).  
     - `num_ships = 15`, `num_berths = 15` (worst-case upper bound).  
     - Big-M values `M_w = 28`, `M_h = 10` for logical constraints.  

   - **3. Objective Function:**  
     Minimize the total number of berths used:  
     \[
     \text{Minimize: } \sum_{j} y[j]
     \]  

   - **4. Constraints:**  
     - **Assignment:** Each ship must be placed in exactly one berth:  
       \[
       \sum_{j} x[i, j] = 1 \quad \forall i
       \]  
     - **Berth Boundaries:** Ships must fit within their assigned berth:  
       \[
       px[i, j] + \text{ship}_i\text{length} \leq 28 \quad \text{if } x[i, j] = 1  
       \]  
       (Analogous for width.)  
     - **Non-Overlapping:** For any two ships in the same berth, enforce at least one spatial separation (left/right/below/above).  
     - **Berth Activation:** A berth is marked used (`y[j] = 1`) if any ship is assigned to it.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
ships = [(25, 2), (5, 6), (4, 6), (9, 1), (27, 5), (13, 7), (11, 8), (24, 9), (1, 7), (18, 6), (9, 10), (1, 7), (1, 2), (8, 4), (7, 1)]  # (length, width) of ships
berth_size = (28, 10)  # (length, width) of each berth
num_ships = 15 # len(ships)
# Maximum berths needed (worst case: one ship per berth)
# Can sometimes be reduced with lower bounds, but num_ships is safe
num_berths = num_ships
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using berth dimensions is common and valid)
M_w = berth_size[0]
M_h = berth_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Berth Packing", env=env)

# --- Decision Variables ---
# x[i,j]: ship i assigned to berth j
x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of ship i if in berth j
px = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of ships *within the same berth*
left  = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="left")
right = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="right")
below = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="below")
above = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_berths))

# --- Constraints ---

# 1. Each ship must be assigned to exactly one berth
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Ship placement constraints within berth boundaries (Big-M formulation)
for j in range(num_berths):
    for i in range(num_ships):
        ship_l, ship_w = ships[i] # Get dimensions for ship i

        # Position variables must be 0 if ship i is not in berth j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Ship's right edge <= berth length IF ship is placed in berth (x[i,j]=1)
        model.addConstr(px[i, j] + ship_l <= berth_size[0] + M_w * (1 - x[i, j]), name=f"Length_Limit_{i}_{j}")
        # Ship's top edge <= berth width IF ship is placed in berth (x[i,j]=1)
        model.addConstr(py[i, j] + ship_w <= berth_size[1] + M_h * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")

# 3. Non-overlapping constraints for ships within the same berth
for j in range(num_berths):
    for i in range(num_ships):
        for k in range(i + 1, num_ships): # Iterate over distinct pairs (i < k)
            ship_i_l, ship_i_w = ships[i]
            ship_k_l, ship_k_w = ships[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => ship i is to the left of ship k
            model.addConstr(px[i, j] + ship_i_l <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => ship i is to the right of ship k (k is left of i)
            model.addConstr(px[k, j] + ship_k_l <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => ship i is below ship k
            model.addConstr(py[i, j] + ship_i_w <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => ship i is above ship k (k is below i)
            model.addConstr(py[k, j] + ship_k_w <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH ship i and ship k are in berth j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link ship assignment to berth usage: If any ship i is in berth j, then berth j must be used (y[j]=1)
#    This can be done per ship or aggregated. Per ship is often tighter.
for j in range(num_berths):
    for i in range(num_ships):
        model.addConstr(x[i, j] <= y[j], name=f"Ship_Berth_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_ships * y[j], name=f"Berth_Activation_{j}")


# --- Solve ---
print("Solving 2DBP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of berths used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    berth_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_berths):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Berth {j_sol + 1} (Used):")
            ships_in_berth_info = []
            for i_sol in range(num_ships):
                if x[i_sol, j_sol].X > 0.5:
                    ship_data = {
                        "id": i_sol,
                        "dims": ships[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    ships_in_berth_info.append(ship_data)
                    print(f"  Ship {ship_data['id']} {ship_data['dims']} at {ship_data['pos']}")
            berth_details.append({'berth_index': j_sol, 'ships': ships_in_berth_info})
            print("-" * 10)
    results_dict['berth_details'] = berth_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 2DBP instance...
Gurobi Error code 10010: Model too large for size-limited license; visit https://gurobi.com/unrestricted for more information

Optimization finished with status: -1. No optimal solution found.


```

================================================================================



--- Problem 244 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy maritime port operates two dedicated berths: Berth 1 for small cargo ships and Berth 2 for large cargo ships. The port manager faces a daily challenge—maximizing profits while efficiently utilizing the limited time available in each berth. Small cargo ship operations take 13 minutes per ship and yield a profit of $6, while large cargo ship operations require 17 minutes but generate a higher profit of $13 per ship. On this particular day, there are 14 small cargo ships and 11 large cargo ships requesting service. The port has a tight operating window of just 154 minutes to accommodate as many ships as possible without exceeding time constraints in either berth. The critical question is: How many small and large cargo ship operations should be scheduled in their respective berths to maximize total profit while staying within the time limits and customer demand?
**

**Modeling Process:**
**
**1. Decision Variables:**
- `x_s1`: Integer variable representing the number of small cargo ship operations assigned to Berth 1.
- `x_l2`: Integer variable representing the number of large cargo ship operations assigned to Berth 2.

**2. Parameters:**
- `time_horizon_minutes = 154`: Total available time (in minutes) for both berths.
- `small_ship_time = 13`: Time (in minutes) required per small cargo ship operation.
- `large_ship_time = 17`: Time (in minutes) required per large cargo ship operation.
- `small_profit = 6`: Profit ($) per small cargo ship operation.
- `large_profit = 13`: Profit ($) per large cargo ship operation.
- `num_small_ships = 14`: Maximum number of small cargo ships available.
- `num_large_ships = 11`: Maximum number of large cargo ships available.

**3. Objective Function:**
- Maximize total profit: `Maximize: 6 * x_s1 + 13 * x_l2`.

**4. Constraints:**
- Berth 1 time capacity: `13 * x_s1 ≤ 154`.
- Berth 2 time capacity: `17 * x_l2 ≤ 154`.
- Small ship limit: `x_s1 ≤ 14`.
- Large ship limit: `x_l2 ≤ 11`.
- Non-negativity and integer constraints: `x_s1 ≥ 0`, `x_l2 ≥ 0`, and both are integers.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
time_horizon_minutes = 154; small_ship_time = 13
large_ship_time = 17; small_profit = 6; large_profit = 13
num_small_ships = 14; num_large_ships = 11
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m6 = gp.Model("Port_Berth_Assignment_MIP", env=env)
    # Vars
    x_s1 = m6.addVar(vtype=GRB.INTEGER, name="small_ship_operations_berth1", lb=0)
    x_l2 = m6.addVar(vtype=GRB.INTEGER, name="large_ship_operations_berth2", lb=0)
    # Objective
    m6.setObjective(small_profit * x_s1 + large_profit * x_l2, sense=GRB.MAXIMIZE)
    # Constraints
    m6.addConstr(small_ship_time * x_s1 <= time_horizon_minutes, "berth1_time_capacity")
    m6.addConstr(large_ship_time * x_l2 <= time_horizon_minutes, "berth2_time_capacity")
    m6.addConstr(x_s1 <= num_small_ships, "small_ship_limit")
    m6.addConstr(x_l2 <= num_large_ships, "large_ship_limit")
    # Optimize
    m6.optimize()
    # Store results
    results_dict['status'] = m6.status
    if m6.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m6.objVal; results_dict['x_s1_opt'] = x_s1.X; results_dict['x_l2_opt'] = x_l2.X
    # Output Results
    print("--- Problem 6: Port Berth Assignment (MIP) ---")
    if m6.status == GRB.OPTIMAL:
        xs1 = results_dict.get('x_s1_opt', 0); xl2 = results_dict.get('x_l2_opt', 0)
        print(f"Optimization Status: Optimal"); print(f"Optimal number of Small ship operations (Berth 1): {int(round(xs1))}")
        print(f"Optimal number of Large ship operations (Berth 2): {int(round(xl2))}"); print(f"Maximum total profit: ${m6.objVal:.2f}")
        print(f"Berth 1 time used: {small_ship_time * xs1:.1f} / {time_horizon_minutes} min")
        print(f"Berth 2 time used: {large_ship_time * xl2:.1f} / {time_horizon_minutes} min")
    else: print(f"Optimization Status: {m6.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_BERTH
```
Answer:
--- Problem 6: Port Berth Assignment (MIP) ---
Optimization Status: Optimal
Optimal number of Small ship operations (Berth 1): 11
Optimal number of Large ship operations (Berth 2): 9
Maximum total profit: $183.00
Berth 1 time used: 143.0 / 154 min
Berth 2 time used: 153.0 / 154 min



================================================================================



--- Problem 245 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy truck depot, a fleet of nine trucks arrives at staggered times throughout the day, each requiring loading or unloading at one of three available docks. The depot manager faces the challenge of minimizing the total time these trucks spend waiting before service begins. Trucks arrive at specific intervals: the first at time 4, followed by others at times 13, 22, 28, 38, 46 (two trucks simultaneously), 49, and 52. Each truck has a predetermined service duration, ranging from 7 to 15 units of time. The docks can handle only one truck at a time, and assignments must ensure no overlaps occur for trucks directed to the same dock. The core question is: *How should the trucks be assigned to docks, and in what sequence, to minimize the cumulative waiting time across all trucks?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[i, j]`: Binary variable (1 if truck `i` is assigned to dock `j`; 0 otherwise).  
     - `s[i]`: Continuous variable representing the start time of service for truck `i`.  
     - `C[i]`: Continuous variable representing the completion time of service for truck `i`.  
     - `W[i]`: Continuous variable representing the waiting time of truck `i` (difference between start time and arrival time).  
     - `y[i, k]`: Binary variable (1 if truck `i` precedes truck `k` on the same dock; 0 otherwise).  

   - **2. Parameters:**  
     - `trucks`: List of truck IDs (0 to 8).  
     - `docks`: List of dock IDs (0 to 2).  
     - `arrival_times[i]`: Time truck `i` arrives (e.g., truck 0 arrives at time 4).  
     - `service_times[i]`: Duration of service for truck `i` (e.g., truck 0 requires 9 time units).  
     - `M`: A large constant (167) to enforce logical constraints.  

   - **3. Objective Function:**  
     Minimize the sum of waiting times:  
     \[
     \text{Minimize: } \sum_{i \in \text{trucks}} W[i].
     \]  

   - **4. Constraints:**  
     - Each truck must be assigned to exactly one dock:  
       \[
       \sum_{j \in \text{docks}} x[i, j] = 1 \quad \forall i \in \text{trucks}.
       \]  
     - Service start time must not precede arrival time:  
       \[
       s[i] \geq \text{arrival\_times}[i] \quad \forall i \in \text{trucks}.
       \]  
     - Completion time is the sum of start time and service time:  
       \[
       C[i] = s[i] + \text{service\_times}[i] \quad \forall i \in \text{trucks}.
       \]  
     - Waiting time definition:  
       \[
       W[i] = s[i] - \text{arrival\_times}[i] \quad \forall i \in \text{trucks}.
       \]  
     - Non-overlapping service for trucks on the same dock (enforced via big-M):  
       \[
       s[k] \geq C[i] - M(1 - y[i, k]) - M(2 - x[i, j] - x[k, j]) \quad \forall i, k \in \text{trucks}, i \neq k, j \in \text{docks}.
       \]  
       \[
       s[i] \geq C[k] - M y[i, k] - M(2 - x[i, j] - x[k, j]) \quad \forall i, k \in \text{trucks}, i \neq k, j \in \text{docks}.
       \]  
     - Precedence logic:  
       \[
       y[i, k] + y[k, i] \geq x[i, j] + x[k, j] - 1 \quad \forall i, k \in \text{trucks}, j \in \text{docks}.
       \]  
       \[
       y[i, k] + y[k, i] \leq 1 \quad \forall i, k \in \text{trucks}.
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [0, 1, 2, 3, 4, 5, 6, 7, 8]
docks = [0, 1, 2]
arrival_times = {0: 4, 1: 13, 2: 22, 3: 28, 4: 38, 5: 46, 6: 46, 7: 49, 8: 52}
service_times = {0: 9, 1: 13, 2: 15, 3: 7, 4: 13, 5: 14, 6: 13, 7: 10, 8: 11}
M = 167 # Big M
# --- End Parameters ---

GUROBI_TIME_LIMIT = 90

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    # env.setParam('MIPGap', 0.01) # Optional: Allow a small gap for faster solves
    env.start()

    # --- Model Creation ---
    m = gp.Model("TRUCK_DEPOT_SCHEDULING", env=env)

    # --- Decision Variables ---
    # x[i, j] = 1 if truck i assigned to dock j
    x = m.addVars(trucks, docks, vtype=GRB.BINARY, name="x")
    # s[i] = start time of service for truck i
    s = m.addVars(trucks, vtype=GRB.CONTINUOUS, lb=0, name="s") # Ensure non-negative start
    # C[i] = completion time of service for truck i
    C = m.addVars(trucks, vtype=GRB.CONTINUOUS, lb=0, name="C") # Ensure non-negative completion
    # W[i] = waiting time for truck i
    W = m.addVars(trucks, vtype=GRB.CONTINUOUS, lb=0, name="W") # Ensure non-negative wait
    # y[i, k] = 1 if truck i precedes truck k on the same dock
    y = m.addVars(trucks, trucks, vtype=GRB.BINARY, name="y")

    # --- Objective Function: Minimize total waiting time ---
    m.setObjective(gp.quicksum(W[i] for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    if trucks and docks: # Basic checks
        # Each truck assigned to exactly one dock
        m.addConstrs((gp.quicksum(x[i, j] for j in docks) == 1 for i in trucks), "Assignment")

        # Service start time constraint (must be >= arrival)
        m.addConstrs((s[i] >= arrival_times.get(i, 0) for i in trucks), "StartTime") # Use .get for safety

        # Completion time definition
        m.addConstrs((C[i] == s[i] + service_times.get(i, 0) for i in trucks), "CompletionTime") # Use .get

        # Waiting time definition
        m.addConstrs((W[i] == s[i] - arrival_times.get(i, 0) for i in trucks), "WaitingTime") # Use .get

        # Non-overlapping constraint for trucks on the same dock (Big-M)
        for j in docks:
            for i in trucks:
                for k in trucks:
                    if i != k:
                        # Define aliases for potentially missing keys
                        xi_j = x.get((i, j))
                        xk_j = x.get((k, j))
                        yi_k = y.get((i, k))
                        yk_i = y.get((k, i)) # Need y[k,i] as well for sum <= 1

                        if xi_j is not None and xk_j is not None and yi_k is not None and yk_i is not None:
                            # s[k] >= C[i] - M * (1 - y[i,k]) - M * (2 - x[i,j] - x[k,j])
                            m.addConstr(s[k] >= C[i] - M * (1 - yi_k) - M * (2 - xi_j - xk_j), f"NonOverlap1_{i}_{k}_{j}")
                            # s[i] >= C[k] - M * y[i,k]       - M * (2 - x[i,j] - x[k,j]) --> Should be 1-y[k,i] or y[i,k]?
                            # Original used M*y[i,k]. Let's assume y[i,k]=1 means i before k.
                            # So, s[i] >= C[k] implies k is before i (y[k,i]=1). We need -M * (1-y[k,i]) or -M*y[i,k]
                            m.addConstr(s[i] >= C[k] - M * yi_k - M * (2 - xi_j - xk_j), f"NonOverlap2_{i}_{k}_{j}")

                            # Ensure y[i,k] + y[k,i] = 1 if they are on the same dock
                            m.addConstr(yi_k + yk_i >= xi_j + xk_j - 1, f"PrecedenceSum1_{i}_{k}_{j}")
                            m.addConstr(yi_k + yk_i <= 1, f"PrecedenceSum2_{i}_{k}_{j}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['W_sol'] = m.getAttr('X', W) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible") # Matches example
    elif m.Status == GRB.TIME_LIMIT:
         print(f"Optimization ended with status {m.Status}") # Matches example's generic else
    else: # Other statuses
        print(f"Optimization ended with status {m.Status}") # Matches example's generic else


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the assignment of trucks to docks and their start, completion, and waiting times
if m.Status == GRB.OPTIMAL:
    for i in trucks:
        assigned_dock = [j for j in docks if x[i, j].X > 0.5][0]
        print(f"Truck {i} is assigned to Dock {assigned_dock}, Start Time: {s[i].X:.2f}, Completion Time: {C[i].X:.2f}, Waiting Time: {W[i].X:.2f}")
```
Answer:
Optimal objective value: 9.00
Truck 0 is assigned to Dock 0, Start Time: 4.00, Completion Time: 13.00, Waiting Time: 0.00
Truck 1 is assigned to Dock 0, Start Time: 13.00, Completion Time: 26.00, Waiting Time: 0.00
Truck 2 is assigned to Dock 2, Start Time: 22.00, Completion Time: 37.00, Waiting Time: 0.00
Truck 3 is assigned to Dock 0, Start Time: 28.00, Completion Time: 35.00, Waiting Time: 0.00
Truck 4 is assigned to Dock 0, Start Time: 38.00, Completion Time: 51.00, Waiting Time: 0.00
Truck 5 is assigned to Dock 2, Start Time: 46.00, Completion Time: 60.00, Waiting Time: 0.00
Truck 6 is assigned to Dock 1, Start Time: 46.00, Completion Time: 59.00, Waiting Time: 0.00
Truck 7 is assigned to Dock 0, Start Time: 51.00, Completion Time: 61.00, Waiting Time: 2.00
Truck 8 is assigned to Dock 1, Start Time: 59.00, Completion Time: 70.00, Waiting Time: 7.00


```

================================================================================



--- Problem 246 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port authority is tasked with scheduling a collection of 39 incoming ships into a limited number of berths for unloading. Each ship has a specific weight and value, and the berths have a strict weight capacity of 24 units. The port can use up to 6 berths, and the goal is to maximize the total value of the unloaded cargo while ensuring no berth exceeds its weight limit. The challenge is to determine which ships to place in which berths to achieve the highest possible total value without violating any constraints.  

   The ships vary significantly in weight and value—some are lightweight but highly valuable (e.g., ship 4 with weight 6 and value 94), while others are heavier but less valuable (e.g., ship 24 with weight 24 and value 6). The port authority must carefully balance these trade-offs to optimize the unloading process's worth. The core question is: *What is the optimal berthing strategy that maximizes the total value while adhering to the berth capacity and berth count limits?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether ship `i` is placed in berth `j` (1 if placed, 0 otherwise).  
   - `y[j]`: Binary variable indicating whether berth `j` is used (1 if used, 0 otherwise).  

   **2. Parameters:**  
   - `ships`: List of tuples `(weight, value)` for each ship (e.g., ship 0 has weight 13 and value 51).  
   - `berth_capacity`: Maximum weight per berth (24 units).  
   - `num_berths`: Maximum number of available berths (6).  

   **3. Objective Function:**  
   Maximize the total value of unloaded cargo:  
   \[
   \text{Maximize: } \sum_{i=0}^{38} \sum_{j=0}^{5} \text{value}_i \cdot x[i, j]
   \]  

   **4. Constraints:**  
   - **Berth weight limit:** For each berth `j`, the total weight of ships assigned must not exceed its capacity:  
     \[
     \sum_{i=0}^{38} \text{weight}_i \cdot x[i, j] \leq \text{berth\_capacity} \cdot y[j] \quad \forall j \in \{0, 1, \dots, 5\}
     \]  
   - **Ship-berth linkage:** If a ship `i` is placed in berth `j`, the berth must be marked as used:  
     \[
     x[i, j] \leq y[j] \quad \forall i \in \{0, 1, \dots, 38\}, \forall j \in \{0, 1, \dots, 5\}
     \]  
   - **Ship assignment:** Each ship can be placed in at most one berth:  
     \[
     \sum_{j=0}^{5} x[i, j] \leq 1 \quad \forall i \in \{0, 1, \dots, 38\}
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Data Definition (Embedded) ---
ships = [(13, 51), (22, 90), (23, 47), (2, 28), (6, 94), (1, 17), (2, 2), (1, 3), (6, 21), (17, 48), (22, 83), (8, 90), (13, 58), (9, 74), (16, 27), (2, 15), (8, 91), (4, 51), (5, 22), (19, 36), (22, 83), (17, 36), (15, 24), (10, 93), (21, 79), (6, 25), (11, 28), (17, 7), (23, 96), (2, 51), (24, 6), (11, 85), (8, 97), (5, 41), (23, 67), (12, 53), (14, 87), (5, 92), (13, 24)]          # List of (weight, value) tuples
berth_capacity = 24      # Maximum weight per berth
num_berths = 6          # Maximum number of available berths (parameter)
num_ships = 39          # len(ships) derived correctly
# --- End Data Definition ---

GUROBI_TIME_LIMIT = 60 # Time limit parameter

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi log in captured output
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Max-Value Berth Scheduling", env=env)

    # --- Decision variables ---
    x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")  # x[i, j] -> ship i placed in berth j
    y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")  # y[j] -> berth j is used

    # --- Objective: Maximize total value of selected ships ---
    # Sum over all ships i and the berth j they are placed in
    model.setObjective(gp.quicksum(ships[i][1] * x[i, j] for i in range(num_ships) for j in range(num_berths)), GRB.MAXIMIZE)

    # --- Constraint 1: Berth weight limit ---
    for j in range(num_berths):
        model.addConstr(gp.quicksum(ships[i][0] * x[i, j] for i in range(num_ships)) <= berth_capacity * y[j], name=f"Berth_{j}_Weight")

    # --- Constraint 2: If a ship is placed in a berth, that berth must be considered used ---
    # (This is often implied by C1 if capacity > 0, but good practice)
    for i in range(num_ships):
        for j in range(num_berths):
            model.addConstr(x[i, j] <= y[j], name=f"Ship_{i}_Triggers_Berth_{j}")

    # --- Constraint 3: Each ship can be placed in at most one berth ---
    # (Ships not placed contribute 0 to objective and constraints)
    for i in range(num_ships):
        model.addConstr(x.sum(i, '*') <= 1, name=f"Ship_{i}_AtMostOneBerth")

    # --- Solve the model ---
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal # Best solution found

    # --- Output results (for capture) ---
    if model.status == GRB.OPTIMAL:
        print(f"Optimal total value: {model.objVal:.2f}") # Format value
        print("-" * 30)
        printed_berth_count = 0
        for j in range(num_berths):
            try:
                 if y[j].x > 0.5:  # Berth is used
                     printed_berth_count += 1
                     assigned_ships = [i for i in range(num_ships) if x[i, j].x > 0.5]
                     assigned_weights = [ships[i][0] for i in assigned_ships]
                     berth_load = sum(assigned_weights)
                     print(f"Berth {printed_berth_count} (Index {j}):")
                     print(f"  Load: {berth_load} / {berth_capacity}")
                     print(f"  Ships (indices): {sorted(assigned_ships)}")
                     # Optional: print ship details
                     # print(f"  Ships (w,v): {[ships[i] for i in sorted(assigned_ships)]}")
                     print("-" * 10)
            except AttributeError:
                 pass # Skip berths not used or if .X missing
    elif model.status == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare if ships fit capacity
    else:
        print(f"\nOptimization finished with status: {model.status}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# The original code already prints the optimal total value and the details of each berth.
# However, it does not print the decision variables x[i, j] explicitly.
# Adding this for completeness:

if model.status == GRB.OPTIMAL:
    print(f"Optimal total value: {model.objVal:.2f}")
    print("-" * 30)
    printed_berth_count = 0
    for j in range(num_berths):
        try:
            if y[j].x > 0.5:  # Berth is used
                printed_berth_count += 1
                assigned_ships = [i for i in range(num_ships) if x[i, j].x > 0.5]
                assigned_weights = [ships[i][0] for i in assigned_ships]
                berth_load = sum(assigned_weights)
                print(f"Berth {printed_berth_count} (Index {j}):")
                print(f"  Load: {berth_load} / {berth_capacity}")
                print(f"  Ships (indices): {sorted(assigned_ships)}")
                print(f"  Ships (w,v): {[ships[i] for i in sorted(assigned_ships)]}")
                print("-" * 10)
        except AttributeError:
            pass  # Skip berths not used or if .X missing
```
Answer:
Optimal total value: 1216.00
------------------------------
Berth 1 (Index 0):
  Load: 24 / 24
  Ships (indices): [4, 12, 37]
----------
Berth 2 (Index 1):
  Load: 24 / 24
  Ships (indices): [15, 16, 17, 29, 32]
----------
Berth 3 (Index 2):
  Load: 24 / 24
  Ships (indices): [7, 31, 35]
----------
Berth 4 (Index 3):
  Load: 24 / 24
  Ships (indices): [3, 11, 36]
----------
Berth 5 (Index 4):
  Load: 24 / 24
  Ships (indices): [5, 28]
----------
Berth 6 (Index 5):
  Load: 24 / 24
  Ships (indices): [13, 23, 33]
----------
Optimal total value: 1216.00
------------------------------
Berth 1 (Index 0):
  Load: 24 / 24
  Ships (indices): [4, 12, 37]
  Ships (w,v): [(6, 94), (13, 58), (5, 92)]
----------
Berth 2 (Index 1):
  Load: 24 / 24
  Ships (indices): [15, 16, 17, 29, 32]
  Ships (w,v): [(2, 15), (8, 91), (4, 51), (2, 51), (8, 97)]
----------
Berth 3 (Index 2):
  Load: 24 / 24
  Ships (indices): [7, 31, 35]
  Ships (w,v): [(1, 3), (11, 85), (12, 53)]
----------
Berth 4 (Index 3):
  Load: 24 / 24
  Ships (indices): [3, 11, 36]
  Ships (w,v): [(2, 28), (8, 90), (14, 87)]
----------
Berth 5 (Index 4):
  Load: 24 / 24
  Ships (indices): [5, 28]
  Ships (w,v): [(1, 17), (23, 96)]
----------
Berth 6 (Index 5):
  Load: 24 / 24
  Ships (indices): [13, 23, 33]
  Ships (w,v): [(9, 74), (10, 93), (5, 41)]
----------


```

================================================================================



--- Problem 247 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port is managed by a three-phase berthing system, where each phase controls the flow of ships from different directions. The port managers face a critical challenge: minimizing the total delay experienced by ships while ensuring the berthing timings adhere to strict operational constraints. Each phase has a distinct traffic flow coefficient, representing the volume of ships affected by the berthing timing—2,990 for phase 1, 2,586 for phase 2, and 253 for phase 3. The total cycle time for the berthing system is fixed at 48 hours, meaning the sum of berthing times across all phases must equal this value. Additionally, each phase’s berthing time must be between 8 and 48 hours. The delay for each phase is proportional to its traffic flow multiplied by its non-berthing time (cycle time minus berthing time). The core question is: *How should the 48-hour cycle be allocated among the three phases to minimize the total delay for all ships passing through the port?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( t_i \) represent the berthing time (in hours) allocated to phase \( i \), where \( i \in \{1, 2, 3\} \). Each \( t_i \) is a continuous variable bounded between 8 and 48.  
   - **2. Parameters:**  
     - \( \text{flow_coeffs} = [2990, 2586, 253] \): Traffic flow coefficients for each phase.  
     - \( \text{cycle_time} = 48 \): Total fixed cycle time (hours).  
     - \( \text{lb_time} = 8 \), \( \text{ub_time} = 48 \): Lower and upper bounds for berthing times.  
   - **3. Objective Function:**  
     - Minimize the total delay:  
       \[
       \text{Minimize: } \sum_{i=1}^{3} \text{flow_coeffs}[i] \times (\text{cycle_time} - t_i)
       \]  
   - **4. Constraints:**  
     - The sum of berthing times must equal the cycle time:  
       \[
       t_1 + t_2 + t_3 = 48
       \]  
     - Bounds on berthing times:  
       \[
       8 \leq t_i \leq 48 \quad \text{for } i \in \{1, 2, 3\}
       \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 3
lb_time = 8          # Lower bound for berthing time
ub_time = 48          # Upper bound for berthing time
cycle_time = 48   # Total cycle time (set equal to ub_time)
flow_coeffs = [2990, 2586, 253] # Traffic flow coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for phase i is proportional to flow * non-berthing_time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total delay: 161400.00
------------------------------
Optimal berthing times (hours):
  t1: 32.00, t2: 8.00, t3: 8.00


```

================================================================================



--- Problem 248 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port manager is tasked with efficiently allocating berth resources to handle a daily influx of ships while minimizing operational costs. The port has two types of berths: automated and manual. Automated berths are cheaper to operate but can only serve ships equipped with automated docking systems, while manual berths handle all other ships, including cargo ships, which are assumed to require manual processing.  

On a typical day, the port expects 2,882 container ships and 77 cargo ships. Historical data shows that 46% of container ships use automated docking systems, while the remaining 54% (along with all cargo ships) must use manual berths. Each automated berth can process up to 404 ships per hour, while each manual berth handles 270. The operational costs are $4/hour for automated berths and $17/hour for manual berths. The port has 4 automated berths and 7 manual berths available, but opening all would be costly.  

The manager must determine how many automated and manual berths to open to meet demand at the lowest possible cost while ensuring capacity constraints are satisfied. The key question is: **What is the optimal number of automated and manual berths to open to minimize hourly operational costs while processing all incoming ships?**
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x_automated`: Integer number of automated berths to open (≥ 0).  
   - `x_manual`: Integer number of manual berths to open (≥ 0).  

   **2. Parameters:**  
   - `automated_ships_arrival = 2,882 * 0.46 = 1,326` (automated-eligible container ships).  
   - `non_automated_ships_manual = (2,882 * 0.54) + 77 = 1,633` (non-automated container ships + cargo ships).  
   - `service_rate_automated = 404` (ships/hour per automated berth).  
   - `service_rate_manual = 270` (ships/hour per manual berth).  
   - `cost_automated = $4/hour` (per automated berth).  
   - `cost_manual = $17/hour` (per manual berth).  
   - `total_automated_berths = 4` (maximum available).  
   - `total_manual_berths = 7` (maximum available).  

   **3. Objective Function:**  
   Minimize total hourly cost:  
   \[
   \text{Minimize: } 4 \cdot x_{\text{automated}} + 17 \cdot x_{\text{manual}}
   \]  

   **4. Constraints:**  
   - Automated capacity must handle automated ships:  
     \[
     404 \cdot x_{\text{automated}} \geq 1,326
     \]  
   - Manual capacity must handle non-automated ships:  
     \[
     270 \cdot x_{\text{manual}} \geq 1,633
     \]  
   - Berth limits:  
     \[
     x_{\text{automated}} \leq 4, \quad x_{\text{manual}} \leq 7
     \]  
   - Non-negativity and integer constraints:  
     \[
     x_{\text{automated}}, x_{\text{manual}} \geq 0 \text{ and integer.}
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
total_automated_berths = 4
total_manual_berths = 7
arrival_container_ships = 2882
arrival_cargo_ships = 77
automated_ship_ratio = 0.46
automated_cargo_ratio = 0.10 # Note: Constraint logic assumes cargo ships go manual
service_rate_automated = 404
service_rate_manual = 270
cost_automated = 4
cost_manual = 17
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# --- Calculated Arrivals (Inside Template) ---
try:
    automated_ships_arrival = arrival_container_ships * automated_ship_ratio
    non_automated_ships_arrival = arrival_container_ships * (1.0 - automated_ship_ratio)
    # All cargo ships need processing capacity from manual berths in this setup
    # Correct interpretation: cargo ships that CAN use automated do, others go manual.
    # Let's stick to the user's example logic where automated_cargo_ratio seems unused
    # and all cargo ships + non-automated container ships go manual
    non_automated_ships_manual = non_automated_ships_arrival + arrival_cargo_ships # All cargo ships + non-automated container ships

    # --- Model Creation ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    m2 = gp.Model("Port_Berth_Mix", env=env)

    # --- Decision Variables ---
    x_automated = m2.addVar(vtype=GRB.INTEGER, name="num_open_automated_berths", lb=0)
    x_manual = m2.addVar(vtype=GRB.INTEGER, name="num_open_manual_berths", lb=0)

    # --- Objective Function ---
    m2.setObjective(cost_automated * x_automated + cost_manual * x_manual, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # 1: Automated capacity for automated ships
    m2.addConstr(service_rate_automated * x_automated >= automated_ships_arrival, name="automated_capacity")
    # 2: Manual capacity for non-automated ships and all cargo ships
    m2.addConstr(service_rate_manual * x_manual >= non_automated_ships_manual, name="manual_capacity")
    # 3: Max available automated berths
    m2.addConstr(x_automated <= total_automated_berths, name="max_automated_berths")
    # 4: Max available manual berths
    m2.addConstr(x_manual <= total_manual_berths, name="max_manual_berths")

    # --- Optimization ---
    m2.optimize()

    # --- Store results ---
    results_dict['status'] = m2.status
    if m2.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m2.objVal
        results_dict['x_automated_optimal'] = x_automated.X
        results_dict['x_manual_optimal'] = x_manual.X

    # --- Output Results (for capture) ---
    # Use original print format
    print("--- Problem 2: Port Berth Mix (Automated vs. Manual) ---")
    if m2.status == GRB.OPTIMAL:
        optimal_automated = results_dict.get('x_automated_optimal', 'N/A')
        optimal_manual = results_dict.get('x_manual_optimal', 'N/A')
        # Round before int() for safety
        if not isinstance(optimal_automated, (int, float)): optimal_automated = -1
        if not isinstance(optimal_manual, (int, float)): optimal_manual = -1

        print(f"Optimization Status: Optimal")
        print(f"Optimal number of automated berths to open: {int(round(optimal_automated))}")
        print(f"Optimal number of manual berths to open: {int(round(optimal_manual))}")
        print(f"Minimum total operational cost: ${m2.objVal:.2f}/hour")
        # Recalculate capacities for output clarity
        automated_cap_achieved = service_rate_automated * optimal_automated
        manual_cap_achieved = service_rate_manual * optimal_manual
        print(f"Automated Capacity: {automated_cap_achieved:.0f} >= {automated_ships_arrival:.0f}")
        print(f"Manual Capacity: {manual_cap_achieved:.0f} >= {non_automated_ships_manual:.0f}")
    elif m2.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible")
    else:
        print(f"Optimization Status: {m2.status}")

except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
--- Problem 2: Port Berth Mix (Automated vs. Manual) ---
Optimization Status: Optimal
Optimal number of automated berths to open: 4
Optimal number of manual berths to open: 7
Minimum total operational cost: $135.00/hour
Automated Capacity: 1616 >= 1326
Manual Capacity: 1890 >= 1633



================================================================================



--- Problem 249 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
A port experiences a sudden reduction in the number of available berths due to an unexpected maintenance issue, reducing its capacity and causing significant disruption. The incident lasts for 2 hours, during which the number of available berths drops from 4 to 2, cutting the port's throughput from 8,440 containers per hour (4 berths × 2,110 cont/h/berth) to just 4,220 cont/h (2 berths × 2,110 cont/h/berth). Meanwhile, containers continue to arrive at a steady rate of 1,059 cont/h. To mitigate congestion, some containers can be diverted to an alternative port, but this detour adds an extra 25 minutes (0.4167 hours) to their travel time. The alternative port has a limited capacity of 1,104 cont/h.  

The challenge is to determine the optimal distribution of containers between the main port and the alternative port to minimize the total delay experienced by all container movements. The main port’s delay is non-linear: if the flow exceeds the reduced capacity, a queue forms, leading to delays that persist even after the incident clears. The alternative port’s delay is straightforward—each container taking it incurs a fixed additional travel time. The goal is to balance these competing delays to find the most efficient container allocation.
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `flow_alt`: The number of containers per hour (cont/h) diverted to the alternative port (continuous, ≥ 0).  
- `flow_main`: The number of containers per hour (cont/h) remaining at the main port (derived from flow conservation).  

**2. Parameters:**  
- `arrival_rate_total = 1059` cont/h: Total incoming container flow.  
- `capacity_main_reduced = 4220` cont/h: Main port capacity during the incident (2 berths × 2,110 cont/h/berth).  
- `capacity_main_normal = 8440` cont/h: Main port capacity post-incident (4 berths × 2,110 cont/h/berth).  
- `alt_port_capacity = 1104` cont/h: Maximum flow the alternative port can handle.  
- `incident_duration = 2.0` h: Duration of the berth closure.  
- `alt_port_extra_time = 0.4167` h: Additional travel time per container on the alternative port.  

**3. Objective Function:**  
Minimize the total delay, which is the sum of:  
- The piecewise-linear approximation of the main port delay (`delay_main_approx`), calculated based on queue dynamics.  
- The alternative port delay (`delay_alt = flow_alt × incident_duration × alt_port_extra_time`).  

**4. Constraints:**  
- **Flow conservation:** `flow_main + flow_alt = arrival_rate_total`.  
- **Alternative port capacity:** `flow_alt ≤ alt_port_capacity`.  
- **Piecewise-linear delay:** `delay_main_approx` is approximated as a function of `flow_main` using precomputed points.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB, GurobiError
import math
import numpy as np # Needed for linspace
import sys
import traceback

# --- Parameters (Embedded) ---
capacity_per_berth = 2110  # cont/h/berth
num_berths_normal = 4      # Number of berths under normal conditions
num_berths_reduced = 2     # Number of berths during incident
arrival_rate_total = 1059 # cont/h
incident_duration = 2.00   # h (Duration of the capacity reduction)
alt_port_capacity = 1104 # cont/h
# Extra time originally in minutes, convert to hours here
alt_port_extra_min = 25
alt_port_extra_time = alt_port_extra_min / 60.0 # h
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit
NUM_PWL_POINTS = 20 # PWL points

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# --- Calculated Parameters ---
capacity_main_reduced = num_berths_reduced * capacity_per_berth # cont/h
capacity_main_normal = num_berths_normal * capacity_per_berth   # cont/h

# --- Helper Function for Main Delay Calculation ---
def calculate_main_delay(flow_main_val, cap_reduced, cap_normal, inc_duration):
    # Calculates main port delay based on flow.
    flow_main_val = max(0.0, flow_main_val)
    cap_reduced = max(0.0, cap_reduced)
    cap_normal = max(0.0, cap_normal)
    inc_duration = max(0.0, inc_duration)
    if flow_main_val <= cap_reduced + 1e-6: return 0.0
    if cap_normal <= cap_reduced + 1e-6: return 1e10
    queue_growth_rate = flow_main_val - cap_reduced
    max_queue = queue_growth_rate * inc_duration
    dissipation_rate = cap_normal - flow_main_val
    if dissipation_rate <= 1e-6: return 1e10
    else:
        dissipation_time = max_queue / dissipation_rate
        total_queue_time = inc_duration + dissipation_time
        delay = 0.5 * max_queue * total_queue_time
        return delay

# --- Generate Points for Piecewise Linear Approximation ---
flow_points = []
delay_points = []
pwl_error_flag = False
try:
    min_flow_main = 0.0
    max_flow_main = float(arrival_rate_total)
    if max_flow_main < min_flow_main: max_flow_main = min_flow_main + 1.0 # Handle edge case

    flow_points = np.linspace(min_flow_main, max_flow_main, NUM_PWL_POINTS).tolist() # Use constant from globals
    crit_reduced = float(capacity_main_reduced)
    crit_normal_minus_1 = float(capacity_main_normal - 1.0)

    if crit_reduced > min_flow_main + 1e-6 and not np.isclose(flow_points, crit_reduced).any():
         flow_points.append(crit_reduced)
    if capacity_main_normal > capacity_main_reduced + 1e-6 and crit_normal_minus_1 < max_flow_main - 1e-6 and crit_normal_minus_1 > min_flow_main and not np.isclose(flow_points, crit_normal_minus_1).any():
         flow_points.append(crit_normal_minus_1)

    flow_points = sorted(list(set(p for p in flow_points if p >= 0)))
    if not flow_points: flow_points = [0.0] # Ensure not empty

    delay_points = [calculate_main_delay(f, capacity_main_reduced, capacity_main_normal, incident_duration) for f in flow_points]
    delay_points = [max(0.0, d) for d in delay_points]

    if len(flow_points) < 2 or len(flow_points) != len(delay_points):
        print(f"Error: Invalid points generated for PWL. flow={len(flow_points)}, delay={len(delay_points)}")
        results_dict['status'] = -4
        results_dict['error_message'] = "Invalid PWL points generated"
        pwl_error_flag = True

except Exception as pwl_e:
    print(f"An unexpected error occurred during PWL point generation:")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -5
    results_dict['error_message'] = f"PWL Generation Error: {pwl_e}"
    pwl_error_flag = True

# --- Gurobi Model ---
try:
    if pwl_error_flag:
        print("Skipping model build due to PWL error.")
    else:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi output
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        m = gp.Model("PortRerouting_PWL", env=env)

        # --- Decision Variables ---
        flow_alt = m.addVar(name="flow_alternative", lb=0.0, ub=arrival_rate_total)
        # --- Intermediate Variables ---
        flow_main = m.addVar(name="flow_main", lb=0.0)
        delay_alt = m.addVar(name="delay_alt", lb=0.0)
        delay_main_approx = m.addVar(name="delay_main_approx", lb=0.0)

        # --- Constraints ---
        m.addConstr(flow_main + flow_alt == arrival_rate_total, name="FlowConservation")
        m.addConstr(flow_alt <= alt_port_capacity, name="AltPortCapacity")
        m.addConstr(delay_alt == flow_alt * incident_duration * alt_port_extra_time, name="CalcAltDelay")
        # Add PWL constraint only if points are valid
        if len(flow_points) > 1 and len(flow_points) == len(delay_points):
             max_delay = max(delay_points) if delay_points else 0
             if max_delay > 1e9: print("Warning: Very large delay calculated for PWL points.")
             m.addGenConstrPWL(flow_main, delay_main_approx, flow_points, delay_points, name="PWL_MainDelay")
        else:
            # Should not be reached if pwl_error_flag logic is correct
            print("Error: Cannot add PWL constraint (points invalid).")
            if results_dict.get('status') is None: results_dict['status'] = -4
            raise ValueError("Invalid PWL points for constraint")

        # --- Objective Function ---
        m.setObjective(delay_main_approx + delay_alt, GRB.MINIMIZE)

        # --- Optimize ---
        m.optimize()

        # --- Store results ---
        results_dict['status'] = m.status
        if m.status == GRB.OPTIMAL:
            results_dict['obj_val'] = m.objVal
            results_dict['flow_alt_optimal'] = flow_alt.X # Store the result

except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"

# --- Output results (for capture) ---
current_status_for_output = results_dict.get('status')
if current_status_for_output == GRB.OPTIMAL:
    optimal_flow_alt = results_dict.get('flow_alt_optimal', 'N/A')
    if isinstance(optimal_flow_alt, (int, float)):
         print(f"{optimal_flow_alt:.2f}") # Output only the value
    else:
         print(f"Error: Optimal flow_alt not found in results.")
elif current_status_for_output == GRB.INFEASIBLE:
    print("Infeasible")
elif current_status_for_output == GRB.UNBOUNDED:
    print("Unbounded")
elif current_status_for_output == GRB.TIME_LIMIT:
     print(f"TimeLimit_{GUROBI_TIME_LIMIT}s")
elif current_status_for_output == -4 or current_status_for_output == -5: # PWL error
     print(f"PWLError: {results_dict.get('error_message', 'Unknown PWL error')}")
else:
    print(f"NonOptimalStatus_{current_status_for_output}")



# Supplemental code block to print additional outputs
if current_status_for_output == GRB.OPTIMAL:
    optimal_flow_alt = results_dict.get('flow_alt_optimal', 'N/A')
    if isinstance(optimal_flow_alt, (int, float)):
        flow_main_optimal = arrival_rate_total - optimal_flow_alt
        delay_alt_optimal = optimal_flow_alt * incident_duration * alt_port_extra_time
        delay_main_approx_optimal = results_dict.get('obj_val', 0.0) - delay_alt_optimal
        print(f"Optimal flow_alt: {optimal_flow_alt:.2f}")
        print(f"Optimal flow_main: {flow_main_optimal:.2f}")
        print(f"Optimal delay_alt: {delay_alt_optimal:.2f}")
        print(f"Optimal delay_main_approx: {delay_main_approx_optimal:.2f}")
        print(f"Total objective value: {results_dict['obj_val']:.2f}")
    else:
        print(f"Error: Optimal flow_alt not found in results.")
```
Answer:
0.00
Optimal flow_alt: 0.00
Optimal flow_main: 1059.00
Optimal delay_alt: 0.00
Optimal delay_main_approx: 0.00
Total objective value: 0.00


```

================================================================================



--- Problem 250 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port is tasked with efficiently scheduling the berthing of incoming ships to minimize total service time while adhering to strict operational constraints. Two ships, labeled A and B, arrive at the port at distinct times—Ship A at time 6 and Ship B at time 9. The port has two berths, each capable of handling the ships but with varying processing times. For instance, assigning Ship A to Berth 1 takes 8 units of time, while Berth 2 requires 7 units. Similarly, Ship B takes 8 units at Berth 1 and 9 at Berth 2. The port authority must decide not only which berth each ship should use but also the precise start times to ensure no overlaps occur at the same berth. The core question is: *How can the port schedule these ships to minimize the total completion time while respecting arrival times and avoiding berth conflicts?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary variable (1 if Ship *i* is assigned to Berth *j*, 0 otherwise).  
   - `start_time[i]`: Continuous variable representing the start time of Ship *i*.  
   - `completion_time[i]`: Continuous variable representing the completion time of Ship *i*.  
   - `precedes[i, k, j]`: Binary variable (1 if Ship *i* precedes Ship *k* at Berth *j*, 0 otherwise).  

   **2. Parameters:**  
   - `ships = [A, B]`, `berths = [1, 2]`.  
   - `arrival_times = {A: 6, B: 9}`.  
   - `processing_times = {(A,1): 8, (A,2): 7, (B,1): 8, (B,2): 9}`.  
   - `H = 100` (a large constant for logical constraints).  

   **3. Objective Function:**  
   Minimize the sum of completion times for all ships:  
   \[
   \text{Minimize: } \sum_{i \in \text{ships}} \text{completion_time}[i].
   \]  

   **4. Constraints:**  
   - **Assignment:** Each ship must be assigned to exactly one berth:  
     \[
     \sum_{j \in \text{berths}} \text{assign}[i, j] = 1 \quad \forall i \in \text{ships}.
     \]  
   - **Arrival Time:** Ships cannot start before their arrival time:  
     \[
     \text{start_time}[i] \geq \text{arrival_times}[i] \quad \forall i \in \text{ships}.
     \]  
   - **Completion Time:** The completion time is the start time plus the processing time at the assigned berth:  
     \[
     \text{completion_time}[i] = \text{start_time}[i] + \sum_{j \in \text{berths}} \text{processing_times}[i, j] \cdot \text{assign}[i, j] \quad \forall i \in \text{ships}.
     \]  
   - **Non-Overlapping:** If two ships are assigned to the same berth, one must precede the other:  
     \[
     \text{If } \text{precedes}[i, k, j] = 1, \text{ then } \text{start_time}[k] \geq \text{completion_time}[i] \quad \forall i < k, j \in \text{berths}.
     \]  
     \[
     \text{If } \text{precedes}[i, k, j] = 0, \text{ then } \text{start_time}[i] \geq \text{completion_time}[k] \quad \forall i < k, j \in \text{berths}.
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = ['A', 'B']
berths = [1, 2]
arrival_times = {'A': 6, 'B': 9}
processing_times = {('A', 1): 8, ('A', 2): 7, ('B', 1): 8, ('B', 2): 9} # Dict {(ship, berth): time}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_8_BERTH_PROC")

    if not ships or not berths: raise ValueError("Empty ships or berths")

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in ships for k in ships if i < k for j in berths],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(completion_time[i] for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time (berth dependent)
    m.addConstrs((completion_time[i] == start_time[i] + gp.quicksum(processing_times.get((i,j), 0) * assign[i,j] for j in berths)
                  for i in ships), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Print Missing Outputs ---

if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in ships:
        for j in berths:
            if assign[i, j].x > 0.5:
                print(f"Ship {i} is assigned to Berth {j}")
                print(f"Start Time for Ship {i}: {start_time[i].x:.4f}")
                print(f"Completion Time for Ship {i}: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
34.0000
Optimal Solution Found:
Ship A is assigned to Berth 2
Start Time for Ship A: 6.0000
Completion Time for Ship A: 13.0000
Ship B is assigned to Berth 1
Start Time for Ship B: 13.0000
Completion Time for Ship B: 21.0000


```

================================================================================



--- Problem 251 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the harbor master is tasked with optimizing the berthing times for three different types of ships to minimize the total waiting time. The port operates with three distinct berthing phases, each serving different ship types. The goal is to allocate berthing times to these phases within a fixed cycle duration of 77 minutes, ensuring smooth operations while adhering to practical constraints. Each phase has a minimum berthing time of 22 minutes and a maximum of 77 minutes, reflecting real-world operational limits. The ship flow coefficients—657, 1644, and 267 for phases 1, 2, and 3, respectively—quantify the relative impact of delays on each phase. The core question is: *How should the berthing times be distributed across the three phases to minimize the total delay experienced by all ships, given the cycle time and flow characteristics?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - \( t_i \): Continuous variable representing the berthing time (in minutes) allocated to phase \( i \) (\( i = 1, 2, 3 \)), with bounds \( 22 \leq t_i \leq 77 \).  

   **2. Parameters:**  
   - \( \text{flow_coeffs} = [657, 1644, 267] \): Ship flow coefficients for each phase.  
   - \( \text{cycle_time} = 77 \): Total cycle time (minutes).  
   - \( \text{lb_time} = 22 \), \( \text{ub_time} = 77 \): Lower and upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize the total delay:  
   \[
   \text{Minimize: } \sum_{i=1}^{3} \text{flow_coeffs}[i] \times (\text{cycle_time} - t_i)
   \]  
   (Delay for phase \( i \) is proportional to its flow coefficient multiplied by its non-berthing time, \( \text{cycle_time} - t_i \)).  

   **4. Constraints:**  
   - The sum of berthing times must equal the cycle time:  
     \[
     t_1 + t_2 + t_3 = 77
     \]  
   - Variable bounds: \( 22 \leq t_i \leq 77 \) for all \( i \).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 3
lb_time = 22          # Lower bound for berthing time
ub_time = 77          # Upper bound for berthing time
cycle_time = 77       # Total cycle time (set equal to ub_time)
flow_coeffs = [657, 1644, 267] # Ship flow coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for phase i is proportional to flow * non-berthing time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total delay: 123156.00
------------------------------
Optimal berthing times (minutes):
  t1: 22.00, t2: 33.00, t3: 22.00


```

================================================================================



--- Problem 252 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy maritime port operates three berths to service a fleet of eight ships, each with unique handling times and profit contributions. The port manager faces the challenge of maximizing daily profit by strategically assigning ships to berths without exceeding the 8.7-hour operational limit per berth. 

Ship S1, for instance, requires 2.9 hours to process but yields $495 in profit, while S3 offers a swift 0.8-hour turnaround with a lucrative $494 payoff. Other ships like S7 and S8 demand 1.2 hours each but contribute modestly ($170 and $272, respectively). The berths must balance high-value, time-intensive assignments (e.g., S1 and S2 totaling 5.3 hours at Berth 1) with quicker, profitable options (like S3 and S4 adding 2.3 hours). 

The core dilemma: *How can the manager assign ships to berths to maximize total profit while ensuring no berth exceeds its 8.7-hour capacity, and each ship is served at most once?* The solution must navigate trade-offs between profit density and time constraints, potentially leaving some ships unserved if they hinder higher-value combinations.
**

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable `x(s, b)`: Equals 1 if ship `s` (e.g., S1, S2) is assigned to berth `b` (0, 1, 2), else 0.

**2. Parameters:**  
- `profit(s)`: Profit from ship `s` (e.g., `profit(S1) = 495`).  
- `time(s)`: Handling time for ship `s` (e.g., `time(S3) = 0.8`).  
- `H = 8.7`: Maximum operational hours per berth.  

**3. Objective Function:**  
- Maximize total profit:  
  `Maximize: sum(profit(s) * x(s, b) for all s, b)`  

**4. Constraints:**  
- **Single assignment per ship:** Each ship `s` assigned to at most one berth:  
  `sum(x(s, b) for all b) <= 1` for all `s`.  
- **Berth time capacity:** Total time at berth `b` cannot exceed `H`:  
  `sum(time(s) * x(s, b) for all s) <= 8.7` for all `b`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
ships_data = {'S1': {'time': 2.9, 'profit': 495}, 'S2': {'time': 2.4, 'profit': 282}, 'S3': {'time': 0.8, 'profit': 494}, 'S4': {'time': 1.5, 'profit': 337}, 'S5': {'time': 2.1, 'profit': 393}, 'S6': {'time': 1.6, 'profit': 442}, 'S7': {'time': 1.2, 'profit': 170}, 'S8': {'time': 1.2, 'profit': 272}}
num_berths = 3; time_horizon = 8.7
ship_ids = ['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8']; berth_ids = [0, 1, 2]
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m9 = gp.Model("Berth_Scheduling_MIP", env=env)
    # Vars
    x = m9.addVars(ship_ids, berth_ids, vtype=GRB.BINARY, name="assign")
    # Objective
    m9.setObjective(gp.quicksum(x[s, b] * ships_data[s]['profit'] for s in ship_ids for b in berth_ids), sense=GRB.MAXIMIZE)
    # Constraints
    for s in ship_ids: m9.addConstr(gp.quicksum(x[s, b] for b in berth_ids) <= 1, f"ship_{s}_assignment")
    for b in berth_ids: m9.addConstr(gp.quicksum(x[s, b] * ships_data[s]['time'] for s in ship_ids) <= time_horizon, f"berth_{b}_time_capacity")
    # Optimize
    m9.optimize()
    # Store results
    results_dict['status'] = m9.status
    if m9.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m9.objVal; results_dict['x_sol'] = m9.getAttr('X', x)
    # Output Results
    print("--- Problem 9: Berth Scheduling (MIP) ---")
    if m9.status == GRB.OPTIMAL:
        print(f"Optimization Status: Optimal"); print(f"Maximum total profit: ${m9.objVal:.2f}"); print("Assignments:")
        x_sol = results_dict.get('x_sol', {}); total_time_berth = [0.0] * num_berths; served_ships = []
        for s in ship_ids:
            for b in berth_ids:
                if x_sol.get((s, b), 0) > 0.5:
                    print(f"  Ship {s} (Time: {ships_data[s]['time']} hrs, Profit: ${ships_data[s]['profit']}) assigned to Berth {b+1}")
                    total_time_berth[b] += ships_data[s]['time']; served_ships.append(s)
        print("Berth Utilization:");
        for b in berth_ids: print(f"  Berth {b+1}: Total time used = {total_time_berth[b]:.1f} / {time_horizon} hours")
        print("Unserved ships:", [s for s in ship_ids if s not in served_ships])
    else: print(f"Optimization Status: {m9.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of BERTH_SCHEDULING
```
Answer:
--- Problem 9: Berth Scheduling (MIP) ---
Optimization Status: Optimal
Maximum total profit: $2885.00
Assignments:
  Ship S1 (Time: 2.9 hrs, Profit: $495) assigned to Berth 1
  Ship S2 (Time: 2.4 hrs, Profit: $282) assigned to Berth 1
  Ship S3 (Time: 0.8 hrs, Profit: $494) assigned to Berth 1
  Ship S4 (Time: 1.5 hrs, Profit: $337) assigned to Berth 1
  Ship S5 (Time: 2.1 hrs, Profit: $393) assigned to Berth 2
  Ship S6 (Time: 1.6 hrs, Profit: $442) assigned to Berth 2
  Ship S7 (Time: 1.2 hrs, Profit: $170) assigned to Berth 2
  Ship S8 (Time: 1.2 hrs, Profit: $272) assigned to Berth 2
Berth Utilization:
  Berth 1: Total time used = 7.6 / 8.7 hours
  Berth 2: Total time used = 6.1 / 8.7 hours
  Berth 3: Total time used = 0.0 / 8.7 hours
Unserved ships: []



================================================================================



--- Problem 253 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
During a major traffic incident, highway authorities must dynamically adjust toll prices on an alternate route to manage congestion. The main highway, with a normal capacity of 6,068 vehicles per hour, is temporarily reduced to 2,690 vehicles per hour due to the incident. Meanwhile, a parallel toll road with a fixed capacity of 3,153 vehicles per hour offers drivers a faster but paid alternative. The initial demand consists of 4,695 vehicles preferring the main road and 506 opting for the toll road.  

The toll price directly influences driver behavior: reducing the toll below the normal price of $4.87 attracts more vehicles to the toll road at a rate of 146 additional vehicles per dollar decrease. However, the toll road’s capacity cannot be exceeded. The goal is to minimize total system delay, accounting for both queueing delays on the congested main road (if demand exceeds reduced capacity) and the extra travel time on the toll road.  

Six pricing options are evaluated: $0.00, $1.00, $2.00, $3.00, $4.00, and $5.00. The critical question is: **What toll price minimizes the combined delay across both roads during the incident?**

Additionally, it is noted that the weather conditions are expected to be rainy, which may affect the driving behavior of some drivers, but this does not impact the optimization model or the results.
---

**

Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable \( y_p \) for each price option \( p \in \{0.0, 1.0, 2.0, 3.0, 4.0, 5.0\} \), where \( y_p = 1 \) if price \( p \) is selected, and \( 0 \) otherwise.  

**2. Parameters:**  
- \( C_{\text{main\_norm}} = 6,068.20 \): Main road normal capacity (veh/h).  
- \( C_{\text{main\_red}} = 2,689.94 \): Main road reduced capacity during incident (veh/h).  
- \( C_{\text{toll}} = 3,152.91 \): Toll road capacity (veh/h).  
- \( \lambda_{\text{demand\_main}} = 4,694.92 \): Initial main road demand (veh/h).  
- \( \lambda_{\text{toll}} = 505.54 \): Initial toll road demand (veh/h).  
- \( T_{\text{inc}} = 2.19 \): Incident duration (hours).  
- \( T_{\text{extra\_toll}} = 0.078 \): Additional travel time on toll road (hours/veh).  
- \( \text{Flow\_increase\_per\_dollar} = 146.25 \): Additional toll road demand per $1 price reduction (veh/h).  

**3. Objective Function:**  
Minimize total system delay:  
\[ \text{Minimize: } \sum_{p} y_p \cdot \text{delay}_p \]  
where \( \text{delay}_p \) is the total delay (vehicle-hours) for price option \( p \), calculated as:  
- If main road demand \( \lambda_{\text{main}} > C_{\text{main\_red}} \), queueing delay is \( 0.5 \times (\lambda_{\text{main}} - C_{\text{main\_red}}) \times T_{\text{inc}} \times (T_{\text{inc}} + t_{\text{diss}}) \), where \( t_{\text{diss}} \) is queue dissipation time.  
- Toll delay is \( \lambda_{\text{toll\_effective}} \times T_{\text{inc}} \times T_{\text{extra\_toll}} \).  

**4. Constraints:**  
- Select exactly one price: \( \sum_{p} y_p = 1 \).  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
C_main_norm = 6068.201490171625
C_main_red = 2689.9408777899894
lambda_demand_main_initial = 4694.922144406603
C_toll = 3152.9055618876446
T_extra_toll_h = 0.07803548129710354
Price_norm = 4.868316874892549
lambda_toll_initial = 505.5395543623528
T_inc_h = 2.188271427321485
Flow_increase_per_dollar = 146.24848808295621
Price_options = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]

Lambda_total = lambda_demand_main_initial + lambda_toll_initial

# --- Calculate total delay for each price option ---
option_delays = {}
print("--- System Delay Calculation per Toll Price Option ---")

for p in Price_options:
    price_decrease = Price_norm - p
    flow_increase_expected = price_decrease * Flow_increase_per_dollar
    lambda_toll_expected = lambda_toll_initial + flow_increase_expected

    # Effective toll flow considering capacity
    lambda_toll_effective = min(lambda_toll_expected, C_toll)

    # Remaining flow on main road
    lambda_main = Lambda_total - lambda_toll_effective

    # Calculate delays
    # Toll road delay (extra travel time only)
    delay_toll = lambda_toll_effective * T_inc_h * T_extra_toll_h

    # Main road queueing delay
    delay_main = 0
    q_max = 0
    t_diss = float('nan')
    if lambda_main > C_main_red:
        q_max = (lambda_main - C_main_red) * T_inc_h
        dissipation_rate = C_main_norm - lambda_main
        if dissipation_rate > 1e-6:
            t_diss = q_max / dissipation_rate
            delay_main = 0.5 * q_max * (T_inc_h + t_diss)
        else:
            delay_main = float('inf') # Queue doesn't dissipate naturally
    else:
         delay_main = 0 # No queue forms

    total_delay = delay_main + delay_toll if delay_main != float('inf') else float('inf')
    option_delays[p] = total_delay

    print(f" Price=${p:.2f}: TollFlow={lambda_toll_effective:.0f}, MainFlow={lambda_main:.0f} -> MainDelay={delay_main:.2f}, TollDelay={delay_toll:.2f} => Total={total_delay:.2f}")

# --- Gurobi Model (Select best price) ---
model = gp.Model("DynamicTollPricingIncident")

# --- Decision Variables ---
y = model.addVars(Price_options, vtype=GRB.BINARY, name="ChoosePrice")

# --- Constraints ---
model.addConstr(gp.quicksum(y[p] for p in Price_options) == 1, name="SelectOnePrice")

# --- Objective Function ---
# Minimize total system delay. Handle infinite delay case (e.g., assign large penalty).
objective = gp.LinExpr()
for p in Price_options:
    cost = option_delays[p]
    if cost == float('inf'):
        cost = 1e12 # Assign large finite cost for infeasible/non-dissipating scenarios
    objective += y[p] * cost

model.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    chosen_price = -1.0
    for p in Price_options:
        if y[p].X > 0.9:
            chosen_price = p
            break

    if chosen_price >= 0:
         print(f"Optimal Toll Price: ${chosen_price:.2f}")
         # Handle displaying infinite delay if that was the "optimal" outcome
         min_delay_val = model.objVal
         if min_delay_val >= 1e11: # Check if the large penalty was chosen
              print(f" Minimum Total System Delay: Infinite (or very large due to non-dissipating queues)")
         else:
              print(f" Minimum Total System Delay: {model.objVal:.2f} vehicle-hours")
    else:
         print("Error: No price selected.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- System Delay Calculation per Toll Price Option ---
 Price=$0.00: TollFlow=1218, MainFlow=3983 -> MainDelay=5015.36, TollDelay=207.91 => Total=5223.27
 Price=$1.00: TollFlow=1071, MainFlow=4129 -> MainDelay=6003.71, TollDelay=182.93 => Total=6186.64
 Price=$2.00: TollFlow=925, MainFlow=4275 -> MainDelay=7153.30, TollDelay=157.96 => Total=7311.26
 Price=$3.00: TollFlow=779, MainFlow=4422 -> MainDelay=8507.12, TollDelay=132.99 => Total=8640.10
 Price=$4.00: TollFlow=633, MainFlow=4568 -> MainDelay=10124.88, TollDelay=108.01 => Total=10232.89
 Price=$5.00: TollFlow=486, MainFlow=4714 -> MainDelay=12092.11, TollDelay=83.04 => Total=12175.15
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 6 columns and 6 nonzeros
Model fingerprint: 0x66266786
Variable types: 0 continuous, 6 integer (6 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [5e+03, 1e+04]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 5223.2692298
Presolve removed 1 rows and 6 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 1: 5223.27 

Optimal solution found (tolerance 1.00e-04)
Best objective 5.223269229827e+03, best bound 5.223269229827e+03, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Toll Price: $0.00
 Minimum Total System Delay: 5223.27 vehicle-hours



================================================================================



--- Problem 254 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy distribution center, four trucks arrive at different times, each requiring a single depot for unloading and processing. The logistics manager faces the challenge of scheduling these trucks to minimize total tardiness—the amount of time each truck completes its processing beyond its due time. The trucks, numbered 1 through 4, arrive at hours 3, 7, 11, and 16, respectively. Their processing times vary: Truck 1 takes 8 hours, Truck 2 takes 3 hours, Truck 3 takes 8 hours, and Truck 4 takes 5 hours. Each truck has a strict due time: Truck 1 by hour 18, Truck 2 by hour 14, Truck 3 by hour 34, and Truck 4 by hour 26. With only one depot available, the manager must sequence the trucks carefully to avoid overlaps while ensuring that tardiness is minimized. The core question is: What is the optimal schedule that ensures the sum of all tardiness across trucks is as small as possible?
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary variable indicating whether truck `i` is assigned to depot `j` (always 1 here, since there's only one depot).  
   - `start_time[i]`: Continuous variable representing the start time of truck `i` on the depot.  
   - `completion_time[i]`: Continuous variable representing the completion time of truck `i` (start time + processing time).  
   - `precedes[i, k, j]`: Binary variable indicating whether truck `i` precedes truck `k` on depot `j`.  
   - `tardiness[i]`: Continuous variable representing the tardiness of truck `i` (max(0, completion_time[i] - due_time[i])).  

   **2. Parameters:**  
   - `trucks = [1, 2, 3, 4]`: List of trucks.  
   - `depots = [1]`: Single depot available.  
   - `arrival_times = {1: 3, 2: 7, 3: 11, 4: 16}`: Arrival times for each truck.  
   - `processing_times = {1: 8, 2: 3, 3: 8, 4: 5}`: Processing times for each truck.  
   - `due_times = {1: 18, 2: 14, 3: 34, 4: 26}`: Due times for each truck.  
   - `H = 100`: A large constant (Big M) for constraint formulation.  

   **3. Objective Function:**  
   Minimize the total tardiness:  
   `Minimize: sum(tardiness[i] for i in trucks)`  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to the single depot:  
     `For each i in trucks: assign[i, 1] = 1`  
   - **Arrival Time:** A truck cannot start processing before its arrival time:  
     `For each i in trucks: start_time[i] >= arrival_times[i]`  
   - **Completion Time:** Completion time is start time plus processing time:  
     `For each i in trucks: completion_time[i] = start_time[i] + processing_times[i]`  
   - **Non-Overlapping:** Only one truck can use the depot at a time. For any two trucks `i` and `k` (where `i < k`), one must precede the other:  
     - If `precedes[i, k, 1] = 1`, then `start_time[k] >= completion_time[i]`.  
     - If `precedes[i, k, 1] = 0`, then `start_time[i] >= completion_time[k]`.  
   - **Tardiness Definition:** Tardiness is the excess of completion time over due time:  
     `For each i in trucks: tardiness[i] >= completion_time[i] - due_times[i]`  
     `For each i in trucks: tardiness[i] >= 0`  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4]
depots = [1] # Should be [1]
arrival_times = {1: 3, 2: 7, 3: 11, 4: 16}
processing_times = {1: 8, 2: 3, 3: 8, 4: 5}
due_times = {1: 18, 2: 14, 3: 34, 4: 26}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_54_MIN_TARDINESS")

    if not trucks or not depots or len(depots)!=1: raise ValueError("Invalid trucks/depots")
    the_depot = depots[0]

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign") # Trivial but keep
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    tardiness = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="tardiness")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(tardiness[i] for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_depot] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (on the single depot) using Indicators
    j = the_depot
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                # Link precedence var: if both assigned (always true), one must precede
                m.addConstr(precedes[i,k,j] + (1-precedes[i,k,j]) == 1, name=f"link_prec_{i}_{k}_{j}") # Enforce binary explicitly

    # 5. Tardiness definition
    m.addConstrs((tardiness[i] >= completion_time[i] - due_times.get(i, 0) for i in trucks), name="tardiness_calc")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Tardiness
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Schedule:")
    for i in trucks:
        print(f"Truck {i}: Start Time = {start_time[i].x:.2f}, Completion Time = {completion_time[i].x:.2f}, Tardiness = {tardiness[i].x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
0.0000
Optimal Schedule:
Truck 1: Start Time = 10.00, Completion Time = 18.00, Tardiness = 0.00
Truck 2: Start Time = 7.00, Completion Time = 10.00, Tardiness = 0.00
Truck 3: Start Time = 26.00, Completion Time = 34.00, Tardiness = 0.00
Truck 4: Start Time = 21.00, Completion Time = 26.00, Tardiness = 0.00


```

================================================================================



--- Problem 255 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port authority is tasked with efficiently scheduling 28 ships of varying sizes into the fewest possible berths, each with a maximum capacity of 28 units. The ships, with sizes [9, 25, 8, 2, 9, 28, 25, 17, 8, 10, 1, 19, 4, 3, 27, 6, 28, 16, 12, 7, 4, 14, 4, 26, 18, 27, 11, 5], must be allocated such that no berth exceeds its capacity. The challenge lies in minimizing the number of berths used while ensuring every ship is assigned to exactly one berth. This problem mirrors real-world scenarios like port operations, where efficient use of berthing space directly impacts operational costs. The key question is: *What is the most efficient way to schedule all ships while using the fewest berths possible?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether ship `i` is assigned to berth `j` (1 if assigned, 0 otherwise).  
   - `y[j]`: Binary variable indicating whether berth `j` is used (1 if used, 0 otherwise).  

   **2. Parameters:**  
   - `ships[i]`: Size of ship `i` (given list).  
   - `capacity`: Maximum size per berth (28 units).  
   - `num_ships`: Total ships (28).  
   - `num_berths`: Maximum possible berths (28, one per ship).  

   **3. Objective Function:**  
   Minimize the total number of berths used:  
   \[
   \text{Minimize: } \sum_{j=1}^{\text{num\_berths}} y[j]
   \]  

   **4. Constraints:**  
   - **Ship Assignment:** Each ship must be assigned to exactly one berth:  
     \[
     \sum_{j=1}^{\text{num\_berths}} x[i, j] = 1 \quad \forall i \in \{1, \dots, \text{num\_ships}\}
     \]  
   - **Berth Capacity:** The total size in any used berth `j` must not exceed its capacity:  
     \[
     \sum_{i=1}^{\text{num\_ships}} \text{ships}[i] \cdot x[i, j] \leq \text{capacity} \cdot y[j] \quad \forall j \in \{1, \dots, \text{num\_berths}\}
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB

# --- Data Definition ---
ships = [9, 25, 8, 2, 9, 28, 25, 17, 8, 10, 1, 19, 4, 3, 27, 6, 28, 16, 12, 7, 4, 14, 4, 26, 18, 27, 11, 5]      # Sizes of ships
capacity = 28           # Berth capacity
num_ships = 28     # len(ships) - Corrected from original template
num_berths = num_ships    # Maximum number of berths (worst case: one ship per berth)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Time limit
# env.setParam('TimeLimit', 30)
env.start()

# Create Model
model = Model("Berth Scheduling Problem", env=env)

# --- Decision Variables ---
# x[i,j]: ship i is assigned to berth j
x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")

# --- Objective: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)

# --- Constraints ---
# 1. Each ship must be assigned to exactly one berth
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Berth capacity constraint: sum of sizes in berth j <= capacity IF berth j is used (y[j]=1)
for j in range(num_berths):
    model.addConstr(gp.quicksum(ships[i] * x[i, j] for i in range(num_ships)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

# --- Solve ---
print("Solving Berth Scheduling instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print(f"\nOptimal number of berths used: {optimal_berths}")
    print("-" * 30)
    berth_details = []
    for j_sol in range(num_berths): # Loop through potential berths
        # Check if the berth variable y[j_sol] exists and is set to 1
        # Using .X requires Gurobi v9+ and that the variable is in the solution
        try:
            if y[j_sol].X > 0.5: # Check if berth j_sol is used
                # Find ships assigned to this berth j_sol
                # ***** CORRECTED LINE BELOW *****
                assigned_ships_indices = [i for i in range(num_ships) if x[i, j_sol].X > 0.5]
                # ***** END OF CORRECTION *****

                assigned_ships_sizes = [ships[i] for i in assigned_ships_indices]
                berth_load = sum(assigned_ships_sizes)
                print(f"Berth {j_sol + 1} (Load: {berth_load}/{capacity}): Ships (indices): {assigned_ships_indices}")
                # Optional: Print sizes too
                # print(f"  Sizes: {assigned_ships_sizes}")
                berth_details.append({'berth_index': j_sol, 'ship_indices': assigned_ships_indices, 'load': berth_load})
        except AttributeError:
            # This might happen if y[j_sol] was optimized to 0 and doesn't have an .X value
            # Or if the model was infeasible/not solved optimally.
            # Since we check for OPTIMAL status first, this is less likely for y,
            # but could happen if x[i, j_sol] is 0. The check x[i,j_sol].X > 0.5 handles this.
            pass # Just skip if variable/attribute doesn't exist for unused berths/ships
    results_dict['berth_details'] = berth_details # Store details
    print("-" * 30)

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount to see if a feasible solution was found
     if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
     else: print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")


```
Answer:
Solving Berth Scheduling instance...

Optimal number of berths used: 14
------------------------------
Berth 1 (Load: 28/28): Ships (indices): [7, 19, 20]
Berth 2 (Load: 25/28): Ships (indices): [11, 15]
Berth 3 (Load: 27/28): Ships (indices): [25]
Berth 4 (Load: 19/28): Ships (indices): [13, 17]
Berth 7 (Load: 28/28): Ships (indices): [16]
Berth 12 (Load: 28/28): Ships (indices): [0, 12, 22, 26]
Berth 15 (Load: 28/28): Ships (indices): [2, 8, 18]
Berth 20 (Load: 28/28): Ships (indices): [9, 24]
Berth 21 (Load: 27/28): Ships (indices): [14]
Berth 23 (Load: 25/28): Ships (indices): [1]
Berth 24 (Load: 28/28): Ships (indices): [4, 21, 27]
Berth 25 (Load: 28/28): Ships (indices): [3, 23]
Berth 26 (Load: 26/28): Ships (indices): [6, 10]
Berth 28 (Load: 28/28): Ships (indices): [5]
------------------------------



================================================================================



--- Problem 256 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port authority is facing a critical challenge with two ship berthing incidents, labeled A and B, occurring at different times, disrupting normal port operations. Incident A occurs at time 0 minutes, while Incident B occurs at 6 minutes. The port has two tugboats, T1 and T2, each with varying travel times to the incidents. For example, T1 takes 20 minutes to reach Incident A and 14 minutes to reach Incident B, while T2 takes 25 minutes to reach Incident A and 16 minutes to reach Incident B. Once an incident is cleared, tugboats may need to travel between incidents, with travel times like 25 minutes from A to B and 12 minutes from B to A.

The incidents have different clearance times: 30 minutes for Incident A and 46 minutes for Incident B. Port operations are also affected, with normal capacities of approximately 98.97 containers per minute for Incident A and 42.63 containers per minute for Incident B. During incidents, these capacities drop to 58.57 and 23.33 containers per minute, respectively. Meanwhile, containers arrive at rates of 43.85 and 33.82 containers per minute for Incidents A and B, leading to potential queue buildup if not addressed promptly.

The core challenge is to assign tugboats to incidents and sequence their responses to minimize the total delay caused by port congestion. The delay is calculated based on the queue growth before clearance, during clearance, and the time required to dissipate the queue afterward. The optimization must account for all these factors while ensuring logical constraints, such as each incident being assigned exactly one tugboat (either directly or after another incident) and no tugboat being assigned to more than one incident at a time.

The central question is: What is the optimal assignment and sequencing of tugboats to incidents to minimize the total delay caused by port congestion?

---

**

Modeling Process:**
**
**1. Decision Variables:**
- `assign_first(k, i)`: Binary variable indicating whether tugboat `k` is assigned to incident `i` as its first task.
- `sequence(k, j, i)`: Binary variable indicating whether tugboat `k` moves from incident `j` to incident `i`.
- `start_clear(i)`: Continuous variable representing the time when clearance begins at incident `i`.
- `end_clear(i)`: Continuous variable representing the time when clearance ends at incident `i`.
- `queue_at_start_clear(i)`: Continuous variable representing the queue size at the start of clearance for incident `i`.
- `queue_at_clear_end(i)`: Continuous variable representing the queue size at the end of clearance for incident `i`.
- `dissipation_time(i)`: Continuous variable representing the time required to dissipate the queue after clearance for incident `i`.

**2. Parameters:**
- `time_occur(i)`: Time when incident `i` occurs (A: 0, B: 6).
- `travel_time_base(k, i)`: Time for tugboat `k` to reach incident `i` directly (e.g., T1 to A: 20).
- `travel_time_inter(j, i)`: Time to travel from incident `j` to `i` (e.g., A to B: 25).
- `clearance_time(i)`: Time to clear incident `i` (A: 30, B: 46).
- `growth_rate_before(i)`: Queue growth rate before clearance (arrival rate minus reduced capacity).
- `dissipation_rate(i)`: Queue dissipation rate after clearance (normal capacity minus arrival rate).
- `can_dissipate(i)`: Boolean indicating whether the queue can dissipate (dissipation rate > 0).
- `inv_dissipation_rate(i)`: Inverse of dissipation rate if dissipation is possible, else 0.
- `non_dissipating_penalty`: Large penalty (10000) for queues that cannot dissipate.

**3. Objective Function:**
Minimize the total delay, which includes:
- Delay before clearance: `0.5 * growth_rate_before(i) * (start_clear(i) - time_occur(i))^2`.
- Delay during clearance: `0.5 * (queue_at_start_clear(i) + queue_at_clear_end(i)) * clearance_time(i)`.
- Delay after clearance: `0.5 * inv_dissipation_rate(i) * queue_at_clear_end(i)^2` (if dissipation is possible), else `non_dissipating_penalty * queue_at_clear_end(i)`.

**4. Constraints:**
- Each incident must be assigned exactly one tugboat (either directly or after another incident).
- Each tugboat can be assigned to at most one incident as its first task.
- Sequencing logic: if a tugboat moves from incident `j` to `i`, it must have been assigned to `j` first.
- No self-loops or immediate loops in tugboat sequences.
- Start and end clearance times must respect travel times and clearance durations.
- Queue sizes and dissipation times are calculated based on growth and dissipation rates.

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
incidents = ['A', 'B']
tugboats = ['T1', 'T2']

# Times in minutes from simulation start
time_occur = {'A': 0, 'B': 6}
travel_time_base = {('T1', 'A'): 20, ('T1', 'B'): 14, ('T2', 'A'): 25, ('T2', 'B'): 16}
travel_time_inter = {('A', 'B'): 25, ('B', 'A'): 12, ('A', 'A'): 0, ('B', 'B'): 0}
clearance_time = {'A': 30, 'B': 46}

# Capacities and Arrival rates (containers per minute)
cap_normal = {'A': 5938/60, 'B': 2558/60} # cont/min
cap_reduced = {'A': 3514/60, 'B': 1400/60} # cont/min
arrival_rate = {'A': 2631/60, 'B': 2029/60} # cont/min

M = 10000
EPSILON = 1e-6

# Pre-calculate rates
growth_rate_before = {}
dissipation_rate = {}
can_dissipate = {}
inv_dissipation_rate = {}
non_dissipating_penalty = 10000

for i in incidents:
    growth_rate_before[i] = max(0, arrival_rate[i] - cap_reduced[i])
    dissipation_rate[i] = cap_normal[i] - arrival_rate[i]
    can_dissipate[i] = dissipation_rate[i] > EPSILON
    if not can_dissipate[i]:
        inv_dissipation_rate[i] = 0
    else:
        inv_dissipation_rate[i] = 1.0 / dissipation_rate[i]

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("IncidentResourceAllocation", env=env)

# --- Decision Variables ---
assign_first = m.addVars(tugboats, incidents, vtype=GRB.BINARY, name="assign_first")
sequence = m.addVars(tugboats, incidents, incidents, vtype=GRB.BINARY, name="sequence")

# Timing variables
start_clear = m.addVars(incidents, name="start_clear", lb=0.0)
end_clear = m.addVars(incidents, name="end_clear", lb=0.0)

# Queue and Delay related variables
queue_start_clear_time_diff = m.addVars(incidents, name="queue_start_clear_time_diff", lb=0.0)
queue_at_start_clear = m.addVars(incidents, name="queue_at_start_clear", lb=0.0)
aux_q_start = m.addVars(incidents, name="aux_q_start", lb=-GRB.INFINITY)
queue_at_clear_end = m.addVars(incidents, name="queue_at_clear_end", lb=0.0)
aux_q_end = m.addVars(incidents, name="aux_q_end", lb=-GRB.INFINITY)
dissipation_time = m.addVars(incidents, name="dissipation_time", lb=0.0)

# --- Constraints ---
for i in incidents:
    m.addConstr(gp.quicksum(assign_first[k, i] for k in tugboats) +
                gp.quicksum(sequence[k, j, i] for k in tugboats for j in incidents if i != j) == 1,
                name="AssignIncident_{0}".format(i))

for k in tugboats:
    m.addConstr(gp.quicksum(assign_first[k, i] for i in incidents) <= 1, name="TugboatStart_{0}".format(k))

for k in tugboats:
    for i in incidents:
        tugboat_served_i = assign_first[k, i] + gp.quicksum(sequence[k, l, i] for l in incidents if l != i)
        m.addConstr(gp.quicksum(sequence[k, i, j] for j in incidents if i != j) <= tugboat_served_i,
                    name="SequenceLogic_{0}_{1}".format(k, i))
        m.addConstr(sequence[k,i,i] == 0, name="NoSelfLoop_{0}_{1}".format(k, i))
        for j in incidents:
             if i != j:
                  m.addConstr(sequence[k,i,j] + sequence[k,j,i] <= 1, name="NoImmediateLoop_{0}_{1}_{2}".format(k, i, j))

for k in tugboats:
    for i in incidents:
        m.addConstr(start_clear[i] >= time_occur[i] + travel_time_base[k, i] - M * (1 - assign_first[k, i]),
                    name="StartTimeFirst_{0}_{1}".format(k, i))
        for j in incidents:
            if i != j:
                m.addConstr(start_clear[i] >= end_clear[j] + travel_time_inter[j, i] - M * (1 - sequence[k, j, i]),
                            name="StartTimeFollow_{0}_{1}_{2}".format(k, j, i))

for i in incidents:
    m.addConstr(end_clear[i] == start_clear[i] + clearance_time[i], name="EndClearTime_{0}".format(i))
    m.addConstr(start_clear[i] >= time_occur[i], name="StartAfterOccur_{0}".format(i))

for i in incidents:
    m.addConstr(queue_start_clear_time_diff[i] >= start_clear[i] - time_occur[i], name="CalcTimeDiff_{0}".format(i))
    m.addConstr(aux_q_start[i] == growth_rate_before[i] * queue_start_clear_time_diff[i], name="CalcAuxQStart_{0}".format(i))
    m.addGenConstrMax(queue_at_start_clear[i], [aux_q_start[i]], 0.0, name="SetQStartMax_{0}".format(i))
    queue_growth_during_clearance = growth_rate_before[i] * clearance_time[i]
    m.addConstr(aux_q_end[i] == queue_at_start_clear[i] + queue_growth_during_clearance, name="CalcAuxQEnd_{0}".format(i))
    m.addGenConstrMax(queue_at_clear_end[i], [aux_q_end[i]], 0.0, name="SetQEndMax_{0}".format(i))
    if can_dissipate[i]:
         m.addConstr(dissipation_time[i] == queue_at_clear_end[i] * inv_dissipation_rate[i], name="CalcDissipationTime_{0}".format(i))
    else:
         m.addConstr(dissipation_time[i] == 0, name="SetDissipationTimeZero_{0}".format(i))

# --- Objective Function ---
objective = gp.QuadExpr()
for i in incidents:
    delay_before = 0.5 * growth_rate_before[i] * queue_start_clear_time_diff[i] * queue_start_clear_time_diff[i]
    objective += delay_before
    delay_during = 0.5 * (queue_at_start_clear[i] + queue_at_clear_end[i]) * clearance_time[i]
    objective += delay_during
    if can_dissipate[i]:
        delay_dissipation = 0.5 * inv_dissipation_rate[i] * queue_at_clear_end[i] * queue_at_clear_end[i]
        objective += delay_dissipation
    else:
        objective += non_dissipating_penalty * queue_at_clear_end[i]

m.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("{0:.2f}".format(m.objVal))
elif m.status == GRB.INFEASIBLE:
    print("Infeasible")
elif m.status == GRB.UNBOUNDED:
    print("Unbounded")
```
Answer:
41307.11



================================================================================



--- Problem 257 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
At a busy urban intersection, traffic signals cycle through phases to manage the flow of vehicles efficiently. The cycle lasts **97.48 seconds**, with **41.93 seconds** allocated to the main road's green phase and **49.47 seconds** to the side road's green phase. Between these phases, a total of **10 seconds** is lost to transition times, split equally between the two directions. An emergency vehicle (EV) arrives at **56.70 seconds** into the cycle, requiring **10.98 seconds** to pass through the intersection. The challenge is to decide whether to preempt the normal signal operation to prioritize the EV or let it wait for the next green phase.  

The decision hinges on balancing two competing costs: the **delay to the EV** (weighted at **10.53** per second) and the **estimated increase in general traffic delay** (weighted at **0.93** per vehicle-second). If no preemption is applied, the EV must wait until the next main green phase, incurring a delay. If preemption is triggered, the EV passes immediately, but general traffic faces disruptions, estimated to add **500 vehicle-seconds** of delay. The core question is: **Which strategy—preemption or no preemption—minimizes the total weighted cost of delays?**

Additionally, the weather conditions are currently clear, and there are no other special events or roadworks that might affect the traffic flow.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y(s)`: Binary variable indicating whether strategy `s` is chosen (`s ∈ {'NoPreemption', 'Preemption'}`).  

   - **2. Parameters:**  
     - `C_cycle = 97.48 s`: Total signal cycle duration.  
     - `T_ev_arrival = 56.70 s`: EV arrival time in the cycle.  
     - `T_ev_pass_duration = 10.98 s`: Time for EV to clear the intersection.  
     - `W_ev = 10.53`: Weight for EV delay.  
     - `W_gen = 0.93`: Weight for general traffic delay.  
     - `strategy_costs`: Precomputed costs for each strategy:  
       - `NoPreemption`: EV delay = **40.8 s**, general delay = **0 veh-s**, total cost = **429.23**.  
       - `Preemption`: EV delay = **0 s**, general delay = **500 veh-s**, total cost = **466.81**.  

   - **3. Objective Function:**  
     Minimize the total weighted cost:  
     `Minimize: y('NoPreemption') * 429.23 + y('Preemption') * 466.81`.  

   - **4. Constraints:**  
     - Exactly one strategy must be selected:  
       `y('NoPreemption') + y('Preemption') = 1`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
C_cycle = 97.48161012370227  # s
g_main_normal = 41.92568100352994  # s
g_side_normal = 49.468353745712626  # s
L_lost_time_total = C_cycle - g_main_normal - g_side_normal  # = 10s -> 5s per phase

# Assume phase sequence: Main Green -> Main L -> Side Green -> Side L
main_green_end = g_main_normal
main_lost_end = main_green_end + L_lost_time_total / 2.0
side_green_end = main_lost_end + g_side_normal
side_lost_end = C_cycle

# EV Arrival time
T_ev_arrival = 56.70204036872454  # seconds
T_ev_pass_duration = 10.98324346281584  # seconds
W_ev = 10.525532186026023  # Weight for EV delay
W_gen = 0.9336159742378001  # Weight for general traffic delay increase

strategies = ['NoPreemption', 'Preemption']

# --- Calculate Delays for each strategy ---
strategy_costs = {}
print("--- Cost Calculation per Strategy ---")

# Strategy N: No Preemption
ev_delay_N = 0
current_time_in_cycle = T_ev_arrival % C_cycle
if not (0 <= current_time_in_cycle < main_green_end):  # Check if EV arrives during main green
    # EV arrives during red or side green. Calculate wait time till next main green.
    time_to_next_main_green = C_cycle - current_time_in_cycle
    ev_delay_N = time_to_next_main_green
gen_delay_increase_N = 0  # Baseline
total_cost_N = ev_delay_N * W_ev + gen_delay_increase_N * W_gen
strategy_costs['NoPreemption'] = total_cost_N
print(f" Strategy 'NoPreemption':")
print(f"  EV arrives at {T_ev_arrival:.1f}s. Cycle pos: {current_time_in_cycle:.1f}s.")
print(f"  EV Delay = {ev_delay_N:.1f}s")
print(f"  General Traffic Delay Increase = {gen_delay_increase_N:.1f} veh*s (Baseline)")
print(f"  Total Weighted Cost = {total_cost_N:.2f}")

# Strategy P: Preemption
ev_delay_P = 0  # Preemption ensures green on arrival
# Estimate general traffic delay increase
lost_side_green = 0
if main_lost_end <= current_time_in_cycle < side_green_end:
     lost_side_green = side_green_end - current_time_in_cycle
# Main green gained: T_ev_pass_duration
gained_main_green = T_ev_pass_duration
# Estimate of delay impact
gen_delay_increase_P = 500.0  # Placeholder veh*s
total_cost_P = ev_delay_P * W_ev + gen_delay_increase_P * W_gen
strategy_costs['Preemption'] = total_cost_P
print(f" Strategy 'Preemption':")
print(f"  EV Delay = {ev_delay_P:.1f}s")
print(f"  Estimated General Traffic Delay Increase = {gen_delay_increase_P:.1f} veh*s")
print(f"  Total Weighted Cost = {total_cost_P:.2f}")

# --- Gurobi Model (Simple selection) ---
model = gp.Model("EV_Preemption_Choice")

# --- Decision Variables ---
y = model.addVars(strategies, vtype=GRB.BINARY, name="ChooseStrategy")

# --- Constraints ---
model.addConstr(gp.quicksum(y[s] for s in strategies) == 1, name="SelectOneStrategy")

# --- Objective Function ---
# Minimize the total weighted cost
objective = gp.quicksum(y[s] * strategy_costs[s] for s in strategies)
model.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    chosen_strategy = ""
    for s in strategies:
        if y[s].X > 0.9:
            chosen_strategy = s
            break

    if chosen_strategy:
         print(f"Optimal Preemption Strategy: {chosen_strategy}")
         print(f" Minimum Total Weighted Cost: {model.objVal:.2f}")
    else:
         print("Error: No strategy selected.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- Cost Calculation per Strategy ---
 Strategy 'NoPreemption':
  EV arrives at 56.7s. Cycle pos: 56.7s.
  EV Delay = 40.8s
  General Traffic Delay Increase = 0.0 veh*s (Baseline)
  Total Weighted Cost = 429.23
 Strategy 'Preemption':
  EV Delay = 0.0s
  Estimated General Traffic Delay Increase = 500.0 veh*s
  Total Weighted Cost = 466.81
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 2 columns and 2 nonzeros
Model fingerprint: 0xe2ef2941
Variable types: 0 continuous, 2 integer (2 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [4e+02, 5e+02]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 429.2266740
Presolve removed 1 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 1: 429.227 

Optimal solution found (tolerance 1.00e-04)
Best objective 4.292266739883e+02, best bound 4.292266739883e+02, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Preemption Strategy: NoPreemption
 Minimum Total Weighted Cost: 429.23



================================================================================



--- Problem 258 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
In a busy maritime port, the port authority faces a scheduling challenge: efficiently berthing a fleet of 10 cargo ships at 4 available berths to minimize the number of berths used while respecting strict arrival and processing timelines. Each ship arrives at a specific time (e.g., Ship 1 at time 4, Ship 2 at time 5) and requires a fixed processing duration (e.g., Ship 1 needs 5 units of time, Ship 2 needs 4). The goal is to optimize berth utilization, ensuring no two ships occupy the same berth simultaneously unless their schedules are non-overlapping. Additionally, the port authority wants to ensure that the total processing time for all ships is minimized. The core question is: *What is the minimum number of berths needed to accommodate all ships without conflicts, given their arrival and processing constraints, while also minimizing the total processing time?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary (1 if ship *i* is assigned to berth *j*, else 0).  
   - `start_time(i)`: Continuous (time when ship *i* begins processing).  
   - `completion_time(i)`: Continuous (time when ship *i* finishes).  
   - `precedes(i, k, j)`: Binary (1 if ship *i* is scheduled before ship *k* on berth *j*).  
   - `berth_used(j)`: Binary (1 if berth *j* is used, else 0).  

   **2. Parameters:**  
   - `ships`: [1, 2, ..., 10].  
   - `berths`: [1, 2, 3, 4].  
   - `arrival_times`: {1:4, 2:5, ..., 10:28}.  
   - `processing_times`: {1:5, 2:4, ..., 10:3}.  
   - `H=100`: A large constant for precedence constraints.  

   **3. Objective Function:**  
   Minimize the total berths used and the total processing time:  
   `Minimize: sum(berth_used[j] for j in berths) + sum(completion_time[i] for i in ships)`.  

   **4. Constraints:**  
   - Each ship assigned to exactly one berth:  
     `sum(assign[i,j] for j in berths) = 1` for all *i*.  
   - Start time ≥ arrival time:  
     `start_time[i] ≥ arrival_times[i]` for all *i*.  
   - Completion time = start time + processing time:  
     `completion_time[i] = start_time[i] + processing_times[i]` for all *i*.  
   - Precedence and non-overlapping on shared berths:  
     For each berth *j* and ships *i*, *k* (*i* < *k*):  
     - `precedes[i,k,j] + precedes[k,i,j] ≥ assign[i,j] + assign[k,j] - 1`.  
     - `precedes[i,k,j] + precedes[k,i,j] ≤ 1`.  
     - If `precedes[i,k,j] = 1`, then `start_time[k] ≥ completion_time[i]`.  
   - Berth usage linkage:  
     `assign[i,j] ≤ berth_used[j]` for all *i*, *j*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
berths = [1, 2, 3, 4]
arrival_times = {1: 4, 2: 5, 3: 6, 4: 11, 5: 13, 6: 14, 7: 16, 8: 20, 9: 24, 10: 28}
processing_times = {1: 5, 2: 4, 3: 5, 4: 3, 5: 7, 6: 4, 7: 6, 8: 4, 9: 5, 10: 3}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_52_MIN_BERTHS")

    if not ships or not berths: raise ValueError("Empty ships or berths")

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(ships, ships, berths, vtype=GRB.BINARY, name="precedes")
    berth_used = m.addVars(berths, vtype=GRB.BINARY, name="BerthUsed") # Objective var

    # --- Objective Function ---
    m.setObjective(gp.quicksum(berth_used[j] for j in berths) + gp.quicksum(completion_time[i] for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")

    # 5. Link BerthUsed to assignments
    m.addConstrs((assign[i, j] <= berth_used[j] for i in ships for j in berths), name="link_used_berth")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is number of berths, should be integer
             print(f"{int(round(obj_val_print))}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    print(f"Objective Value (Total Berths Used + Total Processing Time): {m.objVal}")
    print("Berth Assignments and Schedules:")
    for i in ships:
        for j in berths:
            if assign[i, j].x > 0.5:
                print(f"Ship {i} assigned to Berth {j}, Start Time: {start_time[i].x}, Completion Time: {completion_time[i].x}")
    print("Berths Used:")
    for j in berths:
        if berth_used[j].x > 0.5:
            print(f"Berth {j} is used.")
else:
    print(f"Optimization ended with status {m.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
190
Optimal Solution Found:
Objective Value (Total Berths Used + Total Processing Time): 190.0
Berth Assignments and Schedules:
Ship 1 assigned to Berth 1, Start Time: 4.0, Completion Time: 9.0
Ship 2 assigned to Berth 2, Start Time: 5.0, Completion Time: 9.0
Ship 3 assigned to Berth 4, Start Time: 6.0, Completion Time: 11.0
Ship 4 assigned to Berth 2, Start Time: 11.0, Completion Time: 14.0
Ship 5 assigned to Berth 1, Start Time: 13.0, Completion Time: 20.0
Ship 6 assigned to Berth 2, Start Time: 14.0, Completion Time: 18.0
Ship 7 assigned to Berth 4, Start Time: 16.0, Completion Time: 22.0
Ship 8 assigned to Berth 1, Start Time: 20.0, Completion Time: 24.0
Ship 9 assigned to Berth 4, Start Time: 24.0, Completion Time: 29.0
Ship 10 assigned to Berth 1, Start Time: 28.0, Completion Time: 31.0
Berths Used:
Berth 1 is used.
Berth 2 is used.
Berth 4 is used.


```

================================================================================



--- Problem 259 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy port operates two types of berths: automated and manual. The facility must efficiently manage ship flow while minimizing operational costs. On a typical day, 2,731 small ships and 145 large ships arrive. Data shows that 66% of small ships can use automated berths, while only 10% of large ships can use automated berths—though the current setup assumes all large ships must use manual berths.

Each automated berth processes 570 ships per hour at a cost of $7/hour, while manual berths handle 168 ships per hour at $31/hour. The port has 6 automated and 9 manual berths available. The challenge is to determine how many berths of each type to open to meet demand without exceeding capacity limits, all while keeping costs as low as possible.

The key question: *What is the most cost-effective combination of automated and manual berths to open, ensuring all ships are served without violating berth availability or processing constraints?*  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- `x_auto`: Integer number of automated berths to open (≥ 0).  
- `x_manual`: Integer number of manual berths to open (≥ 0).  

**2. Parameters:**  
- `auto_small_ships_arrival = 2731 * 0.66 = 1802.46` (automated-eligible small ships).  
- `non_auto_ships_manual = (2731 * 0.34) + 145 = 1074.54` (non-automated small ships + all large ships).  
- `service_rate_auto = 570` (ships/hour per automated berth).  
- `service_rate_manual = 168` (ships/hour per manual berth).  
- `cost_auto = $7/hour`, `cost_manual = $31/hour`.  
- `total_auto_berths = 6`, `total_manual_berths = 9` (maximum available).  

**3. Objective Function:**  
Minimize total cost:  
`Minimize: 7 * x_auto + 31 * x_manual`.  

**4. Constraints:**  
- Automated capacity: `570 * x_auto ≥ 1802.46` (automated small ships must be served).  
- Manual capacity: `168 * x_manual ≥ 1074.54` (non-automated small ships + large ships must be served).  
- Berth limits:  
  `x_auto ≤ 6`,  
  `x_manual ≤ 9`.  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
total_auto_berths = 6
total_manual_berths = 9
arrival_small_ships = 2731
arrival_large_ships = 145
auto_small_ship_ratio = 0.66
auto_large_ship_ratio = 0.10 # Note: Constraint logic assumes large ships go manual
service_rate_auto = 570
service_rate_manual = 168
cost_auto = 7
cost_manual = 31
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# --- Calculated Arrivals (Inside Template) ---
try:
    auto_small_ships_arrival = arrival_small_ships * auto_small_ship_ratio
    non_auto_small_ships_arrival = arrival_small_ships * (1.0 - auto_small_ship_ratio)
    # All large ships need processing capacity from manual berths in this setup
    # Correct interpretation: large ships that CAN use automated do, others go manual.
    # Let's stick to the user's example logic where auto_large_ship_ratio seems unused
    # and all large ships + non-automated small ships go manual
    non_auto_ships_manual = non_auto_small_ships_arrival + arrival_large_ships # All large ships + non-automated small ships

    # --- Model Creation ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    m2 = gp.Model("Port_Berth_Mix", env=env)

    # --- Decision Variables ---
    x_auto = m2.addVar(vtype=GRB.INTEGER, name="num_open_auto_berths", lb=0)
    x_manual = m2.addVar(vtype=GRB.INTEGER, name="num_open_manual_berths", lb=0)

    # --- Objective Function ---
    m2.setObjective(cost_auto * x_auto + cost_manual * x_manual, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # 1: Automated capacity for automated small ships
    m2.addConstr(service_rate_auto * x_auto >= auto_small_ships_arrival, name="auto_capacity")
    # 2: Manual capacity for non-automated small ships and all large ships
    m2.addConstr(service_rate_manual * x_manual >= non_auto_ships_manual, name="manual_capacity")
    # 3: Max available automated berths
    m2.addConstr(x_auto <= total_auto_berths, name="max_auto_berths")
    # 4: Max available Manual berths
    m2.addConstr(x_manual <= total_manual_berths, name="max_manual_berths")

    # --- Optimization ---
    m2.optimize()

    # --- Store results ---
    results_dict['status'] = m2.status
    if m2.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m2.objVal
        results_dict['x_auto_optimal'] = x_auto.X
        results_dict['x_manual_optimal'] = x_manual.X

    # --- Output Results (for capture) ---
    # Use original print format
    print("--- Problem 2: Port Berth Mix (Automated vs. Manual) ---")
    if m2.status == GRB.OPTIMAL:
        optimal_auto = results_dict.get('x_auto_optimal', 'N/A')
        optimal_manual = results_dict.get('x_manual_optimal', 'N/A')
        # Round before int() for safety
        if not isinstance(optimal_auto, (int, float)): optimal_auto = -1
        if not isinstance(optimal_manual, (int, float)): optimal_manual = -1

        print(f"Optimization Status: Optimal")
        print(f"Optimal number of Automated berths to open: {int(round(optimal_auto))}")
        print(f"Optimal number of Manual berths to open: {int(round(optimal_manual))}")
        print(f"Minimum total operational cost: ${m2.objVal:.2f}/hour")
        # Recalculate capacities for output clarity
        auto_cap_achieved = service_rate_auto * optimal_auto
        manual_cap_achieved = service_rate_manual * optimal_manual
        print(f"Automated Capacity: {auto_cap_achieved:.0f} >= {auto_small_ships_arrival:.0f}")
        print(f"Manual Capacity: {manual_cap_achieved:.0f} >= {non_auto_ships_manual:.0f}")
    elif m2.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible")
    else:
        print(f"Optimization Status: {m2.status}")

except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
--- Problem 2: Port Berth Mix (Automated vs. Manual) ---
Optimization Status: Optimal
Optimal number of Automated berths to open: 4
Optimal number of Manual berths to open: 7
Minimum total operational cost: $245.00/hour
Automated Capacity: 2280 >= 1802
Manual Capacity: 1176 >= 1074



================================================================================



--- Problem 260 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A port authority manages a dynamic berthing system across a network of 5 berths, each capable of processing up to 46 ships per designated time period. The system aims to balance ship arrivals by adjusting berthing fees in real-time, with three predefined fee levels: Level 1 charges $11 and attracts 124 expected arrivals, Level 2 charges $13 with 100 arrivals, and Level 3 charges $15 with 72 arrivals. The total throughput capacity across all berths is fixed at 230 ships per period. The primary challenge is to select the optimal berthing fee level that minimizes the resulting queue length—ensuring smooth traffic flow while maximizing revenue. The critical question is: *Which fee level should be activated to eliminate queues entirely, given the throughput constraints and arrival projections?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `y[r]` for each fee level `r` (1, 2, 3): `y[r] = 1` if fee `r` is selected, else `0`.  
     - Continuous variable `queue_length` (≥0): Represents the post-throughput queue length.  
   - **2. Parameters:**  
     - `arrivals_at_fee[r]`: Expected ship arrivals for fee `r` (124, 100, 72).  
     - `total_throughput`: Fixed system capacity (230 ships).  
   - **3. Objective Function:**  
     Minimize `queue_length`.  
   - **4. Constraints:**  
     - **Single-fee selection:** Exactly one fee level must be chosen: `sum(y[r] for r in {1,2,3}) = 1`.  
     - **Queue calculation:** `queue_length ≥ sum(arrivals_at_fee[r] * y[r] for r) - total_throughput`.  
     - Implicit non-negativity: `queue_length ≥ 0`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_berths = 5
berth_capacity_period = 46
total_throughput = 230
fees = {1: 11, 2: 13, 3: 15} # Fee level: price
arrivals_at_fee = {1: 124, 2: 100, 3: 72} # Fee level: expected arrivals
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("DYNAMIC_BERTHING", env=env)

    # --- Input Validation ---
    fee_keys = list(fees.keys())
    if not fee_keys: raise ValueError("No fee levels defined")

    # --- Decision Variables ---
    # y[r] = 1 if fee level r is chosen, 0 otherwise
    y = m.addVars(fee_keys, vtype=GRB.BINARY, name="ChooseFee")
    # queue_length: resulting queue length
    queue_length = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="QueueLength")

    # --- Objective Function: Minimize the queue length ---
    m.setObjective(queue_length, GRB.MINIMIZE)

    # --- Constraints ---
    # Exactly one fee must be chosen
    m.addConstr(gp.quicksum(y[r] for r in fee_keys) == 1, "SelectOneFee")

    # Calculate arrivals based on chosen fee
    current_arrivals = gp.quicksum(arrivals_at_fee.get(r, 0) * y[r] for r in fee_keys)

    # Queue length calculation: queue_length >= arrivals - throughput
    m.addConstr(queue_length >= current_arrivals - total_throughput, "QueueCalc")
    # lb=0 handles the max(0, ...) part

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['y_sol'] = m.getAttr('X', y) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Queue length
             print(f"Optimal objective value: {obj_val_print:.1f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]: # Should always be feasible
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the selected fee level
if m.Status == GRB.OPTIMAL:
    for r in fee_keys:
        if y[r].X > 0.5:
            print(f"Selected fee level: {r} (Fee: ${fees[r]}, Arrivals: {arrivals_at_fee[r]})")
```
Answer:
Optimal objective value: 0.0
Selected fee level: 1 (Fee: $11, Arrivals: 124)


```

================================================================================



--- Problem 261 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy logistics hub, three delivery trucks—Truck 1, Truck 2, and Truck 3—arrive at staggered times, each requiring immediate unloading at one of the available depots. The hub has three depots, but the challenge lies in scheduling the trucks efficiently to minimize the total time taken to service all vehicles (known as the *makespan*). Truck 1 arrives at time 2 and takes 3 hours to unload, Truck 2 arrives at time 5 and also requires 3 hours, while Truck 3, arriving at time 9, needs a longer 6-hour window. The hub manager must assign each truck to exactly one depot, ensuring no two trucks occupying the same depot overlap in time. The goal is to determine the optimal assignment and start times for each truck to complete all operations as early as possible, balancing arrival delays and processing constraints.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to depot *j*, 0 otherwise).  
     - `start_time(i)`: Continuous variable representing the start time of truck *i*.  
     - `completion_time(i)`: Continuous variable representing the completion time of truck *i* (start time + processing time).  
     - `precedes(i, k, j)`: Binary variable (1 if truck *i* precedes truck *k* on depot *j*, 0 otherwise).  
     - `makespan`: Continuous variable representing the latest completion time across all trucks.  

   - **2. Parameters:**  
     - `trucks = [1, 2, 3]`, `depots = [1, 2, 3]`.  
     - `arrival_times = {1: 2, 2: 5, 3: 9}` (earliest possible start times).  
     - `processing_times = {1: 3, 2: 3, 3: 6}` (hours required per truck).  
     - `H = 100` (a large constant for logical constraints).  

   - **3. Objective Function:**  
     Minimize `makespan` (the latest completion time among all trucks).  

   - **4. Constraints:**  
     1. **Assignment:** Each truck must be assigned to exactly one depot:  
        `sum(assign(i, j) for j in depots) = 1` for all trucks *i*.  
     2. **Arrival Time:** Trucks cannot start before their arrival time:  
        `start_time(i) >= arrival_times[i]` for all trucks *i*.  
     3. **Completion Time:** Completion is start time plus processing time:  
        `completion_time(i) = start_time(i) + processing_times[i]`.  
     4. **Non-Overlapping:** For each depot *j*, if two trucks *i* and *k* are assigned to it, one must precede the other:  
        - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
        - If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.  
        - Logical linkage: `assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))`.  
     5. **Makespan Definition:** The makespan is the maximum completion time:  
        `makespan >= completion_time(i)` for all trucks *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
depots = [1, 2, 3]
arrival_times = {1: 2, 2: 5, 3: 9}
processing_times = {1: 3, 2: 3, 3: 6}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_51_MIN_MAKESPAN")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
    for i in trucks:
        print(f"Start time for Truck {i}: {start_time[i].x:.4f}")
        print(f"Completion time for Truck {i}: {completion_time[i].x:.4f}")
    print(f"Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
15.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 1
Truck 2 is assigned to Depot 1
Truck 3 is assigned to Depot 1
Start time for Truck 1: 2.0000
Completion time for Truck 1: 5.0000
Start time for Truck 2: 5.0000
Completion time for Truck 2: 8.0000
Start time for Truck 3: 9.0000
Completion time for Truck 3: 15.0000
Makespan: 15.0000


```

================================================================================



--- Problem 262 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
At a busy maritime port, eight ships arrive at staggered times, each requiring a berth for unloading and processing. The port has four berths available, and the challenge is to assign each ship to a berth while minimizing the total waiting time—the difference between when a ship arrives and when it actually starts processing. The ships have varying arrival times (e.g., Ship 1 arrives at time 4, Ship 2 at time 5, etc.) and processing durations (e.g., Ship 1 takes 5 units of time, Ship 2 takes 5, etc.). A critical operational rule requires Ships 5 and 8 to be assigned to the *same* berth, adding a layer of complexity to the scheduling puzzle. Additionally, the port authority aims to ensure that no berth remains idle for more than 10 units of time between consecutive ship assignments. The core question is: *How can we assign ships to berths to minimize total waiting time while respecting arrival times, processing durations, the shared berth requirement for Ships 5 and 8, and the maximum idle time constraint?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `assign(i, j)`: 1 if ship *i* is assigned to berth *j*, else 0.  
     - Continuous variable `start_time(i)`: When ship *i* begins processing.  
     - Continuous variable `completion_time(i)`: When ship *i* finishes processing.  
     - Binary variable `precedes(i, k, j)`: 1 if ship *i* is processed before ship *k* on berth *j*, else 0.  
     - Binary variable `group_berth(j)`: 1 if berth *j* is the designated berth for Ships 5 and 8, else 0.  

   - **2. Parameters:**  
     - `ships`: [1, 2, 3, 4, 5, 6, 7, 8].  
     - `berths`: [1, 2, 3, 4].  
     - `arrival_times`: {1: 4, 2: 5, ..., 8: 25}.  
     - `processing_times`: {1: 5, 2: 5, ..., 8: 5}.  
     - `group_A_ships`: [5, 8].  
     - `H = 100`: A large constant for logical constraints.  
     - `max_idle_time = 10`: Maximum allowed idle time between consecutive ship assignments.

   - **3. Objective Function:**  
     Minimize the total waiting time:  
     `Minimize: sum(start_time[i] - arrival_times[i] for all ships i)`.  

   - **4. Constraints:**  
     1. Each ship is assigned to exactly one berth:  
        `sum(assign(i, j) for all j) = 1` for each ship *i*.  
     2. Start time cannot precede arrival time:  
        `start_time[i] >= arrival_times[i]` for each ship *i*.  
     3. Completion time is start time plus processing time:  
        `completion_time[i] = start_time[i] + processing_times[i]`.  
     4. Non-overlapping assignments on the same berth (using precedence variables).  
     5. Ships 5 and 8 must share a berth:  
        - Exactly one berth is designated for the group (`sum(group_berth[j]) = 1`).  
        - If a ship is in the group, it must use the designated berth (`assign(i, j) <= group_berth(j)` for group ships).  
     6. Maximum idle time between consecutive ship assignments:  
        - For each berth *j* and each pair of ships *i* and *k* where *i* < *k*:  
          `start_time[k] - completion_time[i] <= max_idle_time + H * (1 - precedes[i, k, j])`.

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3, 4, 5, 6, 7, 8]
berths = [1, 2, 3, 4]
arrival_times = {1: 4, 2: 5, 3: 6, 4: 9, 5: 14, 6: 19, 7: 23, 8: 25}
processing_times = {1: 5, 2: 5, 3: 7, 4: 6, 5: 4, 6: 8, 7: 7, 8: 5}
group_A_ships = [5, 8] # Ships that must use the same berth
H = 100 # Big M
max_idle_time = 10 # Maximum allowed idle time between consecutive ship assignments
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_65_GROUP")

    if not ships or not berths: raise ValueError("Empty ships or berths")
    # if not group_A_ships: print("Warning: group_A_ships is empty") # Allow empty group

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in ships for k in ships if i < k for j in berths],
                         vtype=GRB.BINARY, name="precedes")
    group_berth = m.addVars(berths, vtype=GRB.BINARY, name="group_berth")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Group Constraint
    if group_A_ships:
        m.addConstr(group_berth.sum('*') == 1, name="one_group_berth")
        for i in group_A_ships:
            for j in berths:
                m.addConstr(assign[i, j] <= group_berth[j], name=f"group_A_assign_{i}_{j}")
    # 6. Maximum idle time
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr(start_time[k] - completion_time[i] <= max_idle_time + H * (1 - precedes[i, k, j]), name=f"idle_time_{i}_{k}_{j}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Ensure All Key Outputs are Printed ---

if m.status == GRB.OPTIMAL:
    print(f"Objective Value: {m.objVal:.4f}")
    for i in ships:
        for j in berths:
            if assign[i, j].x > 0.5:
                print(f"Ship {i} is assigned to Berth {j}")
    for i in ships:
        print(f"Start Time for Ship {i}: {start_time[i].x:.4f}")
        print(f"Completion Time for Ship {i}: {completion_time[i].x:.4f}")
    for j in berths:
        if group_berth[j].x > 0.5:
            print(f"Berth {j} is the designated berth for Ships 5 and 8")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
213.0000
Objective Value: 213.0000
Ship 1 is assigned to Berth 1
Ship 2 is assigned to Berth 1
Ship 3 is assigned to Berth 1
Ship 4 is assigned to Berth 1
Ship 5 is assigned to Berth 4
Ship 6 is assigned to Berth 1
Ship 7 is assigned to Berth 1
Ship 8 is assigned to Berth 4
Start Time for Ship 1: 54.0000
Completion Time for Ship 1: 59.0000
Start Time for Ship 2: 49.0000
Completion Time for Ship 2: 54.0000
Start Time for Ship 3: 59.0000
Completion Time for Ship 3: 66.0000
Start Time for Ship 4: 43.0000
Completion Time for Ship 4: 49.0000
Start Time for Ship 5: 27.0000
Completion Time for Ship 5: 31.0000
Start Time for Ship 6: 19.0000
Completion Time for Ship 6: 27.0000
Start Time for Ship 7: 36.0000
Completion Time for Ship 7: 43.0000
Start Time for Ship 8: 31.0000
Completion Time for Ship 8: 36.0000
Berth 4 is the designated berth for Ships 5 and 8


```

================================================================================



--- Problem 263 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port operator manages a dynamic pricing system for ship berthing at a terminal with two berths, each capable of processing 48 ships per designated period, totaling 96 ships across both berths. The operator faces fluctuating demand from shipping companies that respond to different berthing fees: Fee Level 1 ($3) attracts 137 expected arrivals, Fee Level 2 ($13) attracts 120, and Fee Level 3 ($15) attracts 105. The goal is to select a single fee level that minimizes the resulting queue length—ships unable to berth during the period—by balancing arrivals against the fixed throughput capacity. The challenge lies in strategically choosing the fee that discourages just enough demand to keep queues manageable, ensuring smooth port operations without excessive congestion.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `y[f]` for each fee level `f` (1, 2, 3): Equals 1 if fee `f` is selected, 0 otherwise.  
     - Continuous variable `queue_length`: Represents the number of ships left queuing (≥0).  
   - **2. Parameters:**  
     - `arrivals_at_fee[f]`: Expected ships at fee `f` (137, 120, 105).  
     - `total_throughput`: Maximum ships processed per period (96).  
   - **3. Objective Function:**  
     - Minimize `queue_length`.  
   - **4. Constraints:**  
     - Exactly one fee level must be chosen: `y[1] + y[2] + y[3] = 1`.  
     - Queue length calculation: `queue_length ≥ (arrivals_at_fee[1]·y[1] + arrivals_at_fee[2]·y[2] + arrivals_at_fee[3]·y[3]) - total_throughput`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_berths = 2
berth_capacity_period = 48
total_throughput = 96
fees = {1: 3, 2: 13, 3: 15} # Fee level: price
arrivals_at_fee = {1: 137, 2: 120, 3: 105} # Fee level: expected arrivals
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("DYNAMIC_BERTHING", env=env)

    # --- Input Validation ---
    fee_keys = list(fees.keys())
    if not fee_keys: raise ValueError("No fee levels defined")

    # --- Decision Variables ---
    # y[f] = 1 if fee level f is chosen, 0 otherwise
    y = m.addVars(fee_keys, vtype=GRB.BINARY, name="ChooseFee")
    # queue_length: resulting queue length
    queue_length = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="QueueLength")

    # --- Objective Function: Minimize the queue length ---
    m.setObjective(queue_length, GRB.MINIMIZE)

    # --- Constraints ---
    # Exactly one fee must be chosen
    m.addConstr(gp.quicksum(y[f] for f in fee_keys) == 1, "SelectOneFee")

    # Calculate arrivals based on chosen fee
    current_arrivals = gp.quicksum(arrivals_at_fee.get(f, 0) * y[f] for f in fee_keys)

    # Queue length calculation: queue_length >= arrivals - throughput
    m.addConstr(queue_length >= current_arrivals - total_throughput, "QueueCalc")
    # lb=0 handles the max(0, ...) part

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['y_sol'] = m.getAttr('X', y) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Queue length
             print(f"Optimal objective value: {obj_val_print:.1f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]: # Should always be feasible
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the chosen fee level and corresponding arrivals
if m.Status == GRB.OPTIMAL:
    for f in fee_keys:
        if y[f].X > 0.5:
            print(f"Chosen Fee Level: {f} (Price: {fees[f]}), Expected Arrivals: {arrivals_at_fee[f]}")
```
Answer:
Optimal objective value: 9.0
Chosen Fee Level: 3 (Price: 15), Expected Arrivals: 105


```

================================================================================



--- Problem 264 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A maritime logistics company operates a fleet of 4 ships to deliver goods from a central port (Node 0) to 4 customer ports (Nodes 1–4). Each ship has a distinct capacity: 12, 34, 16, and 56.9 units, respectively. The customers demand specific quantities: 13, 31, 52, and 2 units at Nodes 1–4. The distances between locations are asymmetric, with the central port to Node 1 taking 27 units, Node 1 to Node 2 taking 17 units, and so on, as defined by the distance matrix.  

The challenge is to assign routes to the ships such that:  
- Every customer port is visited exactly once.  
- Each ship starts and ends at the central port.  
- The total demand on a ship’s route does not exceed its capacity.  
- The total distance traveled by all ships is minimized.  

The stakes are high: inefficient routing would inflate fuel costs and delay deliveries. The question is: *What is the most efficient set of routes that meets all constraints while minimizing total distance?*  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable \(x_{i,j,k}\): 1 if ship \(k\) travels directly from node \(i\) to node \(j\); 0 otherwise.  
- Continuous variable \(u_i\) (for subtour elimination): Auxiliary variable representing the order of node \(i\) in the route.  

**2. Parameters:**  
- \(N = 5\): Total nodes (central port + 4 customer ports).  
- \(K = 4\): Number of ships.  
- \(Q = [12, 34, 16, 56.9]\): Ship capacities.  
- \(q = [0, 13, 31, 52, 2]\): Demand at each node (central port has 0 demand).  
- \(d\): 5x5 asymmetric distance matrix (e.g., \(d_{0,1} = 27\), \(d_{1,2} = 17\)).  

**3. Objective Function:**  
Minimize total distance:  
\[
\text{Minimize} \sum_{k=0}^{3} \sum_{i=0}^{4} \sum_{j=0}^{4} d_{i,j} \cdot x_{i,j,k} \quad \text{(for \(i \neq j\))}.
\]  

**4. Constraints:**  
- **Visit each customer port once:** \(\sum_{k=0}^{3} \sum_{j=0}^{4} x_{i,j,k} = 1 \quad \forall i \in \{1,2,3,4\}\).  
- **Flow conservation:** \(\sum_{j=0}^{4} x_{i,j,k} = \sum_{j=0}^{4} x_{j,i,k} \quad \forall i \in \{0,\dots,4\}, \forall k \in \{0,\dots,3\}\).  
- **Central port departure/return:** Each ship leaves and returns to the central port at most once.  
- **Capacity:** \(\sum_{j=1}^{4} q_j \cdot \sum_{i=0}^{4} x_{i,j,k} \leq Q_k \quad \forall k \in \{0,\dots,3\}\).  
- **Subtour elimination (MTZ):** \(u_i - u_j + (N-1) \cdot x_{i,j,k} \leq N-2 \quad \forall i,j \in \{1,\dots,4\}, i \neq j, \forall k\).  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 5
K = 4
Q = [12, 34, 16, 56.900000000000006]
q = [0, 13, 31, 52, 2]
d = [
    [0, 27, 21, 34, 21],
    [27, 0, 17, 74, 67],
    [21, 17, 0, 71, 48],
    [34, 74, 71, 0, 57],
    [21, 67, 48, 57, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer port (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Ship Departure/Return from Central Port (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for ship {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for ship {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# The provided code already prints the total distance and the routes for each ship, including the load.
# No additional print statements are necessary.
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 206.00

Route for ship 1 (Capacity: 12):
0 -> 4 -> 0
Route Load: 2 / 12

Route for ship 2 (Capacity: 34):
0 -> 2 -> 0
Route Load: 31 / 34

Route for ship 3 (Capacity: 16):
0 -> 1 -> 0
Route Load: 13 / 16

Route for ship 4 (Capacity: 56.900000000000006):
0 -> 3 -> 0
Route Load: 52 / 56.900000000000006


```

================================================================================



--- Problem 265 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy trucking terminal faces the challenge of efficiently assigning incoming cargo trucks to depots to minimize the total operational time. Nine trucks, labeled 1 through 9, arrive at staggered times throughout the day, each requiring a specific duration to unload and process. The terminal has four depots available, and the goal is to assign each truck to exactly one depot while ensuring no two trucks scheduled at the same depot overlap in time. The arrival times vary: Truck 1 arrives at hour 4, Truck 2 at hour 8, and so on, with the latest arrival being Truck 9 at hour 29. Processing times also differ—Truck 1 takes 9 hours, Truck 2 takes 7 hours, and the quickest, Truck 9, requires only 4 hours. The terminal manager must devise a schedule that respects arrival times, avoids depot conflicts, and minimizes the **makespan**—the time when the last truck finishes processing. The core question: *What is the optimal depot assignment and scheduling sequence to complete all operations as early as possible?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary `assign(i, j)`: 1 if truck *i* is assigned to depot *j*, else 0.  
   - Continuous `start_time(i)`: When truck *i* begins processing.  
   - Continuous `completion_time(i)`: When truck *i* finishes (start time + processing time).  
   - Binary `precedes(i, k, j)`: 1 if truck *i* is scheduled before truck *k* at depot *j*, else 0 (for conflict resolution).  
   - Continuous `makespan`: Total operational duration (max completion time across all trucks).  

   **2. Parameters:**  
   - `arrival_times[i]`: Hour truck *i* arrives (e.g., Truck 1: 4, Truck 2: 8).  
   - `processing_times[i]`: Hours to process truck *i* (e.g., Truck 1: 9, Truck 2: 7).  
   - `H = 200`: A sufficiently large constant ("Big M") for linearization.  

   **3. Objective Function:**  
   Minimize `makespan` (the latest completion time among all trucks).  

   **4. Constraints:**  
   - **Assignment:** Each truck *i* must be assigned to exactly one depot:  
     `sum(assign(i, j) for all j) = 1` for all *i*.  
   - **Arrival Time:** Trucks cannot start before arrival:  
     `start_time(i) >= arrival_times[i]` for all *i*.  
   - **Completion Time:** `completion_time(i) = start_time(i) + processing_times[i]` for all *i*.  
   - **Non-Overlapping:** For each depot *j*, if trucks *i* and *k* (*i* < *k*) share it, one must precede the other:  
     - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
     - If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.  
     - Logical link: `assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))`.  
   - **Makespan Definition:** `makespan >= completion_time(i)` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7, 8, 9]
depots = [1, 2, 3, 4]
arrival_times = {1: 4, 2: 8, 3: 12, 4: 13, 5: 16, 6: 19, 7: 23, 8: 25, 9: 29}
processing_times = {1: 9, 2: 7, 3: 6, 4: 8, 5: 6, 6: 9, 7: 10, 8: 8, 9: 4}
H = 200 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_18_LARGE_MAKESPAN")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")
        if m.SolCount > 0 and abs(m.ObjVal) < GRB.INFINITY :
             print(f"{m.ObjVal:.4f}")
        elif m.status != GRB.INFEASIBLE and m.status != GRB.UNBOUNDED:
             print("No feasible solution found.")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the assignment and schedule details
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.2f}")
                print(f"  Completion Time: {completion_time[i].x:.2f}")
    print(f"Total Makespan: {makespan.x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
71.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 1
  Start Time: 4.00
  Completion Time: 13.00
Truck 2 is assigned to Depot 1
  Start Time: 19.00
  Completion Time: 26.00
Truck 3 is assigned to Depot 1
  Start Time: 13.00
  Completion Time: 19.00
Truck 4 is assigned to Depot 1
  Start Time: 32.00
  Completion Time: 40.00
Truck 5 is assigned to Depot 1
  Start Time: 26.00
  Completion Time: 32.00
Truck 6 is assigned to Depot 1
  Start Time: 50.00
  Completion Time: 59.00
Truck 7 is assigned to Depot 1
  Start Time: 40.00
  Completion Time: 50.00
Truck 8 is assigned to Depot 1
  Start Time: 63.00
  Completion Time: 71.00
Truck 9 is assigned to Depot 1
  Start Time: 59.00
  Completion Time: 63.00
Total Makespan: 71.00


```

================================================================================



--- Problem 266 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A port management team is tasked with scheduling ship berthing operations over a 2.72-day project, requiring a total of 19.71 work hours. The project spans three distinct time periods each day: **Peak** (5.78 hours), **OffPeak** (5.75 hours), and **Night** (12.64 hours). Vessel arrival rates vary significantly across these periods, with **Peak** seeing the highest flow at 6,164 vessels per hour, followed by **OffPeak** (4,166 vessels/h) and **Night** (1,556 vessels/h). The team must balance berthing schedules to minimize vessel waiting times, as berthing reduces the port's capacity from 7,721 vessels/h (normal) to 3,425 vessels/h (berthing). Waiting times occur when demand exceeds capacity, with **Peak** and **OffPeak** periods experiencing queues of 2,739 and 741 vessels/h, respectively, during berthing. The **Night** period, however, has no waiting times regardless of berthing activity. The challenge is to allocate the required 7.24 work hours per day across these periods to minimize the total project-wide waiting time, while respecting each period’s duration limits.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `WorkHours_p`: Hours assigned to berthing in period `p` (Peak, OffPeak, Night), continuous and non-negative.  
   - **2. Parameters:**  
     - `Duration_p`: Duration of period `p` (Peak: 5.78h, OffPeak: 5.75h, Night: 12.64h).  
     - `DelayRate_p_work`: Delay rate during berthing in period `p` (Peak: 2,739 vessels/h, OffPeak: 740.6 vessels/h, Night: 0 vessels/h).  
     - `DelayRate_p_nowork`: Delay rate without berthing (all periods: 0 vessels/h).  
     - `WorkHoursPerDay`: Daily work requirement (7.24h).  
     - `T_project_days`: Project duration (2.72 days).  
   - **3. Objective Function:**  
     Minimize total waiting time over the project:  
     `Minimize: T_project_days * sum( (DelayRate_p_work[p] * WorkHours_p[p]) + (DelayRate_p_nowork[p] * (Duration_p[p] - WorkHours_p[p])) for p in periods )`.  
   - **4. Constraints:**  
     - Total daily work hours: `sum(WorkHours_p[p] for p in periods) = 7.24`.  
     - Work hours cannot exceed period duration: `WorkHours_p[p] <= Duration_p[p]` for each `p`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
T_project_days = 2.722699777141478
TotalWorkHoursNeeded = 19.71495025767086
periods = ['Peak', 'OffPeak', 'Night']

# Duration per period per day (hours)
Duration_p = {'Peak': 5.7750719097421905, 'OffPeak': 5.7495902142169415, 'Night': 12.642712748747902}
# Hourly demand per period (vessels/h)
Lambda_p = {'Peak': 6164.053928205336, 'OffPeak': 4165.650742375508, 'Night': 1556.0756058313887}
# Capacities (vessels/h)
C_normal = 7721.311142030308
C_berthing = 3425.059016609316  # 2 lanes closed

# Calculate required work hours per day (assuming uniform distribution)
WorkHoursPerDay = TotalWorkHoursNeeded / T_project_days

# --- Calculate Delay Rates (simplified: vessels queued per hour if demand > capacity) ---
DelayRate_p_work = {}
DelayRate_p_nowork = {}
print("--- Delay Rate Calculation (Vessels Queued per Hour) ---")
for p in periods:
    # Delay rate if working (capacity = C_berthing)
    rate_work = max(0, Lambda_p[p] - C_berthing)
    DelayRate_p_work[p] = rate_work
    # Delay rate if not working (capacity = C_normal)
    rate_nowork = max(0, Lambda_p[p] - C_normal)
    DelayRate_p_nowork[p] = rate_nowork
    print(f" Period {p}: Berthing Delay Rate = {rate_work:.1f} vessels/h, No Berthing Delay Rate = {rate_nowork:.1f} vessels/h")

# --- Gurobi Model ---
model = gp.Model("BerthingTimeOfDayScheduling")

# --- Decision Variables ---
# WorkHours_p: Hours spent berthing within period p each day
WorkHours_p = model.addVars(periods, name="WorkHours", lb=0.0)

# --- Constraints ---
# 1. Total work hours per day must match the requirement
model.addConstr(gp.quicksum(WorkHours_p[p] for p in periods) == WorkHoursPerDay,
            name="DailyWorkHours")

# 2. Work hours in a period cannot exceed the duration of that period
for p in periods:
    model.addConstr(WorkHours_p[p] <= Duration_p[p], name=f"DurationLimit_{p}")

# --- Objective Function ---
# Minimize total delay over the project duration.
daily_delay_expr = gp.quicksum( DelayRate_p_work[p] * WorkHours_p[p] +
                                DelayRate_p_nowork[p] * (Duration_p[p] - WorkHours_p[p])
                                for p in periods )
total_project_delay = T_project_days * daily_delay_expr
model.setObjective(total_project_delay, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    print(f"Minimum Total Delay Proxy (Sum of hourly queue growth * duration): {model.objVal:.2f}")
    print(f"\nOptimal Berthing Schedule (Hours per Day):")
    total_hours_sched = 0
    for p in periods:
        print(f"  Period {p} ({Duration_p[p]}h total): Berthing for {WorkHours_p[p].X:.2f} hours")
        total_hours_sched += WorkHours_p[p].X
    print(f"  Total scheduled berthing hours per day: {total_hours_sched:.2f} (Target={WorkHoursPerDay:.2f})")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
    model.computeIIS()
    model.write("model_iis.ilp")
    print("IIS written to model_iis.ilp")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- Delay Rate Calculation (Vessels Queued per Hour) ---
 Period Peak: Berthing Delay Rate = 2739.0 vessels/h, No Berthing Delay Rate = 0.0 vessels/h
 Period OffPeak: Berthing Delay Rate = 740.6 vessels/h, No Berthing Delay Rate = 0.0 vessels/h
 Period Night: Berthing Delay Rate = 0.0 vessels/h, No Berthing Delay Rate = 0.0 vessels/h
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 4 rows, 3 columns and 6 nonzeros
Model fingerprint: 0xd005a8b6
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [2e+03, 7e+03]
  Bounds range     [0e+00, 0e+00]
  RHS range        [6e+00, 1e+01]
Presolve removed 4 rows and 3 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    0.0000000e+00   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  0.000000000e+00

--- Optimization Results ---
Optimization Status: Optimal
Minimum Total Delay Proxy (Sum of hourly queue growth * duration): 0.00

Optimal Berthing Schedule (Hours per Day):
  Period Peak (5.7750719097421905h total): Berthing for 0.00 hours
  Period OffPeak (5.7495902142169415h total): Berthing for 0.00 hours
  Period Night (12.642712748747902h total): Berthing for 7.24 hours
  Total scheduled berthing hours per day: 7.24 (Target=7.24)



================================================================================



--- Problem 267 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port is divided into three berths, each experiencing varying ship arrival rates and capacity constraints. During incidents, the main berth’s capacity drops significantly, while alternative berths offer limited relief at the cost of additional handling time. The challenge is to determine the optimal diversion strategy—selecting from predefined ratios (10%, 30%, 50%, or 70%)—for each berth to minimize total delay caused by congestion and rerouting.  

   Berth 1 faces the highest arrival rate (4,908 ships/hour) but has robust normal and reduced mainline capacities (4,508 and 2,522 ships/hour, respectively). Its alternative berth can handle only 1,027 ships/hour, with a minor extra handling time of 0.11 hours. Berths 2 and 3 have lower arrival rates (3,427 and 2,736 ships/hour) and tighter reduced capacities (1,667 and 1,417 ships/hour), with alternative berth capacities of 1,135 and 1,168 ships/hour. The incident durations vary (1.61, 1.13, and 1.68 hours), further complicating delay calculations.  

   The core question: *What combination of diversion ratios across all berths minimizes the total system delay, balancing queueing on the main berth and added handling time on alternatives?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable \( y(i, k) \): 1 if diversion option \( k \) (e.g., 10%, 30%) is selected for berth \( i \); 0 otherwise.  

   **2. Parameters:**  
   - \( \text{arrival_rates}[i] \): Ships arriving per hour (e.g., 4,908 for Berth 1).  
   - \( \text{capacities_main_normal}[i], \text{capacities_main_reduced}[i] \): Main berth capacities under normal/incident conditions.  
   - \( \text{capacities_alt}[i] \): Alternative berth capacity (ships/hour).  
   - \( \text{incident_durations}[i] \): Duration of incident (hours).  
   - \( \text{alt_berth_extra_times}[i] \): Additional handling time on alternatives (hours).  
   - \( \text{diversion_options}[k] \): Available ratios (0.1, 0.3, 0.5, 0.7).  
   - Precomputed \( \text{berth_option_delays}[i][k] \): Total delay for berth \( i \) and option \( k \).  

   **3. Objective Function:**  
   Minimize total delay:  
   \[
   \text{Minimize: } \sum_{i=1}^3 \sum_{k=1}^4 y(i, k) \cdot \text{berth_option_delays}[i][k]
   \]  

   **4. Constraints:**  
   - **Feasibility:** For each berth \( i \), exactly one feasible diversion option \( k \) is selected:  
     \[
     \sum_{k \in \text{feasible}(i)} y(i, k) = 1 \quad \forall i
     \]  
   - **Infeasible Options:** \( y(i, k) = 0 \) if option \( k \) exceeds alternative berth capacity for berth \( i \).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 3
capacities_main_normal = [4508, 5322, 4545]  # ships/h
capacities_main_reduced = [2522, 1667, 1417]  # ships/h
capacities_alt = [1027, 1135, 1168]  # ships/h
arrival_rates = [4908, 3427, 2736]  # ships/h
incident_durations = [1.6077076477829064, 1.1306629314851686, 1.6762983672298346]  # h
alt_berth_extra_times = [0.11192559414454638, 0.14388832557393777, 0.08554305651424814]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option and Berth ---
berth_option_delays = {}
berth_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_option_delays[i] = {}
    berth_option_feasible[i] = {}

    for k in range(num_options):
        p_k = diversion_options[k]
        flow_alt_k = arrival_rates[i] * p_k
        flow_main_k = arrival_rates[i] * (1 - p_k)

        # 1. Check Alternative Berth Capacity Feasibility
        if flow_alt_k > capacities_alt[i] + EPSILON:
            berth_option_feasible[i][k] = False
            berth_option_delays[i][k] = LARGE_DELAY
            continue

        berth_option_feasible[i][k] = True

        # 2. Calculate Alternative Berth Delay
        delay_alt_k = flow_alt_k * incident_durations[i] * alt_berth_extra_times[i]

        # 3. Calculate Main Berth Queue Delay
        delay_queue_main_k = 0
        max_queue_main_k = 0

        if flow_main_k > capacities_main_reduced[i] + EPSILON:
            max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * incident_durations[i]
            if flow_main_k >= capacities_main_normal[i] - EPSILON:
                delay_queue_main_k = LARGE_DELAY
            else:
                dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                if dissipation_rate_k < EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                    total_influence_time_k = incident_durations[i] + dissipation_time_main_k
                    delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

        # 4. Calculate Total Delay for this option
        total_delay_k = delay_alt_k + delay_queue_main_k
        berth_option_delays[i][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    feasible_indices = [k for k in range(num_options) if berth_option_feasible[i][k]]
    if not feasible_indices:
        exit()

    m.addConstr(gp.quicksum(y[i,k] for k in feasible_indices) == 1, name="SelectOneFeasibleOption_Berth{0}".format(i))

    for k in range(num_options):
        if not berth_option_feasible[i][k]:
            m.addConstr(y[i,k] == 0, name="ForbidInfeasibleOption_Berth{0}_Option{1}".format(i,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,k] * berth_option_delays[i][k]
        for i in range(NUM_BERTHS)
        for k in range(num_options)
        if berth_option_feasible[i][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Diversion Strategy:")
    for i in range(NUM_BERTHS):
        for k in range(num_options):
            if y[i,k].X > 0.5:
                print("Berth {0}: Option {1} ({2:.0f}%)".format(
                    i+1, k, diversion_options[k]*100
                ))
                break
```
Answer:
Optimal Diversion Strategy:
Berth 1: Option 0 (10%)
Berth 2: Option 1 (30%)
Berth 3: Option 1 (30%)



================================================================================



--- Problem 268 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A maritime logistics company operates a port with three berths, each available for a maximum of 7.6 hours per day. A fleet of 12 ships, labeled S1 through S12, arrives for servicing, each requiring a specific processing time and generating a distinct profit upon completion. The challenge is to assign ships to berths in a way that maximizes total profit while ensuring no berth exceeds its time capacity and no ship is assigned to more than one berth.  

The ships vary significantly in their characteristics: for instance, Ship S10 offers the highest profit ($412) but requires a substantial 3.2 hours of berth time, while Ship S5 yields $292 profit in just 0.7 hours. Meanwhile, Ship S9 contributes only $102 profit but occupies 1.7 hours, making it a less attractive candidate. The berths must be carefully balanced—overloading one could leave others underutilized, while inefficient assignments could miss profitable opportunities.  

The central question is: **How should the ships be assigned to the three berths to maximize total profit without violating time constraints?**
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x(s, b)`: Binary variable indicating whether ship `s` is assigned to berth `b` (1 if assigned, 0 otherwise).  

   **2. Parameters:**  
   - `profit(s)`: Profit generated by servicing ship `s` (e.g., `profit(S1) = 196`).  
   - `time(s)`: Processing time required by ship `s` (e.g., `time(S1) = 3.5` hours).  
   - `time_horizon = 7.6`: Maximum operating time per berth (hours).  
   - `berth_ids = [0, 1, 2]`: Identifiers for the three berths.  

   **3. Objective Function:**  
   Maximize the total profit from assigned ships:  
   `Maximize: sum(profit(s) * x(s, b) for all s, b)`  

   **4. Constraints:**  
   - **Single assignment per ship:** Each ship can be assigned to at most one berth:  
     `sum(x(s, b) for all b) <= 1` for every ship `s`.  
   - **Berth time capacity:** The total processing time of ships assigned to a berth cannot exceed 7.6 hours:  
     `sum(time(s) * x(s, b) for all s) <= time_horizon` for every berth `b`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
ships_data = {'S1': {'time': 3.5, 'profit': 196}, 'S2': {'time': 1.2, 'profit': 193}, 'S3': {'time': 0.7, 'profit': 262}, 'S4': {'time': 1.3, 'profit': 193}, 'S5': {'time': 0.7, 'profit': 292}, 'S6': {'time': 1.7, 'profit': 145}, 'S7': {'time': 1.4, 'profit': 267}, 'S8': {'time': 3.2, 'profit': 123}, 'S9': {'time': 1.7, 'profit': 102}, 'S10': {'time': 3.2, 'profit': 412}, 'S11': {'time': 1.8, 'profit': 223}, 'S12': {'time': 1.3, 'profit': 176}}
num_berths = 3; time_horizon = 7.6
ship_ids = ['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8', 'S9', 'S10', 'S11', 'S12']; berth_ids = [0, 1, 2]
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m9 = gp.Model("Berth_Scheduling_MIP", env=env)
    # Vars
    x = m9.addVars(ship_ids, berth_ids, vtype=GRB.BINARY, name="assign")
    # Objective
    m9.setObjective(gp.quicksum(x[s, b] * ships_data[s]['profit'] for s in ship_ids for b in berth_ids), sense=GRB.MAXIMIZE)
    # Constraints
    for s in ship_ids: m9.addConstr(gp.quicksum(x[s, b] for b in berth_ids) <= 1, f"ship_{s}_assignment")
    for b in berth_ids: m9.addConstr(gp.quicksum(x[s, b] * ships_data[s]['time'] for s in ship_ids) <= time_horizon, f"berth_{b}_time_capacity")
    # Optimize
    m9.optimize()
    # Store results
    results_dict['status'] = m9.status
    if m9.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m9.objVal; results_dict['x_sol'] = m9.getAttr('X', x)
    # Output Results
    print("--- Problem 9: Berth Scheduling (MIP) ---")
    if m9.status == GRB.OPTIMAL:
        print(f"Optimization Status: Optimal"); print(f"Maximum total profit: ${m9.objVal:.2f}"); print("Assignments:")
        x_sol = results_dict.get('x_sol', {}); total_time_berth = [0.0] * num_berths; served_ships = []
        for s in ship_ids:
            for b in berth_ids:
                if x_sol.get((s, b), 0) > 0.5:
                    print(f"  Ship {s} (Time: {ships_data[s]['time']} hrs, Profit: ${ships_data[s]['profit']}) assigned to Berth {b+1}")
                    total_time_berth[b] += ships_data[s]['time']; served_ships.append(s)
        print("Berth Utilization:");
        for b in berth_ids: print(f"  Berth {b+1}: Total time used = {total_time_berth[b]:.1f} / {time_horizon} hours")
        print("Unserved ships:", [s for s in ship_ids if s not in served_ships])
    else: print(f"Optimization Status: {m9.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of BERTH_SCHEDULING
```
Answer:
--- Problem 9: Berth Scheduling (MIP) ---
Optimization Status: Optimal
Maximum total profit: $2584.00
Assignments:
  Ship S1 (Time: 3.5 hrs, Profit: $196) assigned to Berth 1
  Ship S2 (Time: 1.2 hrs, Profit: $193) assigned to Berth 1
  Ship S3 (Time: 0.7 hrs, Profit: $262) assigned to Berth 1
  Ship S4 (Time: 1.3 hrs, Profit: $193) assigned to Berth 1
  Ship S5 (Time: 0.7 hrs, Profit: $292) assigned to Berth 1
  Ship S6 (Time: 1.7 hrs, Profit: $145) assigned to Berth 2
  Ship S7 (Time: 1.4 hrs, Profit: $267) assigned to Berth 2
  Ship S8 (Time: 3.2 hrs, Profit: $123) assigned to Berth 2
  Ship S9 (Time: 1.7 hrs, Profit: $102) assigned to Berth 3
  Ship S10 (Time: 3.2 hrs, Profit: $412) assigned to Berth 3
  Ship S11 (Time: 1.8 hrs, Profit: $223) assigned to Berth 3
  Ship S12 (Time: 1.3 hrs, Profit: $176) assigned to Berth 2
Berth Utilization:
  Berth 1: Total time used = 7.4 / 7.6 hours
  Berth 2: Total time used = 7.6 / 7.6 hours
  Berth 3: Total time used = 6.7 / 7.6 hours
Unserved ships: []



================================================================================



--- Problem 269 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy inland logistics hub, a critical scheduling challenge arises: efficiently assigning a fleet of 11 delivery trucks to 3 available depots to minimize the total time required to service all vehicles. Each truck arrives at a specific time (e.g., Truck 1 at time 4, Truck 2 at time 7) and requires a distinct processing duration (e.g., Truck 1 needs 10 units of time, Truck 2 needs 4). The logistics authority must ensure that no two trucks occupy the same depot simultaneously, and each truck is assigned to exactly one depot. The primary goal is to orchestrate these assignments and schedules such that the last truck finishes as early as possible, optimizing the hub's throughput and reducing idle time. The core question is: *What is the optimal depot assignment and start-time schedule that minimizes the total completion time (makespan) for all trucks?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `assign(i, j)`: 1 if truck *i* is assigned to depot *j*, else 0.  
   - Continuous variable `start_time(i)`: Time when truck *i* begins processing.  
   - Continuous variable `completion_time(i)`: Time when truck *i* finishes (`start_time(i) + processing_time(i)`).  
   - Binary variable `precedes(i, k, j)`: 1 if truck *i* is scheduled before truck *k* on depot *j*, else 0.  
   - Continuous variable `makespan`: Maximum completion time across all trucks.  

   **2. Parameters:**  
   - `trucks`: List of trucks (1 to 11).  
   - `depots`: List of depots (1 to 3).  
   - `arrival_times[i]`: Time truck *i* arrives (e.g., Truck 1: 4).  
   - `processing_times[i]`: Duration to process truck *i* (e.g., Truck 1: 10).  
   - `H` (Big M): Arbitrarily large constant (200) for linearization.  

   **3. Objective Function:**  
   Minimize `makespan` (the latest completion time among all trucks).  

   **4. Constraints:**  
   - Each truck is assigned to exactly one depot: `sum(assign(i, j) for j in depots) = 1` for all *i*.  
   - Start time cannot precede arrival: `start_time(i) >= arrival_times[i]` for all *i*.  
   - Completion time definition: `completion_time(i) = start_time(i) + processing_times[i]` for all *i*.  
   - Non-overlapping on depots: For each depot *j* and trucks *i*, *k* (*i* < *k*):  
     - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
     - Else, `start_time(i) >= completion_time(k)`.  
     - Logical linkage: `assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))`.  
   - Makespan definition: `makespan >= completion_time(i)` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
depots = [1, 2, 3]
arrival_times = {1: 4, 2: 7, 3: 9, 4: 12, 5: 16, 6: 17, 7: 20, 8: 21, 9: 24, 10: 25, 11: 26}
processing_times = {1: 10, 2: 4, 3: 6, 4: 5, 5: 10, 6: 4, 7: 10, 8: 10, 9: 6, 10: 9, 11: 8}
H = 200 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_18_LARGE_MAKESPAN")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")
        if m.SolCount > 0 and abs(m.ObjVal) < GRB.INFINITY :
             print(f"{m.ObjVal:.4f}")
        elif m.status != GRB.INFEASIBLE and m.status != GRB.UNBOUNDED:
             print("No feasible solution found.")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the assignment and schedule details
if m.status == GRB.OPTIMAL:
    print(f"Optimal makespan: {m.objVal:.4f}")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}, Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
86.0000
Optimal makespan: 86.0000
Truck 1 is assigned to Depot 1, Start Time: 4.0000, Completion Time: 14.0000
Truck 2 is assigned to Depot 1, Start Time: 14.0000, Completion Time: 18.0000
Truck 3 is assigned to Depot 1, Start Time: 18.0000, Completion Time: 24.0000
Truck 4 is assigned to Depot 1, Start Time: 24.0000, Completion Time: 29.0000
Truck 5 is assigned to Depot 1, Start Time: 29.0000, Completion Time: 39.0000
Truck 6 is assigned to Depot 1, Start Time: 39.0000, Completion Time: 43.0000
Truck 7 is assigned to Depot 1, Start Time: 43.0000, Completion Time: 53.0000
Truck 8 is assigned to Depot 1, Start Time: 53.0000, Completion Time: 63.0000
Truck 9 is assigned to Depot 1, Start Time: 63.0000, Completion Time: 69.0000
Truck 10 is assigned to Depot 1, Start Time: 69.0000, Completion Time: 78.0000
Truck 11 is assigned to Depot 1, Start Time: 78.0000, Completion Time: 86.0000


```

================================================================================



--- Problem 270 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently routing three delivery trucks from a central depot to serve five customer locations. The depot (Node 0) must dispatch these trucks such that each customer (Nodes 1–5) is visited exactly once, while respecting the unique capacity limits of each truck. The trucks have capacities of 96, 74, and 67.8 units, respectively, and the customer demands are 79, 16, 16, 53, and 52 units. The distances between locations are asymmetric, with the depot-to-customer distances ranging from 3 to 94 units. The challenge is to minimize the total travel distance across all routes while ensuring no truck exceeds its capacity and all customers are serviced. The solution must also prevent subtours—illegal routes that skip the depot—using Miller-Tucker-Zemlin (MTZ) constraints.  

   The operational stakes are high: inefficient routing could inflate fuel costs and delay deliveries. The key question is: *What is the most distance-efficient set of routes that meets all capacity and visitation constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variables `x[i, j, k]` indicate whether truck *k* travels directly from node *i* to node *j*.  
   - Continuous variables `u[i]` (for customers *i* = 1–5) enforce subtour elimination via MTZ constraints.  

   **2. Parameters:**  
   - `N = 6` (depot + 5 customers), `K = 3` (trucks).  
   - Truck capacities `Q = [96, 74, 67.8]`.  
   - Customer demands `q = [0, 79, 16, 16, 53, 52]` (depot demand is 0).  
   - Distance matrix `d[i][j]` (e.g., `d[0][1] = 81`, `d[1][0] = 81`).  

   **3. Objective Function:**  
   Minimize total distance:  
   \[
   \text{Minimize: } \sum_{k=0}^{2} \sum_{i=0}^{5} \sum_{j=0}^{5} (d[i][j] \cdot x[i, j, k]) \quad (i \neq j)
   \]  

   **4. Constraints:**  
   - **Visit each customer once:**  
     \[
     \sum_{k=0}^{2} \sum_{j=0}^{5} x[i, j, k] = 1 \quad \forall i = 1, \dots, 5 \quad (i \neq j)
     \]  
   - **Flow conservation:**  
     \[
     \sum_{j=0}^{5} x[i, j, k] = \sum_{j=0}^{5} x[j, i, k] \quad \forall k, \forall i
     \]  
   - **Depot departure/return:** Each truck leaves/returns to the depot at most once.  
   - **Capacity limits:**  
     \[
     \sum_{j=1}^{5} q[j] \cdot \sum_{i=0}^{5} x[i, j, k] \leq Q[k] \quad \forall k
     \]  
   - **MTZ subtour elimination:**  
     \[
     u[i] - u[j] + 5 \cdot x[i, j, k] \leq 4 \quad \forall k, \forall i, j \geq 1, i \neq j
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 6
K = 3
Q = [96, 74, 67.80000000000001]
q = [0, 79, 16, 16, 53, 52]
d = [
    [0, 81, 9, 80, 31, 21],
    [81, 0, 29, 66, 39, 3],
    [9, 29, 0, 45, 2, 94],
    [80, 66, 45, 0, 88, 22],
    [31, 39, 2, 88, 0, 32],
    [21, 3, 94, 22, 32, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Truck Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for truck {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for truck {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 304.00

Route for truck 1 (Capacity: 96):
0 -> 1 -> 2 -> 0
Route Load: 95 / 96

Route for truck 2 (Capacity: 74):
0 -> 5 -> 3 -> 0
Route Load: 68 / 74

Route for truck 3 (Capacity: 67.80000000000001):
0 -> 4 -> 0
Route Load: 53 / 67.80000000000001


```

================================================================================



--- Problem 271 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port is managed by a four-phase ship berthing system, where each phase must allocate berthing time efficiently to minimize total ship delay. The port handles varying traffic flows: Phase 1 sees heavy traffic with a flow coefficient of 2941 ships per hour, Phase 2 and Phase 3 handle moderate flows of 1185 and 2087, respectively, while Phase 4 deals with lighter traffic at 272. The berthing timing must adhere to strict operational rules: each phase’s berthing time cannot fall below 22 minutes or exceed 93 minutes, and the total cycle time—the sum of all berthing phases—must exactly match the upper bound of 93 minutes. The challenge is to distribute the limited cycle time across the phases such that the cumulative delay, calculated as the product of traffic flow and non-berthing time (cycle time minus berthing time), is minimized. The core question is: *How should the 93-minute cycle be split among the four phases to reduce total delay to the smallest possible value?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( t_i \) represent the berthing time (in minutes) allocated to phase \( i \), where \( i \in \{1, 2, 3, 4\} \). Each \( t_i \) is a continuous variable bounded between 22 and 93.  
   - **2. Parameters:**  
     - \( \text{flow_coeffs} = [2941, 1185, 2087, 272] \): Traffic flow coefficients for each phase.  
     - \( \text{cycle_time} = 93 \): Fixed total cycle time (minutes).  
     - \( \text{lb_time} = 22 \), \( \text{ub_time} = 93 \): Lower/upper bounds for berthing times.  
   - **3. Objective Function:**  
     - Minimize the total delay:  
       \[
       \text{Minimize: } \sum_{i=1}^4 \text{flow_coeffs}[i] \times (\text{cycle_time} - t_i)
       \]  
   - **4. Constraints:**  
     - Total berthing time must equal the cycle time:  
       \[
       t_1 + t_2 + t_3 + t_4 = 93
       \]  
     - Bounds on berthing times:  
       \[
       22 \leq t_i \leq 93 \quad \forall i \in \{1, 2, 3, 4\}
       \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 4
lb_time = 22          # Lower bound for berthing time
ub_time = 93          # Upper bound for berthing time
cycle_time = 93   # Total cycle time (set equal to ub_time)
flow_coeffs = [2941, 1185, 2087, 272] # Traffic flow coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for phase i is proportional to flow * non-berthing time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total delay: 445730.00
------------------------------
Optimal berthing times (minutes):
  t1: 27.00, t2: 22.00, t3: 22.00, t4: 22.00


```

================================================================================



--- Problem 272 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port operates with three berths, each capable of processing a fixed throughput of 26 units per period, summing to a total capacity of 78 units. The port dynamically adjusts the handling fees to manage incoming ship traffic. Three fee levels are available, each with distinct pricing and expected arrival volumes: Fee 1 (priced at 4 units) anticipates 46 arrivals, Fee 2 (5 units) expects 40 arrivals, and Fee 3 (9 units) projects 32 arrivals. The goal is to select the optimal fee level to minimize the resulting queue length—the excess of arrivals over the port’s throughput capacity. The challenge lies in balancing revenue incentives with congestion avoidance, ensuring the chosen fee neither overwhelms the berths nor underutilizes their capacity.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable \( y[f] \): Equals 1 if fee level \( f \) is selected (where \( f \in \{1, 2, 3\} \)), 0 otherwise.  
     - Continuous variable \( \text{queue\_length} \): Represents the excess arrivals beyond throughput (non-negative).  
   - **2. Parameters:**  
     - \( \text{arrivals\_at\_fee}[f] \): Expected arrivals for fee \( f \) (46, 40, 32).  
     - \( \text{total\_throughput} = 78 \): System-wide processing capacity.  
   - **3. Objective Function:**  
     - Minimize \( \text{queue\_length} \).  
   - **4. Constraints:**  
     - Exactly one fee must be chosen: \( \sum_{f=1}^3 y[f] = 1 \).  
     - Queue length calculation: \( \text{queue\_length} \geq \sum_{f=1}^3 (\text{arrivals\_at\_fee}[f] \cdot y[f]) - \text{total\_throughput} \).  
     - Non-negativity: \( \text{queue\_length} \geq 0 \).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_berths = 3
berth_capacity_period = 26
total_throughput = 78
fees = {1: 4, 2: 5, 3: 9} # Fee level: price
arrivals_at_fee = {1: 46, 2: 40, 3: 32} # Fee level: expected arrivals
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("DYNAMIC_PORT_FEES", env=env)

    # --- Input Validation ---
    fee_keys = list(fees.keys())
    if not fee_keys: raise ValueError("No fee levels defined")

    # --- Decision Variables ---
    # y[f] = 1 if fee level f is chosen, 0 otherwise
    y = m.addVars(fee_keys, vtype=GRB.BINARY, name="ChooseFee")
    # queue_length: resulting queue length
    queue_length = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="QueueLength")

    # --- Objective Function: Minimize the queue length ---
    m.setObjective(queue_length, GRB.MINIMIZE)

    # --- Constraints ---
    # Exactly one fee must be chosen
    m.addConstr(gp.quicksum(y[f] for f in fee_keys) == 1, "SelectOneFee")

    # Calculate arrivals based on chosen fee
    current_arrivals = gp.quicksum(arrivals_at_fee.get(f, 0) * y[f] for f in fee_keys)

    # Queue length calculation: queue_length >= arrivals - throughput
    m.addConstr(queue_length >= current_arrivals - total_throughput, "QueueCalc")
    # lb=0 handles the max(0, ...) part

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['y_sol'] = m.getAttr('X', y) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Queue length
             print(f"Optimal objective value: {obj_val_print:.1f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]: # Should always be feasible
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the chosen fee level
if m.Status == GRB.OPTIMAL:
    for f in fee_keys:
        if y[f].X > 0.5:
            print(f"Chosen fee level: {f} (Price: {fees[f]} units, Expected Arrivals: {arrivals_at_fee[f]})")
```
Answer:
Optimal objective value: 0.0
Chosen fee level: 1 (Price: 4 units, Expected Arrivals: 46)


```

================================================================================



--- Problem 273 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port terminal is tasked with efficiently scheduling a diverse set of 20 ships into berthing slots, each with a strict time limit of 80 hours. The ships vary significantly in the time they need to be berthed, ranging from as short as 2 hours to as long as 76 hours, and each is labeled with one of 10 unique types: 'Y', 'R', 'J', 'E', 'K', 'X', 'V', 'B', 'I', 'A', 'C', or 'U'. The challenge is compounded by a critical operational rule: no slot can contain ships with more than two distinct types. This constraint ensures streamlined handling and resource allocation. The terminal manager must determine the minimal number of berthing slots required to schedule all ships without violating time or type restrictions, balancing efficiency with compliance. The core question is: *What is the optimal slot assignment that minimizes the total number of slots while adhering to these constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `x[i, j]`: 1 if ship `i` is assigned to slot `j`, else 0.  
   - Binary variable `y[j]`: 1 if slot `j` is used, else 0.  
   - Binary variable `z[c, j]`: 1 if type `c` is present in slot `j`, else 0.  

   **2. Parameters:**  
   - `ships`: List of ship berthing times (e.g., [41, 17, ..., 65]).  
   - `types`: List of ship types (e.g., ['Y', 'R', ..., 'V']).  
   - `capacity`: Maximum slot time (80 hours).  
   - `unique_types_list`: Sorted list of distinct types.  

   **3. Objective Function:**  
   Minimize the total number of slots used:  
   `Minimize: sum(y[j] for all j)`  

   **4. Constraints:**  
   - **Ship Assignment:** Each ship must be in exactly one slot:  
     `For each ship i: sum(x[i, j] for all j) = 1`.  
   - **Slot Capacity:** Total time in slot `j` cannot exceed capacity:  
     `For each slot j: sum(ships[i] * x[i, j] for all i) <= capacity * y[j]`.  
   - **Type Linking:** If any ship of type `c` is in slot `j`, `z[c, j]` must be 1:  
     `For each type c and slot j: x[i, j] <= z[c, j] for all i of type c`.  
   - **Type Limit:** Each used slot has at most 2 distinct types:  
     `For each slot j: sum(z[c, j] for all c) <= 2 * y[j]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
ships = [41, 17, 49, 70, 67, 39, 68, 28, 73, 2, 26, 24, 52, 57, 18, 76, 2, 55, 57, 65]      # Berthing times of ships
types = ['Y', 'R', 'J', 'E', 'K', 'X', 'V', 'B', 'I', 'E', 'E', 'R', 'U', 'R', 'I', 'A', 'C', 'I', 'B', 'V']    # Types of ships
capacity = 80         # Slot capacity
num_ships = 20       # len(ships) - derived correctly below
num_slots = num_ships      # Maximum slots (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(ships) != len(types) or len(ships) != num_ships:
    print("Error: Data inconsistency (ships/types/num_ships length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_types_list = sorted(list(set(types))) # Get unique types deterministically
ship_indices_by_type = {type: [i for i, t in enumerate(types) if t == type] for type in unique_types_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Type-Constrained Slot Scheduling", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_ships, num_slots, vtype=GRB.BINARY, name="x")  # x[i,j] -> ship i in slot j
        y = model.addVars(num_slots, vtype=GRB.BINARY, name="y")              # y[j] -> whether slot j is used
        # z[c,j] -> whether type c is PRESENT in slot j (Use unique_types_list for keys)
        z = model.addVars(unique_types_list, num_slots, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of slots used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each ship must be assigned to exactly one slot ---
        for i in range(num_ships):
            model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

        # --- Constraint 2: Slot capacity constraint ---
        for j in range(num_slots):
            model.addConstr(gp.quicksum(ships[i] * x[i, j] for i in range(num_ships)) <= capacity * y[j], name=f"Slot_{j}_Capacity")

        # --- Constraint 3: Type constraint (at most 2 *different* types per slot) ---

        # Part 3a: Link x (ship in slot) and z (type in slot).
        for j in range(num_slots):
            for type in unique_types_list:
                indices_of_this_type = ship_indices_by_type.get(type, []) # Use .get for safety

                if not indices_of_this_type:
                    # If no ships of this type exist, z[type, j] must be 0.
                    model.addConstr(z[type, j] == 0, name=f"NoShips_{type}_Slot_{j}")
                    continue

                # If any ship 'i' of this 'type' is placed in slot 'j' (x[i,j]=1),
                # then the presence indicator for that 'type' in slot 'j' (z[type,j]) must be 1.
                for i in indices_of_this_type:
                    model.addConstr(x[i, j] <= z[type, j], name=f"Link_x{i}_z{type}_Slot{j}")

                # Ensure z[type, j] is 0 if no ships of that type are in the slot.
                # This helps tighten the formulation.
                model.addConstr(z[type, j] <= gp.quicksum(x[i, j] for i in indices_of_this_type), name=f"Link_z{type}_SumX_Slot{j}")


        # Part 3b: Limit the number of distinct types (sum of z[c,j] for slot j) to 2 for USED slots.
        for j in range(num_slots):
            # sum(z[c,j] for c in unique_types_list) gives the count of distinct types in slot j.
            # This sum must be <= 2 *IF* the slot is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Types_Slot_{j}")

        # --- Solve ---
        print("Solving TCS instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_slots = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of slots used: {optimal_slots}")
    print("-" * 30)

    slot_details = []
    printed_slot_count = 0
    for j_sol in range(num_slots): # Iterate through all potential slot indices
        try:
             # Check if this slot was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_slot_count += 1
                 assigned_ships_indices = [i for i in range(num_ships) if x[i, j_sol].X > 0.5]
                 assigned_ships_times = [ships[i] for i in assigned_ships_indices]
                 assigned_ships_types = [types[i] for i in assigned_ships_indices]
                 distinct_types_in_slot = sorted(list(set(assigned_ships_types))) # Sort for consistent output
                 slot_load = sum(assigned_ships_times)

                 print(f"Slot {printed_slot_count} (Internal Index {j_sol}):")
                 print(f"  Ships (indices): {assigned_ships_indices}")
                 # print(f"  Ships (times): {assigned_ships_times}") # Optional details
                 # print(f"  Ships (types):  {assigned_ships_types}") # Optional details
                 print(f"  Distinct Types: {distinct_types_in_slot} (Count: {len(distinct_types_in_slot)})")
                 print(f"  Total time:    {slot_load} / {capacity}")
                 print("-" * 10)

                 slot_data = {
                     'slot_index_internal': j_sol,
                     'slot_index_printed': printed_slot_count,
                     'ship_indices': assigned_ships_indices,
                     'distinct_types': distinct_types_in_slot,
                     'load': slot_load
                 }
                 slot_details.append(slot_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for slot index {j_sol}: {e_print}")


    results_dict['slot_details'] = slot_details # Store details

    # Final sanity check
    if printed_slot_count != optimal_slots:
         print(f"Warning: Number of printed used slots ({printed_slot_count}) does not match objective value ({optimal_slots}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# The code provided already prints the key outputs, including the optimal number of slots used and detailed slot assignments.
# No additional print statements are necessary.
```
Answer:
Solving TCS instance...
------------------------------

Optimal solution found.
Optimal number of slots used: 12
------------------------------
Slot 1 (Internal Index 0):
  Ships (indices): [0, 5]
  Distinct Types: ['X', 'Y'] (Count: 2)
  Total time:    80 / 80
----------
Slot 2 (Internal Index 1):
  Ships (indices): [8]
  Distinct Types: ['I'] (Count: 1)
  Total time:    73 / 80
----------
Slot 3 (Internal Index 4):
  Ships (indices): [15]
  Distinct Types: ['A'] (Count: 1)
  Total time:    76 / 80
----------
Slot 4 (Internal Index 6):
  Ships (indices): [14, 18]
  Distinct Types: ['B', 'I'] (Count: 2)
  Total time:    75 / 80
----------
Slot 5 (Internal Index 9):
  Ships (indices): [7, 12]
  Distinct Types: ['B', 'U'] (Count: 2)
  Total time:    80 / 80
----------
Slot 6 (Internal Index 12):
  Ships (indices): [6, 9]
  Distinct Types: ['E', 'V'] (Count: 2)
  Total time:    70 / 80
----------
Slot 7 (Internal Index 14):
  Ships (indices): [2, 10]
  Distinct Types: ['E', 'J'] (Count: 2)
  Total time:    75 / 80
----------
Slot 8 (Internal Index 15):
  Ships (indices): [19]
  Distinct Types: ['V'] (Count: 1)
  Total time:    65 / 80
----------
Slot 9 (Internal Index 16):
  Ships (indices): [1, 13]
  Distinct Types: ['R'] (Count: 1)
  Total time:    74 / 80
----------
Slot 10 (Internal Index 17):
  Ships (indices): [3, 16]
  Distinct Types: ['C', 'E'] (Count: 2)
  Total time:    72 / 80
----------
Slot 11 (Internal Index 18):
  Ships (indices): [4]
  Distinct Types: ['K'] (Count: 1)
  Total time:    67 / 80
----------
Slot 12 (Internal Index 19):
  Ships (indices): [11, 17]
  Distinct Types: ['I', 'R'] (Count: 2)
  Total time:    79 / 80
----------


```

================================================================================



--- Problem 274 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy maritime port is tasked with efficiently berthing a fleet of nine cargo ships at its two available berths. Each ship arrives at a specific time: Ship 1 at 3 hours, Ship 2 at 7 hours, and so on, with the latest arrival being Ship 9 at 39 hours. The processing times vary significantly—Ship 2 requires 12 hours to unload, while Ships 5 through 9 each need only 4 hours. The port operates within a strict 65-hour horizon, and the goal is to minimize the total delay in berthing the ships, ensuring no two ships occupy the same berth simultaneously. The central question is: *How can the port assign ships to berths and schedule their start times to minimize the total delay while respecting arrival times and avoiding overlaps?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign[i, j]`: Binary (1 if ship *i* is assigned to berth *j*, else 0).  
     - `start_time[i]`: Continuous (start time of ship *i*).  
     - `completion_time[i]`: Continuous (completion time of ship *i*).  
     - `precedes[i, k, j]`: Binary (1 if ship *i* precedes ship *k* on berth *j*, else 0).  

   - **2. Parameters:**  
     - `ships`: [1, 2, ..., 9].  
     - `berths`: [1, 2].  
     - `arrival_times`: {1: 3, 2: 7, ..., 9: 39}.  
     - `processing_times`: {1: 5, 2: 12, ..., 9: 4}.  
     - `horizon`: 65 hours.  
     - `H`: 102 (big-M constant for precedence constraints).  

   - **3. Objective Function:**  
     Minimize total delay:  
     `Minimize: sum((start_time[i] - arrival_times[i]) * assign[i, j] for all i, j)`.  

   - **4. Constraints:**  
     - **Assignment:** Each ship to exactly one berth:  
       `sum(assign[i, j] for j in berths) = 1` for all *i*.  
     - **Arrival Time:** Start time ≥ arrival time:  
       `start_time[i] ≥ arrival_times[i]` for all *i*.  
     - **Completion Time:** `completion_time[i] = start_time[i] + processing_times[i]` for all *i*.  
     - **Non-Overlapping:** For each berth *j*, if ships *i* and *k* are assigned, enforce precedence:  
       `precedes[i, k, j] + precedes[k, i, j] ≥ assign[i, j] + assign[k, j] - 1`,  
       with indicator constraints to ensure temporal separation.  
     - **Horizon Limit:** `completion_time[i] ≤ horizon` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3, 4, 5, 6, 7, 8, 9]
berths = [1, 2]
arrival_times = {1: 3, 2: 7, 3: 14, 4: 16, 5: 22, 6: 23, 7: 31, 8: 35, 9: 39}
processing_times = {1: 5, 2: 12, 3: 9, 4: 5, 5: 4, 6: 6, 7: 4, 8: 4, 9: 4}
horizon = 65
H = 102 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_9_MIN_DELAY")

    if not ships or not berths: raise ValueError("Empty ships or berths")

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(ships, ships, berths, vtype=GRB.BINARY, name="precedes")
    # Optional: use_ship[i]=1 if ship i is served (if not all ships must be served)
    # For this model, assume assign.sum == 1 implies ship is served

    # --- Objective Function ---
    # Minimize total delay of assigned ships
    m.setObjective(gp.quicksum((start_time[i] - arrival_times.get(i, 0)) * assign.sum(i, '*') for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Each ship assigned to at most one berth)
    # Original model used == 1, assuming all ships must try to be berthed
    m.addConstrs((assign.sum(i, '*') == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")

    # 5. Horizon Constraint
    m.addConstrs((completion_time[i] <= horizon for i in ships), name="horizon_limit")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        obj = m.getObjective()
        results_dict['obj_val'] = obj.getValue()

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.2f}") # Total delay
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Ensure All Outputs are Printed ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in ships:
        for j in berths:
            if assign[i, j].x > 0.5:
                print(f"Ship {i} is assigned to Berth {j}")
                print(f"  Start Time: {start_time[i].x:.2f}")
                print(f"  Completion Time: {completion_time[i].x:.2f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
5.00
Optimal Solution Found:
Ship 1 is assigned to Berth 1
  Start Time: 3.00
  Completion Time: 8.00
Ship 2 is assigned to Berth 2
  Start Time: 7.00
  Completion Time: 19.00
Ship 3 is assigned to Berth 1
  Start Time: 14.00
  Completion Time: 23.00
Ship 4 is assigned to Berth 2
  Start Time: 19.00
  Completion Time: 24.00
Ship 5 is assigned to Berth 2
  Start Time: 24.00
  Completion Time: 28.00
Ship 6 is assigned to Berth 1
  Start Time: 23.00
  Completion Time: 29.00
Ship 7 is assigned to Berth 2
  Start Time: 31.00
  Completion Time: 35.00
Ship 8 is assigned to Berth 1
  Start Time: 35.00
  Completion Time: 39.00
Ship 9 is assigned to Berth 1
  Start Time: 39.00
  Completion Time: 43.00


```

================================================================================



--- Problem 275 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
At a busy port, maritime logistics managers need to decide the best method for managing container ship berthing. The choice is between implementing a *dedicated berth* (ensuring safety and efficiency but at a higher operational cost) or a *shared berth* (allowing ships to dock during gaps in the schedule, which risks delays but reduces direct costs). The dedicated berth incurs a fixed cost of $43 per hour, reflecting infrastructure and operational adjustments. Conversely, the shared berth introduces an estimated delay penalty of $121 per hour, accounting for ship wait times and potential congestion spillover. The challenge is clear: **Which option—dedicated or shared berth—minimizes the total cost while maintaining acceptable port operations?**
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y_dedicated`: Binary variable where `y_dedicated = 1` if the dedicated berth is selected, and `0` if the shared berth is chosen.  
   - **2. Parameters:**  
     - `cost_dedicated_berth = 43`: Hourly cost of implementing the dedicated berth.  
     - `cost_shared_delay = 121`: Hourly penalty cost due to delays under the shared berth.  
   - **3. Objective Function:**  
     Minimize the total cost:  
     ```  
     Minimize: y_dedicated * cost_dedicated_berth + (1 - y_dedicated) * cost_shared_delay  
     ```  
   - **4. Constraints:**  
     None (unconstrained binary selection).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cost_dedicated_berth = 43 # Proxy cost/hr
cost_shared_delay = 121 # Proxy penalty/hr
# --- End Parameters ---

GUROBI_TIME_LIMIT = 5

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m36 = gp.Model("SHIP_BERTHING_DECISION_IP", env=env)

    # --- Decision Variables ---
    # Binary: y_dedicated = 1 if dedicated berth is chosen, 0 otherwise
    y_dedicated = m36.addVar(vtype=GRB.BINARY, name="use_dedicated_berth")

    # --- Objective Function ---
    # Minimize total cost = cost of chosen berth
    m36.setObjective(y_dedicated * cost_dedicated_berth + (1 - y_dedicated) * cost_shared_delay, sense=GRB.MINIMIZE)

    # --- Constraints: None ---

    # --- Optimization ---
    m36.optimize()

    # --- Store results ---
    results_dict['status'] = m36.status
    if m36.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m36.ObjVal
        results_dict['y_dedicated_sol'] = y_dedicated.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 36: Port Ship Berthing Decision (IP) ---") # Original problem number
    if m36.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        use_dedicated = results_dict.get('y_dedicated_sol', 0) > 0.5

        print(f"Optimization Status: Optimal")
        print(f"Optimal Decision: {'Use Dedicated Berth' if use_dedicated else 'Use Shared Berth'}")
        print(f"  Cost of Dedicated Berth: ${float(cost_dedicated_berth):.2f}")
        print(f"  Estimated Cost of Shared Berth (due to delay): ${float(cost_shared_delay):.2f}")
        print(f"Minimum Estimated Cost: ${float(obj_val_print):.2f}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m36.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 36: Port Ship Berthing Decision (IP) ---
Optimization Status: Optimal
Optimal Decision: Use Dedicated Berth
  Cost of Dedicated Berth: $43.00
  Estimated Cost of Shared Berth (due to delay): $121.00
Minimum Estimated Cost: $43.00


```

================================================================================



--- Problem 276 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the harbor master is tasked with coordinating the berthing times for two ships to minimize the total waiting time. The port operates with a fixed cycle time of 12 hours, divided into two distinct berthing slots. Each slot must allocate a berthing duration between 6 and 12 hours, ensuring smooth ship operations while adhering to the rigid cycle constraint. The urgency coefficients—1018 for the first slot and 2120 for the second—reflect the relative importance of each ship, with higher values indicating greater priority. The core dilemma is determining the exact berthing duration for each slot that minimizes the total waiting time experienced by all ships, calculated as the sum of urgency-weighted idle times (the difference between cycle time and berthing time). The harbor master must balance these competing demands to achieve the most efficient port operations possible under the given constraints.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `t[i]`: Continuous variable representing the berthing time (in hours) allocated to slot `i`, where `i ∈ {0, 1}` (for 2 slots). Each `t[i]` is bounded between 6 and 12 hours.  

   **2. Parameters:**  
   - `urgency_coeffs = [1018, 2120]`: Urgency coefficients for each slot, quantifying waiting sensitivity.  
   - `cycle_time = 12`: Total fixed cycle duration (hours).  
   - `lb_time = 6`, `ub_time = 12`: Lower/upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize the total waiting time:  
   `Minimize: sum(urgency_coeffs[i] * (cycle_time - t[i]) for i in [0, 1])`.  

   **4. Constraints:**  
   - **Cycle time constraint:** The sum of berthing times must equal the cycle time:  
     `t[0] + t[1] == cycle_time`.  
   - **Variable bounds:** `6 ≤ t[i] ≤ 12` for each slot `i`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_slots = 2
lb_time = 6          # Lower bound for berthing time
ub_time = 12         # Upper bound for berthing time
cycle_time = 12      # Total cycle time (set equal to ub_time)
urgency_coeffs = [1018, 2120] # Urgency coefficients per slot
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(urgency_coeffs) != num_slots:
    print("Error: urgency_coeffs length mismatch with num_slots")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: urgency_coeffs length"
    # raise ValueError("urgency_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_slots}-Slot Berthing Scheduling", env=env)

        # --- Decision variables (dynamic based on num_slots) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_slots, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for slot i is proportional to urgency * idle_time = urgency * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(urgency_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_slots)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_slots)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_slots)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_slots):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 18828.00
------------------------------
Optimal berthing times (hours):
  t1: 6.00, t2: 6.00


```

================================================================================



--- Problem 277 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy port, a logistics manager is tasked with efficiently loading 26 containers of varying weights onto the fewest possible ships, each with a strict capacity limit of 8 units. The containers, weighing [5, 7, 4, 4, 3, 1, 6, 4, 5, 5, 6, 5, 3, 8, 7, 3, 2, 1, 3, 6, 3, 3, 6, 2, 7, 8], range from lightweight (1 unit) to heavy (8 units). The manager must ensure every container is assigned to exactly one ship without exceeding the ship’s capacity, while minimizing the total number of ships used. This problem mirrors real-world scenarios like shipping container optimization or warehouse storage, where space is costly and efficiency is paramount. The core question: *What is the minimal number of ships required to load all containers without violating capacity constraints?*
**

**Modeling Process:**
**
- **Decision Variables:**  
     - Binary variable `x[i, j]`: Equals 1 if container `i` is assigned to ship `j`, else 0.  
     - Binary variable `y[j]`: Equals 1 if ship `j` is used (contains at least one container), else 0.  
   - **Parameters:**  
     - `containers[i]`: Weight of container `i` (given list).  
     - `capacity`: Maximum weight per ship (8 units).  
     - `num_containers`: Total containers (26).  
     - `num_ships`: Upper bound of ships (26, one per container).  
   - **Objective Function:**  
     Minimize the total number of ships used:  
     \[
     \text{Minimize: } \sum_{j=1}^{\text{num\_ships}} y[j]
     \]  
   - **Constraints:**  
     1. **Container Assignment:** Each container must be in exactly one ship:  
        \[
        \sum_{j=1}^{\text{num\_ships}} x[i, j] = 1 \quad \forall i \in \{1, \dots, \text{num\_containers}\}
        \]  
     2. **Ship Capacity:** The total weight in any used ship `j` cannot exceed `capacity`:  
        \[
        \sum_{i=1}^{\text{num\_containers}} \text{containers}[i] \cdot x[i, j] \leq \text{capacity} \cdot y[j] \quad \forall j \in \{1, \dots, \text{num\_ships}\}
        \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB

# --- Data Definition ---
containers = [5, 7, 4, 4, 3, 1, 6, 4, 5, 5, 6, 5, 3, 8, 7, 3, 2, 1, 3, 6, 3, 3, 6, 2, 7, 8]      # Weights of containers
capacity = 8           # Ship capacity
num_containers = 26     # len(containers)
num_ships = num_containers    # Maximum number of ships (worst case: one container per ship)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Time limit
# env.setParam('TimeLimit', 30)
env.start()

# Create Model
model = Model("Ship Loading Problem", env=env)

# --- Decision Variables ---
# x[i,j]: container i is assigned to ship j
x = model.addVars(num_containers, num_ships, vtype=GRB.BINARY, name="x")
# y[j]: ship j is used
y = model.addVars(num_ships, vtype=GRB.BINARY, name="y")

# --- Objective: Minimize the number of ships used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)

# --- Constraints ---
# 1. Each container must be assigned to exactly one ship
for i in range(num_containers):
    model.addConstr(x.sum(i, '*') == 1, name=f"Container_{i}_Assignment")

# 2. Ship capacity constraint: sum of weights in ship j <= capacity IF ship j is used (y[j]=1)
for j in range(num_ships):
    model.addConstr(gp.quicksum(containers[i] * x[i, j] for i in range(num_containers)) <= capacity * y[j], name=f"Ship_{j}_Capacity")

# --- Solve ---
print("Solving 1DBP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_ships = int(results_dict.get('obj_val', -1))
    print(f"\nOptimal number of ships used: {optimal_ships}")
    print("-" * 30)
    ship_details = []
    for j_sol in range(num_ships): # Loop through potential ships
        # Check if the ship variable y[j_sol] exists and is set to 1
        # Using .X requires Gurobi v9+ and that the variable is in the solution
        try:
            if y[j_sol].X > 0.5: # Check if ship j_sol is used
                # Find containers assigned to this ship j_sol
                assigned_containers_indices = [i for i in range(num_containers) if x[i, j_sol].X > 0.5]
                assigned_containers_weights = [containers[i] for i in assigned_containers_indices]
                ship_load = sum(assigned_containers_weights)
                print(f"Ship {j_sol + 1} (Load: {ship_load}/{capacity}): Containers (indices): {assigned_containers_indices}")
                # Optional: Print weights too
                # print(f"  Weights: {assigned_containers_weights}")
                ship_details.append({'ship_index': j_sol, 'container_indices': assigned_containers_indices, 'load': ship_load})
        except AttributeError:
            # This might happen if y[j_sol] was optimized to 0 and doesn't have an .X value
            # Or if the model was infeasible/not solved optimally.
            # Since we check for OPTIMAL status first, this is less likely for y,
            # but could happen if x[i, j_sol] is 0. The check x[i,j_sol].X > 0.5 handles this.
            pass # Just skip if variable/attribute doesn't exist for unused ships/containers
    results_dict['ship_details'] = ship_details # Store details
    print("-" * 30)

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount to see if a feasible solution was found
     if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
     else: print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 1DBP instance...

Optimal number of ships used: 16
------------------------------
Ship 1 (Load: 8/8): Containers (indices): [8, 21]
Ship 2 (Load: 8/8): Containers (indices): [10, 23]
Ship 4 (Load: 8/8): Containers (indices): [11, 12]
Ship 5 (Load: 8/8): Containers (indices): [3, 7]
Ship 6 (Load: 3/8): Containers (indices): [20]
Ship 9 (Load: 8/8): Containers (indices): [1, 17]
Ship 13 (Load: 6/8): Containers (indices): [19]
Ship 14 (Load: 8/8): Containers (indices): [0, 18]
Ship 16 (Load: 7/8): Containers (indices): [14]
Ship 17 (Load: 7/8): Containers (indices): [24]
Ship 20 (Load: 8/8): Containers (indices): [4, 9]
Ship 21 (Load: 8/8): Containers (indices): [25]
Ship 23 (Load: 7/8): Containers (indices): [5, 6]
Ship 24 (Load: 7/8): Containers (indices): [2, 15]
Ship 25 (Load: 8/8): Containers (indices): [16, 22]
Ship 26 (Load: 8/8): Containers (indices): [13]
------------------------------


```

================================================================================



--- Problem 278 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy container terminal is preparing to handle 96 incoming trucks. The terminal has three distinct unloading zones (Zones A, B, and C), each with its own capacity and current availability. Zone A has 53 empty slots, Zone B has 9, and Zone C has 71. Directing trucks to these zones incurs different costs: $6 per truck for Zone A, $10 for Zone B, and $11 for Zone C. The terminal manager faces the challenge of assigning all incoming trucks to these zones while minimizing the total direction cost. The critical question is: *How should the trucks be distributed across the three zones to achieve the lowest possible total cost, ensuring no zone exceeds its available empty slots?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( n_i \) represent the number of trucks assigned to Zone \( i \), where \( i \in \{A, B, C\} \). Each \( n_i \) is a non-negative integer.  
   - **2. Parameters:**  
     - **Empty Slots:** \( \text{empty\_slots}_A = 53 \), \( \text{empty\_slots}_B = 9 \), \( \text{empty\_slots}_C = 71 \).  
     - **Direction Costs:** \( \text{cost}_A = 6 \), \( \text{cost}_B = 10 \), \( \text{cost}_C = 11 \).  
     - **Total Arriving Trucks:** \( \text{arriving\_trucks} = 96 \).  
   - **3. Objective Function:**  
     - Minimize the total direction cost:  
       \[ \text{Minimize: } 6n_A + 10n_B + 11n_C \]  
   - **4. Constraints:**  
     - **Total Assignment:** The sum of assigned trucks must equal the arriving trucks:  
       \[ n_A + n_B + n_C = 96 \]  
     - **Zone Capacity:** Assignments cannot exceed empty slots for each zone:  
       \[ n_A \leq 53, \quad n_B \leq 9, \quad n_C \leq 71 \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
zones = ['A', 'B', 'C']
capacity = {'A': 138, 'B': 111, 'C': 143} # For context
empty_slots = {'A': 53, 'B': 9, 'C': 71}
arriving_trucks = 96
direction_cost = {'A': 6, 'B': 10, 'C': 11} # Cost per truck directed to zone i
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("TRUCK_ZONE_DIRECTION", env=env)

    # --- Input Validation ---
    if not zones: raise ValueError("Empty zones list")
    if arriving_trucks < 0: raise ValueError("Arriving trucks cannot be negative")
    if sum(empty_slots.get(i, 0) for i in zones) < arriving_trucks:
        # This case should be prevented by generator, but double-check
        print("Warning: Total empty slots less than arriving trucks, likely infeasible.")
        # raise ValueError("Total empty slots less than arriving trucks")


    # --- Decision Variables ---
    # n[i]: number of trucks assigned to zone i
    n = m.addVars(zones, vtype=GRB.INTEGER, lb=0, name="n")

    # --- Objective Function: Minimize total direction cost ---
    m.setObjective(gp.quicksum(direction_cost.get(i, 0) * n[i] for i in zones), GRB.MINIMIZE)

    # --- Constraints ---
    # Total number of assigned trucks must equal arriving trucks
    m.addConstr(gp.quicksum(n[i] for i in zones) == arriving_trucks, "TotalTrucks")

    # Number of assigned trucks cannot exceed empty slots on each zone
    m.addConstrs((n[i] <= empty_slots.get(i, 0) for i in zones), "ZoneCapacity")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_sol'] = m.getAttr('X', n) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible. Not enough total capacity for arriving trucks.") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the number of trucks assigned to each zone
if m.Status == GRB.OPTIMAL:
    for i in zones:
        print(f"Number of trucks assigned to Zone {i}: {n[i].X}")
```
Answer:
Optimal objective value: 782.00
Number of trucks assigned to Zone A: 53.0
Number of trucks assigned to Zone B: 9.0
Number of trucks assigned to Zone C: 34.0


```

================================================================================



--- Problem 279 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
**
A port operator faces the challenge of dynamically pricing berthing fees during different traffic periods to maximize revenue while respecting berth capacity limits. The port experiences two distinct periods: "off-peak" with a base demand of 966 ships per hour and "peak" with a significantly higher base demand of 2893 ships per hour. The operator can adjust berthing fees up to a maximum of $6 per ship, with demand sensitivity (alpha) set at 38 ships per hour for every dollar increase in berthing fee. The port's capacity is fixed at 1638 ships per hour, meaning the number of ships that can be berthed cannot exceed this limit regardless of demand.  

The core question is: What berthing fees should be set during off-peak and peak periods to maximize total revenue, ensuring that the resulting number of ships does not exceed capacity and that demand responds linearly to fee changes? The operator must balance higher fees (which reduce demand but increase revenue per ship) against lower fees (which attract more ships but may not fully utilize capacity).

---

**Modeling Process:**
**
**1. Decision Variables:**  
- `fee[p]`: Berthing fee (in $) for period `p` (where `p` is either "off" or "peak"). Bounded between 0 and `max_fee` ($6).  
- `demand[p]`: Resulting demand (ships/hr) for period `p`, calculated as `base_demand[p] - alpha * fee[p]`.  
- `flow[p]`: Actual number of ships (ships/hr) for period `p`, constrained by both demand and capacity.  

**2. Parameters:**  
- `capacity = 1638`: Maximum flow capacity (ships/hr).  
- `base_demand = {'off': 966, 'peak': 2893}`: Base demand (ships/hr) when fees are $0.  
- `alpha = 38`: Demand sensitivity (ships/hr per $1 fee increase).  
- `max_fee = 6`: Upper bound on berthing fee ($).  

**3. Objective Function:**  
Maximize total revenue:  
`Maximize: sum(flow[p] * fee[p] for p in periods)`  

**4. Constraints:**  
- Demand calculation for each period `p`:  
  `demand[p] == base_demand[p] - alpha * fee[p]`  
- Flow cannot exceed capacity:  
  `flow[p] <= capacity`  
- Flow cannot exceed demand:  
  `flow[p] <= demand[p]`  
- Non-negativity:  
  `fee[p], demand[p], flow[p] >= 0`  

---

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 1638; base_demand = {'off': 966, 'peak': 2893}; alpha = 38; max_fee = 6; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berthing_Fee_Pricing_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berthing Fee Pricing (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of TOLL_PRICING
```
Answer:
--- Problem 18: Dynamic Berthing Fee Pricing (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $14256.00
  Period: Off
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 738.0 ships/hr (Base: 966)
    Actual Flow (min(Demand, Capacity)): 738.0 ships/hr (Capacity: 1638)
    Revenue this period: $4428.00
  Period: Peak
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 2665.0 ships/hr (Base: 2893)
    Actual Flow (min(Demand, Capacity)): 1638.0 ships/hr (Capacity: 1638)
    Revenue this period: $9828.00
Total ships processed: 2376.0



================================================================================


--- Problem 280 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port handles heavy traffic flows from two competing directions: Direction A with 596 container ships per hour and Direction B with 553 container ships per hour. The port's traffic signal must efficiently allocate green time to both directions while adhering to strict operational constraints. The total cycle time for the signal is fixed at 160 seconds, but each phase transition incurs a 6-second loss due to yellow and all-red clearance times. Additionally, safety regulations mandate a minimum green time of 21 seconds for each direction. The challenge is to distribute the available green time between the two directions in a way that maximizes the overall flow efficiency, weighted by their respective traffic volumes. The core question is: *How should the green times be allocated to maximize the total weighted flow while respecting the cycle time and minimum green constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `g_A`: Green time allocated to Direction A (continuous, ≥ 21 seconds).  
     - `g_B`: Green time allocated to Direction B (continuous, ≥ 21 seconds).  
   - **2. Parameters:**  
     - `cycle_time = 160`: Total signal cycle time (seconds).  
     - `lost_time = 6`: Time lost per phase transition (seconds).  
     - `min_green = 21`: Minimum green time for each direction (seconds).  
     - `flow_A = 596`: Traffic flow for Direction A (ships/hour).  
     - `flow_B = 553`: Traffic flow for Direction B (ships/hour).  
   - **3. Objective Function:**  
     Maximize the weighted sum of green times:  
     `Maximize: flow_A * g_A + flow_B * g_B`.  
   - **4. Constraints:**  
     - Cycle time constraint: `g_A + lost_time + g_B + lost_time = cycle_time`.  
     - Minimum green time: `g_A ≥ min_green`, `g_B ≥ min_green`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cycle_time = 160 # seconds
lost_time = 6 # seconds per phase (yellow + all_red)
min_green = 21 # seconds
flow_A = 596 # ships per hour
flow_B = 553 # ships per hour
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_SIGNAL_TIMING", env=env)

    # --- Decision Variables ---
    # g_A: green time for direction A (seconds)
    g_A = m.addVar(lb=min_green, vtype=GRB.CONTINUOUS, name="g_A")
    # g_B: green time for direction B (seconds)
    g_B = m.addVar(lb=min_green, vtype=GRB.CONTINUOUS, name="g_B")

    # --- Objective Function: Maximize flow-weighted green time ---
    m.setObjective(flow_A * g_A + flow_B * g_B, GRB.MAXIMIZE)

    # --- Constraints ---
    # Cycle time constraint: sum of green times + lost times = cycle time
    m.addConstr(g_A + lost_time + g_B + lost_time == cycle_time, "CycleTimeConstraint")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['g_A_sol'] = g_A.X # Not needed for output
        # results_dict['g_B_sol'] = g_B.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}") # Weighted value
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the green times for each direction
if m.Status == GRB.OPTIMAL:
    print(f"Optimal objective value: {obj_val_print:.2f}")
    print(f"Green time for Direction A: {g_A.X:.2f} seconds")
    print(f"Green time for Direction B: {g_B.X:.2f} seconds")
```
Answer:
Optimal objective value: 87305.00
Optimal objective value: 87305.00
Green time for Direction A: 127.00 seconds
Green time for Direction B: 21.00 seconds


```

================================================================================



--- Problem 281 ---
**Difficulty:** easy
**Category:** MIP

**Problem Description:**
**
A logistics company operates a single delivery truck (capacity: 90 units) to serve one customer location from a central depot. The customer demand is 70 units, and the travel distances are symmetric: 20 units from the depot to the customer and vice versa. The goal is to design the most efficient delivery route that minimizes total travel distance while ensuring the truck’s capacity is not exceeded. The challenge is to determine whether the truck should visit the customer and return to the depot, or if an alternative (but here, trivial) route exists. Given the small problem size, the solution must balance operational efficiency with strict adherence to capacity constraints.
**

**Modeling Process:**
**
- **Decision Variables:**  
     - Binary variable \(x_{i,j,k}\): Equals 1 if truck \(k\) travels directly from node \(i\) to node \(j\), else 0.  
     - Continuous variable \(u_i\) (for subtour elimination): Represents the sequence of node \(i\) in the route (only relevant for problems with >2 nodes).  
   - **Parameters:**  
     - \(N = 2\): Total nodes (depot: 0, customer: 1).  
     - \(K = 1\): Number of trucks.  
     - \(d_{i,j}\): Distance matrix (e.g., \(d_{0,1} = 20\)).  
     - \(q = [0, 70]\): Demand at nodes (depot: 0, customer: 70).  
     - \(Q = [90]\): Truck capacity.  
   - **Objective Function:**  
     Minimize total distance: \(\text{Minimize} \sum_{k=0}^{K-1} \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} d_{i,j} \cdot x_{i,j,k}\).  
   - **Constraints:**  
     1. **Customer Visit:** The customer (node 1) must be visited exactly once.  
     2. **Flow Conservation:** Inflow equals outflow for each node and truck.  
     3. **Depot Departure/Return:** The truck must leave and return to the depot (node 0).  
     4. **Capacity:** Total demand on the route \(\leq\) truck capacity (70 ≤ 90).  
     5. **Subtour Elimination (MTZ):** Not activated here (only for \(N > 2\)).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 2
K = 1
Q = [90]
q = [0, 70]
d = [
    [0, 20],
    [20, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Vehicle Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for vehicle {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for vehicle {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 40.00

Route for vehicle 1 (Capacity: 90):
0 -> 1 -> 0
Route Load: 70 / 90


```

================================================================================



--- Problem 282 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently packing 13 items of varying weights into a selection of 7 available truck types, each with a unique capacity and cost. The items weigh [6, 23, 51, 20, 16, 43, 81, 80, 45, 90, 8, 40, 76] units, and the trucks have capacities and costs as follows: Truck 0 (94 units, $21), Truck 1 (98 units, $70), Truck 2 (95 units, $54), Truck 3 (90 units, $29), Truck 4 (100 units, $94), Truck 5 (99 units, $58), and Truck 6 (100 units, $1). The challenge is to assign each item to exactly one truck without exceeding the truck's capacity while minimizing the total cost of the trucks used. The problem mirrors real-world scenarios like delivery routing, where selecting the right combination of trucks (bins) to hold various goods (items) at the lowest possible cost is critical. The key question is: **What is the most cost-effective way to pack all items into the trucks while respecting their capacities?**
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether item `i` is assigned to truck `j` (1 if assigned, 0 otherwise).  
   - `y[j]`: Binary variable indicating whether truck `j` is used (1 if used, 0 otherwise).  

   **2. Parameters:**  
   - `items[i]`: Weight of item `i` (given list).  
   - `trucks[j]`: Tuple `(capacity, cost)` for truck `j`.  

   **3. Objective Function:**  
   Minimize the total cost of used trucks:  
   `Minimize: sum(y[j] * trucks[j][1] for all j)`  

   **4. Constraints:**  
   - **Item Assignment:** Each item must be assigned to exactly one truck:  
     `For each item i: sum(x[i, j] for all j) = 1`  
   - **Truck Capacity:** The total weight of items in a truck cannot exceed its capacity:  
     `For each truck j: sum(items[i] * x[i, j] for all i) <= trucks[j][0] * y[j]`  
   - **Linking Constraint:** An item can only be assigned to a truck if the truck is used:  
     `For each item i and truck j: x[i, j] <= y[j]`  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys # Make sys available inside exec if needed, e.g. for print traceback
import traceback

# --- Data Definition (Embedded) ---
items = [6, 23, 51, 20, 16, 43, 81, 80, 45, 90, 8, 40, 76]      # Item weights
trucks = [(94, 21), (98, 70), (95, 54), (90, 29), (100, 94), (99, 58), (100, 1)]        # List of (Capacity, Cost) tuples
num_items = 13       # len(items)
num_trucks = 7         # len(trucks)
# --- End Data Definition ---

# Time limit (passed from outer scope via globals if needed, or hardcoded)
GUROBI_TIME_LIMIT = 60

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Keep output clean for saving
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Cost-Sensitive BPP", env=env)

    # --- Decision Variables ---
    x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")

    # --- Objective: Minimize total cost ---
    model.setObjective(gp.quicksum(y[j] * trucks[j][1] for j in range(num_trucks)), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Each item assignment
    for i in range(num_items):
        model.addConstr(x.sum(i, '*') == 1, name=f"Item_{i}_Assignment")

    # 2. Truck capacity
    for j in range(num_trucks):
        truck_capacity = trucks[j][0]
        if truck_capacity < 0: truck_capacity = 0
        model.addConstr(gp.quicksum(items[i] * x[i, j] for i in range(num_items)) <= truck_capacity * y[j], name=f"Truck_{j}_Capacity")

    # 3. Linking item to truck usage
    for i in range(num_items):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Item_{i}_Triggers_Truck_{j}")

    # --- Solve ---
    # print("Solving CS-BPP instance...") # Comment out or keep for debug inside output
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal

    # --- Output results (This will be captured) ---
    # This logic needs to be *inside* the template now
    if model.status == GRB.OPTIMAL:
        print(f"Minimum cost: ${model.objVal:.2f}") # Use model.objVal directly
        print("-" * 30) # Add separator for clarity
        printed_truck_count = 0
        for j in range(num_trucks):
            # Use try-except for safety when accessing .X
            try:
                 if y[j].x > 0.5:
                     printed_truck_count += 1
                     truck_capacity_out, truck_cost_out = trucks[j]
                     assigned_items = [i for i in range(num_items) if x[i, j].x > 0.5]
                     truck_load_out = sum(items[i] for i in assigned_items)
                     # Format output exactly as desired for the log file
                     print(f"Truck {printed_truck_count} (Type Index {j}, Capacity: {truck_capacity_out}, Cost: ${truck_cost_out:.2f}):")
                     print(f"  Load: {truck_load_out} / {truck_capacity_out}")
                     print(f"  Items (indices): {sorted(assigned_items)}") # Sort for consistency
                     print("-" * 10) # Separator between trucks
            except AttributeError:
                 pass # Ignore trucks not used or if .X attribute missing
    elif model.status == GRB.TIME_LIMIT:
        print("\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: ${model.ObjVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {model.status}")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}") # Print errors to captured output
    results_dict['status'] = -1 # Use dict to signal error type to main loop
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:") # Print errors
    traceback.print_exc(file=sys.stdout) # Print traceback to captured stdout
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Minimum cost: $273.00
------------------------------
Truck 1 (Type Index 0, Capacity: 94, Cost: $21.00):
  Load: 94 / 94
  Items (indices): [0, 5, 8]
----------
Truck 2 (Type Index 1, Capacity: 98, Cost: $70.00):
  Load: 97 / 98
  Items (indices): [4, 6]
----------
Truck 3 (Type Index 3, Capacity: 90, Cost: $29.00):
  Load: 90 / 90
  Items (indices): [9]
----------
Truck 4 (Type Index 4, Capacity: 100, Cost: $94.00):
  Load: 100 / 100
  Items (indices): [3, 7]
----------
Truck 5 (Type Index 5, Capacity: 99, Cost: $58.00):
  Load: 99 / 99
  Items (indices): [2, 10, 11]
----------
Truck 6 (Type Index 6, Capacity: 100, Cost: $1.00):
  Load: 99 / 100
  Items (indices): [1, 12]
----------


```

================================================================================



--- Problem 283 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port with four berths is experiencing recurring incidents that reduce the berthing capacity, causing significant delays for ships. Each berth has distinct characteristics: normal and reduced capacities (e.g., Berth 1 can handle 3,632 TEUs/hour normally but drops to 1,383 TEUs during incidents), alternative route capacities (1,200–1,855 TEUs/h), and varying arrival rates (2,128–4,967 TEUs/h) across six 30-minute time periods. Incidents last between 0.82 and 1.33 hours, diverting ships to slower alternative routes with added travel times (0.15–0.22 hours). Port managers must dynamically assign diversion ratios (10%, 30%, 50%, or 70%) to minimize total delay, balancing queue buildup on the main berths against slower alternative routes. The challenge is to determine the optimal diversion strategy for each berth and time period, ensuring no route exceeds capacity while minimizing cumulative delays—a complex trade-off between immediate congestion and prolonged travel times.
**

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variables \( y(i, t, k) \): 1 if diversion option \( k \) (10%, 30%, 50%, 70%) is selected for berth \( i \) in time period \( t \); 0 otherwise.  

**2. Parameters:**  
- \( \text{arrival_rates}[i][t] \): TEUs arriving at berth \( i \) in period \( t \) (e.g., 2,893 TEUs/h for Berth 1, Period 1).  
- \( \text{capacities_main_normal}[i] \), \( \text{capacities_main_reduced}[i] \): Normal/reduced main berth capacities (e.g., 3,632/1,383 TEUs/h for Berth 1).  
- \( \text{capacities_alt}[i] \): Alternative route capacity (e.g., 1,200 TEUs/h for Berth 1).  
- \( \text{alt_route_extra_times}[i] \): Additional travel time on alternative routes (e.g., 0.15 hours for Berth 1).  
- \( \text{TIME_PERIOD_LENGTH} = 0.5 \) hours.  
- \( \text{LARGE_DELAY} = 10^{12} \): Penalty for infeasible options.  

**3. Objective Function:**  
Minimize total delay:  
\[
\sum_{i,t,k} y(i,t,k) \cdot \text{berth_period_option_delays}[i][t][k]
\]  
where delays combine queueing (if main berth flow exceeds reduced capacity) and alternative route delays.  

**4. Constraints:**  
- **Feasibility:** For each berth \( i \) and period \( t \), exactly one feasible diversion option \( k \) must be selected:  
  \[
  \sum_{k \in \text{feasible\_indices}} y(i,t,k) = 1
  \]  
- **Infeasibility:** \( y(i,t,k) = 0 \) if the option \( k \) violates capacity constraints (alternative route or non-dissipating main berth queue).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 4
NUM_TIME_PERIODS = 6
TIME_PERIOD_LENGTH = 0.5  # h
capacities_main_normal = [3632, 3809, 4449, 3980]  # TEUs/h
capacities_main_reduced = [1383, 2448, 2759, 1230]  # TEUs/h
capacities_alt = [1200, 1401, 1236, 1855]  # TEUs/h
arrival_rates = [[2893, 4767, 4637, 2376, 4217, 3595], [3563, 4256, 4807, 3127, 2128, 4940], [2407, 3821, 4976, 2729, 2515, 4051], [4524, 4717, 2212, 2449, 3488, 2350]]  # TEUs/h
incident_durations = [1.134384177757958, 1.292995240320915, 0.8208898450476066, 1.3299306633582981]  # h
alt_route_extra_times = [0.14988516437164895, 0.22374015541008674, 0.20846918221949284, 0.19497940097145705]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Route Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Route Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_route_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:

Berth 1:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 2 (50%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 1 (30%)

Berth 2:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)

Berth 3:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 1 (30%)

Berth 4:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 2 (50%)
  Period 4 (1.5-2.0h): Option 2 (50%)
  Period 5 (2.0-2.5h): Option 2 (50%)
  Period 6 (2.5-3.0h): Option 2 (50%)



================================================================================



--- Problem 284 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
A logistics company is tasked with efficiently loading a fleet of 42 trucks onto four available depots (Depot_A, Depot_B, Depot_C, and Depot_D) while adhering to strict space and weight constraints. Each truck has a unique weight and occupies a specific amount of depot space, both of which vary significantly across the fleet. For instance, Truck 0 weighs 3.6 units and takes up 1.7 space units, while Truck 36 is the lightest at 1.0 weight unit but still requires 1.0 space unit. The depots themselves have differing capacities: Depot_A can hold up to 5.9 space units and 11.1 weight units, whereas Depot_C is the most spacious, accommodating 9.6 space units and 15.9 weight units.  

The challenge lies in maximizing the number of trucks loaded into the depots without exceeding any depot’s capacity. The company must decide which trucks to assign to which depots, ensuring no truck is split across multiple depots and that the combined weight and space of trucks in each depot stay within limits. With tight operational margins and a need to transport as many trucks as possible in a single trip, the central question is: *What is the optimal assignment of trucks to depots that maximizes the total number of loaded trucks while respecting all constraints?*  

---

**Modeling Process:**
- **1. Decision Variables:**  
     - Binary variable \( x(i, d) \): Equals 1 if truck \( i \) is assigned to depot \( d \), and 0 otherwise.  
     - Indices: \( i \in \text{trucks} \) (0 to 41), \( d \in \text{depots} \) (Depot_A, Depot_B, Depot_C, Depot_D).  

   - **2. Parameters:**  
     - \( \text{weights}[i] \): Weight of truck \( i \) (e.g., 3.6 for truck 0).  
     - \( \text{spaces}[i] \): Space occupied by truck \( i \) (e.g., 1.7 for truck 0).  
     - \( \text{depot\_capacity}[d] \): Maximum space for depot \( d \) (e.g., 5.9 for Depot_A).  
     - \( \text{depot\_weight\_limit}[d] \): Maximum weight for depot \( d \) (e.g., 11.1 for Depot_A).  

   - **3. Objective Function:**  
     - Maximize the total number of trucks loaded:  
       \[
       \text{Maximize: } \sum_{i, d} x(i, d)
       \]  

   - **4. Constraints:**  
     - **Single assignment:** Each truck is assigned to at most one depot:  
       \[
       \sum_{d} x(i, d) \leq 1 \quad \forall i \in \text{trucks}
       \]  
     - **Depot space limits:** Total space used per depot must not exceed capacity:  
       \[
       \sum_{i} \text{spaces}[i] \cdot x(i, d) \leq \text{depot\_capacity}[d] \quad \forall d \in \text{depots}
       \]  
     - **Depot weight limits:** Total weight per depot must not exceed limit:  
       \[
       \sum_{i} \text{weights}[i] \cdot x(i, d) \leq \text{depot\_weight\_limit}[d] \quad \forall d \in \text{depots}
       \]  

---

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41] # List of truck indices
weights = {0: 3.6, 1: 1.3, 2: 1.7, 3: 1.9, 4: 1.4, 5: 1.6, 6: 3.1, 7: 1.4, 8: 1.3, 9: 1.2, 10: 1.7, 11: 1.7, 12: 1.9, 13: 2.0, 14: 1.7, 15: 1.7, 16: 1.4, 17: 3.2, 18: 1.1, 19: 3.2, 20: 1.6, 21: 1.6, 22: 1.9, 23: 3.8, 24: 1.1, 25: 1.1, 26: 1.1, 27: 1.8, 28: 4.0, 29: 4.0, 30: 2.0, 31: 3.8, 32: 1.2, 33: 2.2, 34: 1.8, 35: 1.6, 36: 1.0, 37: 2.2, 38: 2.9, 39: 1.5, 40: 1.4, 41: 3.3}   # Dict: truck -> weight
spaces = {0: 1.7, 1: 1.1, 2: 1.1, 3: 1.2, 4: 0.9, 5: 1.1, 6: 1.6, 7: 1.0, 8: 1.0, 9: 1.2, 10: 0.8, 11: 1.2, 12: 1.0, 13: 1.0, 14: 1.2, 15: 0.8, 16: 1.1, 17: 2.4, 18: 1.1, 19: 2.0, 20: 1.0, 21: 1.0, 22: 1.0, 23: 2.3, 24: 1.1, 25: 0.9, 26: 0.9, 27: 1.1, 28: 2.3, 29: 1.6, 30: 0.9, 31: 2.2, 32: 0.9, 33: 2.2, 34: 1.1, 35: 0.9, 36: 1.0, 37: 2.3, 38: 2.2, 39: 0.9, 40: 1.1, 41: 2.1}     # Dict: truck -> space units
depots = ['Depot_A', 'Depot_B', 'Depot_C', 'Depot_D']       # List of depot names
depot_capacity = {'Depot_A': 5.9, 'Depot_B': 7.1, 'Depot_C': 9.6, 'Depot_D': 7.9} # Dict: depot -> space capacity
depot_weight_limit = {'Depot_A': 11.1, 'Depot_B': 14.2, 'Depot_C': 15.9, 'Depot_D': 10.9} # Dict: depot -> weight capacity
# --- End Parameters ---

GUROBI_TIME_LIMIT = 45

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("TRUCK_LOADING", env=env)

    # --- Basic Input Validation ---
    if not trucks or not depots:
        raise ValueError("Empty trucks or depots list")

    # --- Decision Variables ---
    # x[i, d] = 1 if truck i is loaded onto depot d
    load_keys = [(i, d) for i in trucks for d in depots]
    x = m.addVars(load_keys, vtype=GRB.BINARY, name="x")

    # --- Objective Function: Maximize the number of trucks loaded ---
    m.setObjective(gp.quicksum(x[i, d] for i, d in load_keys), GRB.MAXIMIZE)

    # --- Constraints ---
    # Each truck can be assigned to at most one depot
    m.addConstrs((gp.quicksum(x[i, d] for d in depots) <= 1 for i in trucks), "TruckAssignment")

    # Depot capacity constraints
    for d in depots:
        depot_space_cap = depot_capacity.get(d, 0)
        depot_weight_cap = depot_weight_limit.get(d, 0)

        # Space constraint
        m.addConstr(gp.quicksum(spaces.get(i, 0) * x[i, d] for i in trucks) <= depot_space_cap, f"Depot_{d}_Space")
        # Weight constraint
        m.addConstr(gp.quicksum(weights.get(i, 0) * x[i, d] for i in trucks) <= depot_weight_cap, f"Depot_{d}_Weight")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Objective value is the number of trucks, should be integer-like
        if isinstance(obj_val_print, (int, float)):
             # Use round() before int() for safety with potential float results
             print(f"Optimal objective value: {int(round(obj_val_print))}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the assignment of trucks to depots
if m.Status == GRB.OPTIMAL:
    for d in depots:
        assigned_trucks = [i for i in trucks if x[i, d].X > 0.5]
        if assigned_trucks:
            print(f"Trucks assigned to {d}: {assigned_trucks}")
        else:
            print(f"No trucks assigned to {d}")
```
Answer:
Optimal objective value: 29
Trucks assigned to Depot_A: [2, 12, 13, 15, 27, 30]
Trucks assigned to Depot_B: [4, 5, 16, 25, 32, 34, 36]
Trucks assigned to Depot_C: [1, 3, 7, 8, 10, 22, 24, 35, 40]
Trucks assigned to Depot_D: [9, 11, 18, 20, 21, 26, 39]


```

================================================================================



--- Problem 285 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A port manager is tasked with maximizing revenue from two distinct ship categories: short-term and long-term vessels. The port has 26 berths available over an 11.3-hour operational horizon, with a total capacity of 293.8 berth-hours. Short-term vessels stay for an average of 1.3 hours, paying $5.20 per hour, resulting in $6.76 revenue per vessel. Demand for short-term berthing is capped at 48 vessels. Long-term vessels, on the other hand, stay for 7.4 hours at a flat rate of $10.48 per stay, with a maximum demand of 19 vessels.  

The challenge lies in balancing these two segments to fully utilize the available berth-hours while adhering to demand limits. Should the port prioritize short-term vessels for their higher per-hour revenue or accommodate more long-term vessels despite their lower per-stay profitability? The manager must determine the optimal mix of short-term and long-term vessels to maximize total revenue without exceeding capacity or demand constraints.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x_s`: Number of short-term vessels accepted (continuous, ≥ 0).  
   - `x_l`: Number of long-term vessels accepted (continuous, ≥ 0).  

   **2. Parameters:**  
   - `short_stay_hr = 1.3` (hours per short-term vessel).  
   - `short_revenue = 6.76` (revenue per short-term vessel).  
   - `short_max_demand = 48` (maximum short-term vessels).  
   - `long_stay_hr = 7.4` (hours per long-term vessel).  
   - `long_revenue = 10.48` (revenue per long-term vessel).  
   - `long_max_demand = 19` (maximum long-term vessels).  
   - `total_berth_hours = 293.8` (total available berth-hours).  

   **3. Objective Function:**  
   Maximize total revenue:  
   \[
   \text{Maximize: } 6.76 \cdot x_s + 10.48 \cdot x_l
   \]  

   **4. Constraints:**  
   - Berth-hour capacity:  
     \[
     1.3 \cdot x_s + 7.4 \cdot x_l \leq 293.8
     \]  
   - Short-term demand limit:  
     \[
     x_s \leq 48
     \]  
   - Long-term demand limit:  
     \[
     x_l \leq 19
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_berths = 26
time_horizon_hr = 11.3
total_berth_hours = 293.8

# Short-term vessels
short_stay_hr = 1.3
short_rate_per_hr = 5.20
short_revenue = 6.76 # Calculated: rate * stay
short_max_demand = 48

# Long-term vessels
long_stay_hr = 7.4
long_revenue = 10.48 # Flat rate
long_max_demand = 19
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m32 = gp.Model("PORT_BERTHING_ALLOC_LP", env=env)

    # --- Decision Variables ---
    # Number of short-term and long-term vessels accepted (LP allows fractional)
    x_s = m32.addVar(name="num_short_term", lb=0)
    x_l = m32.addVar(name="num_long_term", lb=0)

    # --- Objective Function ---
    # Maximize total revenue
    m32.setObjective(short_revenue * x_s + long_revenue * x_l, sense=GRB.MAXIMIZE)

    # --- Constraints ---
    # Constraint 1: Berth-hour capacity
    m32.addConstr(short_stay_hr * x_s + long_stay_hr * x_l <= total_berth_hours, name="berth_hour_capacity")

    # Constraint 2: Short-term demand limit
    m32.addConstr(x_s <= short_max_demand, name="short_demand")

    # Constraint 3: Long-term demand limit
    m32.addConstr(x_l <= long_max_demand, name="long_demand")

    # --- Optimization ---
    m32.optimize()

    # --- Store results ---
    results_dict['status'] = m32.status
    if m32.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m32.ObjVal
        results_dict['x_s_sol'] = x_s.X
        results_dict['x_l_sol'] = x_l.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- PORT_BERTHING_ALLOC: Berthing Space Allocation for Differing Durations (LP) ---")
    if m32.status == GRB.OPTIMAL:
        opt_s = results_dict.get('x_s_sol', 0)
        opt_l = results_dict.get('x_l_sol', 0)
        obj_val_print = results_dict.get('obj_val', 0)
        berth_hours_used = opt_s * short_stay_hr + opt_l * long_stay_hr

        print(f"Optimization Status: Optimal")
        print(f"Maximum Total Revenue: ${obj_val_print:.2f}")
        # LP solutions can be fractional, print with decimals
        print(f"Optimal Short-term Vessels Accepted: {opt_s:.2f} (Max Demand: {short_max_demand})")
        print(f"Optimal Long-term Vessels Accepted: {opt_l:.2f} (Max Demand: {long_max_demand})")
        print(f"Total Berth-Hours Used: {berth_hours_used:.1f} / {total_berth_hours:.1f}")
        # Calculate breakdown based on potentially fractional optimal values
        revenue_s = opt_s * short_revenue
        revenue_l = opt_l * long_revenue
        print(f"Revenue Breakdown: Short=${revenue_s:.2f}, Long=${revenue_l:.2f}")

    elif m32.status == GRB.INFEASIBLE:
         # Should be rare for this LP structure unless inputs are nonsensical (e.g., negative)
         print(f"Optimization Status: Infeasible.")
         print(f"Check input parameters for validity (e.g., non-negative demands/times/berths).")
    elif m32.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m32.ObjVal is not None and abs(m32.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m32.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m32.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- PORT_BERTHING_ALLOC: Berthing Space Allocation for Differing Durations (LP) ---
Optimization Status: Optimal
Maximum Total Revenue: $523.60
Optimal Short-term Vessels Accepted: 48.00 (Max Demand: 48)
Optimal Long-term Vessels Accepted: 19.00 (Max Demand: 19)
Total Berth-Hours Used: 203.0 / 293.8
Revenue Breakdown: Short=$324.48, Long=$199.12


```

================================================================================



--- Problem 286 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
**
A port operator faces the challenge of dynamically pricing berth fees during different traffic periods to maximize revenue while respecting berth capacity limits. The port experiences two distinct periods: "off-peak" with a base demand of 966 ships per hour and "peak" with a significantly higher base demand of 2893 ships per hour. The operator can adjust berth fees up to a maximum of $6 per ship, with demand sensitivity (alpha) set at 38 ships per hour for every dollar increase in berth fee. The port's capacity is fixed at 1638 ships per hour, meaning the number of ships that can be handled cannot exceed this limit regardless of demand.

The core question is: What berth fees should be set during off-peak and peak periods to maximize total revenue, ensuring that the resulting traffic flow does not exceed capacity and that demand responds linearly to price changes? The operator must balance higher fees (which reduce demand but increase revenue per ship) against lower fees (which attract more ships but may not fully utilize capacity).
**

**Modeling Process:**
**
1. Decision Variables:
- `fee[p]`: Berth fee (in $) for period `p` (where `p` is either "off" or "peak"). Bounded between 0 and `max_fee` ($6).
- `demand[p]`: Resulting demand (ships/hr) for period `p`, calculated as `base_demand[p] - alpha * fee[p]`.
- `flow[p]`: Actual traffic flow (ships/hr) for period `p`, constrained by both demand and capacity.

2. Parameters:
- `capacity = 1638`: Maximum flow capacity (ships/hr).
- `base_demand = {'off': 966, 'peak': 2893}`: Base demand (ships/hr) when fees are $0.
- `alpha = 38`: Demand sensitivity (ships/hr per $1 fee increase).
- `max_fee = 6`: Upper bound on berth fee ($).

3. Objective Function:
Maximize total revenue:
`Maximize: sum(flow[p] * fee[p] for p in periods)`

4. Constraints:
- Demand calculation for each period `p`:
  `demand[p] == base_demand[p] - alpha * fee[p]`
- Flow cannot exceed capacity:
  `flow[p] <= capacity`
- Flow cannot exceed demand:
  `flow[p] <= demand[p]`
- Non-negativity:
  `fee[p], demand[p], flow[p] >= 0`
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 1638; base_demand = {'off': 966, 'peak': 2893}; alpha = 38; max_fee = 6; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berth_Fee_Pricing_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berth Fee Pricing (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of TOLL_PRICING
```
Answer:
--- Problem 18: Dynamic Berth Fee Pricing (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $14256.00
  Period: Off
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 738.0 ships/hr (Base: 966)
    Actual Flow (min(Demand, Capacity)): 738.0 ships/hr (Capacity: 1638)
    Revenue this period: $4428.00
  Period: Peak
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 2665.0 ships/hr (Base: 2893)
    Actual Flow (min(Demand, Capacity)): 1638.0 ships/hr (Capacity: 1638)
    Revenue this period: $9828.00
Total ships processed: 2376.0



================================================================================

--- Problem 287 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently scheduling a set of seven delivery trucks with varying capacities to transport goods. The trucks have capacities of 11, 9, 22, 7, 16, 16, and 16 units, respectively. Each delivery route has a strict capacity limit of 24 units, and the goal is to minimize the number of routes used while ensuring no route exceeds its capacity. The challenge is to find an optimal assignment of trucks to routes, where each truck is assigned to exactly one route, and the total capacity in any active route does not surpass the 24-unit threshold. The company aims to reduce costs by using as few routes as possible, making this a classic bin-packing problem with real-world implications for resource efficiency and operational savings.

The central question is: *What is the minimum number of routes required to schedule all trucks without violating the capacity constraints, and how should the trucks be distributed among these routes?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether truck `i` is assigned to route `j` (1 if assigned, 0 otherwise).  
   - `y[j]`: Binary variable indicating whether route `j` is used (1 if used, 0 otherwise).  

   **2. Parameters:**  
   - `trucks = [11, 9, 22, 7, 16, 16, 16]`: Capacities of the trucks.  
   - `capacity = 24`: Maximum capacity each route can hold.  
   - `num_trucks = 7`: Total number of trucks.  
   - `num_routes = 7`: Maximum possible routes (one per truck in the worst case).  

   **3. Objective Function:**  
   Minimize the total number of routes used:  
   \[
   \text{Minimize: } \sum_{j} y[j]
   \]  

   **4. Constraints:**  
   - **Truck Assignment:** Each truck must be assigned to exactly one route:  
     \[
     \sum_{j} x[i, j] = 1 \quad \text{for each truck } i.
     \]  
   - **Route Capacity:** The total capacity in any route `j` must not exceed its capacity if the route is used:  
     \[
     \sum_{i} (\text{trucks}[i] \cdot x[i, j]) \leq \text{capacity} \cdot y[j] \quad \text{for each route } j.
     \]  
   - **Variable Types:** All variables are binary (`x[i, j] ∈ {0, 1}`, `y[j] ∈ {0, 1}`).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB

# --- Data Definition ---
trucks = [11, 9, 22, 7, 16, 16, 16]      # Capacities of trucks
capacity = 24           # Route capacity
num_trucks = 7     # len(trucks) - Corrected from original template
num_routes = num_trucks    # Maximum number of routes (worst case: one truck per route)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Time limit
# env.setParam('TimeLimit', 30)
env.start()

# Create Model
model = Model("Route Scheduling Problem", env=env)

# --- Decision Variables ---
# x[i,j]: truck i is assigned to route j
x = model.addVars(num_trucks, num_routes, vtype=GRB.BINARY, name="x")
# y[j]: route j is used
y = model.addVars(num_routes, vtype=GRB.BINARY, name="y")

# --- Objective: Minimize the number of routes used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)

# --- Constraints ---
# 1. Each truck must be assigned to exactly one route
for i in range(num_trucks):
    model.addConstr(x.sum(i, '*') == 1, name=f"Truck_{i}_Assignment")

# 2. Route capacity constraint: sum of capacities in route j <= capacity IF route j is used (y[j]=1)
for j in range(num_routes):
    model.addConstr(gp.quicksum(trucks[i] * x[i, j] for i in range(num_trucks)) <= capacity * y[j], name=f"Route_{j}_Capacity")

# --- Solve ---
print("Solving Route Scheduling instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_routes = int(results_dict.get('obj_val', -1))
    print(f"\nOptimal number of routes used: {optimal_routes}")
    print("-" * 30)
    route_details = []
    for j_sol in range(num_routes): # Loop through potential routes
        # Check if the route variable y[j_sol] exists and is set to 1
        # Using .X requires Gurobi v9+ and that the variable is in the solution
        try:
            if y[j_sol].X > 0.5: # Check if route j_sol is used
                # Find trucks assigned to this route j_sol
                # ***** CORRECTED LINE BELOW *****
                assigned_trucks_indices = [i for i in range(num_trucks) if x[i, j_sol].X > 0.5]
                # ***** END OF CORRECTION *****

                assigned_trucks_capacities = [trucks[i] for i in assigned_trucks_indices]
                route_load = sum(assigned_trucks_capacities)
                print(f"Route {j_sol + 1} (Load: {route_load}/{capacity}): Trucks (indices): {assigned_trucks_indices}")
                # Optional: Print capacities too
                # print(f"  Capacities: {assigned_trucks_capacities}")
                route_details.append({'route_index': j_sol, 'truck_indices': assigned_trucks_indices, 'load': route_load})
        except AttributeError:
            # This might happen if y[j_sol] was optimized to 0 and doesn't have an .X value
            # Or if the model was infeasible/not solved optimally.
            # Since we check for OPTIMAL status first, this is less likely for y,
            # but could happen if x[i, j_sol] is 0. The check x[i,j_sol].X > 0.5 handles this.
            pass # Just skip if variable/attribute doesn't exist for unused routes/trucks
    results_dict['route_details'] = route_details # Store details
    print("-" * 30)

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount to see if a feasible solution was found
     if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
     else: print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving Route Scheduling instance...

Optimal number of routes used: 5
------------------------------
Route 1 (Load: 22/24): Trucks (indices): [2]
Route 2 (Load: 23/24): Trucks (indices): [3, 6]
Route 3 (Load: 16/24): Trucks (indices): [5]
Route 5 (Load: 16/24): Trucks (indices): [4]
Route 6 (Load: 20/24): Trucks (indices): [0, 1]
------------------------------


```

================================================================================



--- Problem 288 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A logistics company operates a fleet of two trucks to serve three locations: a central depot (Location 0) and two customer sites (Locations 1 and 2). The trucks have distinct capacities—Truck 1 can carry up to 30 units, while Truck 2 can handle up to 98 units. Customer demands are specific: Location 1 requires 95 units, and Location 2 needs 6 units. The distances between locations are fixed, with the depot 20 units away from Location 1, 55 units from Location 2, and Locations 1 and 2 separated by 16 units.  

   The challenge is to assign routes to the trucks such that:  
   - Each customer is visited exactly once.  
   - Trucks start and end at the depot.  
   - Total demand on each route does not exceed truck capacity.  
   - The combined travel distance is minimized.  

   The stakes are high: inefficient routing could inflate costs, while optimal planning ensures timely deliveries and resource efficiency. The core question is: *What is the most distance-efficient routing plan that meets all operational constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable \(x_{i,j,k}\): 1 if truck \(k\) travels directly from location \(i\) to \(j\); 0 otherwise.  
   - Continuous variable \(u_i\) (for subtour elimination): Auxiliary variable representing the order of visit to customer \(i\).  

   **2. Parameters:**  
   - \(N = 3\): Total locations (depot + 2 customers).  
   - \(K = 2\): Number of trucks.  
   - \(Q = [30, 98]\): Truck capacities.  
   - \(q = [0, 95, 6]\): Demand at each location (depot has 0 demand).  
   - \(d\): Distance matrix (e.g., \(d_{0,1} = 20\)).  

   **3. Objective Function:**  
   Minimize total distance:  
   \[
   \text{Minimize} \sum_{k=0}^{1} \sum_{i=0}^{2} \sum_{j=0}^{2} d_{i,j} \cdot x_{i,j,k} \quad \text{(for \(i \neq j\))}.
   \]  

   **4. Constraints:**  
   - **Visit each customer once:** \(\sum_{k=0}^{1} \sum_{j=0}^{2} x_{i,j,k} = 1\) for \(i = 1, 2\).  
   - **Flow conservation:** \(\sum_{j=0}^{2} x_{i,j,k} = \sum_{j=0}^{2} x_{j,i,k}\) for all \(i, k\).  
   - **Depot departure/return:** Each truck leaves and returns to the depot at most once.  
   - **Capacity:** \(\sum_{j=1}^{2} q_j \cdot \sum_{i=0}^{2} x_{i,j,k} \leq Q_k\) for each \(k\).  
   - **Subtour elimination (MTZ):** \(u_i - u_j + 2 \cdot x_{i,j,k} \leq 1\) for \(i,j \geq 1, i \neq j\).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 3
K = 2
Q = [30, 98]
q = [0, 95, 6]
d = [
    [0, 20, 55],
    [20, 0, 16],
    [55, 16, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Vehicle Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for vehicle {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for vehicle {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 150.00

Route for vehicle 1 (Capacity: 30):
0 -> 2 -> 0
Route Load: 6 / 30

Route for vehicle 2 (Capacity: 98):
0 -> 1 -> 0
Route Load: 95 / 98


```

================================================================================



--- Problem 289 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy trucking terminal, four delivery trucks arrive at staggered times, each requiring immediate access to a loading dock to unload their goods. The terminal has three loading docks available, but the challenge lies in efficiently assigning trucks to docks while respecting their arrival times and unloading durations. Truck 1 arrives at time 1 and takes 6 hours to unload; Truck 2 arrives at time 6, also needing 6 hours; Truck 3 arrives at time 8 with a 5-hour task; and Truck 4 arrives at time 10, requiring 8 hours of dock occupancy. The terminal manager must schedule these assignments to minimize the total time taken to service all trucks—known as the *makespan*—ensuring no two trucks occupy the same dock simultaneously unless their unloading times do not overlap. The core question is: **What is the optimal dock assignment and scheduling sequence that achieves the shortest possible makespan?**
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to dock *j*, else 0).  
     - `start_time(i)`: Continuous variable for the time truck *i* begins unloading.  
     - `completion_time(i)`: Continuous variable for the time truck *i* finishes (start_time + unloading_time).  
     - `precedes(i, k, j)`: Binary variable (1 if truck *i* is scheduled before truck *k* on dock *j*).  
     - `makespan`: Continuous variable representing the latest completion time across all trucks.  

   - **2. Parameters:**  
     - `trucks = [1, 2, 3, 4]`, `docks = [1, 2, 3]`.  
     - `arrival_times = {1: 1, 2: 6, 3: 8, 4: 10}`.  
     - `unloading_times = {1: 6, 2: 6, 3: 5, 4: 8}`.  
     - `H = 100` (a large constant for precedence constraints).  

   - **3. Objective Function:**  
     - Minimize `makespan` (the maximum completion time).  

   - **4. Constraints:**  
     - Each truck must be assigned to exactly one dock: `sum(assign(i, j) for j in docks) = 1` for all *i*.  
     - Trucks cannot start before arrival: `start_time(i) >= arrival_times(i)` for all *i*.  
     - Completion time definition: `completion_time(i) = start_time(i) + unloading_times(i)` for all *i*.  
     - Non-overlapping on the same dock: For each dock *j* and trucks *i*, *k* (*i < k*), enforce either `precedes(i, k, j)` or `precedes(k, i, j)` if both are assigned to *j*, with corresponding start-time constraints.  
     - Makespan bounds: `makespan >= completion_time(i)` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4]
docks = [1, 2, 3]
arrival_times = {1: 1, 2: 6, 3: 8, 4: 10}
unloading_times = {1: 6, 2: 6, 3: 5, 4: 8}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DOCKING_PROBLEM_51_MIN_MAKESPAN")

    if not trucks or not docks: raise ValueError("Empty trucks or docks")

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, docks, vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times[i] for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + unloading_times[i] for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in docks:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the assignment and schedule details
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in docks:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Dock {j}")
                print(f"  Start Time: {start_time[i].x:.2f}")
                print(f"  Completion Time: {completion_time[i].x:.2f}")
    print(f"Total Makespan: {makespan.x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
18.0000
Optimal Solution Found:
Truck 1 is assigned to Dock 1
  Start Time: 1.00
  Completion Time: 7.00
Truck 2 is assigned to Dock 3
  Start Time: 7.00
  Completion Time: 13.00
Truck 3 is assigned to Dock 2
  Start Time: 8.00
  Completion Time: 13.00
Truck 4 is assigned to Dock 1
  Start Time: 10.00
  Completion Time: 18.00
Total Makespan: 18.00


```

================================================================================



--- Problem 290 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy port, the harbor master must efficiently allocate 71 ships (labeled 0 through 70) to one of two berthing areas: **Berth_A** (capacity: 23) or **Berth_B** (capacity: 54). Each ship has a distinct preference for **Berth_A**, quantified as a probability (e.g., Ship 4 has an 88% preference, while Ship 10 prefers it only 15%). If assigned to their non-preferred berth, the shipping companies incur a dissatisfaction cost—**\$4.41** for **Berth_A** and **\$2.36** for **Berth_B**—scaled by the mismatch probability (e.g., assigning Ship 4 to **Berth_B** costs \$2.36 × 0.88). The goal is to minimize total dissatisfaction costs while respecting berth capacities, ensuring no berthing area is overcrowded. The core question: *How should ships be distributed between the two berths to keep shipping companies as satisfied as possible without exceeding berth limits?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable \(x[i, j]\): 1 if ship \(i\) is assigned to berth \(j\) (where \(j \in \{\text{Berth\_A}, \text{Berth\_B}\}\)), 0 otherwise.  
   - **2. Parameters:**  
     - \(pref[i]\): Preference score of ship \(i\) for **Berth_A** (e.g., \(pref[4] = 0.88\)).  
     - \(cost_A = 4.41\), \(cost_B = 2.36\): Dissatisfaction costs per berth.  
     - \(cap_A = 23\), \(cap_B = 54\): Maximum capacities.  
   - **3. Objective Function:**  
     - Minimize total cost:  
       \[
       \text{Minimize: } \sum_{i} \left( cost_A \cdot (1 - pref[i]) \cdot x[i, \text{Berth\_A}] + cost_B \cdot pref[i] \cdot x[i, \text{Berth\_B}] \right)
       \]  
   - **4. Constraints:**  
     - Each ship assigned to exactly one berth: \(\sum_{j} x[i, j] = 1 \quad \forall i\).  
     - Berth capacities:  
       \[
       \sum_{i} x[i, \text{Berth\_A}] \leq 23, \quad \sum_{i} x[i, \text{Berth\_B}] \leq 54
       \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70]
berths = ['Berth_A', 'Berth_B']
capacity = {'Berth_A': 23, 'Berth_B': 54}
# Preferences defined for the first berth (e.g., Berth_A)
preferences = {0: 0.58, 1: 0.35, 2: 0.14, 3: 0.34, 4: 0.88, 5: 0.4, 6: 0.62, 7: 0.55, 8: 0.68, 9: 0.41, 10: 0.15, 11: 0.21, 12: 0.24, 13: 0.86, 14: 0.71, 15: 0.26, 16: 0.16, 17: 0.68, 18: 0.32, 19: 0.88, 20: 0.46, 21: 0.51, 22: 0.3, 23: 0.23, 24: 0.28, 25: 0.54, 26: 0.11, 27: 0.32, 28: 0.26, 29: 0.31, 30: 0.44, 31: 0.18, 32: 0.52, 33: 0.16, 34: 0.59, 35: 0.19, 36: 0.14, 37: 0.8, 38: 0.43, 39: 0.2, 40: 0.2, 41: 0.45, 42: 0.22, 43: 0.83, 44: 0.19, 45: 0.41, 46: 0.78, 47: 0.83, 48: 0.17, 49: 0.57, 50: 0.65, 51: 0.48, 52: 0.53, 53: 0.12, 54: 0.75, 55: 0.88, 56: 0.65, 57: 0.17, 58: 0.89, 59: 0.41, 60: 0.74, 61: 0.45, 62: 0.21, 63: 0.78, 64: 0.35, 65: 0.45, 66: 0.84, 67: 0.77, 68: 0.72, 69: 0.25, 70: 0.56} # Dict: ship_id -> preference for first berth
dissatisfaction_cost = {'Berth_A': 4.41, 'Berth_B': 2.36} # Dict: berth -> cost if forced here when preferred elsewhere
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_MANAGEMENT", env=env)

    # --- Calculate Assignment Costs ---
    # Assumes preference is for the *first* berth in the list
    cost = {}
    if berths: # Check if berths list is not empty
        first_berth = berths[0]
        for i in ships:
            pref_first = preferences.get(i, 0.5) # Default to 0.5 if missing
            for berth_idx, berth_name in enumerate(berths):
                if berth_name == first_berth:
                    # Cost if assigned first_berth = cost_A * prob_prefers_other
                    # Assuming preference for 'other' is (1 - pref_first)
                    cost[i, berth_name] = dissatisfaction_cost.get(berth_name, 1.0) * (1.0 - pref_first)
                else:
                    # Cost if assigned other_berth = cost_other * prob_prefers_first
                    cost[i, berth_name] = dissatisfaction_cost.get(berth_name, 1.0) * pref_first
    # print(f"Calculated costs: {cost}") # Debug print

    # --- Decision Variables ---
    # x[i, j] = 1 if ship i is guided to berth j, 0 otherwise
    # Use tuplelist of valid (ship, berth) pairs
    assign_keys = [(i,j) for i in ships for j in berths]
    x = m.addVars(assign_keys, vtype=GRB.BINARY, name="x")

    # --- Objective Function: Minimize total dissatisfaction cost ---
    # Use .get() on cost dict for safety
    m.setObjective(gp.quicksum(cost.get((i, j), 0) * x[i, j] for i, j in assign_keys), GRB.MINIMIZE)

    # --- Constraints ---
    # Each ship must be guided to exactly one berth
    if ships and berths:
        m.addConstrs((gp.quicksum(x[i, j] for j in berths) == 1 for i in ships), "ShipAssignment")

        # Capacity constraint for each Berth
        for berth_name, berth_cap in capacity.items():
            if berth_name in berths: # Check if berth exists
                m.addConstr(gp.quicksum(x[i, berth_name] for i in ships) <= berth_cap, f"Capacity_{berth_name}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show decimals
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code to print the assignment of ships to berths
if m.Status == GRB.OPTIMAL:
    for i in ships:
        for j in berths:
            if x[i, j].X > 0.5:
                print(f"Ship {i} is assigned to {j}")
```
Answer:
Optimal objective value: 59.7174
Ship 0 is assigned to Berth_B
Ship 1 is assigned to Berth_B
Ship 2 is assigned to Berth_B
Ship 3 is assigned to Berth_B
Ship 4 is assigned to Berth_A
Ship 5 is assigned to Berth_B
Ship 6 is assigned to Berth_B
Ship 7 is assigned to Berth_B
Ship 8 is assigned to Berth_A
Ship 9 is assigned to Berth_B
Ship 10 is assigned to Berth_B
Ship 11 is assigned to Berth_B
Ship 12 is assigned to Berth_B
Ship 13 is assigned to Berth_A
Ship 14 is assigned to Berth_A
Ship 15 is assigned to Berth_B
Ship 16 is assigned to Berth_B
Ship 17 is assigned to Berth_A
Ship 18 is assigned to Berth_B
Ship 19 is assigned to Berth_A
Ship 20 is assigned to Berth_B
Ship 21 is assigned to Berth_B
Ship 22 is assigned to Berth_B
Ship 23 is assigned to Berth_B
Ship 24 is assigned to Berth_B
Ship 25 is assigned to Berth_B
Ship 26 is assigned to Berth_B
Ship 27 is assigned to Berth_B
Ship 28 is assigned to Berth_B
Ship 29 is assigned to Berth_B
Ship 30 is assigned to Berth_B
Ship 31 is assigned to Berth_B
Ship 32 is assigned to Berth_B
Ship 33 is assigned to Berth_B
Ship 34 is assigned to Berth_B
Ship 35 is assigned to Berth_B
Ship 36 is assigned to Berth_B
Ship 37 is assigned to Berth_A
Ship 38 is assigned to Berth_B
Ship 39 is assigned to Berth_B
Ship 40 is assigned to Berth_B
Ship 41 is assigned to Berth_B
Ship 42 is assigned to Berth_B
Ship 43 is assigned to Berth_A
Ship 44 is assigned to Berth_B
Ship 45 is assigned to Berth_B
Ship 46 is assigned to Berth_A
Ship 47 is assigned to Berth_A
Ship 48 is assigned to Berth_B
Ship 49 is assigned to Berth_B
Ship 50 is assigned to Berth_B
Ship 51 is assigned to Berth_B
Ship 52 is assigned to Berth_B
Ship 53 is assigned to Berth_B
Ship 54 is assigned to Berth_A
Ship 55 is assigned to Berth_A
Ship 56 is assigned to Berth_B
Ship 57 is assigned to Berth_B
Ship 58 is assigned to Berth_A
Ship 59 is assigned to Berth_B
Ship 60 is assigned to Berth_A
Ship 61 is assigned to Berth_B
Ship 62 is assigned to Berth_B
Ship 63 is assigned to Berth_A
Ship 64 is assigned to Berth_B
Ship 65 is assigned to Berth_B
Ship 66 is assigned to Berth_A
Ship 67 is assigned to Berth_A
Ship 68 is assigned to Berth_A
Ship 69 is assigned to Berth_B
Ship 70 is assigned to Berth_B


```

================================================================================



--- Problem 291 ---
**Difficulty:** easy
**Category:** LP

**Problem Description:**
**
A port manager is tasked with maximizing revenue by strategically allocating berths to two distinct ship segments: short-term and long-term users. The port has 102 berths available over a 10.5-hour operating window, providing a total capacity of 1,071 berth-hours. Short-term ships stay for an average of 1.2 hours, paying $2.83 per hour, which translates to $3.40 in revenue per ship. Demand for short-term berthing is capped at 95 ships. Long-term ships, on the other hand, stay for 5.2 hours and pay a flat rate of $8.98 per stay, with a maximum demand of 41 ships. The challenge is to determine how many ships from each segment to accept without exceeding the port’s berth-hour capacity or the respective demand limits, all while maximizing total revenue. The central question is: *What combination of short-term and long-term ships should be accommodated to achieve the highest possible revenue?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x_s`: Number of short-term ships accepted (continuous, ≥ 0).  
   - `x_l`: Number of long-term ships accepted (continuous, ≥ 0).  

   **2. Parameters:**  
   - `short_stay_hr = 1.2`: Hours per short-term ship.  
   - `short_revenue = 3.40`: Revenue per short-term ship.  
   - `short_max_demand = 95`: Upper limit on short-term ships.  
   - `long_stay_hr = 5.2`: Hours per long-term ship.  
   - `long_revenue = 8.98`: Revenue per long-term ship.  
   - `long_max_demand = 41`: Upper limit on long-term ships.  
   - `total_berth_hours = 1071.0`: Total available berth-hours.  

   **3. Objective Function:**  
   Maximize total revenue:  
   ```  
   Maximize: (3.40 * x_s) + (8.98 * x_l)  
   ```  

   **4. Constraints:**  
   - Berth-hour capacity: `1.2 * x_s + 5.2 * x_l ≤ 1071.0`  
   - Short-term demand limit: `x_s ≤ 95`  
   - Long-term demand limit: `x_l ≤ 41`  
   - Non-negativity: `x_s ≥ 0`, `x_l ≥ 0`  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_berths = 102
time_horizon_hr = 10.5
total_berth_hours = 1071.0

# Short-term ships
short_stay_hr = 1.2
short_rate_per_hr = 2.83
short_revenue = 3.40 # Calculated: rate * stay
short_max_demand = 95

# Long-term ships
long_stay_hr = 5.2
long_revenue = 8.98 # Flat rate
long_max_demand = 41
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m32 = gp.Model("PORT_BERTH_ALLOC_LP", env=env)

    # --- Decision Variables ---
    # Number of short-term and long-term ships accepted (LP allows fractional)
    x_s = m32.addVar(name="num_short_term", lb=0)
    x_l = m32.addVar(name="num_long_term", lb=0)

    # --- Objective Function ---
    # Maximize total revenue
    m32.setObjective(short_revenue * x_s + long_revenue * x_l, sense=GRB.MAXIMIZE)

    # --- Constraints ---
    # Constraint 1: Berth-hour capacity
    m32.addConstr(short_stay_hr * x_s + long_stay_hr * x_l <= total_berth_hours, name="berth_hour_capacity")

    # Constraint 2: Short-term demand limit
    m32.addConstr(x_s <= short_max_demand, name="short_demand")

    # Constraint 3: Long-term demand limit
    m32.addConstr(x_l <= long_max_demand, name="long_demand")

    # --- Optimization ---
    m32.optimize()

    # --- Store results ---
    results_dict['status'] = m32.status
    if m32.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m32.ObjVal
        results_dict['x_s_sol'] = x_s.X
        results_dict['x_l_sol'] = x_l.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- PORT_BERTH_ALLOC: Berth Allocation for Differing Durations (LP) ---")
    if m32.status == GRB.OPTIMAL:
        opt_s = results_dict.get('x_s_sol', 0)
        opt_l = results_dict.get('x_l_sol', 0)
        obj_val_print = results_dict.get('obj_val', 0)
        berth_hours_used = opt_s * short_stay_hr + opt_l * long_stay_hr

        print(f"Optimization Status: Optimal")
        print(f"Maximum Total Revenue: ${obj_val_print:.2f}")
        # LP solutions can be fractional, print with decimals
        print(f"Optimal Short-term Ships Accepted: {opt_s:.2f} (Max Demand: {short_max_demand})")
        print(f"Optimal Long-term Ships Accepted: {opt_l:.2f} (Max Demand: {long_max_demand})")
        print(f"Total Berth-Hours Used: {berth_hours_used:.1f} / {total_berth_hours:.1f}")
        # Calculate breakdown based on potentially fractional optimal values
        revenue_s = opt_s * short_revenue
        revenue_l = opt_l * long_revenue
        print(f"Revenue Breakdown: Short=${revenue_s:.2f}, Long=${revenue_l:.2f}")

    elif m32.status == GRB.INFEASIBLE:
         # Should be rare for this LP structure unless inputs are nonsensical (e.g., negative)
         print(f"Optimization Status: Infeasible.")
         print(f"Check input parameters for validity (e.g., non-negative demands/times/berths).")
    elif m32.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m32.ObjVal is not None and abs(m32.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m32.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m32.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2


```
Answer:
--- PORT_BERTH_ALLOC: Berth Allocation for Differing Durations (LP) ---
Optimization Status: Optimal
Maximum Total Revenue: $691.18
Optimal Short-term Ships Accepted: 95.00 (Max Demand: 95)
Optimal Long-term Ships Accepted: 41.00 (Max Demand: 41)
Total Berth-Hours Used: 327.2 / 1071.0
Revenue Breakdown: Short=$323.00, Long=$368.18



================================================================================



--- Problem 292 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy port authority faces the challenge of scheduling three cargo trucks (Truck 1, Truck 2, and Truck 3) to a single depot, where operational hours impose strict time windows for unloading. Trucks arrive at different times: Truck 1 at 5 hours, Truck 2 at 7 hours, and Truck 3 at 10 hours. Each truck requires a specific processing time: 3 hours for Truck 1, 4 hours for Truck 2, and 4 hours for Truck 3. The operational cycle repeats every 12 hours, with a 6-hour window during which trucks can unload safely. Missing this window forces a delay until the next cycle, risking operational inefficiencies and potential penalties.  

   The port’s goal is to assign trucks to the depot in a way that minimizes the total completion time (makespan) while respecting arrival times, processing durations, and operational constraints. Trucks cannot overlap on the depot, and their start times must align with the operational windows. The challenge is to sequence the trucks optimally—balancing arrival times, processing requirements, and operational limitations—to ensure the last truck finishes as early as possible.  

   **Key Question:** What is the optimal schedule for these trucks that minimizes the total completion time while adhering to operational constraints and avoiding overlaps?
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary variable indicating whether truck `i` is assigned to depot `j` (here, `j` is always the single depot).  
   - `start_time[i]`: Continuous variable representing the start time of truck `i` at the depot.  
   - `completion_time[i]`: Continuous variable representing the completion time of truck `i` (start time + processing time).  
   - `precedes[i, k, j]`: Binary variable indicating whether truck `i` precedes truck `k` on depot `j`.  
   - `makespan`: Continuous variable representing the total completion time (maximum `completion_time` across all trucks).  
   - `z[i, k]`: Binary variable indicating whether truck `i` starts in operational cycle `k`.  

   **2. Parameters:**  
   - `trucks = [1, 2, 3]`: List of trucks.  
   - `depots = [1]`: Single depot available.  
   - `arrival_times = {1: 5, 2: 7, 3: 10}`: Arrival times for each truck.  
   - `processing_times = {1: 3, 2: 4, 3: 4}`: Processing durations for each truck.  
   - `operational_cycle = 12`: Duration of the operational cycle.  
   - `operational_duration = 6`: Duration of the operational window within each cycle.  
   - `H = 100`: A large constant (Big-M) for logical constraints.  
   - `max_k = 4`: Maximum number of operational cycles considered.  

   **3. Objective Function:**  
   Minimize the makespan:  
   \[
   \text{Minimize: } \text{makespan}
   \]  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to the depot:  
     \[
     \text{assign}[i, 1] = 1 \quad \forall i \in \text{trucks}
     \]  
   - **Arrival Time:** Trucks cannot start before their arrival time:  
     \[
     \text{start_time}[i] \geq \text{arrival_times}[i] \quad \forall i \in \text{trucks}
     \]  
   - **Completion Time:** Completion time is the start time plus processing time:  
     \[
     \text{completion_time}[i] = \text{start_time}[i] + \text{processing_times}[i] \quad \forall i \in \text{trucks}
     \]  
   - **Non-Overlapping:** Trucks cannot overlap on the depot (using precedence variables):  
     \[
     \text{If } \text{precedes}[i, k, 1] = 1, \text{ then } \text{start_time}[k] \geq \text{completion_time}[i] \quad \forall i < k
     \]  
     \[
     \text{If } \text{precedes}[i, k, 1] = 0, \text{ then } \text{start_time}[i] \geq \text{completion_time}[k] \quad \forall i < k
     \]  
   - **Makespan Definition:** The makespan is the maximum completion time:  
     \[
     \text{makespan} \geq \text{completion_time}[i] \quad \forall i \in \text{trucks}
     \]  
   - **Operational Constraints:** Trucks must start and finish within an operational window:  
     \[
     \sum_{k} \text{z}[i, k] = 1 \quad \forall i \in \text{trucks} \quad \text{(each truck starts in exactly one cycle)}
     \]  
     \[
     \text{If } \text{z}[i, k] = 1, \text{ then } \text{start_time}[i] \geq k \cdot \text{operational_cycle} \quad \forall i, k
     \]  
     \[
     \text{If } \text{z}[i, k] = 1, \text{ then } \text{completion_time}[i] \leq k \cdot \text{operational_cycle} + \text{operational_duration} \quad \forall i, k
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
depots = [1] # Should be [1]
arrival_times = {1: 5, 2: 7, 3: 10}
processing_times = {1: 3, 2: 4, 3: 4}
operational_cycle = 12
operational_duration = 6
H = 100 # Big M
max_k = 4 # Estimated max cycles needed
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_13_OPERATIONAL")

    if not trucks or not depots or len(depots)!=1: raise ValueError("Invalid trucks/depots")
    the_depot = depots[0]

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign") # Trivial
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    # Operational constraint variables
    z = m.addVars(trucks, range(max_k), vtype=GRB.BINARY, name="start_cycle")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_depot] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (on the single depot) using Indicators
    j = the_depot
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. Operational Constraint
    for i in trucks:
        m.addConstr(z.sum(i, '*') == 1, name=f"truck_{i}_one_cycle")
        for k in range(max_k):
            window_start = k * operational_cycle
            # Allow starting exactly at window_end? Original logic might need <= window_end
            # Using strict < window_end by using window_start + duration as upper bound
            window_end_strict = window_start + operational_duration
            # If z[i,k]=1, then window_start <= s[i] < window_end_strict
            m.addGenConstrIndicator(z[i,k], True, start_time[i] >= window_start, name=f"operational_start_lower_{i}_{k}")
            # Cannot use strict inequality, use epsilon or ensure proc time fits
            # Ensure completion time is within the window if it starts in the window
            # This is the complex part often simplified. Let's ensure proc time fits.
            m.addGenConstrIndicator(z[i,k], True, start_time[i] + processing_times.get(i,0) <= window_end_strict, name=f"operational_end_upper_{i}_{k}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the start times, completion times, and makespan
if m.status == GRB.OPTIMAL:
    obj_val_print = results_dict.get('obj_val', 'N/A')
    if isinstance(obj_val_print, (int, float)):
        print(f"Optimal Makespan: {obj_val_print:.4f}")
    else:
        print(f"Optimal Makespan: {obj_val_print}")

    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
39.0000
Optimal Makespan: 39.0000
Truck 1 - Start Time: 36.0000, Completion Time: 39.0000
Truck 2 - Start Time: 24.0000, Completion Time: 28.0000
Truck 3 - Start Time: 12.0000, Completion Time: 16.0000


```

================================================================================



--- Problem 293 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port is managed by a two-phase berthing system, where each phase controls the flow of ships from different directions. The port managers face a critical challenge: minimizing the total delay experienced by ships while ensuring the berthing timings adhere to strict operational constraints. The port’s cycle time—the total duration for all berthing phases to complete—is fixed at 28 hours. Each phase must allocate a berthing time between 14 and 28 hours. The ship flow coefficients, representing the volume of ships per phase, are 1428 and 2685, respectively. Higher flow phases contribute more significantly to delays if their berthing times are insufficient. The core question is: *How should the 28-hour cycle be divided between the two phases to minimize the total delay caused by waiting times, given the flow demands and timing constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `t[i]`: Continuous variable representing the berthing time (in hours) allocated to phase `i` (where `i = 1, 2`). Each `t[i]` must lie between 14 and 28 hours.  
   - **2. Parameters:**  
     - `flow_coeffs = [1428, 2685]`: Ship flow coefficients for phases 1 and 2, respectively.  
     - `cycle_time = 28`: Total cycle time (hours).  
     - `lb_time = 14`, `ub_time = 28`: Lower and upper bounds for berthing times.  
   - **3. Objective Function:**  
     Minimize the total delay, calculated as:  
     ```  
     Minimize: flow_coeffs[1] × (cycle_time - t[1]) + flow_coeffs[2] × (cycle_time - t[2])  
     ```  
     (Delay for each phase is proportional to its flow multiplied by its waiting time, where waiting time = `cycle_time - berthing_time`.)  
   - **4. Constraints:**  
     - The sum of berthing times must equal the cycle time:  
       ```  
       t[1] + t[2] = 28  
       ```  
     - Bounds on berthing times:  
       ```  
       14 ≤ t[i] ≤ 28 for i = 1, 2  
       ```  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 2
lb_time = 14          # Lower bound for berthing time
ub_time = 28          # Upper bound for berthing time
cycle_time = 28   # Total cycle time (set equal to ub_time)
flow_coeffs = [1428, 2685] # Ship flow coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for phase i is proportional to flow * waiting_time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total delay: 57582.00
------------------------------
Optimal berthing times (hours):
  t1: 14.00, t2: 14.00


```

================================================================================



--- Problem 294 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy logistics hub, a critical scheduling challenge arises: three delivery trucks (Truck 1, Truck 2, and Truck 3) must be assigned to a single available depot for unloading and loading operations. Each truck arrives at the hub at distinct times—Truck 1 at time 1, Truck 2 at time 3, and Truck 3 at time 5—and requires varying processing durations: 6, 7, and 5 time units, respectively. The hub authority faces strict deadlines for each truck’s completion: Truck 1 must finish by time 12, Truck 2 by time 19, and Truck 3 by time 15. Delays beyond these deadlines incur penalties, measured as tardiness. The core challenge is to schedule the trucks on the single depot in a way that minimizes the total tardiness across all trucks, ensuring efficient use of the depot while respecting arrival times and processing requirements. The question is: *What is the optimal sequence and start times for the trucks to achieve zero total tardiness?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign[i, j]`: Binary variable (1 if truck *i* is assigned to depot *j*; 0 otherwise). Here, *j* is fixed to the single depot.  
     - `start_time[i]`: Continuous variable for the time truck *i* begins processing.  
     - `completion_time[i]`: Continuous variable for the time truck *i* finishes (start time + processing time).  
     - `precedes[i, k, j]`: Binary variable (1 if truck *i* is scheduled before truck *k* on depot *j*; 0 otherwise).  
     - `tardiness[i]`: Continuous variable capturing the delay (if any) of truck *i* beyond its deadline.  

   - **2. Parameters:**  
     - `arrival_times[i]`: Time truck *i* arrives (Truck 1: 1, Truck 2: 3, Truck 3: 5).  
     - `processing_times[i]`: Duration to process truck *i* (Truck 1: 6, Truck 2: 7, Truck 3: 5).  
     - `due_times[i]`: Deadline for truck *i* (Truck 1: 12, Truck 2: 19, Truck 3: 15).  
     - `H`: A large constant (100) for logical constraints.  

   - **3. Objective Function:**  
     Minimize the total tardiness:  
     \[
     \text{Minimize: } \sum_{i \in \text{trucks}} \text{tardiness}[i]
     \]  

   - **4. Constraints:**  
     - **Assignment:** Each truck must be assigned to the single depot.  
     - **Arrival Time:** Start time of truck *i* ≥ its arrival time.  
     - **Completion Time:** `completion_time[i] = start_time[i] + processing_times[i]`.  
     - **Non-Overlapping:** For any two trucks *i* and *k*, one must precede the other on the depot.  
     - **Tardiness Calculation:** `tardiness[i] ≥ completion_time[i] - due_times[i]` (zero if early/on-time).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
depots = [1] # Should be [1]
arrival_times = {1: 1, 2: 3, 3: 5}
processing_times = {1: 6, 2: 7, 3: 5}
due_times = {1: 12, 2: 19, 3: 15}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_4_MIN_TARDINESS")

    if not trucks or not depots or len(depots)!=1: raise ValueError("Invalid trucks/depots")
    the_depot = depots[0]

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign") # Trivial but keep
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    tardiness = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="tardiness")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(tardiness[i] for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_depot] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (on the single depot) using Indicators
    j = the_depot
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                # Link precedence var: if both assigned (always true), one must precede
                m.addConstr(precedes[i,k,j] + (1-precedes[i,k,j]) == 1, name=f"link_prec_{i}_{k}_{j}") # Enforce binary explicitly

    # 5. Tardiness definition
    m.addConstrs((tardiness[i] >= completion_time[i] - due_times.get(i, 0) for i in trucks), name="tardiness_calc")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Tardiness
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal sequence and start times for the trucks:")
    for i in trucks:
        print(f"Truck {i}: Start Time = {start_time[i].x:.4f}, Completion Time = {completion_time[i].x:.4f}, Tardiness = {tardiness[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
0.0000
Optimal sequence and start times for the trucks:
Truck 1: Start Time = 1.0000, Completion Time = 7.0000, Tardiness = 0.0000
Truck 2: Start Time = 12.0000, Completion Time = 19.0000, Tardiness = 0.0000
Truck 3: Start Time = 7.0000, Completion Time = 12.0000, Tardiness = 0.0000


```

================================================================================



--- Problem 295 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy inland port, six cargo trucks arrive at varying times, each requiring a depot for unloading and processing. The port has only two depots available, creating a complex scheduling challenge. Truck 1 arrives at time 2, followed by Truck 2 at time 5, Truck 3 at time 6, Truck 4 at time 11, Truck 5 at time 16, and Truck 6 at time 17. Each truck has a specific processing duration: Truck 1 takes 6 units of time, Truck 2 takes 7, Truck 3 takes 8, Truck 4 takes 4, Truck 5 takes 3, and Truck 6 takes 5. The port manager must assign each truck to a depot and determine their start times such that no two trucks occupy the same depot simultaneously. The primary goal is to minimize the **maximum waiting time** any truck experiences—the time between its arrival and the start of its processing. This ensures fairness and efficiency in operations, preventing excessive delays for any single vehicle.  

   The core question is: **What is the optimal depot assignment and scheduling sequence that minimizes the longest waiting time across all trucks?**
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `assign(i, j)`: 1 if truck `i` is assigned to depot `j`, else 0.  
   - Continuous variable `start_time(i)`: The time truck `i` begins processing.  
   - Continuous variable `completion_time(i)`: The time truck `i` finishes processing.  
   - Binary variable `precedes(i, k, j)`: 1 if truck `i` is processed before truck `k` on depot `j`, else 0.  
   - Continuous variable `max_wait_time`: Represents the maximum waiting time across all trucks.  

   **2. Parameters:**  
   - `trucks = [1, 2, 3, 4, 5, 6]`: List of trucks.  
   - `depots = [1, 2]`: List of depots.  
   - `arrival_times`: Dictionary mapping trucks to their arrival times.  
   - `processing_times`: Dictionary mapping trucks to their processing durations.  
   - `H = 100`: A large constant (Big-M) for logical constraints.  

   **3. Objective Function:**  
   Minimize `max_wait_time`.  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot.  
     `For each truck i: sum(assign(i, j) for all j) = 1`.  
   - **Arrival Time:** A truck cannot start processing before its arrival time.  
     `For each truck i: start_time(i) >= arrival_times[i]`.  
   - **Completion Time:** The completion time is the start time plus processing time.  
     `For each truck i: completion_time(i) = start_time(i) + processing_times[i]`.  
   - **Non-Overlapping:** If two trucks are assigned to the same depot, one must precede the other.  
     `For each depot j, and trucks i < k: precedes(i, k, j) = 1 implies start_time(k) >= completion_time(i)`.  
     `For each depot j, and trucks i < k: precedes(i, k, j) = 0 implies start_time(i) >= completion_time(k)`.  
   - **Max Wait Time Definition:** The maximum waiting time is the largest difference between start time and arrival time across all trucks.  
     `For each truck i: max_wait_time >= start_time(i) - arrival_times[i]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
depots = [1, 2]
arrival_times = {1: 2, 2: 5, 3: 6, 4: 11, 5: 16, 6: 17}
processing_times = {1: 6, 2: 7, 3: 8, 4: 4, 5: 3, 6: 5}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_12_MIN_MAX_WAIT")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    max_wait_time = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Wmax") # Objective var

    # --- Objective Function ---
    m.setObjective(max_wait_time, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Max waiting time definition
    m.addConstrs((max_wait_time >= start_time[i] - arrival_times.get(i, 0) for i in trucks), name="wmax_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Max wait time
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the complete solution
if m.status == GRB.OPTIMAL:
    print(f"Optimal Maximum Waiting Time: {m.objVal:.4f}")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time for Truck {i}: {start_time[i].x:.4f}")
                print(f"Completion Time for Truck {i}: {completion_time[i].x:.4f}")
                print(f"Waiting Time for Truck {i}: {start_time[i].x - arrival_times[i]:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
13.0000
Optimal Maximum Waiting Time: 13.0000
Truck 1 is assigned to Depot 2
Start Time for Truck 1: 2.0000
Completion Time for Truck 1: 8.0000
Waiting Time for Truck 1: 0.0000
Truck 2 is assigned to Depot 2
Start Time for Truck 2: 8.0000
Completion Time for Truck 2: 15.0000
Waiting Time for Truck 2: 3.0000
Truck 3 is assigned to Depot 2
Start Time for Truck 3: 15.0000
Completion Time for Truck 3: 23.0000
Waiting Time for Truck 3: 9.0000
Truck 4 is assigned to Depot 2
Start Time for Truck 4: 23.0000
Completion Time for Truck 4: 27.0000
Waiting Time for Truck 4: 12.0000
Truck 5 is assigned to Depot 2
Start Time for Truck 5: 27.0000
Completion Time for Truck 5: 30.0000
Waiting Time for Truck 5: 11.0000
Truck 6 is assigned to Depot 2
Start Time for Truck 6: 30.0000
Completion Time for Truck 6: 35.0000
Waiting Time for Truck 6: 13.0000


```

================================================================================



--- Problem 296 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A maritime logistics company operates a fleet of two ships (Ship 1 and Ship 2) with capacities of 95 and 100 units, respectively. Their task is to deliver goods from a central port (Node 0) to four customer locations (Nodes 1–4), each with specific demand quantities: 54, 41, 71, and 14 units. The distances between nodes are asymmetric, meaning the travel time from Node A to Node B may differ from the reverse trip. For instance, traveling from the port (Node 0) to Node 2 takes 35 units of distance, while the return trip takes 71 units.  

   The challenge is to assign routes to the ships such that:  
   - Every customer is visited exactly once.  
   - Each ship starts and ends at the port.  
   - The total demand served by a ship does not exceed its capacity.  
   - The combined travel distance for both ships is minimized.  

   The operational stakes are high: inefficient routing could lead to wasted fuel, delayed deliveries, and increased costs. The key question is: *What is the most efficient way to assign customers to the two ships while respecting all constraints, ensuring minimal total travel distance?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variables `x[i, j, k]`: Indicates whether ship `k` travels directly from node `i` to node `j` (1 if yes, 0 otherwise).  
   - Continuous variables `u[i]`: Used for subtour elimination (MTZ constraints), ensuring routes are connected and valid.  

   **2. Parameters:**  
   - `N = 5`: Total nodes (1 port + 4 customers).  
   - `K = 2`: Number of ships.  
   - `Q = [95, 100]`: Ship capacities.  
   - `q = [0, 54, 41, 71, 14]`: Demand at each node (port has 0 demand).  
   - `d[i][j]`: Distance matrix between nodes.  

   **3. Objective Function:**  
   Minimize the total distance traveled by both ships:  
   \[
   \text{Minimize: } \sum_{k=0}^{1} \sum_{i=0}^{4} \sum_{j=0}^{4} d[i][j] \cdot x[i, j, k] \quad (i \neq j)
   \]  

   **4. Constraints:**  
   - **Visit each customer once:**  
     \[
     \sum_{k=0}^{1} \sum_{j=0}^{4} x[i, j, k] = 1 \quad \forall i \in \{1, 2, 3, 4\}, \, i \neq j
     \]  
   - **Flow conservation:**  
     \[
     \sum_{j=0}^{4} x[i, j, k] = \sum_{j=0}^{4} x[j, i, k] \quad \forall k \in \{0, 1\}, \, \forall i \in \{0, 1, 2, 3, 4\}, \, i \neq j
     \]  
   - **Port departure/return:**  
     Each ship must leave and return to the port (Node 0) exactly once:  
     \[
     \sum_{j=1}^{4} x[0, j, k] = 1 \quad \text{and} \quad \sum_{j=1}^{4} x[j, 0, k] = 1 \quad \forall k \in \{0, 1\}
     \]  
   - **Capacity constraints:**  
     Total demand served by ship `k` cannot exceed `Q[k]`:  
     \[
     \sum_{j=1}^{4} q[j] \cdot \sum_{i=0}^{4} x[i, j, k] \leq Q[k] \quad \forall k \in \{0, 1\}, \, i \neq j
     \]  
   - **Subtour elimination (MTZ):**  
     Ensures no disconnected cycles:  
     \[
     u[i] - u[j] + 4 \cdot x[i, j, k] \leq 3 \quad \forall k \in \{0, 1\}, \, \forall i, j \in \{1, 2, 3, 4\}, \, i \neq j
     \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 5
K = 2
Q = [95, 100]
q = [0, 54, 41, 71, 14]
d = [
    [0, 66, 35, 70, 63],
    [66, 0, 72, 10, 58],
    [35, 72, 0, 96, 71],
    [70, 10, 96, 0, 81],
    [63, 58, 71, 81, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Ship Departure/Return from Port (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartPort_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnPort_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for ship {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for ship {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 387.00

Route for ship 1 (Capacity: 95):
0 -> 2 -> 1 -> 0
Route Load: 95 / 95

Route for ship 2 (Capacity: 100):
0 -> 4 -> 3 -> 0
Route Load: 85 / 100


```

================================================================================



--- Problem 297 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
A port authority is tasked with scheduling the berthing of ships at a total of 18,934 meters of available dock space. The operations manager must decide how many ships to berth to minimize costs while adhering to operational constraints. Each ship incurs a fixed docking fee of $48, regardless of the length of the dock it occupies. Fuel consumption for each ship is a major expense, with ships burning 0.195 liters per meter at a cost of $2.12 per liter. The total fuel cost for the entire dock space is fixed at $7,827.32, as it depends solely on the distance and consumption rate. The port has a maximum of 28 ships that can be accommodated but seeks to determine the optimal number to berth to balance fixed costs against fuel expenses. The challenge is to find the number of ships that minimizes the total cost—fixed costs plus fuel—while ensuring the solution is feasible within the given ship limits.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n`: Integer variable representing the number of ships to berth, bounded between 1 and 28 (inclusive).  
   - **2. Parameters:**  
     - `fixed_cost_per_ship = 48` ($ per ship).  
     - `total_fuel_cost = 7827.32` ($, constant for the given dock space).  
     - `max_ships = 28` (upper bound on `n`).  
   - **3. Objective Function:**  
     - Minimize the total cost:  
       \[
       \text{Minimize: } n \times 48 + 7827.32
       \]  
   - **4. Constraints:**  
     - \( 1 \leq n \leq 28 \) (bounds on the number of ships).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_dock_space_m = 18934
fuel_consumption_rate_L_per_m = 0.195
fuel_cost_per_L = 2.12
fixed_cost_per_ship = 48
max_ships = 28

# Calculated total fuel cost (constant)
total_fuel_cost = 7827.32
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m30 = gp.Model("SHIP_BERTHING_COST_MINIMIZE_IP", env=env)

    # --- Decision Variables ---
    # Integer: Number of ships to berth
    # Ensure lb=1 so division in output works
    n = m30.addVar(vtype=GRB.INTEGER, name="num_ships_berthed", lb=1, ub=max_ships)

    # --- Objective Function ---
    # Minimize total fixed cost + total fuel cost
    total_fixed_cost_expr = n * fixed_cost_per_ship
    m30.setObjective(total_fixed_cost_expr + total_fuel_cost, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraints on n are handled by variable bounds (lb=1, ub=max_ships)
    # No other constraints in this simple model

    # --- Optimization ---
    m30.optimize()

    # --- Store results ---
    results_dict['status'] = m30.status
    if m30.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m30.ObjVal
        results_dict['n_sol'] = n.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- SHIP_BERTHING_COST_MINIMIZE: Cost Minimization for Berthing Ships (IP) ---")
    if m30.status == GRB.OPTIMAL:
        opt_n = int(round(results_dict.get('n_sol', 1))) # Round and ensure integer >= 1
        opt_fixed_cost = opt_n * fixed_cost_per_ship
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Optimal Number of Ships to Berth: {opt_n} (Max allowed: {max_ships})")
        print(f"Resulting Fixed Docking Fee: ${opt_fixed_cost:.2f} (Cost/Ship: ${fixed_cost_per_ship})")
        print(f"Total Fuel Cost (Constant): ${total_fuel_cost:.2f}")
        print(f"Minimum Total Cost: ${obj_val_print:.2f}")
        # Avoid division by zero if opt_n somehow becomes 0 (lb=1 should prevent)
        if opt_n > 0:
             print(f"Dock space per ship: {total_dock_space_m / opt_n:.1f} m (Total: {total_dock_space_m} m)")
        else:
             print("Cannot calculate dock space per ship (0 ships).")


    elif m30.status == GRB.INFEASIBLE:
         # Should not happen with lb=1 and ub >= lb
         print(f"Optimization Status: Infeasible. Check variable bounds (lb=1, ub={max_ships}).")
    elif m30.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         # Should be very fast, but include handling just in case
         if m30.ObjVal is not None and abs(m30.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m30.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m30.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- SHIP_BERTHING_COST_MINIMIZE: Cost Minimization for Berthing Ships (IP) ---
Optimization Status: Optimal
Optimal Number of Ships to Berth: 1 (Max allowed: 28)
Resulting Fixed Docking Fee: $48.00 (Cost/Ship: $48)
Total Fuel Cost (Constant): $7827.32
Minimum Total Cost: $7875.32
Dock space per ship: 18934.0 m (Total: 18934 m)


```

================================================================================



--- Problem 298 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling three delivery trucks at a single loading dock to minimize the total operational time. Each truck arrives at a specific time: Truck 1 at 4 hours, Truck 2 at 9 hours, and Truck 3 at 12 hours. The processing times for unloading and servicing these trucks vary—Truck 1 requires 5 hours, Truck 2 needs 7 hours, and Truck 3 takes 3 hours. The hub manager must carefully schedule the trucks to avoid overlaps, ensuring no two trucks occupy the dock simultaneously. The primary goal is to determine the optimal start times for each truck so that the last truck finishes as early as possible, minimizing the total makespan—the time when all operations are completed. Given the tight schedule and limited dock availability, the question is: *What is the earliest possible time all trucks can be serviced without conflicts?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary variable indicating whether truck `i` is assigned to dock `j`.  
     - `start_time(i)`: Continuous variable representing the start time of truck `i`.  
     - `completion_time(i)`: Continuous variable representing the completion time of truck `i`.  
     - `precedes(i, k, j)`: Binary variable indicating whether truck `i` is scheduled before truck `k` on dock `j`.  
     - `makespan`: Continuous variable representing the total completion time of all trucks.  

   - **2. Parameters:**  
     - `trucks = [1, 2, 3]`: List of trucks.  
     - `docks = [1]`: List of docks (only one in this case).  
     - `arrival_times = {1: 4, 2: 9, 3: 12}`: Arrival times for each truck.  
     - `processing_times = {1: 5, 2: 7, 3: 3}`: Processing times for each truck.  
     - `H = 100`: A large constant (Big M) used in constraints.  

   - **3. Objective Function:**  
     Minimize `makespan`, the latest completion time among all trucks.  

   - **4. Constraints:**  
     1. **Assignment:** Each truck must be assigned to exactly one dock:  
        `sum(assign(i, j) for j in docks) = 1` for all `i` in trucks.  
     2. **Arrival Time:** A truck cannot start before its arrival time:  
        `start_time(i) >= arrival_times[i]` for all `i` in trucks.  
     3. **Completion Time:** The completion time is the start time plus processing time:  
        `completion_time(i) = start_time(i) + processing_times[i]` for all `i` in trucks.  
     4. **Non-Overlapping:** For any two trucks assigned to the same dock, one must precede the other:  
        - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
        - If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.  
     5. **Makespan Definition:** The makespan is the maximum completion time:  
        `makespan >= completion_time(i)` for all `i` in trucks.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
docks = [1]
arrival_times = {1: 4, 2: 9, 3: 12}
processing_times = {1: 5, 2: 7, 3: 3}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DOCKING_PROBLEM_2_MIN_MAKESPAN")

    if not trucks or not docks: raise ValueError("Empty trucks or docks")

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in docks:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal makespan: {m.objVal:.4f}")
    for i in trucks:
        print(f"Truck {i} start time: {start_time[i].x:.4f}, completion time: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
19.0000
Optimal makespan: 19.0000
Truck 1 start time: 4.0000, completion time: 9.0000
Truck 2 start time: 9.0000, completion time: 16.0000
Truck 3 start time: 16.0000, completion time: 19.0000


```

================================================================================



--- Problem 299 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A fleet of 15 electric trucks, labeled Truck_1 through Truck_15, requires overnight charging at a depot equipped with three distinct chargers: Chgr_1 (57.5 kW), Chgr_2 (78.4 kW), and Chgr_3 (21.1 kW). Each truck has a unique charging demand, ranging from 30 kWh (Truck_4) to 100 kWh (Truck_12), translating to varying charging times depending on the charger's power output. For instance, Truck_1 needs 78 kWh, taking approximately 81.4 minutes on Chgr_1 but nearly 222 minutes on the slower Chgr_3. The depot manager faces a critical scheduling challenge: assign each truck to exactly one charger such that the last truck finishes charging as early as possible. This minimizes downtime and ensures the fleet is ready for morning operations. The core question is: *How should the trucks be distributed across the chargers to achieve the shortest possible total charging time?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `assign[t, c]` = 1 if truck `t` is assigned to charger `c`, else 0.  
   - Continuous variable `charger_makespan[c]` = Total time charger `c` is in use (sum of assigned trucks' charging times).  
   - Continuous variable `makespan` = Overall completion time (maximum of all `charger_makespan[c]`).  

   **2. Parameters:**  
   - `charging_time_min[t, c]`: Precomputed time (minutes) for truck `t` on charger `c` (e.g., Truck_1 on Chgr_1: 81.39 min).  
   - `trucks`: List of 15 trucks.  
   - `chargers`: List of 3 chargers with their power ratings.  

   **3. Objective Function:**  
   Minimize `makespan` (the time when the last charger finishes).  

   **4. Constraints:**  
   - Each truck must be assigned to exactly one charger:  
     `sum(assign[t, c] for c in chargers) = 1` for all trucks `t`.  
   - Charger makespan is the sum of assigned trucks' times:  
     `charger_makespan[c] = sum(assign[t, c] * charging_time_min[t, c] for all trucks t)` for all chargers `c`.  
   - Overall makespan is the maximum charger makespan:  
     `makespan >= charger_makespan[c]` for all chargers `c`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = ['Truck_1', 'Truck_2', 'Truck_3', 'Truck_4', 'Truck_5', 'Truck_6', 'Truck_7', 'Truck_8', 'Truck_9', 'Truck_10', 'Truck_11', 'Truck_12', 'Truck_13', 'Truck_14', 'Truck_15']
charge_needs_kwh = {'Truck_1': 78, 'Truck_2': 58, 'Truck_3': 44, 'Truck_4': 30, 'Truck_5': 80, 'Truck_6': 54, 'Truck_7': 88, 'Truck_8': 99, 'Truck_9': 47, 'Truck_10': 44, 'Truck_11': 69, 'Truck_12': 100, 'Truck_13': 84, 'Truck_14': 76, 'Truck_15': 50}
chargers = ['Chgr_1', 'Chgr_2', 'Chgr_3']
charger_power_kw = {'Chgr_1': 57.5, 'Chgr_2': 78.4, 'Chgr_3': 21.1}
# Calculated charging times (truck, charger): time_in_minutes
charging_time_min = {('Truck_1', 'Chgr_1'): 81.39130434782608, ('Truck_1', 'Chgr_2'): 59.69387755102041, ('Truck_1', 'Chgr_3'): 221.80094786729856, ('Truck_2', 'Chgr_1'): 60.52173913043478, ('Truck_2', 'Chgr_2'): 44.38775510204081, ('Truck_2', 'Chgr_3'): 164.92890995260663, ('Truck_3', 'Chgr_1'): 45.913043478260875, ('Truck_3', 'Chgr_2'): 33.6734693877551, ('Truck_3', 'Chgr_3'): 125.11848341232226, ('Truck_4', 'Chgr_1'): 31.304347826086957, ('Truck_4', 'Chgr_2'): 22.959183673469386, ('Truck_4', 'Chgr_3'): 85.30805687203791, ('Truck_5', 'Chgr_1'): 83.47826086956522, ('Truck_5', 'Chgr_2'): 61.224489795918366, ('Truck_5', 'Chgr_3'): 227.48815165876775, ('Truck_6', 'Chgr_1'): 56.34782608695652, ('Truck_6', 'Chgr_2'): 41.326530612244895, ('Truck_6', 'Chgr_3'): 153.55450236966823, ('Truck_7', 'Chgr_1'): 91.82608695652175, ('Truck_7', 'Chgr_2'): 67.3469387755102, ('Truck_7', 'Chgr_3'): 250.23696682464453, ('Truck_8', 'Chgr_1'): 103.30434782608695, ('Truck_8', 'Chgr_2'): 75.76530612244898, ('Truck_8', 'Chgr_3'): 281.51658767772506, ('Truck_9', 'Chgr_1'): 49.04347826086957, ('Truck_9', 'Chgr_2'): 35.969387755102034, ('Truck_9', 'Chgr_3'): 133.64928909952604, ('Truck_10', 'Chgr_1'): 45.913043478260875, ('Truck_10', 'Chgr_2'): 33.6734693877551, ('Truck_10', 'Chgr_3'): 125.11848341232226, ('Truck_11', 'Chgr_1'): 72.0, ('Truck_11', 'Chgr_2'): 52.806122448979586, ('Truck_11', 'Chgr_3'): 196.2085308056872, ('Truck_12', 'Chgr_1'): 104.34782608695652, ('Truck_12', 'Chgr_2'): 76.53061224489795, ('Truck_12', 'Chgr_3'): 284.3601895734597, ('Truck_13', 'Chgr_1'): 87.65217391304348, ('Truck_13', 'Chgr_2'): 64.28571428571428, ('Truck_13', 'Chgr_3'): 238.86255924170615, ('Truck_14', 'Chgr_1'): 79.30434782608695, ('Truck_14', 'Chgr_2'): 58.16326530612245, ('Truck_14', 'Chgr_3'): 216.11374407582937, ('Truck_15', 'Chgr_1'): 52.17391304347826, ('Truck_15', 'Chgr_2'): 38.265306122448976, ('Truck_15', 'Chgr_3'): 142.18009478672985}
# --- End Parameters ---

GUROBI_TIME_LIMIT = 45

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m35 = gp.Model("ELECTRIC_TRUCK_CHARGING_MIP", env=env)

    # --- Basic Input Validation ---
    if not trucks or not chargers: raise ValueError("Empty trucks or chargers list")
    # Check if any charging time is infinite (due to zero power)
    if any(t == float('inf') for t in charging_time_min.values()):
         print("Warning: Some charger has zero power, potentially infeasible.")

    # --- Decision Variables ---
    # Binary: assign[t, c]=1 if truck t assigned to charger c
    assign_keys = [(t, c) for t in trucks for c in chargers if charging_time_min.get((t,c), float('inf')) != float('inf')]
    if not assign_keys: raise ValueError("No possible assignments due to zero power chargers?")
    assign = m35.addVars(assign_keys, vtype=GRB.BINARY, name="assign")
    # Continuous: Makespan for each charger
    charger_makespan = m35.addVars(chargers, name="charger_makespan", lb=0)
    # Continuous: Overall makespan (objective)
    makespan = m35.addVar(name="overall_makespan", lb=0)

    # --- Objective Function ---
    # Minimize the overall makespan (time last truck finishes charging)
    m35.setObjective(makespan, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Assignment constraint: Each truck assigned to exactly one charger
    # Sum only over possible assignments (assign_keys) for each truck
    for t in trucks:
        m35.addConstr(gp.quicksum(assign[t_key, c_key] for t_key, c_key in assign_keys if t_key == t) == 1, name=f"assign_truck_{t}")

    # Makespan calculation constraints:
    # 1. Calculate makespan for each charger (sum of charging times of assigned trucks)
    for c in chargers:
        # Sum only over possible assignments involving charger c
        m35.addConstr(charger_makespan[c] == gp.quicksum(assign[t_key, c_key] * charging_time_min.get((t_key, c_key), 0)
                                                        for t_key, c_key in assign_keys if c_key == c), name=f"makespan_charger_{c}")

    # 2. Overall makespan is the maximum of individual charger makespans
    for c in chargers:
        m35.addConstr(makespan >= charger_makespan[c], name=f"overall_makespan_ge_charger_{c}")

    # --- Optimization ---
    m35.optimize()

    # --- Store results ---
    results_dict['status'] = m35.status
    if m35.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m35.ObjVal # = makespan.X
        results_dict['charger_makespan_sol'] = m35.getAttr('X', charger_makespan)
        results_dict['assign_sol'] = m35.getAttr('X', assign)

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 35: Electric Truck Charging Schedule (MIP) ---") # Original problem number
    if m35.status == GRB.OPTIMAL:
        makespan_sol = results_dict.get('obj_val', 'N/A')
        charger_mk_sol = results_dict.get('charger_makespan_sol', {})
        assign_sol = results_dict.get('assign_sol', {})

        print(f"Optimization Status: Optimal")
        if isinstance(makespan_sol, (int, float)):
             print(f"Minimum Makespan (Time until all trucks charged): {makespan_sol:.1f} minutes")
        else:
             print(f"Minimum Makespan (Time until all trucks charged): {makespan_sol}")

        print("Assignments and Charger Makespans:")
        assignments_dict = {} # Track assignments for final print
        for c in chargers:
            trucks_on_charger = []
            charger_mk_print = charger_mk_sol.get(c, 'N/A')
            # Iterate through solution dictionary `assign_sol`
            for (t_key, c_key), assigned_val in assign_sol.items():
                if c_key == c and assigned_val > 0.5:
                    charge_time_print = charging_time_min.get((t_key, c_key), '?')
                    trucks_on_charger.append(f"{t_key} ({float(charge_time_print):.0f} min)")
                    assignments_dict[t_key] = c_key # Store assignment

            # Format charger makespan value
            if isinstance(charger_mk_print, (int, float)):
                 charger_mk_str = f"{charger_mk_print:.1f} min"
            else:
                 charger_mk_str = f"{charger_mk_print}"
            print(f"  Charger {c}: Assigned Trucks: {', '.join(trucks_on_charger)}. Charger Makespan: {charger_mk_str}")

        print("Truck Assignments:")
        for t in trucks: print(f"  Truck {t} -> Charger {assignments_dict.get(t, 'Unassigned')}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m35.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# The provided code already prints all the necessary outputs, so no additional print statements are needed.
```
Answer:
--- Problem 35: Electric Truck Charging Schedule (MIP) ---
Optimization Status: Optimal
Minimum Makespan (Time until all trucks charged): 383.0 minutes
Assignments and Charger Makespans:
  Charger Chgr_1: Assigned Trucks: Truck_4 (31 min), Truck_7 (92 min), Truck_8 (103 min), Truck_12 (104 min), Truck_15 (52 min). Charger Makespan: 383.0 min
  Charger Chgr_2: Assigned Trucks: Truck_1 (60 min), Truck_2 (44 min), Truck_3 (34 min), Truck_9 (36 min), Truck_10 (34 min), Truck_11 (53 min), Truck_13 (64 min), Truck_14 (58 min). Charger Makespan: 382.7 min
  Charger Chgr_3: Assigned Trucks: Truck_5 (227 min), Truck_6 (154 min). Charger Makespan: 381.0 min
Truck Assignments:
  Truck Truck_1 -> Charger Chgr_2
  Truck Truck_2 -> Charger Chgr_2
  Truck Truck_3 -> Charger Chgr_2
  Truck Truck_4 -> Charger Chgr_1
  Truck Truck_5 -> Charger Chgr_3
  Truck Truck_6 -> Charger Chgr_3
  Truck Truck_7 -> Charger Chgr_1
  Truck Truck_8 -> Charger Chgr_1
  Truck Truck_9 -> Charger Chgr_2
  Truck Truck_10 -> Charger Chgr_2
  Truck Truck_11 -> Charger Chgr_2
  Truck Truck_12 -> Charger Chgr_1
  Truck Truck_13 -> Charger Chgr_2
  Truck Truck_14 -> Charger Chgr_2
  Truck Truck_15 -> Charger Chgr_1


```

================================================================================



--- Problem 300 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A busy container terminal, divided into five distinct areas (Area_A to Area_E), is facing an urgent need to clear containers due to an incoming storm. With a total of 249, 286, 250, 166, and 124 containers in each area respectively, the terminal must efficiently direct containers to one of two available loading docks (Dock 1 and Dock 2) within a tight 16-minute window. Each dock can process containers at a rate of 17 containers per minute, translating to a total capacity of 272 containers per dock over the entire period. The challenge lies in maximizing the number of containers cleared while adhering to two critical constraints: no area can send out more containers than it contains, and no dock can handle more than its total capacity. The central question is: *How should containers be routed from each area to the docks to clear the maximum possible number of containers within the given time and capacity limits?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `f[i, j]`: A continuous variable representing the number of containers flowing from area `i` (where `i` is one of Area_A to Area_E) to dock `j` (where `j` is 1 or 2).  
   - **2. Parameters:**  
     - `area_containers[i]`: Number of containers initially in area `i` (e.g., Area_A has 249).  
     - `total_dock_capacity[j]`: Total capacity of dock `j` over 16 minutes (272 containers per dock).  
   - **3. Objective Function:**  
     - Maximize the total number of cleared containers:  
       `Maximize: sum(f[i, j] for all i, j)`.  
   - **4. Constraints:**  
     - **Area Supply:** For each area `i`, the total outflow cannot exceed its container count:  
       `sum(f[i, j] for j in docks) <= area_containers[i]`.  
     - **Dock Capacity:** For each dock `j`, the total inflow cannot exceed its capacity:  
       `sum(f[i, j] for i in areas) <= total_dock_capacity[j]`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
areas = ['Area_A', 'Area_B', 'Area_C', 'Area_D', 'Area_E']
docks = [1, 2]
area_containers = {'Area_A': 249, 'Area_B': 286, 'Area_C': 250, 'Area_D': 166, 'Area_E': 124} # Dict area: count
dock_capacity_rate = 17 # containers per minute per dock
time_period = 16 # minutes
total_dock_capacity = {1: 272, 2: 272} # Dict dock: capacity over period
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("CONTAINER_TERMINAL_CLEARING", env=env)

    # --- Basic Input Validation ---
    if not areas or not docks:
        raise ValueError("Empty areas or docks list")

    # --- Decision Variables ---
    # f[i, j]: Number of containers flowing from area i to dock j within the time period
    flow_keys = [(i, j) for i in areas for j in docks]
    f = m.addVars(flow_keys, vtype=GRB.CONTINUOUS, lb=0, name="flow")

    # --- Objective Function: Maximize total containers exiting ---
    m.setObjective(gp.quicksum(f[i, j] for i, j in flow_keys), GRB.MAXIMIZE)

    # --- Constraints ---
    # Flow out of an area cannot exceed the number of containers in it
    m.addConstrs((gp.quicksum(f[i, j] for j in docks) <= area_containers.get(i, 0) for i in areas), "AreaSupply")

    # Flow into a dock cannot exceed its capacity over the period
    m.addConstrs((gp.quicksum(f[i, j] for i in areas) <= total_dock_capacity.get(j, 0) for j in docks), "DockCapacity")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['f_sol'] = m.getAttr('X', f) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Objective is total containers, potentially float
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the flow of containers from each area to each dock
if m.Status == GRB.OPTIMAL:
    for i in areas:
        for j in docks:
            print(f"Containers from {i} to Dock {j}: {f[i, j].X:.2f}")
```
Answer:
Optimal objective value: 544.00
Containers from Area_A to Dock 1: 101.00
Containers from Area_A to Dock 2: 148.00
Containers from Area_B to Dock 1: 171.00
Containers from Area_B to Dock 2: 0.00
Containers from Area_C to Dock 1: 0.00
Containers from Area_C to Dock 2: 0.00
Containers from Area_D to Dock 1: 0.00
Containers from Area_D to Dock 2: 0.00
Containers from Area_E to Dock 1: 0.00
Containers from Area_E to Dock 2: 124.00


```

================================================================================



--- Problem 301 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
A single-lane bridge serves as a critical bottleneck for northbound (NB) and southbound (SB) truck traffic, requiring precise signal timing to maximize throughput while ensuring fairness. The bridge operates on a fixed cycle length of 161 seconds, with 24 seconds lost to switching directions, leaving 137 seconds of effective green time to allocate between the two directions. The challenge is to distribute this green time optimally to accommodate truck traffic demand without exceeding lane capacity. 

Northbound truck traffic arrives at a rate of 129 vehicles per hour, while southbound truck traffic flows at 105 vehicles per hour. The bridge’s capacity is governed by a conversion factor: each second of green time can handle approximately 4.7516 vehicles per hour. The goal is to maximize total throughput (NB + SB) while ensuring that the allocated green time respects both demand limits and a fairness constraint—traffic flow must be proportional to demand. If one direction has no demand, its throughput must be zero. The optimization must also ensure that the sum of green times for both directions matches the total effective green time available.

**Modeling Process:**
**1. Decision Variables:**
- `g_n`: Green time allocated to northbound truck traffic (seconds).
- `g_s`: Green time allocated to southbound truck traffic (seconds).
- `t_n`: Throughput of northbound truck traffic (vehicles/hour).
- `t_s`: Throughput of southbound truck traffic (vehicles/hour).

**2. Parameters:**
- `cycle_length_sec = 161`: Total cycle time (seconds).
- `lost_time_per_switch = 12`: Time lost per direction switch (seconds).
- `total_lost_time = 24`: Total lost time per cycle (seconds).
- `effective_green_total = 137`: Total effective green time to allocate (seconds).
- `demand_n_veh_per_hr = 129`: Northbound demand (vehicles/hour).
- `demand_s_veh_per_hr = 105`: Southbound demand (vehicles/hour).
- `capacity_factor = 4.7516`: Capacity conversion factor (vehicles/hour per second of green time).

**3. Objective Function:**
Maximize total throughput:  
`Maximize: t_n + t_s`

**4. Constraints:**
- Total green time must equal effective green time:  
  `g_n + g_s == effective_green_total`
- Throughput cannot exceed capacity:  
  `t_n <= capacity_factor * g_n`  
  `t_s <= capacity_factor * g_s`
- Throughput cannot exceed demand:  
  `t_n <= demand_n_veh_per_hr`  
  `t_s <= demand_s_veh_per_hr`
- Proportional flow (if both demands are non-zero):  
  `t_n * demand_s_veh_per_hr == t_s * demand_n_veh_per_hr`
- Zero throughput if demand is zero:  
  If `demand_n_veh_per_hr == 0`, then `t_n == 0`  
  If `demand_s_veh_per_hr == 0`, then `t_s == 0`

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cycle_length_sec = 161
lost_time_per_switch = 12
total_lost_time = 24
effective_green_total = 137
lane_capacity_veh_per_hr = 765
demand_n_veh_per_hr = 129
demand_s_veh_per_hr = 105
capacity_factor = 4.7516 # veh/hr per second of green
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m28 = gp.Model("SINGLE_LANE_BRIDGE_LP", env=env)

    # --- Decision Variables ---
    g_n = m28.addVar(name="green_north_truck", lb=0)
    g_s = m28.addVar(name="green_south_truck", lb=0)
    t_n = m28.addVar(name="throughput_north_truck", lb=0)
    t_s = m28.addVar(name="throughput_south_truck", lb=0)

    # --- Objective Function ---
    # Maximize total throughput
    m28.setObjective(t_n + t_s, sense=GRB.MAXIMIZE)

    # --- Constraints ---
    # Total green time equals effective green time
    m28.addConstr(g_n + g_s == effective_green_total, name="total_green_time")

    # Throughput limited by capacity (proportional to green time)
    m28.addConstr(t_n <= capacity_factor * g_n, name="north_capacity_limit")
    m28.addConstr(t_s <= capacity_factor * g_s, name="south_capacity_limit")

    # Throughput limited by demand
    m28.addConstr(t_n <= demand_n_veh_per_hr, name="north_demand_limit")
    m28.addConstr(t_s <= demand_s_veh_per_hr, name="south_demand_limit")

    # Proportional flow constraint (ensure fairness based on demand ratio)
    # Avoid division by zero if demand is 0
    if demand_n_veh_per_hr > 1e-6 and demand_s_veh_per_hr > 1e-6:
         m28.addConstr(t_n * demand_s_veh_per_hr == t_s * demand_n_veh_per_hr, name="proportional_flow")
    elif demand_n_veh_per_hr <= 1e-6: # If north demand is zero, north throughput must be zero
         m28.addConstr(t_n == 0, name="proportional_flow_n0")
    elif demand_s_veh_per_hr <= 1e-6: # If south demand is zero, south throughput must be zero
         m28.addConstr(t_s == 0, name="proportional_flow_s0")


    # --- Optimization ---
    m28.optimize()

    # --- Store results ---
    results_dict['status'] = m28.status
    if m28.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m28.ObjVal
        results_dict['g_n_sol'] = g_n.X
        results_dict['g_s_sol'] = g_s.X
        results_dict['t_n_sol'] = t_n.X
        results_dict['t_s_sol'] = t_s.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- SINGLE_LANE_BRIDGE: Single-Lane Bridge Alternating Flow (LP) ---")
    if m28.status == GRB.OPTIMAL:
        g_n_sol = results_dict.get('g_n_sol', 0)
        g_s_sol = results_dict.get('g_s_sol', 0)
        t_n_sol = results_dict.get('t_n_sol', 0)
        t_s_sol = results_dict.get('t_s_sol', 0)
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Optimal NB Green Time (g_n): {g_n_sol:.1f} sec")
        print(f"Optimal SB Green Time (g_s): {g_s_sol:.1f} sec")
        print(f"Total Effective Green: {g_n_sol + g_s_sol:.1f} / {effective_green_total} sec (Cycle: {cycle_length_sec}s, Lost: {total_lost_time}s)")
        print(f"Maximized NB Throughput (t_n): {t_n_sol:.1f} veh/hr (Demand: {demand_n_veh_per_hr})")
        print(f"Maximized SB Throughput (t_s): {t_s_sol:.1f} veh/hr (Demand: {demand_s_veh_per_hr})")
        print(f"Total Maximized Throughput: {obj_val_print:.1f} veh/hr")

        # Check capacity needed vs provided
        cap_n_provided = capacity_factor * g_n_sol
        cap_s_provided = capacity_factor * g_s_sol
        print(f"NB Capacity Provided: {cap_n_provided:.1f} veh/hr (Lane Capacity: {lane_capacity_veh_per_hr} veh/hr)")
        print(f"SB Capacity Provided: {cap_s_provided:.1f} veh/hr")

        # Check proportionality
        prop_n = t_n_sol / demand_n_veh_per_hr if demand_n_veh_per_hr > 1e-6 else 0
        prop_s = t_s_sol / demand_s_veh_per_hr if demand_s_veh_per_hr > 1e-6 else 0
        if abs(prop_n - prop_s) < 1e-4:
             print(f"Flow is proportional to demand (Ratio ~ {prop_n:.3f}).")
        else:
             # Check if one demand was zero
             if demand_n_veh_per_hr <= 1e-6 and abs(t_n_sol) < 1e-6:
                  print("Flow proportional (North demand/throughput is zero).")
             elif demand_s_veh_per_hr <= 1e-6 and abs(t_s_sol) < 1e-6:
                  print("Flow proportional (South demand/throughput is zero).")
             else:
                  print(f"Flow proportionality check failed: N={prop_n:.3f}, S={prop_s:.3f}")

    elif m28.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible.")
         # Check if total demand <= total capacity in cycle
         # Effective capacity calculation might be subtle. Use model capacity factor approach.
         total_demand_ph = demand_n_veh_per_hr + demand_s_veh_per_hr
         total_effective_capacity_ph = capacity_factor * effective_green_total
         print(f"Total Demand: {total_demand_ph:.1f} veh/hr")
         print(f"Total Effective Capacity per hour (using factor*effective_green): {total_effective_capacity_ph:.1f} veh/hr")
         print("(Infeasibility often due to proportionality constraint conflicting with capacity/demand limits).")

    elif m28.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m28.ObjVal is not None and abs(m28.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m28.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m28.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- SINGLE_LANE_BRIDGE: Single-Lane Bridge Alternating Flow (LP) ---
Optimization Status: Optimal
Optimal NB Green Time (g_n): 27.1 sec
Optimal SB Green Time (g_s): 109.9 sec
Total Effective Green: 137.0 / 137 sec (Cycle: 161s, Lost: 24s)
Maximized NB Throughput (t_n): 129.0 veh/hr (Demand: 129)
Maximized SB Throughput (t_s): 105.0 veh/hr (Demand: 105)
Total Maximized Throughput: 234.0 veh/hr
NB Capacity Provided: 129.0 veh/hr (Lane Capacity: 765 veh/hr)
SB Capacity Provided: 522.0 veh/hr
Flow is proportional to demand (Ratio ~ 1.000).


```

================================================================================



--- Problem 302 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port terminal is tasked with efficiently scheduling a diverse set of 18 ships into berths, each with a strict time limit of 84 hours. The ships vary significantly in the time they need to load and unload, ranging from as short as 3 hours to as long as 83 hours, and each belongs to one of 12 distinct shipping companies (e.g., 'N', 'J', 'U', etc.). The challenge is compounded by a critical operational rule: no berth may serve ships from more than two different shipping companies, ensuring compatibility with downstream logistics systems. The terminal manager must determine the minimal number of berths required to accommodate all ships while adhering to both time and company constraints. This optimization directly impacts port efficiency and operational costs, as fewer berths reduce handling expenses and space requirements. The core question is: *What is the smallest number of berths needed to schedule all ships without violating time or company restrictions?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `x[i, j]`: Equals 1 if ship *i* is assigned to berth *j*, else 0.  
     - Binary variable `y[j]`: Equals 1 if berth *j* is used, else 0.  
     - Binary variable `z[c, j]`: Equals 1 if shipping company *c* is present in berth *j*, else 0.  
   - **2. Parameters:**  
     - `ships[i]`: Time required for ship *i* (e.g., [48, 23, ..., 75, 37]).  
     - `companies[i]`: Company label of ship *i* (e.g., ['N', 'J', ..., 'T', 'H']).  
     - `capacity`: Maximum time per berth (84 hours).  
     - `unique_companies_list`: Sorted list of distinct companies (e.g., ['B', 'D', ..., 'W', 'Z']).  
   - **3. Objective Function:**  
     Minimize the total number of berths used:  
     \[
     \text{Minimize: } \sum_{j} y[j]
     \]  
   - **4. Constraints:**  
     - **Ship Assignment:** Each ship must be in exactly one berth:  
       \[
       \sum_{j} x[i, j] = 1 \quad \forall i
       \]  
     - **Berth Capacity:** Total time in berth *j* cannot exceed capacity:  
       \[
       \sum_{i} ships[i] \cdot x[i, j] \leq capacity \cdot y[j] \quad \forall j
       \]  
     - **Company Linking:** If any ship of company *c* is in berth *j*, `z[c, j]` must be 1:  
       \[
       x[i, j] \leq z[companies[i], j] \quad \forall i, j
       \]  
     - **Company Limit:** Each used berth contains at most 2 distinct companies:  
       \[
       \sum_{c} z[c, j] \leq 2 \cdot y[j] \quad \forall j
       \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
ships = [48, 23, 52, 40, 35, 13, 83, 23, 55, 19, 63, 48, 3, 39, 5, 72, 75, 37]      # Times required for ships
companies = ['N', 'J', 'U', 'Z', 'N', 'K', 'Q', 'B', 'W', 'K', 'Z', 'R', 'D', 'D', 'T', 'O', 'T', 'H']    # Companies of ships
capacity = 84         # Berth capacity
num_ships = 18       # len(ships) - derived correctly below
num_berths = num_ships      # Maximum berths (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(ships) != len(companies) or len(ships) != num_ships:
    print("Error: Data inconsistency (ships/companies/num_ships length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_companies_list = sorted(list(set(companies))) # Get unique companies deterministically
ship_indices_by_company = {company: [i for i, c in enumerate(companies) if c == company] for company in unique_companies_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Company-Constrained Berth Scheduling", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")  # x[i,j] -> ship i in berth j
        y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")              # y[j] -> whether berth j is used
        # z[c,j] -> whether company c is PRESENT in berth j (Use unique_companies_list for keys)
        z = model.addVars(unique_companies_list, num_berths, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of berths used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each ship must be assigned to exactly one berth ---
        for i in range(num_ships):
            model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

        # --- Constraint 2: Berth capacity constraint ---
        for j in range(num_berths):
            model.addConstr(gp.quicksum(ships[i] * x[i, j] for i in range(num_ships)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

        # --- Constraint 3: Company constraint (at most 2 *different* companies per berth) ---

        # Part 3a: Link x (ship in berth) and z (company in berth).
        for j in range(num_berths):
            for company in unique_companies_list:
                indices_of_this_company = ship_indices_by_company.get(company, []) # Use .get for safety

                if not indices_of_this_company:
                    # If no ships of this company exist, z[company, j] must be 0.
                    model.addConstr(z[company, j] == 0, name=f"NoShips_{company}_Berth_{j}")
                    continue

                # If any ship 'i' of this 'company' is placed in berth 'j' (x[i,j]=1),
                # then the presence indicator for that 'company' in berth 'j' (z[company,j]) must be 1.
                for i in indices_of_this_company:
                    model.addConstr(x[i, j] <= z[company, j], name=f"Link_x{i}_z{company}_Berth{j}")

                # Ensure z[company, j] is 0 if no ships of that company are in the berth.
                # This helps tighten the formulation.
                model.addConstr(z[company, j] <= gp.quicksum(x[i, j] for i in indices_of_this_company), name=f"Link_z{company}_SumX_Berth{j}")


        # Part 3b: Limit the number of distinct companies (sum of z[c,j] for berth j) to 2 for USED berths.
        for j in range(num_berths):
            # sum(z[c,j] for c in unique_companies_list) gives the count of distinct companies in berth j.
            # This sum must be <= 2 *IF* the berth is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Companies_Berth_{j}")

        # --- Solve ---
        print("Solving CCBP instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of berths used: {optimal_berths}")
    print("-" * 30)

    berth_details = []
    printed_berth_count = 0
    for j_sol in range(num_berths): # Iterate through all potential berth indices
        try:
             # Check if this berth was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_berth_count += 1
                 assigned_ships_indices = [i for i in range(num_ships) if x[i, j_sol].X > 0.5]
                 assigned_ships_times = [ships[i] for i in assigned_ships_indices]
                 assigned_ships_companies = [companies[i] for i in assigned_ships_indices]
                 distinct_companies_in_berth = sorted(list(set(assigned_ships_companies))) # Sort for consistent output
                 berth_load = sum(assigned_ships_times)

                 print(f"Berth {printed_berth_count} (Internal Index {j_sol}):")
                 print(f"  Ships (indices): {assigned_ships_indices}")
                 # print(f"  Ships (times): {assigned_ships_times}") # Optional details
                 # print(f"  Ships (companies):  {assigned_ships_companies}") # Optional details
                 print(f"  Distinct Companies: {distinct_companies_in_berth} (Count: {len(distinct_companies_in_berth)})")
                 print(f"  Total time:    {berth_load} / {capacity}")
                 print("-" * 10)

                 berth_data = {
                     'berth_index_internal': j_sol,
                     'berth_index_printed': printed_berth_count,
                     'ship_indices': assigned_ships_indices,
                     'distinct_companies': distinct_companies_in_berth,
                     'load': berth_load
                 }
                 berth_details.append(berth_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for berth index {j_sol}: {e_print}")


    results_dict['berth_details'] = berth_details # Store details

    # Final sanity check
    if printed_berth_count != optimal_berths:
         print(f"Warning: Number of printed used berths ({printed_berth_count}) does not match objective value ({optimal_berths}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# The code provided already prints the optimal number of berths and detailed information about each berth.
# However, it does not print the total time for all berths combined, which could be useful for a complete overview.
# Additionally, it does not print the list of ships with their respective companies and times for each berth.

# Supplemental code to print the total time for all berths and detailed ship information:
if results_dict.get('status') == GRB.OPTIMAL:
    total_time = sum(berth['load'] for berth in berth_details)
    print(f"Total time for all berths: {total_time} / {capacity * optimal_berths}")

    for berth in berth_details:
        print(f"Berth {berth['berth_index_printed']} (Internal Index {berth['berth_index_internal']}):")
        print(f"  Ships (indices): {berth['ship_indices']}")
        print(f"  Ships (times): {[ships[i] for i in berth['ship_indices']]}")
        print(f"  Ships (companies): {[companies[i] for i in berth['ship_indices']]}")
        print(f"  Distinct Companies: {berth['distinct_companies']} (Count: {len(berth['distinct_companies'])})")
        print(f"  Total time: {berth['load']} / {capacity}")
        print("-" * 10)
```
Answer:
Solving CCBP instance...
------------------------------

Optimal solution found.
Optimal number of berths used: 10
------------------------------
Berth 1 (Internal Index 0):
  Ships (indices): [14, 15]
  Distinct Companies: ['O', 'T'] (Count: 2)
  Total time:    77 / 84
----------
Berth 2 (Internal Index 1):
  Ships (indices): [4, 11]
  Distinct Companies: ['N', 'R'] (Count: 2)
  Total time:    83 / 84
----------
Berth 3 (Internal Index 2):
  Ships (indices): [3, 17]
  Distinct Companies: ['H', 'Z'] (Count: 2)
  Total time:    77 / 84
----------
Berth 4 (Internal Index 3):
  Ships (indices): [7, 12, 13]
  Distinct Companies: ['B', 'D'] (Count: 2)
  Total time:    65 / 84
----------
Berth 5 (Internal Index 4):
  Ships (indices): [0, 5, 9]
  Distinct Companies: ['K', 'N'] (Count: 2)
  Total time:    80 / 84
----------
Berth 6 (Internal Index 5):
  Ships (indices): [10]
  Distinct Companies: ['Z'] (Count: 1)
  Total time:    63 / 84
----------
Berth 7 (Internal Index 6):
  Ships (indices): [6]
  Distinct Companies: ['Q'] (Count: 1)
  Total time:    83 / 84
----------
Berth 8 (Internal Index 10):
  Ships (indices): [2]
  Distinct Companies: ['U'] (Count: 1)
  Total time:    52 / 84
----------
Berth 9 (Internal Index 13):
  Ships (indices): [16]
  Distinct Companies: ['T'] (Count: 1)
  Total time:    75 / 84
----------
Berth 10 (Internal Index 16):
  Ships (indices): [1, 8]
  Distinct Companies: ['J', 'W'] (Count: 2)
  Total time:    78 / 84
----------
Total time for all berths: 733 / 840
Berth 1 (Internal Index 0):
  Ships (indices): [14, 15]
  Ships (times): [5, 72]
  Ships (companies): ['T', 'O']
  Distinct Companies: ['O', 'T'] (Count: 2)
  Total time: 77 / 84
----------
Berth 2 (Internal Index 1):
  Ships (indices): [4, 11]
  Ships (times): [35, 48]
  Ships (companies): ['N', 'R']
  Distinct Companies: ['N', 'R'] (Count: 2)
  Total time: 83 / 84
----------
Berth 3 (Internal Index 2):
  Ships (indices): [3, 17]
  Ships (times): [40, 37]
  Ships (companies): ['Z', 'H']
  Distinct Companies: ['H', 'Z'] (Count: 2)
  Total time: 77 / 84
----------
Berth 4 (Internal Index 3):
  Ships (indices): [7, 12, 13]
  Ships (times): [23, 3, 39]
  Ships (companies): ['B', 'D', 'D']
  Distinct Companies: ['B', 'D'] (Count: 2)
  Total time: 65 / 84
----------
Berth 5 (Internal Index 4):
  Ships (indices): [0, 5, 9]
  Ships (times): [48, 13, 19]
  Ships (companies): ['N', 'K', 'K']
  Distinct Companies: ['K', 'N'] (Count: 2)
  Total time: 80 / 84
----------
Berth 6 (Internal Index 5):
  Ships (indices): [10]
  Ships (times): [63]
  Ships (companies): ['Z']
  Distinct Companies: ['Z'] (Count: 1)
  Total time: 63 / 84
----------
Berth 7 (Internal Index 6):
  Ships (indices): [6]
  Ships (times): [83]
  Ships (companies): ['Q']
  Distinct Companies: ['Q'] (Count: 1)
  Total time: 83 / 84
----------
Berth 8 (Internal Index 10):
  Ships (indices): [2]
  Ships (times): [52]
  Ships (companies): ['U']
  Distinct Companies: ['U'] (Count: 1)
  Total time: 52 / 84
----------
Berth 9 (Internal Index 13):
  Ships (indices): [16]
  Ships (times): [75]
  Ships (companies): ['T']
  Distinct Companies: ['T'] (Count: 1)
  Total time: 75 / 84
----------
Berth 10 (Internal Index 16):
  Ships (indices): [1, 8]
  Ships (times): [23, 55]
  Ships (companies): ['J', 'W']
  Distinct Companies: ['J', 'W'] (Count: 2)
  Total time: 78 / 84
----------


```

================================================================================



--- Problem 303 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy port is managing the berthing and unloading of 19 ships. Each ship must go through two sequential stages: first, berthing (Stage 0) and then unloading (Stage 1). The challenge is to minimize the total time taken for all ships to complete both stages, known as the *makespan*, which directly impacts the port's operational efficiency and customer satisfaction.

The processing times vary significantly across ships and stages. For instance, Ship 0 takes 18 minutes to berth and 26 minutes to unload, while Ship 13 requires 87 minutes to berth and 66 minutes to unload. The ships must adhere to a strict first-come-first-served sequence, but their stage transitions must respect two rules: a ship cannot start unloading until its berthing is complete, and no two ships can occupy the same stage simultaneously. The core question is: *What is the shortest possible time to process all 19 ships under these constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `C[i, j]`: Continuous variable representing the completion time of ship `i` at stage `j` (e.g., `C[2, 1]` is when Ship 2 finishes unloading).  
   - **2. Parameters:**  
     - `ships`: List of 19 ships (indices 0 to 18).  
     - `process_times[i][j]`: Time for ship `i` at stage `j` (e.g., `process_times[4][0] = 29` minutes for Ship 4’s berthing).  
     - `num_stages = 2` (berthing and unloading).  
   - **3. Objective Function:**  
     - Minimize `C[18, 1]` (completion time of the last ship at the final stage).  
   - **4. Constraints:**  
     - **Stage 0 (Berthing):**  
       - Ship 0: `C[0, 0] ≥ process_times[0][0]`.  
       - Subsequent ships: `C[i, 0] ≥ C[i-1, 0] + process_times[i][0]` for `i > 0`.  
     - **Stage 1 (Unloading):**  
       - Ship 0: `C[0, 1] ≥ C[0, 0] + process_times[0][1]`.  
       - Subsequent ships:  
         - Must finish Stage 0 first: `C[i, 1] ≥ C[i, 0] + process_times[i][1]`.  
         - Must wait for prior ship at Stage 1: `C[i, 1] ≥ C[i-1, 1] + process_times[i][1]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] # List of ship indices [0, 1, ...]
# process_times[ship][stage], stage 0=Berthing, stage 1=Unloading
process_times = [[18, 26], [64, 32], [58, 75], [83, 85], [29, 64], [78, 71], [82, 46], [72, 37], [71, 60], [68, 37], [65, 84], [36, 69], [53, 53], [87, 66], [59, 20], [54, 41], [64, 54], [24, 66], [51, 71]]
num_stages = 2 # Should be 2 based on original code
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_FLOW_SHOP", env=env)

    # --- Basic Input Validation ---
    if not ships or num_stages <= 0 or not process_times or len(process_times) != len(ships):
        raise ValueError("Invalid input data for Port Flow Shop")
    if any(len(row) != num_stages for row in process_times):
         raise ValueError("Inconsistent number of stages in process_times")

    # --- Decision Variables ---
    # C[i, j]: Completion time of ship i at stage j
    C = m.addVars(ships, range(num_stages), vtype=GRB.CONTINUOUS, lb=0, name="C")

    # --- Objective Function: Minimize the makespan ---
    # Makespan is completion time of the last ship at the last stage
    last_ship_idx = ships[-1]
    last_stage_idx = num_stages - 1
    m.setObjective(C[last_ship_idx, last_stage_idx], GRB.MINIMIZE)

    # --- Constraints ---
    # Stage 0 completion times (assuming fixed sequence 0, 1, 2...)
    # First ship at stage 0
    m.addConstr(C[0, 0] >= process_times[0][0], "C0_0")
    # Subsequent ships at stage 0
    for i in range(1, len(ships)):
        m.addConstr(C[i, 0] >= C[i-1, 0] + process_times[i][0], f"C0_{i}")

    # Completion times for subsequent stages (j > 0)
    for j in range(1, num_stages):
        # First ship at stage j
        m.addConstr(C[0, j] >= C[0, j-1] + process_times[0][j], f"C{j}_0")
        # Subsequent ships at stage j
        for i in range(1, len(ships)):
            # Must complete stage j-1 first
            m.addConstr(C[i, j] >= C[i, j-1] + process_times[i][j], f"C{j}_{i}_StagePrev")
            # Must wait for previous ship to finish stage j
            m.addConstr(C[i, j] >= C[i-1, j] + process_times[i][j], f"C{j}_{i}_ShipPrev")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['C_sol'] = m.getAttr('X', C) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}") # Makespan
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block to print the completion times for each ship at each stage)
if m.Status == GRB.OPTIMAL:
    for i in ships:
        for j in range(num_stages):
            print(f"Completion time of Ship {i} at Stage {j}: {C[i, j].X:.2f}")
```
Answer:
Optimal objective value: 1232.00
Completion time of Ship 0 at Stage 0: 18.00
Completion time of Ship 0 at Stage 1: 44.00
Completion time of Ship 1 at Stage 0: 82.00
Completion time of Ship 1 at Stage 1: 114.00
Completion time of Ship 2 at Stage 0: 140.00
Completion time of Ship 2 at Stage 1: 215.00
Completion time of Ship 3 at Stage 0: 223.00
Completion time of Ship 3 at Stage 1: 308.00
Completion time of Ship 4 at Stage 0: 252.00
Completion time of Ship 4 at Stage 1: 372.00
Completion time of Ship 5 at Stage 0: 330.00
Completion time of Ship 5 at Stage 1: 443.00
Completion time of Ship 6 at Stage 0: 412.00
Completion time of Ship 6 at Stage 1: 489.00
Completion time of Ship 7 at Stage 0: 484.00
Completion time of Ship 7 at Stage 1: 526.00
Completion time of Ship 8 at Stage 0: 555.00
Completion time of Ship 8 at Stage 1: 615.00
Completion time of Ship 9 at Stage 0: 623.00
Completion time of Ship 9 at Stage 1: 660.00
Completion time of Ship 10 at Stage 0: 688.00
Completion time of Ship 10 at Stage 1: 772.00
Completion time of Ship 11 at Stage 0: 724.00
Completion time of Ship 11 at Stage 1: 841.00
Completion time of Ship 12 at Stage 0: 777.00
Completion time of Ship 12 at Stage 1: 894.00
Completion time of Ship 13 at Stage 0: 864.00
Completion time of Ship 13 at Stage 1: 960.00
Completion time of Ship 14 at Stage 0: 923.00
Completion time of Ship 14 at Stage 1: 980.00
Completion time of Ship 15 at Stage 0: 977.00
Completion time of Ship 15 at Stage 1: 1021.00
Completion time of Ship 16 at Stage 0: 1041.00
Completion time of Ship 16 at Stage 1: 1095.00
Completion time of Ship 17 at Stage 0: 1065.00
Completion time of Ship 17 at Stage 1: 1161.00
Completion time of Ship 18 at Stage 0: 1116.00
Completion time of Ship 18 at Stage 1: 1232.00


```

================================================================================



--- Problem 304 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy container port is preparing for a high-traffic evening, expecting a surge of 1,297 trucks arriving at its entry gates within a tight 40-minute window. The port has four entry gates, each capable of processing 328 trucks per hour. However, opening gates incurs a cost of $45 per gate per hour, while any unmet demand leads to frustrated drivers—quantified as a $0.24 penalty per truck per minute of waiting time. The operations team faces a critical trade-off: deploy too few gates, and the penalties from delays could skyrocket; open too many, and the fixed costs eat into the budget. The challenge is to determine the exact number of gates to activate, balancing these costs while ensuring the system can handle the incoming flow without unnecessary expenditure.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x`: Integer variable representing the number of gates to open (0 ≤ `x` ≤ 4).  
     - `y`: Binary variable indicating whether capacity is insufficient (`y = 1` if demand exceeds service rate; else `y = 0`).  
     - `wait_penalty`: Continuous variable for the total waiting penalty cost ($).  

   - **2. Parameters:**  
     - Arrival rate: 1,297 trucks/hour.  
     - Service rate per gate: 328 trucks/hour.  
     - Cost per gate: $45/hour.  
     - Penalty rate: $0.24/truck/minute (converted to $14.4/truck/hour for consistency).  
     - Event duration: 40 minutes (2/3 hour).  
     - Big-M (M): 10,000 (arbitrarily large constant for linearization).  
     - Epsilon (ε): 0.1 (small tolerance to enforce binary logic).  

   - **3. Objective Function:**  
     Minimize total cost:  
     \[
     \text{Total Cost} = (45 \cdot x) + \text{wait\_penalty}
     \]  

   - **4. Constraints:**  
     - **Capacity trigger:**  
       If demand exceeds capacity (`arrival_rate > service_rate * x`), force `y = 1`:  
       \[
       1297 - 328x \leq M \cdot y
       \]  
       Else, force `y = 0`:  
       \[
       1297 - 328x \geq \epsilon - M \cdot (1 - y)
       \]  
     - **Penalty bounds:**  
       If `y = 1`, penalty equals unmet demand scaled by duration and rate:  
       \[
       \text{wait\_penalty} \geq (1297 - 328x) \cdot \frac{2}{3} \cdot 0.24 - M \cdot (1 - y)
       \]  
       Upper bounds ensure `wait_penalty` is zero if `y = 0` and tightly constrained otherwise.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math; import numpy as np
# Params
total_gates = 4; arrival_rate_event = 1297; service_rate_per_gate = 328
cost_per_gate = 45; penalty_per_truck_minute = 0.24; event_duration_minutes = 40
M = 10000; epsilon = 0.1
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m4 = gp.Model("Port_Entry_Gates_MIP", env=env)
    # Vars
    x = m4.addVar(vtype=GRB.INTEGER, name="num_open_gates", lb=0, ub=total_gates)
    y = m4.addVar(vtype=GRB.BINARY, name="capacity_insufficient")
    wait_penalty = m4.addVar(name="total_wait_penalty", lb=0)
    # Objective
    m4.setObjective(cost_per_gate * x + wait_penalty, sense=GRB.MINIMIZE)
    # Constraints
    m4.addConstr(arrival_rate_event - service_rate_per_gate * x <= M * y, "force_y_if_insufficient")
    m4.addConstr(arrival_rate_event - service_rate_per_gate * x >= epsilon - M * (1 - y), "force_y_if_sufficient")
    penalty_expr = (arrival_rate_event - service_rate_per_gate * x) * event_duration_minutes * penalty_per_truck_minute
    m4.addConstr(wait_penalty >= penalty_expr - M * (1 - y), "penalty_lower_bound")
    m4.addConstr(wait_penalty <= M * y, "penalty_upper_bound_y0")
    m4.addConstr(wait_penalty <= penalty_expr + M*(1-y), name="penalty_upper_bound_y1_tight")
    # Optimize
    m4.optimize()
    # Store results
    results_dict['status'] = m4.status
    if m4.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m4.objVal; results_dict['x_optimal'] = x.X
        results_dict['y_optimal'] = y.X; results_dict['wait_penalty_optimal'] = wait_penalty.X
    # Output Results
    print("--- Problem 4: Port Entry Gates (MIP) ---")
    if m4.status == GRB.OPTIMAL:
        opt_x = results_dict.get('x_optimal', -1); opt_y = results_dict.get('y_optimal', -1); opt_pen = results_dict.get('wait_penalty_optimal', -1)
        print(f"Optimization Status: Optimal"); print(f"Optimal number of gates to open: {int(round(opt_x))}")
        capacity = service_rate_per_gate * opt_x; print(f"Total processing capacity: {capacity:.0f} trucks/hour (Arrival rate: {arrival_rate_event})")
        op_cost = cost_per_gate * opt_x; print(f"Operating cost: ${op_cost:.2f}/hour"); print(f"Estimated waiting penalty: ${opt_pen:.2f}")
        print(f"Total minimized cost: ${m4.objVal:.2f}/hour"); print(f"Is capacity insufficient (y=1)? {'Yes' if opt_y > 0.5 else 'No'}")
    elif m4.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible")
    else: print(f"Optimization Status: {m4.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_ENTRY_GATES
```
Answer:
--- Problem 4: Port Entry Gates (MIP) ---
Optimization Status: Optimal
Optimal number of gates to open: 4
Total processing capacity: 1312 trucks/hour (Arrival rate: 1297)
Operating cost: $180.00/hour
Estimated waiting penalty: $0.00
Total minimized cost: $180.00/hour
Is capacity insufficient (y=1)? No



================================================================================



--- Problem 305 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
In a busy maritime port, a critical challenge arises in sequencing ships through a two-stage berthing process to minimize the total time taken to serve all vessels. The first stage involves unloading cargo, while the second stage handles loading new cargo. Each ship has distinct processing times for these stages, and the sequence of ships is fixed (Ship 0, 1, 2, etc.). The goal is to determine the optimal completion times for each ship at each stage such that the last ship exits the system as quickly as possible.  

The operation must adhere to strict sequencing rules:  
- At the first stage (unloading), each ship cannot start until the preceding ship has finished.  
- At the second stage (loading), a ship must wait until it completes the first stage *and* the preceding ship has finished the second stage.  

With six ships and their respective processing times (e.g., Ship 0 takes 19 units for unloading and 50 for loading, Ship 1 takes 81 and 73, etc.), the port manager faces the question: *What is the minimum possible total time required to serve all ships under these constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `C[i, j]`: Continuous variable representing the completion time of ship `i` at stage `j` (where `i` ranges over ships 0 to 5, and `j` is 0 or 1 for unloading/loading stages).  

   - **2. Parameters:**  
     - `process_times[i][j]`: Processing time of ship `i` at stage `j` (e.g., `process_times[0][0] = 19`, `process_times[1][1] = 73`).  
     - Fixed ship sequence: [0, 1, 2, 3, 4, 5].  

   - **3. Objective Function:**  
     - Minimize `C[5, 1]` (the completion time of the last ship at the last stage).  

   - **4. Constraints:**  
     - **Stage 0 (Unloading):**  
       - First ship: `C[0, 0] >= process_times[0][0]`.  
       - Subsequent ships: `C[i, 0] >= C[i-1, 0] + process_times[i][0]` for `i = 1 to 5`.  
     - **Stage 1 (Loading):**  
       - First ship: `C[0, 1] >= C[0, 0] + process_times[0][1]`.  
       - Subsequent ships:  
         - Must finish Stage 0 first: `C[i, 1] >= C[i, 0] + process_times[i][1]`.  
         - Must wait for preceding ship: `C[i, 1] >= C[i-1, 1] + process_times[i][1]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3, 4, 5] # List of ship indices [0, 1, ...]
# process_times[ship][stage], stage 0=Unloading, stage 1=Loading
process_times = [[19, 50], [81, 73], [43, 17], [52, 53], [83, 75], [71, 72]]
num_stages = 2 # Should be 2 based on original code
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTHING_FLOW_SHOP", env=env)

    # --- Basic Input Validation ---
    if not ships or num_stages <= 0 or not process_times or len(process_times) != len(ships):
        raise ValueError("Invalid input data for Port Berthing Flow Shop")
    if any(len(row) != num_stages for row in process_times):
         raise ValueError("Inconsistent number of stages in process_times")

    # --- Decision Variables ---
    # C[i, j]: Completion time of ship i at stage j
    C = m.addVars(ships, range(num_stages), vtype=GRB.CONTINUOUS, lb=0, name="C")

    # --- Objective Function: Minimize the makespan ---
    # Makespan is completion time of the last ship at the last stage
    last_ship_idx = ships[-1]
    last_stage_idx = num_stages - 1
    m.setObjective(C[last_ship_idx, last_stage_idx], GRB.MINIMIZE)

    # --- Constraints ---
    # Stage 0 completion times (assuming fixed sequence 0, 1, 2...)
    # First ship at stage 0
    m.addConstr(C[0, 0] >= process_times[0][0], "C0_0")
    # Subsequent ships at stage 0
    for i in range(1, len(ships)):
        m.addConstr(C[i, 0] >= C[i-1, 0] + process_times[i][0], f"C0_{i}")

    # Completion times for subsequent stages (j > 0)
    for j in range(1, num_stages):
        # First ship at stage j
        m.addConstr(C[0, j] >= C[0, j-1] + process_times[0][j], f"C{j}_0")
        # Subsequent ships at stage j
        for i in range(1, len(ships)):
            # Must complete stage j-1 first
            m.addConstr(C[i, j] >= C[i, j-1] + process_times[i][j], f"C{j}_{i}_StagePrev")
            # Must wait for previous ship to finish stage j
            m.addConstr(C[i, j] >= C[i-1, j] + process_times[i][j], f"C{j}_{i}_ShipPrev")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['C_sol'] = m.getAttr('X', C) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}") # Makespan
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# The code provided already prints the optimal objective value, which is the total time required to serve all ships.
# However, it does not print the completion times for each ship at each stage, which are also important outputs.

if m.Status == GRB.OPTIMAL:
    obj_val_print = results_dict.get('obj_val', 'N/A')
    if isinstance(obj_val_print, (int, float)):
        print(f"Optimal objective value: {obj_val_print:.2f}")  # Makespan
    else:
        print(f"Optimal objective value: {obj_val_print}")

    # Print the completion times for each ship at each stage
    for i in range(len(ships)):
        for j in range(num_stages):
            print(f"Completion time of ship {i} at stage {j}: {C[i, j].X:.2f}")
```
Answer:
Optimal objective value: 425.00
Optimal objective value: 425.00
Completion time of ship 0 at stage 0: 19.00
Completion time of ship 0 at stage 1: 69.00
Completion time of ship 1 at stage 0: 100.00
Completion time of ship 1 at stage 1: 173.00
Completion time of ship 2 at stage 0: 143.00
Completion time of ship 2 at stage 1: 190.00
Completion time of ship 3 at stage 0: 195.00
Completion time of ship 3 at stage 1: 248.00
Completion time of ship 4 at stage 0: 278.00
Completion time of ship 4 at stage 1: 353.00
Completion time of ship 5 at stage 0: 349.00
Completion time of ship 5 at stage 1: 425.00


```

================================================================================



--- Problem 306 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
A busy port’s crane dispatch center faces a critical challenge: efficiently allocating its fleet of 87 cranes between two high-demand zones, A and B. Zone A, a dense container storage area, can accommodate up to 41 cranes at any given time, while Zone B, a sprawling bulk cargo area, has a higher capacity of 57 cranes. The dispatch team aims to minimize the number of cranes assigned to Zone B—perhaps due to higher operational costs, longer idle times, or strategic preferences for container handling—while ensuring every crane is deployed and neither zone exceeds its capacity. The question is clear: *What is the smallest number of cranes that can be assigned to Zone B without leaving any cranes idle or violating zone capacities?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n_A`: Integer, the number of cranes assigned to Zone A (lower bound: 0).  
     - `n_B`: Integer, the number of cranes assigned to Zone B (lower bound: 0).  
   - **2. Parameters:**  
     - Total cranes: 87.  
     - Zone A capacity: 41.  
     - Zone B capacity: 57.  
   - **3. Objective Function:**  
     Minimize `n_B` (the cranes in Zone B).  
   - **4. Constraints:**  
     - Total assignment: `n_A + n_B = 87`.  
     - Zone A limit: `n_A ≤ 41`.  
     - Zone B limit: `n_B ≤ 57`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_cranes = 87
capacity_A = 41
capacity_B = 57
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("CRANE_QUEUE_MANAGEMENT", env=env)

    # --- Decision Variables ---
    # n_A: number of cranes assigned to area A
    n_A = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_A")
    # n_B: number of cranes assigned to area B
    n_B = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_B")

    # --- Objective Function: Minimize the number of cranes in area B ---
    m.setObjective(n_B, GRB.MINIMIZE)

    # --- Constraints ---
    # All cranes must be assigned
    m.addConstr(n_A + n_B == total_cranes, "TotalCranes")

    # Capacity constraint for area A
    m.addConstr(n_A <= capacity_A, "CapacityA")

    # Capacity constraint for area B
    m.addConstr(n_B <= capacity_B, "CapacityB")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_A_sol'] = n_A.X # Not needed for output
        # results_dict['n_B_sol'] = n_B.X # Not needed for output (obj_val)

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is number of cranes, should be integer
             print(f"Optimal objective value: {int(round(obj_val_print))}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
if m.Status == GRB.OPTIMAL:
    print(f"Number of cranes assigned to Zone A: {int(round(n_A.X))}")
    print(f"Number of cranes assigned to Zone B: {int(round(n_B.X))}")
```
Answer:
Optimal objective value: 46
Number of cranes assigned to Zone A: 41
Number of cranes assigned to Zone B: 46


```

================================================================================



--- Problem 307 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port authority is tasked with efficiently assigning a set of 10 ships to the fewest possible berths, each with a strict length capacity of 17 units. The ships have varying lengths: 1, 3, 15, 5, 5, 16, 2, 4, 15, and 12 units. The challenge is to assign each ship to exactly one berth without exceeding the berth's length while minimizing the total number of berths used. This problem mirrors real-world scenarios like ship berthing optimization or port management, where space is limited and costs rise with each additional berth. The core question is: *What is the most efficient way to assign these ships to use the fewest berths possible?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable (0 or 1) indicating whether ship `i` is assigned to berth `j`.  
   - `y[j]`: Binary variable (0 or 1) indicating whether berth `j` is used.  

   **2. Parameters:**  
   - `ships`: List of ship lengths [1, 3, 15, 5, 5, 16, 2, 4, 15, 12].  
   - `capacity`: Maximum length per berth (17).  
   - `num_ships`: Total ships (10).  
   - `num_berths`: Maximum possible berths (10, one per ship).  

   **3. Objective Function:**  
   Minimize the total number of berths used:  
   `Minimize: sum(y[j] for all j)`  

   **4. Constraints:**  
   - **Ship Assignment:** Each ship must be assigned to exactly one berth:  
     `For each ship i: sum(x[i, j] for all j) = 1`.  
   - **Berth Capacity:** The total length in any berth `j` must not exceed its capacity if the berth is used:  
     `For each berth j: sum(ships[i] * x[i, j] for all i) <= capacity * y[j]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB

# --- Data Definition ---
ships = [1, 3, 15, 5, 5, 16, 2, 4, 15, 12]      # Lengths of ships
capacity = 17           # Berth capacity
num_ships = 10     # len(ships)
num_berths = num_ships    # Maximum number of berths (worst case: one ship per berth)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Time limit
# env.setParam('TimeLimit', 30)
env.start()

# Create Model
model = Model("Berth Packing Problem", env=env)

# --- Decision Variables ---
# x[i,j]: ship i is assigned to berth j
x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")

# --- Objective: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)

# --- Constraints ---
# 1. Each ship must be assigned to exactly one berth
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Berth capacity constraint: sum of lengths in berth j <= capacity IF berth j is used (y[j]=1)
for j in range(num_berths):
    model.addConstr(gp.quicksum(ships[i] * x[i, j] for i in range(num_ships)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

# --- Solve ---
print("Solving Berth Packing instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print(f"\nOptimal number of berths used: {optimal_berths}")
    print("-" * 30)
    berth_details = []
    for j_sol in range(num_berths): # Loop through potential berths
        # Check if the berth variable y[j_sol] exists and is set to 1
        # Using .X requires Gurobi v9+ and that the variable is in the solution
        try:
            if y[j_sol].X > 0.5: # Check if berth j_sol is used
                # Find ships assigned to this berth j_sol
                assigned_ships_indices = [i for i in range(num_ships) if x[i, j_sol].X > 0.5]
                assigned_ships_lengths = [ships[i] for i in assigned_ships_indices]
                berth_load = sum(assigned_ships_lengths)
                print(f"Berth {j_sol + 1} (Load: {berth_load}/{capacity}): Ships (indices): {assigned_ships_indices}")
                # Optional: Print lengths too
                # print(f"  Lengths: {assigned_ships_lengths}")
                berth_details.append({'berth_index': j_sol, 'ship_indices': assigned_ships_indices, 'load': berth_load})
        except AttributeError:
            # This might happen if y[j_sol] was optimized to 0 and doesn't have an .X value
            # Or if the model was infeasible/not solved optimally.
            # Since we check for OPTIMAL status first, this is less likely for y,
            # but could happen if x[i, j_sol] is 0. The check x[i,j_sol].X > 0.5 handles this.
            pass # Just skip if variable/attribute doesn't exist for unused berths/ships
    results_dict['berth_details'] = berth_details # Store details
    print("-" * 30)

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount to see if a feasible solution was found
     if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
     else: print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving Berth Packing instance...

Optimal number of berths used: 5
------------------------------
Berth 1 (Load: 16/17): Ships (indices): [0, 1, 9]
Berth 3 (Load: 15/17): Ships (indices): [8]
Berth 5 (Load: 17/17): Ships (indices): [2, 6]
Berth 8 (Load: 14/17): Ships (indices): [3, 4, 7]
Berth 10 (Load: 16/17): Ships (indices): [5]
------------------------------


```

================================================================================



--- Problem 308 ---
**Difficulty:** easy
**Category:** LP

**Problem Description:**
**
In a busy port, a critical container terminal is managed by a two-phase crane scheduling system. Each phase must allocate operational time to different loading and unloading tasks, balancing efficiency and minimizing delays. The total cycle time for the cranes is fixed at 74 minutes, with each phase's operational time bounded between 23 and 74 minutes. The first phase handles a lighter workload, represented by a coefficient of 111, while the second phase deals with a significantly heavier workload, quantified by a coefficient of 939. The challenge is to distribute the operational times between these two phases such that the total delay—calculated as the sum of workload coefficients multiplied by their respective idle times (cycle time minus operational time)—is minimized. The key question is: *How should the operational times be allocated to these two phases to achieve the least possible total delay while adhering to the cycle time constraint?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( t_1 \) and \( t_2 \) represent the operational times (in minutes) allocated to Phase 1 and Phase 2, respectively. Both are continuous variables bounded between 23 and 74.  
   - **2. Parameters:**  
     - \( \text{workload_coeffs} = [111, 939] \): Workload coefficients for Phase 1 and Phase 2.  
     - \( \text{cycle_time} = 74 \): Total fixed cycle time (minutes).  
     - \( \text{lb_time} = 23 \), \( \text{ub_time} = 74 \): Lower and upper bounds for operational times.  
   - **3. Objective Function:**  
     - Minimize the total delay:  
       \[
       \text{Minimize: } 111 \times (74 - t_1) + 939 \times (74 - t_2)
       \]  
   - **4. Constraints:**  
     - The sum of operational times must equal the cycle time:  
       \[
       t_1 + t_2 = 74
       \]  
     - Bounds on operational times:  
       \[
       23 \leq t_1 \leq 74, \quad 23 \leq t_2 \leq 74
       \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 2
lb_time = 23          # Lower bound for operational time
ub_time = 74          # Upper bound for operational time
cycle_time = 74   # Total cycle time (set equal to ub_time)
workload_coeffs = [111, 939] # Workload coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(workload_coeffs) != num_phases:
    print("Error: workload_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: workload_coeffs length"
    # raise ValueError("workload_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Crane Scheduling", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for phase i is proportional to workload * idle_time = workload * (cycle_time - operational_time[i])
        model.setObjective(gp.quicksum(workload_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of operational times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal operational times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
Optimal total delay: 27258.00
------------------------------
Optimal operational times (minutes):
  t1: 23.00, t2: 51.00



================================================================================



--- Problem 309 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A high-end valet parking service at a luxury hotel faces the challenge of efficiently assigning 17 cars to 17 parking spots while minimizing both retrieval time and penalties for VIP customers. The parking area consists of 9 premium spots (P1-P9) with a swift 3-minute retrieval time and 8 standard spots (S1-S8) with a slower 5-minute retrieval time. Among the cars, 4 are VIPs (C1-C4), which incur a hefty $20 penalty if assigned to standard spots due to the hotel’s premium service guarantee. The remaining 13 cars (C5-C17) are non-VIPs and can be parked anywhere without penalty.  

The valet manager must ensure every car gets exactly one spot, no spot holds more than one car, and VIPs are prioritized for premium spots to avoid penalties. The goal is to find the assignment that minimizes the total cost, combining retrieval time and VIP penalties. The optimal solution must balance speed and VIP satisfaction while utilizing all available spots.  

**Key Question:** What is the most efficient way to assign cars to spots to minimize the total cost (retrieval time + penalties)?  

---
**

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable `assign(c, s)` for each car `c` and spot `s`:  
  - `1` if car `c` is assigned to spot `s`, `0` otherwise.  

**2. Parameters:**  
- `retrieval_time['Premium'] = 3` (minutes), `retrieval_time['Standard'] = 5` (minutes).  
- `vip_penalty_standard = 20` ($ penalty for assigning a VIP to a standard spot).  
- Sets:  
  - `cars = [C1, ..., C17]`, `vip_cars = [C1, C2, C3, C4]`.  
  - `premium_spots = [P1, ..., P9]`, `standard_spots = [S1, ..., S8]`.  

**3. Objective Function:**  
Minimize the sum of:  
- Total retrieval time:  
  - Sum of `assign(c, p) * 3` for premium spots `p` + `assign(c, s) * 5` for standard spots `s`.  
- Total VIP penalties:  
  - Sum of `assign(c, s) * 20` for VIP cars `c` assigned to standard spots `s`.  

**4. Constraints:**  
- **Each car gets exactly one spot:**  
  - For every car `c`, sum of `assign(c, s)` over all spots `s` equals `1`.  
- **Each spot holds at most one car:**  
  - For every spot `s`, sum of `assign(c, s)` over all cars `c` is ≤ `1`.  

---

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
num_premium_spots = 9; num_standard_spots = 8
premium_spots = ['P1', 'P2', 'P3', 'P4', 'P5', 'P6', 'P7', 'P8', 'P9']; standard_spots = ['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8']; all_spots = ['P1', 'P2', 'P3', 'P4', 'P5', 'P6', 'P7', 'P8', 'P9', 'S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8']
num_total_cars = 17; num_vip_cars = 4
cars = ['C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9', 'C10', 'C11', 'C12', 'C13', 'C14', 'C15', 'C16', 'C17']; vip_cars = ['C1', 'C2', 'C3', 'C4']; non_vip_cars = ['C5', 'C6', 'C7', 'C8', 'C9', 'C10', 'C11', 'C12', 'C13', 'C14', 'C15', 'C16', 'C17']
retrieval_time = {'Premium': 3, 'Standard': 5}; vip_penalty_standard = 20
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m16 = gp.Model("Valet_Spot_Assignment_MIP", env=env)
    # Vars
    assign = m16.addVars(cars, all_spots, vtype=GRB.BINARY, name="assign")
    # Objective
    total_retrieval_time = gp.quicksum(assign[c, p] * retrieval_time['Premium'] for c in cars for p in premium_spots) + gp.quicksum(assign[c, s] * retrieval_time['Standard'] for c in cars for s in standard_spots)
    total_penalty = gp.quicksum(assign[c, s] * vip_penalty_standard for c in vip_cars for s in standard_spots)
    m16.setObjective(total_retrieval_time + total_penalty, sense=GRB.MINIMIZE)
    # Constraints
    for c in cars: m16.addConstr(gp.quicksum(assign[c, spot] for spot in all_spots) == 1, f"car_{c}_must_park")
    for spot in all_spots: m16.addConstr(gp.quicksum(assign[c, spot] for c in cars) <= 1, f"spot_{spot}_capacity")
    # Optimize
    m16.optimize()
    # Store results
    results_dict['status'] = m16.status
    if m16.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m16.objVal
        results_dict['assign_sol'] = m16.getAttr('X', assign)
    # Output Results
    print("--- Problem 16: Valet Parking Spot Assignment (MIP) ---")
    if m16.status == GRB.OPTIMAL:
        print(f"Optimization Status: Optimal")
        print(f"Minimum Total Cost (Retrieval Time + Penalty): {m16.objVal:.2f}")
        print("Assignments & Costs:")
        assign_sol = results_dict.get('assign_sol', {})
        rt_sum = 0; pen_sum = 0; assignments_dict = {}
        for c in cars:
            for spot in all_spots:
                if assign_sol.get((c, spot), 0) > 0.5:
                    assignments_dict[c] = spot; is_premium = spot in premium_spots; is_vip = c in vip_cars
                    rt = retrieval_time['Premium'] if is_premium else retrieval_time['Standard']; pen = 0
                    if is_vip and not is_premium: pen = vip_penalty_standard
                    rt_sum += rt; pen_sum += pen
                    print(f"  Car {c} ({'VIP' if is_vip else 'Non-VIP'}) -> Spot {spot} ({'Premium' if is_premium else 'Standard'}) | RT: {rt} min, Penalty: ${pen}")
        print(f"\nTotal Retrieval Time: {rt_sum} min"); print(f"Total VIP Penalty: ${pen_sum}"); print(f"Objective Value Check: {rt_sum + pen_sum}")
    else: print(f"Optimization Status: {m16.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of VALET_PARKING
```
Answer:
--- Problem 16: Valet Parking Spot Assignment (MIP) ---
Optimization Status: Optimal
Minimum Total Cost (Retrieval Time + Penalty): 67.00
Assignments & Costs:
  Car C1 (VIP) -> Spot P1 (Premium) | RT: 3 min, Penalty: $0
  Car C2 (VIP) -> Spot P6 (Premium) | RT: 3 min, Penalty: $0
  Car C3 (VIP) -> Spot P3 (Premium) | RT: 3 min, Penalty: $0
  Car C4 (VIP) -> Spot P7 (Premium) | RT: 3 min, Penalty: $0
  Car C5 (Non-VIP) -> Spot P2 (Premium) | RT: 3 min, Penalty: $0
  Car C6 (Non-VIP) -> Spot S2 (Standard) | RT: 5 min, Penalty: $0
  Car C7 (Non-VIP) -> Spot P8 (Premium) | RT: 3 min, Penalty: $0
  Car C8 (Non-VIP) -> Spot P4 (Premium) | RT: 3 min, Penalty: $0
  Car C9 (Non-VIP) -> Spot S1 (Standard) | RT: 5 min, Penalty: $0
  Car C10 (Non-VIP) -> Spot S7 (Standard) | RT: 5 min, Penalty: $0
  Car C11 (Non-VIP) -> Spot P9 (Premium) | RT: 3 min, Penalty: $0
  Car C12 (Non-VIP) -> Spot S8 (Standard) | RT: 5 min, Penalty: $0
  Car C13 (Non-VIP) -> Spot S6 (Standard) | RT: 5 min, Penalty: $0
  Car C14 (Non-VIP) -> Spot S5 (Standard) | RT: 5 min, Penalty: $0
  Car C15 (Non-VIP) -> Spot S3 (Standard) | RT: 5 min, Penalty: $0
  Car C16 (Non-VIP) -> Spot S4 (Standard) | RT: 5 min, Penalty: $0
  Car C17 (Non-VIP) -> Spot P5 (Premium) | RT: 3 min, Penalty: $0

Total Retrieval Time: 67 min
Total VIP Penalty: $0
Objective Value Check: 67



================================================================================



--- Problem 310 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port is dealing with an imbalance of containers across its terminals. Terminal A currently has a surplus of 91 containers, while terminals B and C face deficits of 12 and 36 containers, respectively. To restore equilibrium, the port must redistribute containers from A to B and C using a single truck with a capacity of 22 containers per trip. However, failing to meet demand at B or C incurs a penalty of $3 per unmet container—a cost the operations team is keen to minimize. The challenge lies in determining how many trucks to allocate to each route (B or C) and how many containers to transport, ensuring the total penalty for unmet demand is as low as possible while respecting the truck’s capacity and the limited availability of containers at A.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n_B`: Integer, number of trucks assigned to route A→B (0 ≤ `n_B` ≤ 1).  
     - `n_C`: Integer, number of trucks assigned to route A→C (0 ≤ `n_C` ≤ 1).  
     - `x_AB`: Integer, containers transported from A to B (≥ 0).  
     - `x_AC`: Integer, containers transported from A to C (≥ 0).  
     - `shortfall_B`: Continuous, unmet demand at B (≥ 0).  
     - `shortfall_C`: Continuous, unmet demand at C (≥ 0).  

   - **2. Parameters:**  
     - Surplus at A: 91 containers.  
     - Deficits: B = 12, C = 36.  
     - Truck capacity: 22 containers/truck.  
     - Penalty rate: $3 per container shortfall.  

   - **3. Objective Function:**  
     Minimize total penalty:  
     `3 * shortfall_B + 3 * shortfall_C`.  

   - **4. Constraints:**  
     - Total trucks: `n_B + n_C ≤ 1`.  
     - Truck capacity:  
       `x_AB ≤ 22 * n_B`,  
       `x_AC ≤ 22 * n_C`.  
     - Supply limit: `x_AB + x_AC ≤ 91`.  
     - Shortfall definitions:  
       `shortfall_B ≥ 12 - x_AB`,  
       `shortfall_C ≥ 36 - x_AC`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
surplus_A = 91
deficit_B = 12
deficit_C = 36
truck_capacity = 22
num_trucks = 1
shortfall_penalty = 3 # Penalty per unit of unmet demand
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("CONTAINER_REDISTRIBUTION_SHORTFALL", env=env)

    # --- Decision Variables ---
    # n_B, n_C: number of trucks
    n_B = m.addVar(vtype=GRB.INTEGER, lb=0, ub=num_trucks, name="n_B")
    n_C = m.addVar(vtype=GRB.INTEGER, lb=0, ub=num_trucks, name="n_C")
    # x_AB, x_AC: number of containers transported
    x_AB = m.addVar(vtype=GRB.INTEGER, lb=0, name="x_AB")
    x_AC = m.addVar(vtype=GRB.INTEGER, lb=0, name="x_AC")
    # shortfall_B, shortfall_C: unmet demand
    shortfall_B = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="shortfall_B")
    shortfall_C = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="shortfall_C")

    # --- Objective Function: Minimize total shortfall (weighted by penalty) ---
    m.setObjective(shortfall_penalty * shortfall_B + shortfall_penalty * shortfall_C, GRB.MINIMIZE)

    # --- Constraints ---
    # Total number of trucks used
    m.addConstr(n_B + n_C <= num_trucks, "TotalTrucks")

    # Transported amount cannot exceed truck capacity
    if truck_capacity > 0:
        m.addConstr(x_AB <= truck_capacity * n_B, "CapacityB")
        m.addConstr(x_AC <= truck_capacity * n_C, "CapacityC")
    else:
        m.addConstr(x_AB == 0, "CapacityB_Zero")
        m.addConstr(x_AC == 0, "CapacityC_Zero")

    # Transported amount cannot exceed surplus at A
    m.addConstr(x_AB + x_AC <= surplus_A, "SupplyA")

    # Shortfall calculation: Shortfall >= Deficit - Transported
    m.addConstr(shortfall_B >= deficit_B - x_AB, "ShortfallCalcB")
    m.addConstr(shortfall_C >= deficit_C - x_AC, "ShortfallCalcC")
    # lb=0 on shortfall variables handles the max(0, ...) part

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['shortfall_B_sol'] = shortfall_B.X # Not needed
        # results_dict['shortfall_C_sol'] = shortfall_C.X # Not needed

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is total penalty, can be float if shortfalls are continuous
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
         print("Model is infeasible") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print all key outputs
if m.Status == GRB.OPTIMAL:
    obj_val_print = results_dict.get('obj_val', 'N/A')
    if isinstance(obj_val_print, (int, float)):
        print(f"Optimal objective value: {obj_val_print:.2f}")
    else:
        print(f"Optimal objective value: {obj_val_print}")

    # Print decision variables
    print(f"Number of trucks to B: {n_B.X}")
    print(f"Number of trucks to C: {n_C.X}")
    print(f"Containers transported from A to B: {x_AB.X}")
    print(f"Containers transported from A to C: {x_AC.X}")
    print(f"Shortfall at B: {shortfall_B.X:.2f}")
    print(f"Shortfall at C: {shortfall_C.X:.2f}")
```
Answer:
Optimal objective value: 78.00
Optimal objective value: 78.00
Number of trucks to B: 0.0
Number of trucks to C: 1.0
Containers transported from A to B: 0.0
Containers transported from A to C: 22.0
Shortfall at B: 12.00
Shortfall at C: 14.00


```

================================================================================



--- Problem 311 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently scheduling the loading of four rectangular cargo containers onto a series of trucks to minimize the number of trucks used. Each truck has a fixed width of 95 units and a height of 25 units. The containers vary in size: Container 0 (4×13), Container 1 (10×13), Container 2 (78×20), and Container 3 (59×25). The challenge is to arrange these containers into the fewest possible trucks without overlaps or exceeding truck dimensions. The goal is to optimize space utilization while adhering to strict placement rules—each container must fit entirely within its assigned truck, and no two containers in the same truck can overlap. The solution must determine not only the optimal truck count but also the precise coordinates for each container’s bottom-left corner within its truck.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary `x[i,j]`: 1 if container *i* is assigned to truck *j*, else 0.  
     - Binary `y[j]`: 1 if truck *j* is used, else 0.  
     - Continuous `px[i,j]`, `py[i,j]`: *x*- and *y*-coordinates of container *i*’s bottom-left corner in truck *j*.  
     - Binary `left[i,k,j]`, `right[i,k,j]`, `below[i,k,j]`, `above[i,k,j]`: 1 if container *i* is to the left/right/below/above container *k* in truck *j*.  

   - **2. Parameters:**  
     - `containers`: List of container dimensions [(4,13), (10,13), (78,20), (59,25)].  
     - `truck_size`: (95, 25).  
     - `M_w`, `M_h`: Big-M values (95 and 25, respectively).  

   - **3. Objective Function:**  
     Minimize total trucks used:  
     \[
     \text{Minimize: } \sum_{j} y[j]
     \]  

   - **4. Constraints:**  
     - **Assignment:** Each container *i* must be in exactly one truck:  
       \[
       \sum_{j} x[i,j] = 1 \quad \forall i
       \]  
     - **Truck Boundaries:** Container *i*’s placement in truck *j* must respect truck dimensions:  
       \[
       px[i,j] + \text{container}_i\text{.width} \leq 95 + M_w (1 - x[i,j]) \quad \forall i,j
       \]  
       \[
       py[i,j] + \text{container}_i\text{.height} \leq 25 + M_h (1 - x[i,j]) \quad \forall i,j
       \]  
     - **Non-Overlapping:** For containers *i* and *k* in the same truck *j*, enforce relative positioning:  
       \[
       \text{left}[i,k,j] + \text{right}[i,k,j] + \text{below}[i,k,j] + \text{above}[i,k,j] \geq x[i,j] + x[k,j] - 1 \quad \forall i < k, j
       \]  
     - **Truck Activation:** Truck *j* is used if any container is assigned to it:  
       \[
       x[i,j] \leq y[j] \quad \forall i,j
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
containers = [(4, 13), (10, 13), (78, 20), (59, 25)]  # (width, height) of containers
truck_size = (95, 25)  # (width, height) of each truck
num_containers = 4 # len(containers)
# Maximum trucks needed (worst case: one container per truck)
# Can sometimes be reduced with lower bounds, but num_containers is safe
num_trucks = num_containers
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using truck dimensions is common and valid)
M_w = truck_size[0]
M_h = truck_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Truck Packing", env=env)

# --- Decision Variables ---
# x[i,j]: container i assigned to truck j
x = model.addVars(num_containers, num_trucks, vtype=GRB.BINARY, name="x")
# y[j]: truck j is used
y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of container i if in truck j
px = model.addVars(num_containers, num_trucks, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_containers, num_trucks, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of containers *within the same truck*
left  = model.addVars(num_containers, num_containers, num_trucks, vtype=GRB.BINARY, name="left")
right = model.addVars(num_containers, num_containers, num_trucks, vtype=GRB.BINARY, name="right")
below = model.addVars(num_containers, num_containers, num_trucks, vtype=GRB.BINARY, name="below")
above = model.addVars(num_containers, num_containers, num_trucks, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of trucks used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_trucks))

# --- Constraints ---

# 1. Each container must be assigned to exactly one truck
for i in range(num_containers):
    model.addConstr(x.sum(i, '*') == 1, name=f"Container_{i}_Assignment")

# 2. Container placement constraints within truck boundaries (Big-M formulation)
for j in range(num_trucks):
    for i in range(num_containers):
        container_w, container_h = containers[i] # Get dimensions for container i

        # Position variables must be 0 if container i is not in truck j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Container's right edge <= truck width IF container is placed in truck (x[i,j]=1)
        model.addConstr(px[i, j] + container_w <= truck_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Container's top edge <= truck height IF container is placed in truck (x[i,j]=1)
        model.addConstr(py[i, j] + container_h <= truck_size[1] + M_h * (1 - x[i, j]), name=f"Height_Limit_{i}_{j}")

# 3. Non-overlapping constraints for containers within the same truck
for j in range(num_trucks):
    for i in range(num_containers):
        for k in range(i + 1, num_containers): # Iterate over distinct pairs (i < k)
            container_i_w, container_i_h = containers[i]
            container_k_w, container_k_h = containers[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => container i is to the left of container k
            model.addConstr(px[i, j] + container_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => container i is to the right of container k (k is left of i)
            model.addConstr(px[k, j] + container_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => container i is below container k
            model.addConstr(py[i, j] + container_i_h <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => container i is above container k (k is below i)
            model.addConstr(py[k, j] + container_k_h <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH container i and container k are in truck j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link container assignment to truck usage: If any container i is in truck j, then truck j must be used (y[j]=1)
#    This can be done per container or aggregated. Per container is often tighter.
for j in range(num_trucks):
    for i in range(num_containers):
        model.addConstr(x[i, j] <= y[j], name=f"Container_Truck_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_containers * y[j], name=f"Truck_Activation_{j}")


# --- Solve ---
print("Solving 2DTP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of trucks used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    truck_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_trucks):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Truck {j_sol + 1} (Used):")
            containers_in_truck_info = []
            for i_sol in range(num_containers):
                if x[i_sol, j_sol].X > 0.5:
                    container_data = {
                        "id": i_sol,
                        "dims": containers[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    containers_in_truck_info.append(container_data)
                    print(f"  Container {container_data['id']} {container_data['dims']} at {container_data['pos']}")
            truck_details.append({'truck_index': j_sol, 'containers': containers_in_truck_info})
            print("-" * 10)
    results_dict['truck_details'] = truck_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 2DTP instance...

Optimal number of trucks used: 2
------------------------------
Truck 1 (Used):
  Container 0 (4, 13) at (10.0, 0.0)
  Container 1 (10, 13) at (0.0, 0.0)
  Container 2 (78, 20) at (14.0, 0.0)
----------
Truck 4 (Used):
  Container 3 (59, 25) at (0.0, 0.0)
----------


```

================================================================================



--- Problem 312 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
A logistics company is tasked with optimizing delivery routes for a fleet of 10 trucks serving 10 locations, including a central depot (node 0) and 9 customer sites. Each truck has a unique capacity (ranging from 21 to 99 units), and each customer has a specific demand (ranging from 1 to 81 units). The distances between locations are asymmetric, meaning the travel time from node A to node B may differ from the return trip. For example, traveling from the depot (node 0) to node 3 takes 3 units of distance, but the reverse trip takes 75 units.  

The challenge is to assign routes to trucks such that:  
- Every customer is visited exactly once.  
- Each truck starts and ends at the depot.  
- The total demand serviced by any truck does not exceed its capacity.  
- The combined travel distance across all routes is minimized.  

The company aims to find the most efficient allocation of deliveries to trucks, balancing capacity constraints and minimizing operational costs. The key question is: *What is the optimal set of routes that satisfies all constraints while achieving the lowest possible total travel distance?*  

---

**Modeling Process:**
**1. Decision Variables:**  
- Binary variables `x(i, j, k)` indicate whether truck `k` travels directly from node `i` to node `j` (1 if yes, 0 otherwise).  
- Continuous variables `u(i)` (for subtour elimination) track the order in which node `i` is visited.  

**2. Parameters:**  
- `N = 10`: Number of nodes (depot + customers).  
- `K = 10`: Number of trucks.  
- `Q[k]`: Capacity of truck `k` (e.g., `Q[0] = 99`).  
- `q[j]`: Demand at customer `j` (e.g., `q[1] = 1`).  
- `d[i][j]`: Distance from node `i` to node `j` (e.g., `d[0][3] = 3`).  

**3. Objective Function:**  
Minimize the total distance traveled by all trucks:  
```
Minimize: sum(d[i][j] * x(i, j, k) for all i, j, k where i ≠ j)
```

**4. Constraints:**  
- **Visit each customer once:** For every customer `i` (excluding depot), the sum of incoming edges across all trucks equals 1.  
- **Flow conservation:** For each truck `k` and node `i`, the number of incoming edges equals outgoing edges.  
- **Depot departure/return:** Each truck `k` must leave and return to the depot (node 0) at most once.  
- **Capacity constraint:** The total demand serviced by truck `k` must not exceed `Q[k]`.  
- **Subtour elimination (MTZ):** For `i ≠ j`, `u[i] - u[j] + (N-1) * x(i, j, k) ≤ N-2` ensures no disconnected cycles.  

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 10
K = 10
Q = [99, 75, 82, 53, 66, 68, 21, 99, 26, 27]
q = [0, 1, 67, 11, 66, 25, 11, 81, 64, 8]
d = [
    [0, 99, 88, 3, 25, 91, 33, 81, 55, 89],
    [99, 0, 40, 75, 90, 74, 81, 28, 88, 55],
    [88, 40, 0, 79, 18, 63, 85, 32, 58, 46],
    [3, 75, 79, 0, 92, 46, 98, 77, 60, 23],
    [25, 90, 18, 92, 0, 94, 13, 39, 61, 45],
    [91, 74, 63, 46, 94, 0, 12, 6, 36, 25],
    [33, 81, 85, 98, 13, 12, 0, 10, 51, 18],
    [81, 28, 32, 77, 39, 6, 10, 0, 6, 22],
    [55, 88, 58, 60, 61, 36, 51, 6, 0, 64],
    [89, 55, 46, 23, 45, 25, 18, 22, 64, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Truck Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for truck {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for truck {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 585.00

Route for truck 1 (Capacity: 99):
0 -> 7 -> 6 -> 0
Route Load: 92 / 99

Route for truck 3 (Capacity: 82):
0 -> 3 -> 1 -> 2 -> 0
Route Load: 79 / 82

Route for truck 6 (Capacity: 68):
0 -> 4 -> 0
Route Load: 66 / 68

Route for truck 8 (Capacity: 99):
0 -> 9 -> 5 -> 8 -> 0
Route Load: 97 / 99


```

================================================================================



--- Problem 313 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the harbor master is tasked with coordinating the berthing times for two different types of ships to minimize the total waiting time. The port operates with a fixed cycle time of 40 minutes, divided into two distinct phases. Each phase must allocate a berthing time between 19 and 40 minutes, ensuring smooth ship traffic while adhering to the rigid cycle constraint. The waiting time experienced by ships in each phase is influenced by the number of ships, represented by flow coefficients of 161 and 1410 for the respective phases. The core optimization task is to determine the exact berthing time allocation for each phase that minimizes the total waiting time across the port, balancing the competing demands of high-traffic and low-traffic flows. The critical question is: *What is the optimal distribution of berthing times within the 40-minute cycle to achieve the least possible cumulative waiting time for all ships?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `t(i)`: Continuous variable representing the berthing time (in minutes) allocated to phase `i`, where `i ∈ {0, 1}` (for 2 phases). Each `t(i)` is bounded between 19 and 40 minutes.  

   **2. Parameters:**  
   - `flow_coeffs = [161, 1410]`: Number of ships for phases 0 and 1, respectively.  
   - `cycle_time = 40`: Total cycle time (minutes), fixed for all phases.  
   - `lb_time = 19`, `ub_time = 40`: Lower and upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize the total waiting time, calculated as:  
   `sum(flow_coeffs[i] * (cycle_time - t(i)) for i in {0, 1})`.  

   **4. Constraints:**  
   - **Total cycle constraint:** The sum of berthing times must equal the cycle time:  
     `t(0) + t(1) = 40`.  
   - **Variable bounds:** `19 ≤ t(i) ≤ 40` for each phase `i`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 2
lb_time = 19          # Lower bound for berthing time
ub_time = 40          # Upper bound for berthing time
cycle_time = 40       # Total cycle time (set equal to ub_time)
flow_coeffs = [161, 1410] # Number of ships per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Time", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for phase i is proportional to flow * non-berthing time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 30171.00
------------------------------
Optimal berthing times (minutes):
  t1: 19.00, t2: 21.00


```

================================================================================



--- Problem 314 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the harbor master is tasked with optimizing the berthing schedule for ships to minimize the total waiting time. The port operates with a fixed cycle time of 22 hours, divided into two distinct phases. Each phase has a berthing duration that must be carefully calibrated—too short, and queues build up; too long, and time is wasted unnecessarily. The challenge is compounded by varying ship arrivals: Phase 1 handles a heavier volume with a flow coefficient of 2755, while Phase 2 sees slightly lighter traffic at 2291. The harbor master must allocate berthing times between 10 and 22 hours for each phase, ensuring the sum matches the cycle time. The core question is: *What berthing durations for each phase will minimize the total waiting time experienced by all ships?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( t_i \) represent the berthing time (in hours) allocated to phase \( i \), where \( i \in \{1, 2\} \). Each \( t_i \) is a continuous variable bounded between 10 and 22.  
   - **2. Parameters:**  
     - \( \text{flow_coeffs} = [2755, 2291] \): Ship arrival coefficients for each phase.  
     - \( \text{cycle_time} = 22 \): Total fixed cycle time (hours).  
     - \( \text{lb_time} = 10 \), \( \text{ub_time} = 22 \): Lower/upper bounds for berthing times.  
   - **3. Objective Function:**  
     - Minimize the total waiting time: \( \text{Minimize: } 2755 \cdot (22 - t_1) + 2291 \cdot (22 - t_2) \).  
   - **4. Constraints:**  
     - The sum of berthing times must equal the cycle time: \( t_1 + t_2 = 22 \).  
     - Bounds: \( 10 \leq t_1 \leq 22 \), \( 10 \leq t_2 \leq 22 \).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 2
lb_time = 10          # Lower bound for berthing time
ub_time = 22          # Upper bound for berthing time
cycle_time = 22   # Total cycle time (set equal to ub_time)
flow_coeffs = [2755, 2291] # Ship arrival coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Schedule", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for phase i is proportional to flow * non-berthing time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 55042.00
------------------------------
Optimal berthing times (hours):
  t1: 12.00, t2: 10.00


```

================================================================================



--- Problem 315 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
At a busy container port, the terminal operators need to coordinate the berthing times for two primary vessel flows: East-West (EW) and North-South (NS). The EW direction handles a high volume of vessels, with an arrival flow of 883 vessels per day and a saturation flow (maximum capacity) of 1,957 vessels per day. The NS direction, while less congested, still contributes significantly, with an arrival flow of 335 vessels per day and a saturation flow of 2,188 vessels per day.

The berthing schedule operates on a fixed cycle time of 84 hours, which includes berthing times for both directions as well as mandatory clearance intervals: 4 hours of preparation time and 3 hours of maintenance time (totaling 7 hours of "lost time" per phase). To ensure smooth operations, each phase must have a minimum berthing time of 26 hours.

The core challenge is to allocate berthing times between the EW and NS phases in a way that maximizes the overall efficiency of the terminal. Efficiency is measured as a weighted sum of berthing times, where the weights reflect the degree of saturation (arrival flow divided by saturation flow) for each direction. The question is: *How should berthing times be distributed between the EW and NS phases to maximize this weighted efficiency while respecting the cycle time and minimum berthing constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `b_ew`: Berthing time (in hours) allocated to the East-West phase.  
- `b_ns`: Berthing time (in hours) allocated to the North-South phase.  

**2. Parameters:**  
- `cycle_time = 84`: Total berthing cycle time (hours).  
- `lost_time_per_phase = 7`: Sum of preparation (4 hours) and maintenance (3 hours) times per phase.  
- `min_berth = 26`: Minimum berthing time (hours) for any phase.  
- `sat_flow_ew = 1957`, `arr_flow_ew = 883`: Saturation and arrival flows for EW (vessels/day).  
- `sat_flow_ns = 2188`, `arr_flow_ns = 335`: Saturation and arrival flows for NS (vessels/day).  
- `weight_ew = arr_flow_ew / sat_flow_ew`: Weight for EW berthing time (0.451).  
- `weight_ns = arr_flow_ns / sat_flow_ns`: Weight for NS berthing time (0.153).  

**3. Objective Function:**  
Maximize the weighted sum of berthing times:  
`Maximize: weight_ew * b_ew + weight_ns * b_ns`  

**4. Constraints:**  
- **Cycle time constraint:** Total phase times must equal the cycle time:  
  `b_ew + lost_time_per_phase + b_ns + lost_time_per_phase = cycle_time`  
- **Minimum berthing times:**  
  `b_ew >= min_berth`  
  `b_ns >= min_berth`  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cycle_time = 84
preparation_time = 4
maintenance_time = 3
min_berth = 26
sat_flow_ew = 1957
arr_flow_ew = 883
sat_flow_ns = 2188
arr_flow_ns = 335
lost_time_per_phase = 7 # preparation + maintenance
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTHING_TIMING", env=env)

    # --- Decision Variables ---
    # b_ew: berthing time for East-West phase (hours)
    b_ew = m.addVar(lb=min_berth, vtype=GRB.CONTINUOUS, name="b_ew")
    # b_ns: berthing time for North-South phase (hours)
    b_ns = m.addVar(lb=min_berth, vtype=GRB.CONTINUOUS, name="b_ns")

    # --- Objective Function: Maximize weighted berthing times ---
    # Weight by flow/saturation ratio (degree of saturation)
    # Avoid division by zero
    weight_ew = arr_flow_ew / sat_flow_ew if sat_flow_ew > 1e-6 else 0
    weight_ns = arr_flow_ns / sat_flow_ns if sat_flow_ns > 1e-6 else 0
    m.setObjective(weight_ew * b_ew + weight_ns * b_ns, GRB.MAXIMIZE)

    # --- Constraints ---
    # Cycle time constraint: sum of phase times must equal cycle time
    # Phase time = berthing + lost_time_per_phase
    m.addConstr(b_ew + lost_time_per_phase + b_ns + lost_time_per_phase == cycle_time, "CycleTimeConstraint")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['b_ew_sol'] = b_ew.X # Not needed for output
        # results_dict['b_ns_sol'] = b_ns.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Format objective value (weighted berthing time sum)
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show more decimals for weighted sum
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block to print missing outputs)
if m.Status == GRB.OPTIMAL:
    b_ew_sol = b_ew.X
    b_ns_sol = b_ns.X
    print(f"Optimal berthing time for East-West phase: {b_ew_sol:.4f} hours")
    print(f"Optimal berthing time for North-South phase: {b_ns_sol:.4f} hours")
```
Answer:
Optimal objective value: 23.8336
Optimal berthing time for East-West phase: 44.0000 hours
Optimal berthing time for North-South phase: 26.0000 hours


```

================================================================================



--- Problem 316 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A maritime port with six berths is experiencing recurring incidents that reduce the capacity of the main berthing routes. Port managers must dynamically divert ships to alternative berths to minimize total delay while adhering to operational constraints. Each berth has distinct characteristics: main route capacities under normal (e.g., 4046–5193 ships/h) and reduced conditions (e.g., 1751–2938 ships/h), alternative berth capacities (e.g., 866–1804 ships/h), and incident durations (e.g., 0.77–1.95 hours). Arrival rates fluctuate hourly (e.g., 2028–4902 ships/h), and diverting ships incurs extra travel time (e.g., 0.10–0.29 hours) on alternative berths.  

The challenge is to assign one of four diversion ratios (10%, 30%, 50%, or 70%) to each berth and time period (30-minute intervals over 5 hours) such that:  
- The total diversion ratio across all berths and periods stays between 30% and 70%.  
- No two consecutive periods diverge by more than 20 percentage points to ensure smooth traffic flow.  
- Alternative berth capacities are never exceeded.  
The goal is to minimize the cumulative delay, accounting for both queueing on the main berths and extra travel time on alternatives.  

Key Question: What is the optimal dynamic diversion strategy that minimizes total delay while satisfying all operational constraints?  
**

**Modeling Process:**
**
1. Decision Variables:  
- Binary variable \( y(i, t, k) \): Equals 1 if berth \( i \) at time \( t \) uses diversion option \( k \) (where \( k \) corresponds to ratios 0.1, 0.3, 0.5, 0.7), else 0.  
- Continuous variable \( \text{TotalDiversion} \): Average diversion ratio across all berths and periods.  

2. Parameters:  
- \( \text{arrival_rates}[i][t] \): Ships arriving at berth \( i \) in period \( t \) (ships/h).  
- \( \text{capacities_main_normal}[i], \text{capacities_main_reduced}[i] \): Main berth capacities (ships/h).  
- \( \text{capacities_alt}[i] \): Alternative berth capacity (ships/h).  
- \( \text{alt_berth_extra_times}[i] \): Additional travel time for alternative berths (hours).  
- \( \text{MAX_DIVERSION_CHANGE} = 0.2 \): Maximum allowed diversion ratio change between periods.  
- \( \text{MIN_TOTAL_DIVERSION} = 0.3 \), \( \text{MAX_TOTAL_DIVERSION} = 0.7 \): Bounds on total diversion.  

3. Objective Function:  
Minimize the sum of delays:  
\[
\sum_{i,t,k} y(i,t,k) \cdot \text{berth_period_option_delays}[i][t][k]
\]  
where delays combine queueing (if main berth flow exceeds reduced capacity) and alternative berth travel time.  

4. Constraints:  
- **Feasibility:** Only select diversion options \( k \) where alternative berth flow \( \leq \text{capacities_alt}[i] \).  
- **Single Option:** For each \( (i,t) \), exactly one \( y(i,t,k) = 1 \).  
- **Smooth Transitions:** If \( y(i,t-1,k_1) = 1 \), then \( y(i,t,k_2) = 0 \) if \( |k_1 - k_2| > 0.2 \).  
- **Total Diversion Bounds:** \( 0.3 \leq \text{TotalDiversion} \leq 0.7 \).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 6
NUM_TIME_PERIODS = 10
TIME_PERIOD_LENGTH = 0.5  # h
MAX_DIVERSION_CHANGE = 0.2  # Maximum allowed change in diversion ratio
MIN_TOTAL_DIVERSION = 0.3  # Minimum total diversion ratio
MAX_TOTAL_DIVERSION = 0.7  # Maximum total diversion ratio
capacities_main_normal = [4046, 5762, 3575, 3586, 4944, 5193]  # ships/h
capacities_main_reduced = [1751, 2401, 1915, 1274, 2169, 2938]  # ships/h
capacities_alt = [1804, 866, 1393, 883, 1600, 1747]  # ships/h
arrival_rates = [[3673, 3716, 4902, 2408, 4550, 3875, 4722, 3056, 4739, 2362], [3088, 2822, 4578, 3503, 4544, 3042, 2993, 2085, 3662, 2820], [3299, 2206, 3888, 3935, 3426, 2065, 2028, 3556, 4364, 4015], [3375, 3792, 3249, 4902, 4642, 2647, 3295, 4413, 3070, 4947], [3828, 2712, 2041, 2589, 2524, 2918, 3319, 3400, 4949, 2849], [3249, 2757, 2363, 2569, 4607, 4460, 3382, 4455, 3771, 3104]]  # ships/h
incident_durations = [0.7696972122133341, 1.3058963474014813, 0.7017116562962309, 1.782954296796178, 1.950156136000948, 1.4706196014572086]  # h
alt_berth_extra_times = [0.11110991773404448, 0.27407149998194436, 0.15613676394796017, 0.09882648039922427, 0.2928137340582431, 0.22562480049916706]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")
total_diversion = m.addVar(name="TotalDiversion")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

        # Add smooth transition constraints between periods
        if t > 0:
            for k1 in range(num_options):
                for k2 in range(num_options):
                    if abs(diversion_options[k1] - diversion_options[k2]) > MAX_DIVERSION_CHANGE:
                        m.addConstr(y[i,t-1,k1] + y[i,t,k2] <= 1,
                                  name="SmoothTransition_Berth{0}_Period{1}_Options{2}{3}".format(i,t,k1,k2))

# Calculate total diversion ratio
m.addConstr(total_diversion == gp.quicksum(
    y[i,t,k] * diversion_options[k]
    for i in range(NUM_BERTHS)
    for t in range(NUM_TIME_PERIODS)
    for k in range(num_options)
    if berth_period_option_feasible[i][t][k]
) / (NUM_BERTHS * NUM_TIME_PERIODS),
name="TotalDiversionRatio")

# Add total diversion ratio constraints
m.addConstr(total_diversion >= MIN_TOTAL_DIVERSION, name="MinTotalDiversion")
m.addConstr(total_diversion <= MAX_TOTAL_DIVERSION, name="MaxTotalDiversion")

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    print(f"Total Diversion Ratio: {0:.1f}%".format(total_diversion.X * 100))
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:
Total Diversion Ratio: 0.0%

Berth 1:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 2 (50%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 2 (50%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 2 (50%)

Berth 2:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 0 (10%)
  Period 10 (4.5-5.0h): Option 1 (30%)

Berth 3:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 2 (50%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 2 (50%)
  Period 7 (3.0-3.5h): Option 2 (50%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 1 (30%)

Berth 4:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 0 (10%)
  Period 9 (4.0-4.5h): Option 0 (10%)
  Period 10 (4.5-5.0h): Option 0 (10%)

Berth 5:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 2 (50%)
  Period 3 (1.0-1.5h): Option 3 (70%)
  Period 4 (1.5-2.0h): Option 2 (50%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 1 (30%)

Berth 6:
  Period 1 (0.0-0.5h): Option 2 (50%)
  Period 2 (0.5-1.0h): Option 2 (50%)
  Period 3 (1.0-1.5h): Option 3 (70%)
  Period 4 (1.5-2.0h): Option 2 (50%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)
  Period 9 (4.0-4.5h): Option 1 (30%)
  Period 10 (4.5-5.0h): Option 2 (50%)



================================================================================



--- Problem 317 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy inland logistics hub faces the challenge of efficiently scheduling five incoming trucks at three available depots, each with strict timing constraints. The trucks arrive at staggered times: Truck 1 at 5 hours, Truck 2 at 6, Truck 3 at 10, Truck 4 at 11, and Truck 5 at 14. Each truck requires a specific processing duration—Truck 1 takes 6 hours, Truck 2 takes 5, Truck 3 takes 3, Truck 4 takes 4, and Truck 5 takes 6. The hub must minimize the total operational time (makespan) while adhering to a critical service-level agreement (SLA): Truck 1, designated as high-priority, must begin servicing within 5.3 hours of its arrival. The core question is: *How can the hub assign trucks to depots and schedule their servicing to meet the SLA while finishing all operations as quickly as possible?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary `assign[i, j]`: 1 if truck *i* is assigned to depot *j*, else 0.  
     - Continuous `start_time[i]`: When servicing begins for truck *i*.  
     - Continuous `completion_time[i]`: When servicing ends for truck *i* (`start_time[i] + processing_times[i]`).  
     - Binary `precedes[i, k, j]`: 1 if truck *i* is serviced before truck *k* on depot *j*, else 0.  
     - Continuous `makespan`: Latest completion time across all trucks.  

   - **2. Parameters:**  
     - `arrival_times[i]`: Truck *i*'s arrival time (e.g., Truck 1: 5).  
     - `processing_times[i]`: Truck *i*'s servicing duration (e.g., Truck 1: 6).  
     - `H=100`: Large constant for precedence constraints.  
     - `sla_truck=1`: High-priority truck (Truck 1).  
     - `sla_max_wait=5.3`: Max wait time for Truck 1.  

   - **3. Objective Function:**  
     Minimize `makespan` (latest completion time).  

   - **4. Constraints:**  
     1. Each truck assigned to exactly one depot: `sum(assign[i, j] for j in depots) = 1` for all *i*.  
     2. Servicing starts after arrival: `start_time[i] >= arrival_times[i]` for all *i*.  
     3. Completion time definition: `completion_time[i] = start_time[i] + processing_times[i]`.  
     4. No overlapping on depots: For each depot *j*, if trucks *i* and *k* are assigned, enforce `precedes[i, k, j]` or `precedes[k, i, j]` to sequence them.  
     5. SLA for Truck 1: `start_time[1] - arrival_times[1] <= 5.3`.  
     6. `makespan` is the maximum completion time: `makespan >= completion_time[i]` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2, 3]
arrival_times = {1: 5, 2: 6, 3: 10, 4: 11, 5: 14}
processing_times = {1: 6, 2: 5, 3: 3, 4: 4, 5: 6}
H = 100 # Big M
sla_truck = 1
sla_max_wait = 5.3
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")
    if sla_truck not in trucks: raise ValueError("SLA truck not in trucks list")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. SLA Constraint
    m.addConstr(start_time[sla_truck] - arrival_times.get(sla_truck, 0) <= sla_max_wait, name=f"SLA_truck_{sla_truck}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Ensure All Key Outputs are Printed ---

if m.status == GRB.OPTIMAL:
    print(f"Optimal Makespan: {m.objVal:.4f}")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time for Truck {i}: {start_time[i].x:.4f}")
                print(f"Completion Time for Truck {i}: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
20.0000
Optimal Makespan: 20.0000
Truck 1 is assigned to Depot 2
Start Time for Truck 1: 5.0000
Completion Time for Truck 1: 11.0000
Truck 2 is assigned to Depot 1
Start Time for Truck 2: 6.0000
Completion Time for Truck 2: 11.0000
Truck 3 is assigned to Depot 2
Start Time for Truck 3: 11.0000
Completion Time for Truck 3: 14.0000
Truck 4 is assigned to Depot 3
Start Time for Truck 4: 11.0000
Completion Time for Truck 4: 15.0000
Truck 5 is assigned to Depot 1
Start Time for Truck 5: 14.0000
Completion Time for Truck 5: 20.0000


```

================================================================================



--- Problem 318 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A maritime logistics company operates a fleet of 5 ships (with capacities 86, 99, 89, 69, and 100 units) to deliver goods from a central port (Node 0) to 6 customer locations (Nodes 1–6). Each customer has a specific demand (56, 47, 89, 99, 82, and 49 units, respectively), and the distances between all pairs of nodes are predefined. The challenge is to assign routes to the ships such that:  
   - Every customer is visited exactly once.  
   - Ships start and end at the central port.  
   - No ship exceeds its capacity.  
   - The total travel distance across all routes is minimized.  

   The company aims to optimize delivery efficiency while respecting ship constraints, ensuring timely service and cost-effective operations. The key question: *What is the most efficient set of routes that meets all demands while minimizing total distance traveled?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable \(x_{ijk}\): 1 if ship \(k\) travels directly from node \(i\) to node \(j\); 0 otherwise.  
   - Continuous variable \(u_i\): Subtour elimination auxiliary variable for node \(i\) (Miller-Tucker-Zemlin formulation).  

   **2. Parameters:**  
   - \(N = 7\) (central port + 6 customers).  
   - \(K = 5\) (ships).  
   - \(Q_k\): Capacity of ship \(k\) (e.g., \(Q_1 = 86\)).  
   - \(q_j\): Demand at customer \(j\) (e.g., \(q_1 = 56\)).  
   - \(d_{ij}\): Distance from node \(i\) to node \(j\) (e.g., \(d_{0,1} = 71\)).  

   **3. Objective Function:**  
   Minimize total distance:  
   \[
   \text{Minimize: } \sum_{k=1}^K \sum_{i=0}^6 \sum_{j=0}^6 d_{ij} \cdot x_{ijk} \quad (i \neq j)
   \]  

   **4. Constraints:**  
   - **Visit each customer once:** \(\sum_{k=1}^5 \sum_{j=0}^6 x_{ijk} = 1 \quad \forall i \in \{1,\dots,6\}\).  
   - **Flow conservation:** \(\sum_{i=0}^6 x_{ijk} = \sum_{i=0}^6 x_{jik} \quad \forall j \in \{0,\dots,6\}, k \in \{1,\dots,5\}\).  
   - **Port departure/return:** \(\sum_{j=1}^6 x_{0jk} \leq 1\) and \(\sum_{j=1}^6 x_{0jk} = \sum_{j=1}^6 x_{j0k} \quad \forall k\).  
   - **Capacity:** \(\sum_{j=1}^6 q_j \cdot \sum_{i=0}^6 x_{ijk} \leq Q_k \quad \forall k\).  
   - **Subtour elimination:** \(u_i - u_j + 6 \cdot x_{ijk} \leq 5 \quad \forall i,j \in \{1,\dots,6\}, k \in \{1,\dots,5\}\).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 7
K = 5
Q = [86, 99, 89, 69, 100]
q = [0, 56, 47, 89, 99, 82, 49]
d = [
    [0, 71, 42, 32, 49, 89, 47],
    [71, 0, 25, 49, 68, 85, 46],
    [42, 25, 0, 62, 6, 66, 37],
    [32, 49, 62, 0, 76, 3, 82],
    [49, 68, 6, 76, 0, 24, 29],
    [89, 85, 66, 3, 24, 0, 97],
    [47, 46, 37, 82, 29, 97, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Ship Departure/Return from Central Port (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartPort_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnPort_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for ship {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for ship {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 608.00

Route for ship 1 (Capacity: 86):
0 -> 5 -> 0
Route Load: 82 / 86

Route for ship 2 (Capacity: 99):
0 -> 6 -> 2 -> 0
Route Load: 96 / 99

Route for ship 3 (Capacity: 89):
0 -> 3 -> 0
Route Load: 89 / 89

Route for ship 4 (Capacity: 69):
0 -> 1 -> 0
Route Load: 56 / 69

Route for ship 5 (Capacity: 100):
0 -> 4 -> 0
Route Load: 99 / 100


```

================================================================================



--- Problem 319 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A maritime logistics company is tasked with delivering goods from a central port (Node 0) to three customer ports (Nodes 1, 2, and 3) using a fleet of three ships. Each ship has a distinct capacity: Ship 1 can carry up to 31 units, Ship 2 up to 32 units, and Ship 3 up to approximately 23.05 units. The customers have specific demand quantities: Customer Port 1 requires 29 units, Customer Port 2 needs 21 units, and Customer Port 3 demands 31 units.  

The distances between locations are asymmetric and given as follows:  
- From the central port (Node 0) to Customer Port 1 (Node 1): 19 nautical miles  
- From the central port to Customer Port 2 (Node 2): 97 nautical miles  
- From the central port to Customer Port 3 (Node 3): 100 nautical miles  
- Between customer ports, distances vary (e.g., Customer Port 1 to Customer Port 2 is 67 nautical miles).  

The challenge is to assign routes to the ships such that:  
- Each customer port is visited exactly once.  
- All ships start and end at the central port.  
- The total demand on each ship’s route does not exceed its capacity.  
- The combined travel distance across all ships is minimized.  

The central question is: **What is the most efficient routing plan that meets all delivery requirements while minimizing the total distance traveled?**  

---

**

Modeling Process:**
**
1. Decision Variables:**  
- Binary variables `x[i, j, k]` indicate whether ship `k` travels directly from node `i` to node `j` (`1` if yes, `0` otherwise).  
- Continuous variables `u[i]` (for subtour elimination) track the order in which node `i` is visited.  

**2. Parameters:**  
- `N = 4` (central port + 3 customer ports).  
- `K = 3` (ships).  
- `Q[k]`: Capacity of ship `k` (31, 32, 23.05).  
- `q[i]`: Demand at node `i` (0 for central port, 29, 21, 31 for customer ports).  
- `d[i][j]`: Distance from node `i` to node `j`.  

**3. Objective Function:**  
Minimize the total distance traveled by all ships:  
```
Minimize: sum(d[i][j] * x[i, j, k] for all i, j, k where i ≠ j)
```  

**4. Constraints:**  
- **Visit Each Customer Once:**  
  For each customer port `i` (1 to 3):  
  `sum(x[i, j, k] for all j, k where i ≠ j) = 1`.  

- **Flow Conservation:**  
  For each ship `k` and node `i`:  
  `sum(x[i, j, k] for all j where i ≠ j) = sum(x[j, i, k] for all j where i ≠ j)`.  

- **Central Port Departure/Return:**  
  Each ship `k` must leave and return to the central port (Node 0) at most once:  
  `sum(x[0, j, k] for all j ≠ 0) ≤ 1` and  
  `sum(x[0, j, k] for all j ≠ 0) = sum(x[j, 0, k] for all j ≠ 0)`.  

- **Capacity Limits:**  
  For each ship `k`:  
  `sum(q[j] * sum(x[i, j, k] for all i ≠ j) for all j ≠ 0) ≤ Q[k]`.  

- **Subtour Elimination (MTZ):**  
  For `i, j ≠ 0` and `i ≠ j`:  
  `u[i] - u[j] + (N-1) * x[i, j, k] ≤ N-2`.  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 4
K = 3
Q = [31, 32, 23.049999999999997]
q = [0, 29, 21, 31]
d = [
    [0, 19, 97, 100],
    [19, 0, 67, 53],
    [97, 67, 0, 41],
    [100, 53, 41, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Vehicle Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for ship {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for ship {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 432.00

Route for ship 1 (Capacity: 31):
0 -> 1 -> 0
Route Load: 29 / 31

Route for ship 2 (Capacity: 32):
0 -> 3 -> 0
Route Load: 31 / 32

Route for ship 3 (Capacity: 23.049999999999997):
0 -> 2 -> 0
Route Load: 21 / 23.049999999999997


```

================================================================================



--- Problem 320 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A port is optimizing its ship berthing operations to balance cost efficiency with the demand for berthing slots. During peak hours, the arrival rate of ships surges to 60 ships per hour, and the port must decide between two berth configurations: a **single-berth setup** (handling 55 ships/hour at $15/hour operational cost) or a **dual-berth setup** (handling 110 ships/hour at $35/hour). If the chosen configuration fails to meet demand, a penalty of $76/hour is incurred due to lost revenue and customer dissatisfaction. The goal is to minimize the total cost—combining operational expenses and potential penalties—while ensuring the configuration can handle the rush. The challenge is to determine whether the higher-cost dual-berth setup justifies its expense by avoiding penalties or if the cheaper single-berth setup suffices despite its lower capacity.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `y(c)`: 1 if configuration `c` is chosen (`single` or `dual`), 0 otherwise.  
     - Binary variable `z`: 1 if capacity is insufficient (arrival rate > service rate), 0 otherwise.  
   - **2. Parameters:**  
     - `configs`: Dictionary with keys `single` and `dual`, each specifying `rate` (ships/hour) and `cost` ($/hour).  
     - `arrival_rate_rush = 60` (ships/hour).  
     - `penalty_insufficient_capacity = 76` ($/hour).  
     - `M = 1000` (large constant for linearization).  
     - `epsilon = 0.1` (small constant to enforce strict inequalities).  
   - **3. Objective Function:**  
     Minimize total cost:  
     `Operational Cost + Penalty * z = sum(y[c] * configs[c]['cost'] for c) + 76 * z`.  
   - **4. Constraints:**  
     - Exactly one configuration must be chosen: `sum(y[c] for c) = 1`.  
     - If arrival rate exceeds capacity, `z` is forced to 1: `60 - sum(y[c] * configs[c]['rate']) <= M * z`.  
     - If capacity meets/exceeds demand, `z` is forced to 0: `sum(y[c] * configs[c]['rate']) - 60 >= epsilon - M * z`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
configs = {'single': {'rate': 55, 'cost': 15}, 'dual': {'rate': 110, 'cost': 35}}
arrival_rate_rush = 60; penalty_insufficient_capacity = 76
M = 1000; epsilon = 0.1
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    config_keys = list(configs.keys())
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m10 = gp.Model("Berth_Optimization_IP", env=env)
    # Vars
    y = m10.addVars(config_keys, vtype=GRB.BINARY, name="config_choice")
    z = m10.addVar(vtype=GRB.BINARY, name="is_capacity_insufficient")
    # Intermediate Expressions
    capacity = gp.quicksum(y[c] * configs[c]['rate'] for c in config_keys)
    op_cost = gp.quicksum(y[c] * configs[c]['cost'] for c in config_keys)
    # Objective
    m10.setObjective(op_cost + penalty_insufficient_capacity * z, sense=GRB.MINIMIZE)
    # Constraints
    m10.addConstr(gp.quicksum(y[c] for c in config_keys) == 1, "choose_one_config")
    m10.addConstr(arrival_rate_rush - capacity <= M * z, "force_z_if_insufficient")
    m10.addConstr(capacity - arrival_rate_rush >= epsilon - M * z, "force_z_if_sufficient")
    # Optimize
    m10.optimize()
    # Store results
    results_dict['status'] = m10.status
    if m10.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m10.objVal; results_dict['y_sol'] = m10.getAttr('X', y); results_dict['z_sol'] = z.X
    # Output Results
    print("--- Problem 10: Berth Optimization (IP) ---")
    if m10.status == GRB.OPTIMAL:
        y_sol = results_dict.get('y_sol', {}); z_sol = results_dict.get('z_sol', -1)
        chosen_config = "";
        for c in config_keys:
             if y_sol.get(c, 0) > 0.5: chosen_config = c; break
        if chosen_config:
            final_capacity = configs[chosen_config]['rate']; final_op_cost = configs[chosen_config]['cost']
            final_penalty = penalty_insufficient_capacity * z_sol
            print(f"Optimization Status: Optimal"); print(f"Optimal configuration: {chosen_config.capitalize()}")
            print(f"  Service Rate: {final_capacity} ships/hr (Arrival: {arrival_rate_rush} ships/hr)"); print(f"  Operational Cost: ${final_op_cost:.2f}/hr")
            print(f"  Insufficient Capacity Penalty Applied: ${final_penalty:.2f}/hr (z={int(round(z_sol))})"); print(f"Minimum Total Cost: ${m10.objVal:.2f}/hr")
        else: print("Error: Optimal status but no config chosen.")
    else: print(f"Optimization Status: {m10.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of BERTH_OPTIMIZATION
```
Answer:
--- Problem 10: Berth Optimization (IP) ---
Optimization Status: Optimal
Optimal configuration: Dual
  Service Rate: 110 ships/hr (Arrival: 60 ships/hr)
  Operational Cost: $35.00/hr
  Insufficient Capacity Penalty Applied: $0.00/hr (z=0)
Minimum Total Cost: $35.00/hr



================================================================================



--- Problem 321 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A high-end valet service at a luxury hotel faces the challenge of efficiently assigning parking spots to a mix of VIP and regular vehicles. The goal is to minimize the total time required to retrieve cars upon guest requests while adhering to strict service standards.  

The valet area has **15 spots**:  
- **9 premium spots** (P1–P9) with a **1-minute retrieval time**.  
- **6 standard spots** (S1–S6) with a **2-minute retrieval time**.  

There are **12 cars** to park:  
- **5 VIP cars** (C1–C5) that incur a **$10 penalty** if assigned to standard spots (to prioritize premium access).  
- **7 non-VIP cars** (C6–C12) with no penalties.  

The valet manager must assign each car to **exactly one spot**, with no spot holding more than one car. Additionally, due to a special event, the valet service must ensure that at least 3 VIP cars are parked in premium spots. The objective is to minimize the **combined retrieval time and penalties**, balancing speed for VIPs with efficient use of all spots.  

**Key Question:** *What is the optimal assignment of cars to spots to achieve the lowest total cost (retrieval time + penalties) while ensuring at least 3 VIP cars are in premium spots?*  

---

###

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable `assign(c, s)` = 1 if car `c` is assigned to spot `s`, else 0.  
  - Indices: `c` ∈ {C1, ..., C12}, `s` ∈ {P1, ..., P9, S1, ..., S6}.  

**2. Parameters:**  
- `retrieval_time(s)`: 1 min (premium), 2 min (standard).  
- `vip_penalty_standard`: $10 (applied per VIP car in standard spots).  
- `vip_cars`: {C1, ..., C5}.  

**3. Objective Function:**  
Minimize:  
```
Total Retrieval Time + Total Penalty  
= ∑(assign(c, p) * 1 for all c, p ∈ premium_spots)  
+ ∑(assign(c, s) * 2 for all c, s ∈ standard_spots)  
+ ∑(assign(c, s) * 10 for all c ∈ vip_cars, s ∈ standard_spots)  
```

**4. Constraints:**  
- **Each car parked exactly once:**  
  `∑(assign(c, s) for all s) = 1` for each car `c`.  
- **Spot capacity (≤1 car per spot):**  
  `∑(assign(c, s) for all c) ≤ 1` for each spot `s`.  
- **At least 3 VIP cars in premium spots:**  
  `∑(assign(c, p) for all c ∈ vip_cars, p ∈ premium_spots) ≥ 3`  

---

### 3.
**

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
num_premium_spots = 9; num_standard_spots = 6
premium_spots = ['P1', 'P2', 'P3', 'P4', 'P5', 'P6', 'P7', 'P8', 'P9']; standard_spots = ['S1', 'S2', 'S3', 'S4', 'S5', 'S6']; all_spots = ['P1', 'P2', 'P3', 'P4', 'P5', 'P6', 'P7', 'P8', 'P9', 'S1', 'S2', 'S3', 'S4', 'S5', 'S6']
num_total_cars = 12; num_vip_cars = 5
cars = ['C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9', 'C10', 'C11', 'C12']; vip_cars = ['C1', 'C2', 'C3', 'C4', 'C5']; non_vip_cars = ['C6', 'C7', 'C8', 'C9', 'C10', 'C11', 'C12']
retrieval_time = {'Premium': 1, 'Standard': 2}; vip_penalty_standard = 10
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m16 = gp.Model("Valet_Spot_Assignment_MIP", env=env)
    # Vars
    assign = m16.addVars(cars, all_spots, vtype=GRB.BINARY, name="assign")
    # Objective
    total_retrieval_time = gp.quicksum(assign[c, p] * retrieval_time['Premium'] for c in cars for p in premium_spots) + gp.quicksum(assign[c, s] * retrieval_time['Standard'] for c in cars for s in standard_spots)
    total_penalty = gp.quicksum(assign[c, s] * vip_penalty_standard for c in vip_cars for s in standard_spots)
    m16.setObjective(total_retrieval_time + total_penalty, sense=GRB.MINIMIZE)
    # Constraints
    for c in cars: m16.addConstr(gp.quicksum(assign[c, spot] for spot in all_spots) == 1, f"car_{c}_must_park")
    for spot in all_spots: m16.addConstr(gp.quicksum(assign[c, spot] for c in cars) <= 1, f"spot_{spot}_capacity")
    # New Constraint: At least 3 VIP cars in premium spots
    m16.addConstr(gp.quicksum(assign[c, p] for c in vip_cars for p in premium_spots) >= 3, "at_least_3_vip_in_premium")
    # Optimize
    m16.optimize()
    # Store results
    results_dict['status'] = m16.status
    if m16.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m16.objVal
        results_dict['assign_sol'] = m16.getAttr('X', assign)
    # Output Results
    print("--- Problem 16: Valet Parking Spot Assignment (MIP) ---")
    if m16.status == GRB.OPTIMAL:
        print(f"Optimization Status: Optimal")
        print(f"Minimum Total Cost (Retrieval Time + Penalty): {m16.objVal:.2f}")
        print("Assignments & Costs:")
        assign_sol = results_dict.get('assign_sol', {})
        rt_sum = 0; pen_sum = 0; assignments_dict = {}
        for c in cars:
            for spot in all_spots:
                if assign_sol.get((c, spot), 0) > 0.5:
                    assignments_dict[c] = spot; is_premium = spot in premium_spots; is_vip = c in vip_cars
                    rt = retrieval_time['Premium'] if is_premium else retrieval_time['Standard']; pen = 0
                    if is_vip and not is_premium: pen = vip_penalty_standard
                    rt_sum += rt; pen_sum += pen
                    print(f"  Car {c} ({'VIP' if is_vip else 'Non-VIP'}) -> Spot {spot} ({'Premium' if is_premium else 'Standard'}) | RT: {rt} min, Penalty: ${pen}")
        print(f"\nTotal Retrieval Time: {rt_sum} min"); print(f"Total VIP Penalty: ${pen_sum}"); print(f"Objective Value Check: {rt_sum + pen_sum}")
    else: print(f"Optimization Status: {m16.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of VALET_PARKING
```
Answer:
--- Problem 16: Valet Parking Spot Assignment (MIP) ---
Optimization Status: Optimal
Minimum Total Cost (Retrieval Time + Penalty): 15.00
Assignments & Costs:
  Car C1 (VIP) -> Spot P3 (Premium) | RT: 1 min, Penalty: $0
  Car C2 (VIP) -> Spot P1 (Premium) | RT: 1 min, Penalty: $0
  Car C3 (VIP) -> Spot P8 (Premium) | RT: 1 min, Penalty: $0
  Car C4 (VIP) -> Spot P7 (Premium) | RT: 1 min, Penalty: $0
  Car C5 (VIP) -> Spot P2 (Premium) | RT: 1 min, Penalty: $0
  Car C6 (Non-VIP) -> Spot P4 (Premium) | RT: 1 min, Penalty: $0
  Car C7 (Non-VIP) -> Spot S1 (Standard) | RT: 2 min, Penalty: $0
  Car C8 (Non-VIP) -> Spot S2 (Standard) | RT: 2 min, Penalty: $0
  Car C9 (Non-VIP) -> Spot P6 (Premium) | RT: 1 min, Penalty: $0
  Car C10 (Non-VIP) -> Spot P5 (Premium) | RT: 1 min, Penalty: $0
  Car C11 (Non-VIP) -> Spot S6 (Standard) | RT: 2 min, Penalty: $0
  Car C12 (Non-VIP) -> Spot P9 (Premium) | RT: 1 min, Penalty: $0

Total Retrieval Time: 15 min
Total VIP Penalty: $0
Objective Value Check: 15



================================================================================



--- Problem 322 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, two cranes are used to load and unload containers from ships. Each crane must be allocated a specific working time within a fixed cycle length of 53 minutes, ensuring efficient operation while minimizing the total waiting time for the ships. The challenge lies in balancing the working times for both cranes, as the first crane handles a heavier workload (913 containers per hour) compared to the second crane (817 containers per hour). The working time for each crane must fall between 12 and 53 minutes, and the sum of both working times must exactly match the cycle length. The core question is: *How should the working times be allocated to minimize the total waiting time experienced by the ships?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - \( t_i \): Continuous variable representing the working time (in minutes) allocated to crane \( i \), where \( i \in \{1, 2\} \).  
     - Bounds: \( 12 \leq t_i \leq 53 \).  

   - **2. Parameters:**  
     - \( \text{workload_coeffs} = [913, 817] \): Workload coefficients (containers/hour) for cranes 1 and 2.  
     - \( \text{cycle_time} = 53 \): Total cycle time (minutes).  
     - \( \text{lb_time} = 12 \), \( \text{ub_time} = 53 \): Lower and upper bounds for working times.  

   - **3. Objective Function:**  
     Minimize the total waiting time, calculated as:  
     \[
     \text{Minimize: } 913 \cdot (53 - t_1) + 817 \cdot (53 - t_2).
     \]  
     Here, \( (53 - t_i) \) represents the idle time for crane \( i \), and the waiting time is proportional to the product of workload and idle time.  

   - **4. Constraints:**  
     - **Total Cycle Constraint:** The sum of working times must equal the cycle time:  
       \[
       t_1 + t_2 = 53.
       \]  
     - **Variable Bounds:**  
       \[
       12 \leq t_1 \leq 53, \quad 12 \leq t_2 \leq 53.
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_cranes = 2
lb_time = 12          # Lower bound for working time
ub_time = 53          # Upper bound for working time
cycle_time = 53   # Total cycle time (set equal to ub_time)
workload_coeffs = [913, 817] # Workload coefficients per crane
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(workload_coeffs) != num_cranes:
    print("Error: workload_coeffs length mismatch with num_cranes")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: workload_coeffs length"
    # raise ValueError("workload_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_cranes}-Cranes Working Time Allocation", env=env)

        # --- Decision variables (dynamic based on num_cranes) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_cranes, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for crane i is proportional to workload * idle_time = workload * (cycle_time - working_time[i])
        model.setObjective(gp.quicksum(workload_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_cranes)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of working times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_cranes)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_cranes)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal working times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_cranes):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 44453.00
------------------------------
Optimal working times (minutes):
  t1: 41.00, t2: 12.00


```

================================================================================



--- Problem 323 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
**
A port operator faces the challenge of dynamically pricing berthing fees during different traffic periods to maximize revenue while respecting berth capacity limits. The port experiences two distinct periods: "off-peak" with a base demand of 966 ships per hour and "peak" with a significantly higher base demand of 2893 ships per hour. The operator can adjust berthing fees up to a maximum of $6 per ship, with demand sensitivity (alpha) set at 38 ships per hour for every dollar increase in berthing fee. The port's capacity is fixed at 1638 ships per hour, meaning traffic flow cannot exceed this limit regardless of demand.  

The core question is: What berthing fees should be set during off-peak and peak periods to maximize total revenue, ensuring that the resulting traffic flow does not exceed capacity and that demand responds linearly to price changes? The operator must balance higher fees (which reduce demand but increase revenue per ship) against lower fees (which attract more ships but may not fully utilize capacity).

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- `fee[p]`: Berthing fee (in $) for period `p` (where `p` is either "off" or "peak"). Bounded between 0 and `max_fee` ($6).  
- `demand[p]`: Resulting demand (ships/hr) for period `p`, calculated as `base_demand[p] - alpha * fee[p]`.  
- `flow[p]`: Actual traffic flow (ships/hr) for period `p`, constrained by both demand and capacity.  

**2. Parameters:**  
- `capacity = 1638`: Maximum flow capacity (ships/hr).  
- `base_demand = {'off': 966, 'peak': 2893}`: Base demand (ships/hr) when fees are $0.  
- `alpha = 38`: Demand sensitivity (ships/hr per $1 fee increase).  
- `max_fee = 6`: Upper bound on berthing fee ($).  

**3. Objective Function:**  
Maximize total revenue:  
`Maximize: sum(flow[p] * fee[p] for p in periods)`  

**4. Constraints:**  
- Demand calculation for each period `p`:  
  `demand[p] == base_demand[p] - alpha * fee[p]`  
- Flow cannot exceed capacity:  
  `flow[p] <= capacity`  
- Flow cannot exceed demand:  
  `flow[p] <= demand[p]`  
- Non-negativity:  
  `fee[p], demand[p], flow[p] >= 0`  

---

**

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 1638; base_demand = {'off': 966, 'peak': 2893}; alpha = 38; max_fee = 6; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berthing_Fees_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berthing Fees (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of DYNAMIC_BERTHING_FEES
```
Answer:
--- Problem 18: Dynamic Berthing Fees (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $14256.00
  Period: Off
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 738.0 ships/hr (Base: 966)
    Actual Flow (min(Demand, Capacity)): 738.0 ships/hr (Capacity: 1638)
    Revenue this period: $4428.00
  Period: Peak
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 2665.0 ships/hr (Base: 2893)
    Actual Flow (min(Demand, Capacity)): 1638.0 ships/hr (Capacity: 1638)
    Revenue this period: $9828.00
Total ships processed: 2376.0



================================================================================


--- Problem 324 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A port authority is tasked with managing the berthing of 234 ships in a day. The port has two options to manage this demand: using its own berths or outsourcing to a nearby private port. Each berth can handle 11 ships per day, and the cost of operating a berth for a day is $113. Outsourcing, while flexible, comes at a higher cost of $43 per ship. The port must decide how many berths to use (up to a maximum of 50) and how many ships to outsource to minimize the total daily cost while ensuring all 234 ships are berthed. The challenge lies in balancing the fixed cost of using berths against the variable cost of outsourcing, especially when the port’s capacity may exceed or fall short of demand.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n`: Integer number of berths to use (0 ≤ `n` ≤ 50).  
     - `outsourced`: Integer number of ships outsourced (`outsourced` ≥ 0).  
   - **2. Parameters:**  
     - `total_ships_demand = 234`: Total ships requiring berthing.  
     - `ships_per_berth_day = 11`: Ships one berth can handle daily.  
     - `cost_per_berth_day = 113`: Daily cost per berth.  
     - `cost_per_outsourced_ship = 43`: Cost per outsourced ship.  
     - `max_berths = 50`: Upper limit on berths available.  
   - **3. Objective Function:**  
     Minimize total cost:  
     \[
     \text{Minimize: } 113 \cdot n + 43 \cdot \text{outsourced}
     \]  
   - **4. Constraints:**  
     - Demand fulfillment:  
       \[
       11 \cdot n + \text{outsourced} \geq 234
       \]  
     - Variable bounds:  
       \[
       n \in \{0, 1, ..., 50\}, \quad \text{outsourced} \geq 0
       \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_ships_demand = 234
ships_per_berth_day = 11
cost_per_berth_day = 113
cost_per_outsourced_ship = 43
max_berths = 50
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m37 = gp.Model("BERTH_SIZE_OPTIMIZATION_IP", env=env)

    # --- Decision Variables ---
    # Integer: Number of berths to use
    n = m37.addVar(vtype=GRB.INTEGER, name="num_berths", lb=0, ub=max_berths)
    # Integer: Number of ships outsourced
    outsourced = m37.addVar(vtype=GRB.INTEGER, name="num_outsourced", lb=0)

    # --- Objective Function ---
    # Minimize total cost (berth cost + outsourcing cost)
    m37.setObjective(n * cost_per_berth_day + outsourced * cost_per_outsourced_ship, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Ensure total demand is met by own berths + outsourcing
    # Avoid division by zero for ships_per_berth_day
    if ships_per_berth_day > 0:
        m37.addConstr(n * ships_per_berth_day + outsourced >= total_ships_demand, name="demand_met")
    else:
        # If capacity is zero, all demand must be outsourced
        m37.addConstr(outsourced >= total_ships_demand, name="demand_met_zero_cap")
        m37.addConstr(n == 0, name="force_zero_berths") # Cannot use berths with zero capacity

    # --- Optimization ---
    m37.optimize()

    # --- Store results ---
    results_dict['status'] = m37.status
    if m37.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m37.ObjVal
        results_dict['n_sol'] = n.X
        results_dict['outsourced_sol'] = outsourced.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 37: Berth Size Optimization (IP) ---") # Original problem number
    if m37.status == GRB.OPTIMAL:
        opt_n = int(round(results_dict.get('n_sol', 0)))
        opt_outsourced = int(round(results_dict.get('outsourced_sol', 0)))
        capacity_own = opt_n * ships_per_berth_day
        cost_own = opt_n * cost_per_berth_day
        cost_outsource = opt_outsourced * cost_per_outsourced_ship
        obj_val_print = results_dict.get('obj_val', 'N/A')

        print(f"Optimization Status: Optimal")
        print(f"Optimal Number of Berths: {opt_n} (Max: {max_berths})")
        print(f"  Own Berth Capacity: {capacity_own} ships")
        print(f"Number of Outsourced Ships: {opt_outsourced}")
        print(f"Total Ships Berthed: {capacity_own + opt_outsourced} (Demand: {total_ships_demand})")
        print(f"\nCosts:")
        print(f"  Own Berth Cost: ${cost_own:.2f}")
        print(f"  Outsourcing Cost: ${cost_outsource:.2f}")
        print(f"Minimum Total Daily Cost: ${float(obj_val_print):.2f}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m37.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 37: Berth Size Optimization (IP) ---
Optimization Status: Optimal
Optimal Number of Berths: 22 (Max: 50)
  Own Berth Capacity: 242 ships
Number of Outsourced Ships: 0
Total Ships Berthed: 242 (Demand: 234)

Costs:
  Own Berth Cost: $2486.00
  Outsourcing Cost: $0.00
Minimum Total Daily Cost: $2486.00


```

================================================================================



--- Problem 325 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy port, Terminal A has an unexpected surplus of 80 containers, while Terminals B and C face deficits of 14 and 20 containers, respectively. To rebalance the network, a fleet of 4 trucks is available, each capable of carrying up to 18 containers per trip. However, failing to meet demand comes at a cost: every unmet container at Terminals B or C incurs a penalty of $8, reflecting lost revenue and customer dissatisfaction. The logistics team must decide how many trucks to dispatch to each terminal and how many containers to transport, ensuring the total penalty from unmet demand is minimized. The challenge lies in allocating limited truck resources efficiently—balancing capacity constraints, supply limits, and the urgency of demand—while avoiding unnecessary penalties. The core question is: *What is the optimal redistribution plan that minimizes the total penalty from unmet demand at Terminals B and C?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `n_B`: Integer number of trucks sent to Terminal B (0 ≤ `n_B` ≤ 4).  
   - `n_C`: Integer number of trucks sent to Terminal C (0 ≤ `n_C` ≤ 4).  
   - `x_AB`: Integer number of containers transported from A to B (≥ 0).  
   - `x_AC`: Integer number of containers transported from A to C (≥ 0).  
   - `shortfall_B`: Continuous unmet demand at B (≥ 0).  
   - `shortfall_C`: Continuous unmet demand at C (≥ 0).  

   **2. Parameters:**  
   - Surplus at A: 80 containers.  
   - Deficits: B = 14, C = 20 containers.  
   - Truck capacity: 18 containers/truck.  
   - Penalty rate: $8 per unmet container.  

   **3. Objective Function:**  
   Minimize total penalty:  
   `Minimize: 8 * shortfall_B + 8 * shortfall_C`.  

   **4. Constraints:**  
   - **Truck limit:** `n_B + n_C ≤ 4`.  
   - **Capacity constraints:**  
     `x_AB ≤ 18 * n_B`,  
     `x_AC ≤ 18 * n_C`.  
   - **Supply limit:** `x_AB + x_AC ≤ 80`.  
   - **Shortfall definition:**  
     `shortfall_B ≥ 14 - x_AB`,  
     `shortfall_C ≥ 20 - x_AC`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
surplus_A = 80
deficit_B = 14
deficit_C = 20
truck_capacity = 18
num_trucks = 4
shortfall_penalty = 8 # Penalty per unit of unmet demand
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("CONTAINER_REDISTRIBUTION_SHORTFALL", env=env)

    # --- Decision Variables ---
    # n_B, n_C: number of trucks
    n_B = m.addVar(vtype=GRB.INTEGER, lb=0, ub=num_trucks, name="n_B")
    n_C = m.addVar(vtype=GRB.INTEGER, lb=0, ub=num_trucks, name="n_C")
    # x_AB, x_AC: number of containers transported
    x_AB = m.addVar(vtype=GRB.INTEGER, lb=0, name="x_AB")
    x_AC = m.addVar(vtype=GRB.INTEGER, lb=0, name="x_AC")
    # shortfall_B, shortfall_C: unmet demand
    shortfall_B = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="shortfall_B")
    shortfall_C = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="shortfall_C")

    # --- Objective Function: Minimize total shortfall (weighted by penalty) ---
    m.setObjective(shortfall_penalty * shortfall_B + shortfall_penalty * shortfall_C, GRB.MINIMIZE)

    # --- Constraints ---
    # Total number of trucks used
    m.addConstr(n_B + n_C <= num_trucks, "TotalTrucks")

    # Transported amount cannot exceed truck capacity
    if truck_capacity > 0:
        m.addConstr(x_AB <= truck_capacity * n_B, "CapacityB")
        m.addConstr(x_AC <= truck_capacity * n_C, "CapacityC")
    else:
        m.addConstr(x_AB == 0, "CapacityB_Zero")
        m.addConstr(x_AC == 0, "CapacityC_Zero")

    # Transported amount cannot exceed surplus at A
    m.addConstr(x_AB + x_AC <= surplus_A, "SupplyA")

    # Shortfall calculation: Shortfall >= Deficit - Transported
    m.addConstr(shortfall_B >= deficit_B - x_AB, "ShortfallCalcB")
    m.addConstr(shortfall_C >= deficit_C - x_AC, "ShortfallCalcC")
    # lb=0 on shortfall variables handles the max(0, ...) part

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['shortfall_B_sol'] = shortfall_B.X # Not needed
        # results_dict['shortfall_C_sol'] = shortfall_C.X # Not needed

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is total penalty, can be float if shortfalls are continuous
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
         print("Model is infeasible") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print all key outputs
if m.Status == GRB.OPTIMAL:
    obj_val_print = results_dict.get('obj_val', 'N/A')
    if isinstance(obj_val_print, (int, float)):
        print(f"Optimal objective value: {obj_val_print:.2f}")
    else:
        print(f"Optimal objective value: {obj_val_print}")

    # Print the number of trucks sent to each terminal
    print(f"Number of trucks to Terminal B: {n_B.X}")
    print(f"Number of trucks to Terminal C: {n_C.X}")

    # Print the number of containers transported from A to B and A to C
    print(f"Containers transported from A to B: {x_AB.X}")
    print(f"Containers transported from A to C: {x_AC.X}")

    # Print the shortfalls at Terminals B and C
    print(f"Shortfall at Terminal B: {shortfall_B.X}")
    print(f"Shortfall at Terminal C: {shortfall_C.X}")
```
Answer:
Optimal objective value: 0.00
Optimal objective value: 0.00
Number of trucks to Terminal B: 2.0
Number of trucks to Terminal C: 2.0
Containers transported from A to B: 14.0
Containers transported from A to C: 20.0
Shortfall at Terminal B: 0.0
Shortfall at Terminal C: 0.0


```

================================================================================



--- Problem 326 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
At a busy urban intersection disrupted by an accident, traffic engineers face the critical task of managing limited green time between northbound and southbound lanes to maximize vehicle throughput. The traffic signal operates on a fixed cycle length of 120 seconds, with 20 seconds lost to transitions and delays, leaving only 100 seconds of effective green time to allocate. The northbound approach has a demand of 850 vehicles per hour, while the southbound approach sees 750 vehicles per hour. Each lane can process up to 1,100 vehicles per hour under ideal conditions. The challenge is to distribute the green time between the two directions such that the total throughput is maximized while ensuring flow proportionality—vehicles from each direction are served in proportion to their demand. The core question is: *How should the 100 seconds of effective green time be split between northbound and southbound lanes to achieve the highest possible total throughput while maintaining fair, demand-proportional flow?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `g_n`: Green time allocated to the northbound lane (in seconds), a non-negative continuous variable.  
     - `g_s`: Green time allocated to the southbound lane (in seconds), a non-negative continuous variable.  
     - `t_n`: Throughput (flow rate) of the northbound lane (in vehicles per hour), a non-negative continuous variable.  
     - `t_s`: Throughput (flow rate) of the southbound lane (in vehicles per hour), a non-negative continuous variable.  

   - **2. Parameters:**  
     - Cycle length = 120 seconds, lost time = 20 seconds → Effective green time = 100 seconds.  
     - Lane capacity = 1,100 vehicles per hour.  
     - Northbound demand = 850 vehicles per hour, southbound demand = 750 vehicles per hour.  
     - Capacity factor = 1,100 / 3,600 ≈ 0.3056 vehicles per second (converted for constraint scaling).  

   - **3. Objective Function:**  
     Maximize total throughput: `t_n + t_s`.  

   - **4. Constraints:**  
     - Total green time: `g_n + g_s = 100`.  
     - Northbound throughput cannot exceed capacity: `t_n ≤ 0.3056 * g_n`.  
     - Southbound throughput cannot exceed capacity: `t_s ≤ 0.3056 * g_s`.  
     - Demand limits: `t_n ≤ 850`, `t_s ≤ 750`.  
     - Proportional flow (if demand > 0): `t_n * 750 = t_s * 850`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
cycle_length_sec = 120; lost_time_sec = 20; lane_capacity_veh_per_hr = 1100
demand_n_veh_per_hr = 850; demand_s_veh_per_hr = 750
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    effective_green_total = cycle_length_sec - lost_time_sec
    if effective_green_total < 1e-6: raise ValueError("Effective green time is non-positive")
    capacity_factor = lane_capacity_veh_per_hr / cycle_length_sec if cycle_length_sec > 1e-6 else 0
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m13 = gp.Model("Accident_Scene_Flow_LP", env=env)
    # Vars
    g_n = m13.addVar(name="green_north", lb=0); g_s = m13.addVar(name="green_south", lb=0)
    t_n = m13.addVar(name="throughput_north", lb=0); t_s = m13.addVar(name="throughput_south", lb=0)
    # Objective
    m13.setObjective(t_n + t_s, sense=GRB.MAXIMIZE)
    # Constraints
    m13.addConstr(g_n + g_s == effective_green_total, "total_green_time")
    m13.addConstr(t_n <= capacity_factor * g_n, "north_capacity_limit")
    m13.addConstr(t_s <= capacity_factor * g_s, "south_capacity_limit")
    m13.addConstr(t_n <= demand_n_veh_per_hr, "north_demand_limit")
    m13.addConstr(t_s <= demand_s_veh_per_hr, "south_demand_limit")
    # Proportional flow constraint (handle division by zero)
    if demand_n_veh_per_hr > 1e-6 and demand_s_veh_per_hr > 1e-6:
         m13.addConstr(t_n * demand_s_veh_per_hr == t_s * demand_n_veh_per_hr, "proportional_flow")
    elif demand_n_veh_per_hr <= 1e-6: m13.addConstr(t_n == 0, "zero_demand_n") # Force zero throughput if zero demand
    elif demand_s_veh_per_hr <= 1e-6: m13.addConstr(t_s == 0, "zero_demand_s") # Force zero throughput if zero demand
    # Optimize
    m13.optimize()
    # Store results
    results_dict['status'] = m13.status
    if m13.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m13.objVal; results_dict['g_n_opt'] = g_n.X; results_dict['g_s_opt'] = g_s.X
        results_dict['t_n_opt'] = t_n.X; results_dict['t_s_opt'] = t_s.X
    # Output Results
    print("--- Problem 13: Accident Scene Lane Management (LP) ---")
    if m13.status == GRB.OPTIMAL:
        gn = results_dict.get('g_n_opt',0); gs = results_dict.get('g_s_opt',0)
        tn = results_dict.get('t_n_opt',0); ts = results_dict.get('t_s_opt',0)
        print(f"Optimization Status: Optimal")
        print(f"Optimal Northbound Green Time (g_n): {gn:.1f} sec"); print(f"Optimal Southbound Green Time (g_s): {gs:.1f} sec")
        print(f"Total Effective Green: {gn + gs:.1f} / {effective_green_total} sec")
        print(f"Maximized Northbound Throughput (t_n): {tn:.1f} veh/hr (Demand: {demand_n_veh_per_hr})")
        print(f"Maximized Southbound Throughput (t_s): {ts:.1f} veh/hr (Demand: {demand_s_veh_per_hr})")
        print(f"Total Maximized Throughput: {m13.objVal:.1f} veh/hr")
        prop_n = tn / demand_n_veh_per_hr if demand_n_veh_per_hr > 1e-6 else 0
        prop_s = ts / demand_s_veh_per_hr if demand_s_veh_per_hr > 1e-6 else 0
        if abs(prop_n - prop_s) < 1e-4: print(f"Flow is proportional to demand.")
        else: print(f"Flow proportionality check: N={prop_n:.3f}, S={prop_s:.3f}")
    elif m13.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    else: print(f"Optimization Status: {m13.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of ACCIDENT_FLOW
```
Answer:
--- Problem 13: Accident Scene Lane Management (LP) ---
Optimization Status: Optimal
Optimal Northbound Green Time (g_n): 53.1 sec
Optimal Southbound Green Time (g_s): 46.9 sec
Total Effective Green: 100.0 / 100 sec
Maximized Northbound Throughput (t_n): 487.0 veh/hr (Demand: 850)
Maximized Southbound Throughput (t_s): 429.7 veh/hr (Demand: 750)
Total Maximized Throughput: 916.7 veh/hr
Flow is proportional to demand.



================================================================================



--- Problem 327 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling six incoming trucks across three available depots, each with specific capabilities. The trucks arrive at staggered times: Truck 1 at 3 hours, Truck 2 at 4, Truck 3 at 8, Truck 4 at 13, Truck 5 at 18, and Truck 6 at 19. Each truck has a unique processing time, ranging from 3 to 7 hours, and belongs to one of two types: 'A' (Trucks 4 and 5) or 'D' (Trucks 1, 2, 3, and 6). The depots are specialized: Depot 1 handles only type 'A', Depot 2 only type 'D', and Depot 3 only type 'A'. The hub manager must assign each truck to a compatible depot while ensuring no two trucks scheduled at the same depot overlap in time. The goal is to minimize the total waiting time—the difference between each truck's start time and its arrival—so that vehicles spend as little time idle as possible before being processed. The core question is: *How can the hub assign trucks to depots to achieve the smallest possible cumulative waiting time, respecting compatibility and scheduling constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to depot *j*, 0 otherwise).  
   - `start_time(i)`: Continuous variable representing the time truck *i* begins processing.  
   - `completion_time(i)`: Continuous variable (start_time(i) + processing_time(i)).  
   - `precedes(i, k, j)`: Binary variable (1 if truck *i* is scheduled before truck *k* at depot *j*, 0 otherwise).  

   **2. Parameters:**  
   - `trucks`: [1, 2, 3, 4, 5, 6].  
   - `depots`: [1, 2, 3].  
   - `arrival_times`: {1:3, 2:4, 3:8, 4:13, 5:18, 6:19}.  
   - `processing_times`: {1:6, 2:6, 3:7, 4:3, 5:7, 6:4}.  
   - `truck_types`: {1:'D', 2:'D', 3:'D', 4:'A', 5:'A', 6:'D'}.  
   - `depot_capabilities`: {1:['A'], 2:['D'], 3:['A']}.  
   - `H`: 100 (large constant for logical constraints).  

   **3. Objective Function:**  
   Minimize the total waiting time:  
   `Minimize: sum(start_time(i) - arrival_times(i) for all trucks i)`.  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot:  
     `sum(assign(i, j) for all j) = 1` for each truck *i*.  
   - **Arrival Time:** Trucks cannot start before arrival:  
     `start_time(i) >= arrival_times(i)` for each *i*.  
   - **Completion Time:** `completion_time(i) = start_time(i) + processing_times(i)`.  
   - **Non-Overlapping:** For each depot *j*, if trucks *i* and *k* are assigned to *j*, one must precede the other:  
     If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
     If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.  
   - **Compatibility:** Trucks can only be assigned to compatible depots:  
     `assign(i, j) = 0` if `truck_types(i)` is not in `depot_capabilities(j)`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
depots = [1, 2, 3]
arrival_times = {1: 3, 2: 4, 3: 8, 4: 13, 5: 18, 6: 19}
processing_times = {1: 6, 2: 6, 3: 7, 4: 3, 5: 7, 6: 4}
truck_types = {1: 'D', 2: 'D', 3: 'D', 4: 'A', 5: 'A', 6: 'D'} # Dict {truck_id: type_str}
depot_capabilities = {1: ['A'], 2: ['D'], 3: ['A']} # Dict {depot_id: [list_of_types]}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_5_COMPATIBILITY")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Compatibility Constraint
    for i in trucks:
        truck_type = truck_types.get(i)
        if truck_type:
             for j in depots:
                 allowed_types = depot_capabilities.get(j, [])
                 if truck_type not in allowed_types:
                     m.addConstr(assign[i, j] == 0, name=f"compatibility_{i}_{j}")
        else: print(f"Warning: Truck type unknown for {i}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.2f}, Completion Time: {completion_time[i].x:.2f}")
    print(f"Total Waiting Time: {obj_val_print:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
34.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 2
Start Time: 3.00, Completion Time: 9.00
Truck 2 is assigned to Depot 2
Start Time: 23.00, Completion Time: 29.00
Truck 3 is assigned to Depot 2
Start Time: 9.00, Completion Time: 16.00
Truck 4 is assigned to Depot 3
Start Time: 16.00, Completion Time: 19.00
Truck 5 is assigned to Depot 3
Start Time: 29.00, Completion Time: 36.00
Truck 6 is assigned to Depot 2
Start Time: 19.00, Completion Time: 23.00
Total Waiting Time: 34.0000


```

================================================================================



--- Problem 328 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy port, a logistics manager is tasked with efficiently assigning 15 high-value containers to 10 available berths, each with distinct capacities and costs. The containers, weighing between 1 and 98 units, must be carefully assigned to berths to minimize the total cost while respecting each berth's weight limit. The berths vary not only in capacity (ranging from 3 to 100 units) but also in cost (from $3 to $100), making the selection process a delicate balance between space utilization and expense.

The manager’s goal is to ensure every container is placed in exactly one berth without exceeding the berth’s capacity, while also minimizing the total cost of the berths used. This requires strategic decisions: Should a cheaper berth with limited space be chosen, even if it means using more berths overall? Or is it better to opt for a higher-capacity, costlier berth to consolidate containers? The core question is: **What is the most cost-effective way to assign all containers while adhering to the berth constraints?**
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether container `i` is assigned to berth `j` (1 if assigned, 0 otherwise).  
   - `y[j]`: Binary variable indicating whether berth `j` is used (1 if used, 0 otherwise).  

   **2. Parameters:**  
   - `containers[i]`: Weight of container `i` (values: [30, 65, 20, 10, 98, 95, 5, 1, 27, 32, 25, 57, 71, 66, 80]).  
   - `berths[j]`: Tuple `(capacity, cost)` for berth `j` (e.g., (98, 32) for berth 0).  

   **3. Objective Function:**  
   Minimize the total cost of used berths:  
   `Minimize: sum(y[j] * berths[j][1] for all j)`  

   **4. Constraints:**  
   - **Container Assignment:** Each container must be placed in exactly one berth:  
     `sum(x[i, j] for all j) = 1` for every container `i`.  
   - **Berth Capacity:** The total weight of containers in a berth cannot exceed its capacity:  
     `sum(containers[i] * x[i, j] for all i) <= berths[j][0] * y[j]` for every berth `j`.  
   - **Linking Constraint:** A container can only be assigned to a berth if the berth is used:  
     `x[i, j] <= y[j]` for every container `i` and berth `j`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys # Make sys available inside exec if needed, e.g. for print traceback
import traceback

# --- Data Definition (Embedded) ---
containers = [30, 65, 20, 10, 98, 95, 5, 1, 27, 32, 25, 57, 71, 66, 80]      # Container weights
berths = [(98, 32), (98, 24), (99, 92), (100, 3), (99, 77), (98, 44), (99, 100), (98, 56), (98, 93), (99, 22)]        # List of (Capacity, Cost) tuples
num_containers = 15       # len(containers)
num_berths = 10         # len(berths)
# --- End Data Definition ---

# Time limit (passed from outer scope via globals if needed, or hardcoded)
GUROBI_TIME_LIMIT = 60

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Keep output clean for saving
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Cost-Sensitive BPP", env=env)

    # --- Decision Variables ---
    x = model.addVars(num_containers, num_berths, vtype=GRB.BINARY, name="x")
    y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")

    # --- Objective: Minimize total cost ---
    model.setObjective(gp.quicksum(y[j] * berths[j][1] for j in range(num_berths)), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Each container assignment
    for i in range(num_containers):
        model.addConstr(x.sum(i, '*') == 1, name=f"Container_{i}_Assignment")

    # 2. Berth capacity
    for j in range(num_berths):
        berth_capacity = berths[j][0]
        if berth_capacity < 0: berth_capacity = 0
        model.addConstr(gp.quicksum(containers[i] * x[i, j] for i in range(num_containers)) <= berth_capacity * y[j], name=f"Berth_{j}_Capacity")

    # 3. Linking container to berth usage
    for i in range(num_containers):
        for j in range(num_berths):
            model.addConstr(x[i, j] <= y[j], name=f"Container_{i}_Triggers_Berth_{j}")

    # --- Solve ---
    # print("Solving CS-BPP instance...") # Comment out or keep for debug inside output
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal

    # --- Output results (This will be captured) ---
    # This logic needs to be *inside* the template now
    if model.status == GRB.OPTIMAL:
        print(f"Minimum cost: ${model.objVal:.2f}") # Use model.objVal directly
        print("-" * 30) # Add separator for clarity
        printed_berth_count = 0
        for j in range(num_berths):
            # Use try-except for safety when accessing .X
            try:
                 if y[j].x > 0.5:
                     printed_berth_count += 1
                     berth_capacity_out, berth_cost_out = berths[j]
                     assigned_containers = [i for i in range(num_containers) if x[i, j].x > 0.5]
                     berth_load_out = sum(containers[i] for i in assigned_containers)
                     # Format output exactly as desired for the log file
                     print(f"Berth {printed_berth_count} (Type Index {j}, Capacity: {berth_capacity_out}, Cost: ${berth_cost_out:.2f}):")
                     print(f"  Load: {berth_load_out} / {berth_capacity_out}")
                     print(f"  Containers (indices): {sorted(assigned_containers)}") # Sort for consistency
                     print("-" * 10) # Separator between berths
            except AttributeError:
                 pass # Ignore berths not used or if .X attribute missing
    elif model.status == GRB.TIME_LIMIT:
        print("\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: ${model.ObjVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {model.status}")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}") # Print errors to captured output
    results_dict['status'] = -1 # Use dict to signal error type to main loop
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:") # Print errors
    traceback.print_exc(file=sys.stdout) # Print traceback to captured stdout
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Minimum cost: $258.00
------------------------------
Berth 1 (Type Index 0, Capacity: 98, Cost: $32.00):
  Load: 96 / 98
  Containers (indices): [10, 12]
----------
Berth 2 (Type Index 1, Capacity: 98, Cost: $24.00):
  Load: 95 / 98
  Containers (indices): [5]
----------
Berth 3 (Type Index 3, Capacity: 100, Cost: $3.00):
  Load: 100 / 100
  Containers (indices): [2, 14]
----------
Berth 4 (Type Index 4, Capacity: 99, Cost: $77.00):
  Load: 98 / 99
  Containers (indices): [4]
----------
Berth 5 (Type Index 5, Capacity: 98, Cost: $44.00):
  Load: 98 / 98
  Containers (indices): [1, 7, 9]
----------
Berth 6 (Type Index 7, Capacity: 98, Cost: $56.00):
  Load: 97 / 98
  Containers (indices): [0, 3, 11]
----------
Berth 7 (Type Index 9, Capacity: 99, Cost: $22.00):
  Load: 98 / 99
  Containers (indices): [6, 8, 13]
----------


```

================================================================================



--- Problem 329 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port manager is tasked with optimizing the allocation of berths for two types of vessels: container ships and cruise ships. The port has a total of 497 berth spots, operational for 14.3 hours daily, providing a total of 7,107.1 berth-hours available. Container ships, which pay $56 per booking, occupy a berth for an average of 4.8 hours. The demand for container ship bookings fluctuates, with a minimum requirement of 8 bookings (to ensure baseline revenue) and a maximum potential demand of 69. Meanwhile, cruise ships pay $11.20 per hour and stay for 2.8 hours on average, with a maximum demand of 212 ships. The manager must strategically allocate berths between these two types of vessels to maximize total revenue without exceeding the port’s physical or time-based constraints. The core question is: *How many container ship bookings and cruise ship bookings should the port accept to achieve the highest possible daily revenue while adhering to all operational limits?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x_container`: Integer number of container ship bookings to accept (≥0).  
     - `x_cruise`: Integer number of cruise ship bookings to accept (≥0).  

   - **2. Parameters:**  
     - `total_spots = 497`: Total physical berth spots.  
     - `total_berth_hours = 7107.1`: Maximum berth-hours available daily.  
     - `container_price = 56`, `cruise_revenue_per_hour = 11.20`: Revenue per vessel type.  
     - `container_stay = 4.8`, `cruise_stay = 2.8`: Hours occupied per vessel type.  
     - `container_max_demand = 69`, `container_min_required = 8`: Container ship booking bounds.  
     - `cruise_max_demand = 212`: Cruise ship upper limit.  

   - **3. Objective Function:**  
     Maximize total revenue:  
     `Maximize: (56 * x_container) + (11.20 * x_cruise)`.  

   - **4. Constraints:**  
     - Berth-hour capacity: `4.8 * x_container + 2.8 * x_cruise ≤ 7107.1`.  
     - Container ship demand bounds: `8 ≤ x_container ≤ 69`.  
     - Cruise ship demand bound: `x_cruise ≤ 212`.  
     - Physical spot limit (container): `x_container ≤ 497` (redundant due to berth-hour constraint).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_spots = 497
op_hours = 14.3
total_berth_hours = 7107.1
container_price = 56
container_stay = 4.8
container_max_demand = 69
container_min_required = 8
cruise_rate = 4
cruise_stay = 2.8
cruise_revenue_per_hour = 11.20
cruise_max_demand = 212
# --- End Parameters ---

GUROBI_TIME_LIMIT = 45

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m27 = gp.Model("PORT_REVENUE_MGT_MIP", env=env)

    # --- Decision Variables ---
    # Integer: Number of container ship bookings and cruise ship bookings accepted
    x_container = m27.addVar(vtype=GRB.INTEGER, name="num_container_bookings", lb=0)
    x_cruise = m27.addVar(vtype=GRB.INTEGER, name="num_cruise_bookings", lb=0)

    # --- Objective Function ---
    # Maximize total daily revenue
    m27.setObjective(container_price * x_container + cruise_revenue_per_hour * x_cruise, sense=GRB.MAXIMIZE)

    # --- Constraints ---
    # Constraint 1: Total berth-hour usage capacity
    m27.addConstr(x_container * container_stay + x_cruise * cruise_stay <= total_berth_hours, name="berth_hour_capacity")

    # Constraint 2: Container ship demand upper bound
    m27.addConstr(x_container <= container_max_demand, name="container_demand_max")

    # Constraint 3: Container ship minimum requirement
    m27.addConstr(x_container >= container_min_required, name="container_demand_min")

    # Constraint 4: Cruise ship demand upper bound
    m27.addConstr(x_cruise <= cruise_max_demand, name="cruise_demand_max")

    # Constraint 5: Physical spot limit (optional, but good check)
    m27.addConstr(x_container <= total_spots, name="container_spot_limit")
    # Physical limit for cruise is trickier, rely on berth hours

    # --- Optimization ---
    m27.optimize()

    # --- Store results ---
    results_dict['status'] = m27.status
    if m27.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m27.ObjVal
        results_dict['x_container_sol'] = x_container.X
        results_dict['x_cruise_sol'] = x_cruise.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- PORT_REVENUE_MGT: Port Revenue Management (MIP) ---")
    if m27.status == GRB.OPTIMAL:
        opt_container = int(round(results_dict.get('x_container_sol', 0))) # Round and convert to int
        opt_cruise = int(round(results_dict.get('x_cruise_sol', 0)))
        berth_hours_used = opt_container * container_stay + opt_cruise * cruise_stay
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Maximum Total Daily Revenue: ${obj_val_print:.2f}")
        print(f"Optimal number of Container Ship Bookings: {opt_container} (Demand: {container_min_required}-{container_max_demand})")
        print(f"Optimal number of Cruise Ship Bookings: {opt_cruise} (Demand: {cruise_max_demand})")
        print(f"Total Berth-Hours Used: {berth_hours_used:.1f} / {total_berth_hours:.1f}")
        # Calculate breakdown based on optimal integer values
        revenue_container = opt_container * container_price
        revenue_cruise = opt_cruise * cruise_revenue_per_hour
        print(f"Revenue Breakdown: Container=${revenue_container:.2f}, Cruise=${revenue_cruise:.2f}")

    elif m27.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible.")
         print(f"Check constraints: Min Container Required ({container_min_required}) vs Max Demand ({container_max_demand}), Berth Hours ({total_berth_hours:.1f}), Spots ({total_spots}).")
         print(f"Min container requires {container_min_required * container_stay:.1f} berth-hours.")

    elif m27.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         # Try to get objective if available (MIPs might have feasible before timeout)
         if m27.ObjVal is not None and abs(m27.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m27.ObjVal:.2f} (Solution may be suboptimal or non-integer)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m27.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- PORT_REVENUE_MGT: Port Revenue Management (MIP) ---
Optimization Status: Optimal
Maximum Total Daily Revenue: $6238.40
Optimal number of Container Ship Bookings: 69 (Demand: 8-69)
Optimal number of Cruise Ship Bookings: 212 (Demand: 212)
Total Berth-Hours Used: 924.8 / 7107.1
Revenue Breakdown: Container=$3864.00, Cruise=$2374.40


```

================================================================================



--- Problem 330 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
At a busy maritime port, the port authority is tasked with efficiently managing ship berthing to minimize delays while ensuring smooth operations. The port has two types of berths: **4 container berths**, each capable of processing **20 containers per hour**, and **4 general cargo berths**, each handling **61 general cargo units per hour**. On a typical day, **27 container ships** and **216 general cargo ships** arrive, demanding prompt processing to avoid congestion. The goal is to determine the **minimum number of berths to open** while meeting the hourly demand for both container and general cargo ships.  

The core question is: *How can the port operate at peak efficiency by opening the fewest berths possible without exceeding the capacity constraints for container and general cargo ships?* The solution must balance resource utilization—ensuring container berths (which can also process general cargo) are used optimally—while avoiding unnecessary berth openings that increase operational costs.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `open_container[i]`: Binary variable (0 or 1) indicating whether container berth *i* is opened (1) or closed (0).  
   - `open_general[j]`: Binary variable (0 or 1) indicating whether general cargo berth *j* is opened (1) or closed (0).  

   **2. Parameters:**  
   - `num_container_berths = 4`: Total available container berths.  
   - `num_general_berths = 4`: Total available general cargo berths.  
   - `container_service_rate = 20`: Containers processed per hour per open container berth.  
   - `general_service_rate = 61`: General cargo units processed per hour per open berth (container or general cargo).  
   - `arrival_containers = 27`: Total container ships arriving per hour.  
   - `arrival_general = 216`: Total general cargo ships arriving per hour.  

   **3. Objective Function:**  
   Minimize the total number of open berths:  
   ```  
   Minimize: sum(open_container[i] for all i) + sum(open_general[j] for all j)  
   ```  

   **4. Constraints:**  
   - **Container capacity:** Total container processing capacity must meet demand:  
     ```  
     sum(open_container[i] * container_service_rate for all i) >= arrival_containers  
     ```  
   - **General cargo capacity:** Total general cargo processing capacity (from container berths + general cargo berths) must meet demand:  
     ```  
     sum(open_container[i] * general_service_rate for all i) + sum(open_general[j] * general_service_rate for all j) >= arrival_general  
     ```  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
num_container_berths = 4; num_general_berths = 4
container_service_rate = 20; general_service_rate = 61
arrival_general = 216; arrival_containers = 27
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m8 = gp.Model("Port_Berthing_MIP", env=env)
    # Vars
    open_container = m8.addVars(num_container_berths, vtype=GRB.BINARY, name="open_container_berth")
    open_general = m8.addVars(num_general_berths, vtype=GRB.BINARY, name="open_general_berth")
    # Objective
    m8.setObjective(gp.quicksum(open_container) + gp.quicksum(open_general), sense=GRB.MINIMIZE)
    # Constraints
    m8.addConstr(gp.quicksum(open_container[i] * container_service_rate for i in range(num_container_berths)) >= arrival_containers, "container_capacity")
    m8.addConstr(gp.quicksum(open_container[i] * general_service_rate for i in range(num_container_berths)) + gp.quicksum(open_general[j] * general_service_rate for j in range(num_general_berths)) >= arrival_general, "general_capacity")
    # Optimize
    m8.optimize()
    # Store results
    results_dict['status'] = m8.status
    if m8.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m8.objVal
        results_dict['open_container_opt'] = [open_container[i].X for i in range(num_container_berths)]
        results_dict['open_general_opt'] = [open_general[j].X for j in range(num_general_berths)]
    # Output Results
    print("--- Problem 8: Port Berthing (MIP) ---")
    if m8.status == GRB.OPTIMAL:
        oc_opt = results_dict.get('open_container_opt', []); og_opt = results_dict.get('open_general_opt', [])
        num_open_container = sum(v > 0.5 for v in oc_opt); num_open_general = sum(v > 0.5 for v in og_opt)
        print(f"Optimization Status: Optimal")
        print(f"Optimal number of container berths to open: {int(num_open_container)} / {num_container_berths}")
        print(f"Optimal number of general cargo berths to open: {int(num_open_general)} / {num_general_berths}")
        print(f"Minimum total open berths: {int(m8.objVal)}")
        container_cap = sum(v * container_service_rate for v in oc_opt)
        general_cap = sum(v * general_service_rate for v in oc_opt) + sum(v * general_service_rate for v in og_opt)
        print(f"Total container capacity: {container_cap:.1f} >= {arrival_containers}")
        print(f"Total general cargo capacity: {general_cap:.1f} >= {arrival_general}")
    elif m8.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible")
    else: print(f"Optimization Status: {m8.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_BERTHING
```
Answer:
--- Problem 8: Port Berthing (MIP) ---
Optimization Status: Optimal
Optimal number of container berths to open: 4 / 4
Optimal number of general cargo berths to open: 0 / 4
Minimum total open berths: 4
Total container capacity: 80.0 >= 27
Total general cargo capacity: 244.0 >= 216



================================================================================



--- Problem 331 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port operations center faces a critical challenge: managing two simultaneous ship berthing incidents (A and B) with limited response resources. Two tugboats (T1 and T2) are available to assist these incidents, but each incident has unique characteristics. Incident A occurs at time 0 minutes, while Incident B occurs 9 minutes later. The tugboats have varying base travel times to each incident: T1 takes 29 minutes to reach A and 22 minutes to B, while T2 takes 27 minutes to A and 20 minutes to B. Once a tugboat finishes assisting one incident, it can travel to the other, with inter-incident travel times of 17 minutes (A to B) and 21 minutes (B to A).

Each incident has a fixed assistance time (46 minutes for A, 52 minutes for B) and impacts port operations differently. Under normal conditions, the port segments can handle 4258/60 and 4255/60 ships per minute (for A and B, respectively), but during incidents, these capacities drop to 2541/60 and 1914/60. Meanwhile, ships arrive at rates of 2241/60 and 2147/60 per minute for A and B, respectively. If the arrival rate exceeds the reduced capacity, queues form and grow until assistance begins. After assistance, queues may dissipate if the normal capacity exceeds the arrival rate (true for both incidents here).

The core challenge is to assign tugboats to incidents and sequence their movements to **minimize the total delay** caused by these incidents. Delays accumulate in three phases: (1) before assistance starts (queue growth), (2) during assistance (continued growth), and (3) after assistance (queue dissipation, if possible). The optimization must account for these dynamics while respecting travel times, assistance durations, and the logical sequencing of tugboat assignments.
**

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary `assign_first(k, i)`: 1 if tugboat *k* (T1 or T2) is assigned to incident *i* (A or B) as its first task.  
- Binary `sequence(k, j, i)`: 1 if tugboat *k* serves incident *i* immediately after incident *j*.  
- Continuous `start_assist(i)`, `end_assist(i)`: Time (minutes) when assistance begins/ends at incident *i*.  
- Auxiliary variables for queue calculations (e.g., `queue_at_start_assist(i)`, `dissipation_time(i)`).  

**2. Parameters:**  
- `time_occur[i]`: Incident occurrence times (A: 0, B: 9).  
- `travel_time_base[k, i]`: Tugboat *k*’s travel time to incident *i* (e.g., T1 to A: 29).  
- `travel_time_inter[j, i]`: Travel time between incidents (e.g., A to B: 17).  
- `assistance_time[i]`: Time to assist incident *i* (A: 46, B: 52).  
- `growth_rate_before[i]`: Queue growth rate before assistance (arrival rate - reduced capacity).  
- `dissipation_rate[i]`: Queue dissipation rate after assistance (normal capacity - arrival rate).  

**3. Objective Function:**  
Minimize total delay =  
- Sum over incidents of:  
  - **Delay before assistance**: `0.5 × growth_rate_before[i] × (start_assist[i] - time_occur[i])²`  
  - **Delay during assistance**: `0.5 × (queue_at_start_assist[i] + queue_at_assist_end[i]) × assistance_time[i]`  
  - **Delay after assistance**: If dissipation is possible, `0.5 × (queue_at_assist_end[i]² / dissipation_rate[i])`; else, penalize with `10000 × queue_at_assist_end[i]`.  

**4. Constraints:**  
- Each incident is assigned exactly once (first or in sequence).  
- Each tugboat starts at most one incident.  
- Sequencing logic: If a tugboat serves *i* after *j*, it must have served *j* earlier.  
- Start/end times respect travel and assistance durations.  
- Queue dynamics: Calculate queue sizes at assistance start/end and dissipation times.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
incidents = ['A', 'B']
tugboats = ['T1', 'T2']

# Times in minutes from simulation start
time_occur = {'A': 0, 'B': 9}
travel_time_base = {('T1', 'A'): 29, ('T1', 'B'): 22, ('T2', 'A'): 27, ('T2', 'B'): 20}
travel_time_inter = {('A', 'B'): 17, ('B', 'A'): 21, ('A', 'A'): 0, ('B', 'B'): 0}
assistance_time = {'A': 46, 'B': 52}

# Capacities and Arrival rates (ships per minute)
cap_normal = {'A': 4258/60, 'B': 4255/60} # ships/min
cap_reduced = {'A': 2541/60, 'B': 1914/60} # ships/min
arrival_rate = {'A': 2241/60, 'B': 2147/60} # ships/min

M = 10000
EPSILON = 1e-6

# Pre-calculate rates
growth_rate_before = {}
dissipation_rate = {}
can_dissipate = {}
inv_dissipation_rate = {}
non_dissipating_penalty = 10000

for i in incidents:
    growth_rate_before[i] = max(0, arrival_rate[i] - cap_reduced[i])
    dissipation_rate[i] = cap_normal[i] - arrival_rate[i]
    can_dissipate[i] = dissipation_rate[i] > EPSILON
    if not can_dissipate[i]:
        inv_dissipation_rate[i] = 0
    else:
        inv_dissipation_rate[i] = 1.0 / dissipation_rate[i]

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("IncidentResourceAllocation", env=env)

# --- Decision Variables ---
assign_first = m.addVars(tugboats, incidents, vtype=GRB.BINARY, name="assign_first")
sequence = m.addVars(tugboats, incidents, incidents, vtype=GRB.BINARY, name="sequence")

# Timing variables
start_assist = m.addVars(incidents, name="start_assist", lb=0.0)
end_assist = m.addVars(incidents, name="end_assist", lb=0.0)

# Queue and Delay related variables
queue_start_assist_time_diff = m.addVars(incidents, name="queue_start_assist_time_diff", lb=0.0)
queue_at_start_assist = m.addVars(incidents, name="queue_at_start_assist", lb=0.0)
aux_q_start = m.addVars(incidents, name="aux_q_start", lb=-GRB.INFINITY)
queue_at_assist_end = m.addVars(incidents, name="queue_at_assist_end", lb=0.0)
aux_q_end = m.addVars(incidents, name="aux_q_end", lb=-GRB.INFINITY)
dissipation_time = m.addVars(incidents, name="dissipation_time", lb=0.0)

# --- Constraints ---
for i in incidents:
    m.addConstr(gp.quicksum(assign_first[k, i] for k in tugboats) +
                gp.quicksum(sequence[k, j, i] for k in tugboats for j in incidents if i != j) == 1,
                name="AssignIncident_{0}".format(i))

for k in tugboats:
    m.addConstr(gp.quicksum(assign_first[k, i] for i in incidents) <= 1, name="TugboatStart_{0}".format(k))

for k in tugboats:
    for i in incidents:
        tugboat_served_i = assign_first[k, i] + gp.quicksum(sequence[k, l, i] for l in incidents if l != i)
        m.addConstr(gp.quicksum(sequence[k, i, j] for j in incidents if i != j) <= tugboat_served_i,
                    name="SequenceLogic_{0}_{1}".format(k, i))
        m.addConstr(sequence[k,i,i] == 0, name="NoSelfLoop_{0}_{1}".format(k, i))
        for j in incidents:
             if i != j:
                  m.addConstr(sequence[k,i,j] + sequence[k,j,i] <= 1, name="NoImmediateLoop_{0}_{1}_{2}".format(k, i, j))

for k in tugboats:
    for i in incidents:
        m.addConstr(start_assist[i] >= time_occur[i] + travel_time_base[k, i] - M * (1 - assign_first[k, i]),
                    name="StartTimeFirst_{0}_{1}".format(k, i))
        for j in incidents:
            if i != j:
                m.addConstr(start_assist[i] >= end_assist[j] + travel_time_inter[j, i] - M * (1 - sequence[k, j, i]),
                            name="StartTimeFollow_{0}_{1}_{2}".format(k, j, i))

for i in incidents:
    m.addConstr(end_assist[i] == start_assist[i] + assistance_time[i], name="EndAssistTime_{0}".format(i))
    m.addConstr(start_assist[i] >= time_occur[i], name="StartAfterOccur_{0}".format(i))

for i in incidents:
    m.addConstr(queue_start_assist_time_diff[i] >= start_assist[i] - time_occur[i], name="CalcTimeDiff_{0}".format(i))
    m.addConstr(aux_q_start[i] == growth_rate_before[i] * queue_start_assist_time_diff[i], name="CalcAuxQStart_{0}".format(i))
    m.addGenConstrMax(queue_at_start_assist[i], [aux_q_start[i]], 0.0, name="SetQStartMax_{0}".format(i))
    queue_growth_during_assistance = growth_rate_before[i] * assistance_time[i]
    m.addConstr(aux_q_end[i] == queue_at_start_assist[i] + queue_growth_during_assistance, name="CalcAuxQEnd_{0}".format(i))
    m.addGenConstrMax(queue_at_assist_end[i], [aux_q_end[i]], 0.0, name="SetQEndMax_{0}".format(i))
    if can_dissipate[i]:
         m.addConstr(dissipation_time[i] == queue_at_assist_end[i] * inv_dissipation_rate[i], name="CalcDissipationTime_{0}".format(i))
    else:
         m.addConstr(dissipation_time[i] == 0, name="SetDissipationTimeZero_{0}".format(i))

# --- Objective Function ---
objective = gp.QuadExpr()
for i in incidents:
    delay_before = 0.5 * growth_rate_before[i] * queue_start_assist_time_diff[i] * queue_start_assist_time_diff[i]
    objective += delay_before
    delay_during = 0.5 * (queue_at_start_assist[i] + queue_at_assist_end[i]) * assistance_time[i]
    objective += delay_during
    if can_dissipate[i]:
        delay_dissipation = 0.5 * inv_dissipation_rate[i] * queue_at_assist_end[i] * queue_at_assist_end[i]
        objective += delay_dissipation
    else:
        objective += non_dissipating_penalty * queue_at_assist_end[i]

m.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("{0:.2f}".format(m.objVal))
elif m.status == GRB.INFEASIBLE:
    print("Infeasible")
elif m.status == GRB.UNBOUNDED:
    print("Unbounded")
```
Answer:
11178.16



================================================================================



--- Problem 332 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy trucking depot, four delivery trucks arrive at different times, each requiring a loading dock for unloading and processing. The depot has only one loading dock available, creating a challenging scheduling problem. Truck 1 arrives at time 2, needing 4 hours to process, and must depart by time 8 to avoid penalties. Truck 2 arrives at time 5, takes 5 hours to process, and has a deadline of time 14. Truck 3 arrives at time 9, requires 5 hours, and must leave by time 27. Lastly, Truck 4 arrives at time 12, takes 7 hours, and has a due time of 35. 

The depot manager faces a critical trade-off: minimizing both the waiting time of trucks before processing begins and the tardiness of trucks that miss their deadlines. Waiting time is penalized with a weight of 3, while tardiness carries a weight of 2. The goal is to schedule the trucks on the single loading dock in a way that balances these penalties, ensuring efficient operations while respecting deadlines as much as possible. The core question is: What is the optimal sequence for processing these trucks to minimize the total weighted cost of waiting and tardiness?
**

**Modeling Process:**
**
**1. Decision Variables:**
- `assign(i, j)`: Binary variable indicating whether truck `i` is assigned to loading dock `j`.
- `start_time(i)`: Continuous variable representing the start time of processing for truck `i`.
- `completion_time(i)`: Continuous variable representing the completion time of processing for truck `i`.
- `precedes(i, k, j)`: Binary variable indicating whether truck `i` precedes truck `k` on loading dock `j`.
- `tardiness(i)`: Continuous variable representing the tardiness of truck `i` (how much it misses its deadline).

**2. Parameters:**
- `trucks = [1, 2, 3, 4]`: List of trucks.
- `docks = [1]`: List of loading docks.
- `arrival_times = {1: 2, 2: 5, 3: 9, 4: 12}`: Arrival times for each truck.
- `processing_times = {1: 4, 2: 5, 3: 5, 4: 7}`: Processing times for each truck.
- `due_times = {1: 8, 2: 14, 3: 27, 4: 35}`: Deadlines for each truck.
- `weight_wait = 3`: Penalty weight for waiting time.
- `weight_tardy = 2`: Penalty weight for tardiness.
- `H = 100`: A large constant (Big M) for constraints.

**3. Objective Function:**
Minimize the total weighted cost of waiting time and tardiness:
\[
\text{Minimize: } 3 \times \sum_{i} (\text{start_time}(i) - \text{arrival_times}(i)) + 2 \times \sum_{i} \text{tardiness}(i)
\]

**4. Constraints:**
- **Assignment:** Each truck must be assigned to exactly one loading dock:
  \[
  \sum_{j} \text{assign}(i, j) = 1 \quad \forall i
  \]
- **Arrival Time:** Processing cannot start before a truck arrives:
  \[
  \text{start_time}(i) \geq \text{arrival_times}(i) \quad \forall i
  \]
- **Completion Time:** Completion time is the sum of start time and processing time:
  \[
  \text{completion_time}(i) = \text{start_time}(i) + \text{processing_times}(i) \quad \forall i
  \]
- **Non-overlapping:** Trucks assigned to the same loading dock cannot overlap in processing:
  \[
  \text{precedes}(i, k, j) = 1 \implies \text{start_time}(k) \geq \text{completion_time}(i) \quad \forall i < k, j
  \]
  \[
  \text{precedes}(i, k, j) = 0 \implies \text{start_time}(i) \geq \text{completion_time}(k) \quad \forall i < k, j
  \]
  \[
  \text{assign}(i, j) + \text{assign}(k, j) - 1 \leq \text{precedes}(i, k, j) + (1 - \text{precedes}(i, k, j))
  \]
- **Tardiness:** Tardiness is the amount by which completion time exceeds the deadline:
  \[
  \text{tardiness}(i) \geq \text{completion_time}(i) - \text{due_times}(i) \quad \forall i
  \]
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4]
docks = [1]
arrival_times = {1: 2, 2: 5, 3: 9, 4: 12}
processing_times = {1: 4, 2: 5, 3: 5, 4: 7}
due_times = {1: 8, 2: 14, 3: 27, 4: 35}
weight_wait = 3
weight_tardy = 2
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("LOADING_DOCK_PROBLEM")

    if not trucks or not docks: raise ValueError("Empty trucks or docks")

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes")
    tardiness = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="tardiness")

    # --- Objective Function ---
    wait_term = gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in trucks)
    tardy_term = gp.quicksum(tardiness[i] for i in trucks)
    m.setObjective(weight_wait * wait_term + weight_tardy * tardy_term, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in docks:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Tardiness definition
    m.addConstrs((tardiness[i] >= completion_time[i] - due_times.get(i, 0) for i in trucks), name="tardiness_calc")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Weighted cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Print Missing Outputs ---

if m.status == GRB.OPTIMAL:
    print("Optimal Schedule:")
    for i in trucks:
        print(f"Truck {i}: Start Time = {start_time[i].x:.2f}, Completion Time = {completion_time[i].x:.2f}, Tardiness = {tardiness[i].x:.2f}")
    print(f"Total Weighted Cost: {obj_val_print:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
21.0000
Optimal Schedule:
Truck 1: Start Time = 2.00, Completion Time = 6.00, Tardiness = 0.00
Truck 2: Start Time = 6.00, Completion Time = 11.00, Tardiness = 0.00
Truck 3: Start Time = 11.00, Completion Time = 16.00, Tardiness = 0.00
Truck 4: Start Time = 16.00, Completion Time = 23.00, Tardiness = 0.00
Total Weighted Cost: 21.0000


```

================================================================================



--- Problem 333 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port is managed by a three-phase ship berthing system, where each phase must allocate berthing time efficiently to minimize total ship waiting time. The ship arrival rates vary significantly across phases, with coefficients of 223, 2091, and 1181 ships per hour, respectively, reflecting the uneven distribution of ship demand. The port controller must adhere to strict operational rules: each phase’s berthing time must last between 30 and 91 minutes, and the sum of all berthing times must exactly match the fixed cycle time of 91 minutes. The challenge is to determine the optimal berthing time allocation for each phase such that the total waiting time—calculated as the product of ship arrival rate and non-berthing time (cycle time minus berthing time)—is minimized. This optimization directly impacts port congestion levels, fuel consumption, and shipping company satisfaction.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( t_i \) represent the berthing time (in minutes) allocated to phase \( i \), where \( i \in \{1, 2, 3\} \). Each \( t_i \) is a continuous variable bounded between 30 and 91 minutes.  
   - **2. Parameters:**  
     - \( \text{arrival_rates} = [223, 2091, 1181] \): Ship arrival rates for each phase.  
     - \( \text{cycle_time} = 91 \): Total fixed cycle time (minutes).  
     - \( \text{lb_time} = 30 \), \( \text{ub_time} = 91 \): Lower and upper bounds for berthing times.  
   - **3. Objective Function:**  
     - Minimize the total waiting time:  
       \[ \text{Minimize: } \sum_{i=1}^{3} \text{arrival_rates}[i] \times (\text{cycle_time} - t_i) \]  
   - **4. Constraints:**  
     - Total berthing time must equal the cycle time:  
       \[ t_1 + t_2 + t_3 = 91 \]  
     - Bounds on berthing times:  
       \[ 30 \leq t_i \leq 91 \quad \forall i \in \{1, 2, 3\} \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 3
lb_time = 30          # Lower bound for berthing time
ub_time = 91          # Upper bound for berthing time
cycle_time = 91   # Total cycle time (set equal to ub_time)
arrival_rates = [223, 2091, 1181] # Ship arrival rates per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_rates) != num_phases:
    print("Error: arrival_rates length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_rates length"
    # raise ValueError("arrival_rates length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for phase i is proportional to arrival_rate * non-berthing_time = arrival_rate * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_rates[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
Optimal total waiting time: 211104.00
------------------------------
Optimal berthing times (minutes):
  t1: 30.00, t2: 31.00, t3: 30.00



================================================================================



--- Problem 334 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port with three critical berths faces recurring congestion due to ship arrivals, requiring dynamic berth allocation strategies to minimize total delay. Each berth has distinct characteristics: normal and reduced handling capacities during disruptions (e.g., Berth 1 can handle 4831 TEU/h normally but drops to 3099 TEU/h during disruptions), and alternative berths with fixed capacities (1500, 1137, and 1735 TEU/h for Berths 1–3). Ship arrivals occur at fluctuating rates (e.g., Berth 3 sees arrivals ranging from 4550 to 2486 TEU/h across four 30-minute periods). Disruptions last varying durations (0.95 to 1.8 hours), and re-allocations to alternative berths incur extra handling times (0.13 to 0.30 hours per TEU). The challenge is to assign one of four re-allocation ratios (10%, 30%, 50%, or 70% of traffic) to each berth and time period, ensuring alternative flows stay within capacity and minimizing the sum of delays from queuing (on main berths) and re-allocations (on alternatives). The optimization must dynamically adapt to each berth’s disruption state and ship influx while avoiding infeasible allocations that would overwhelm either berth.
**

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable `y(i, t, k)` equals 1 if Berth `i` in Period `t` uses Re-allocation Option `k` (else 0).  
  *Indices*: `i` (berths: 0–2), `t` (periods: 0–3), `k` (options: 0–3 for 10%–70% re-allocation).  

**2. Parameters:**  
- `capacities_main_normal[i]`, `capacities_main_reduced[i]`: Main berth capacities (TEU/h).  
- `capacities_alt[i]`: Alternative berth capacities (TEU/h).  
- `arrival_rates[i][t]`: Ship inflow (TEU/h) for Berth `i`, Period `t`.  
- `TIME_PERIOD_LENGTH = 0.5h`: Duration of each period.  
- `alt_berth_extra_times[i]`: Additional handling time (h) for alternatives.  
- `berth_period_option_delays[i][t][k]`: Precomputed total delay (h·TEU) for choosing Option `k` in Berth `i`, Period `t`.  
- `LARGE_DELAY = 1e12`: Penalty for infeasible options.  

**3. Objective Function:**  
Minimize total delay:  
`Sum over i, t, k of [y(i,t,k) * berth_period_option_delays[i][t][k]]`.  

**4. Constraints:**  
- **Feasibility Selection:** For each Berth `i` and Period `t`, exactly one feasible option must be chosen:  
  `Sum over k in feasible_indices of y(i,t,k) = 1`.  
- **Infeasible Option Ban:** Forbid infeasible `k` (where alternative flow exceeds capacity):  
  `y(i,t,k) = 0` if `berth_period_option_feasible[i][t][k] = False`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 3
NUM_TIME_PERIODS = 4
TIME_PERIOD_LENGTH = 0.5  # h
capacities_main_normal = [4831, 3149, 4036]  # TEU/h
capacities_main_reduced = [3099, 1201, 2510]  # TEU/h
capacities_alt = [1500, 1137, 1735]  # TEU/h
arrival_rates = [[4102, 3722, 2292, 2829], [2394, 4603, 4986, 2051], [4550, 4910, 3384, 2486]]  # TEU/h
disruption_durations = [0.9514202852337614, 1.47733506137937, 1.8027146743561953]  # h
alt_berth_extra_times = [0.13335820738738186, 0.3010438885762488, 0.13875485605117854]  # h
re_allocation_options = [0.1, 0.3, 0.5, 0.7]  # Available re-allocation ratios
num_options = len(re_allocation_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = re_allocation_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_ReAllocationStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Re-Allocation Strategy:")
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, re_allocation_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Re-Allocation Strategy:

Berth 1:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)

Berth 2:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 1 (30%)

Berth 3:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 0 (10%)



================================================================================



--- Problem 335 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
At a busy port, the operations manager is tasked with allocating berthing times for four different types of cargo ships to minimize the total waiting time. Each type of ship has a specific arrival rate, quantified by flow coefficients of 2543, 1657, 1892, and 1466 ships per hour. The berthing cycle must adhere to strict operational limits: berthing times for each type of ship cannot fall below 10 minutes or exceed 93 minutes, and the total cycle duration is fixed at 93 minutes. Waiting times arise when ships wait during non-berthing intervals, which depend on the difference between the cycle time and the allocated berthing time. The core question is: *How should the 93-minute cycle be partitioned among the four types of ships to minimize the cumulative waiting time experienced by all ships?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `t_i`: Continuous variable representing the berthing time (in minutes) allocated to ship type `i` (where `i = 1, 2, 3, 4`). Bounded between 10 and 93.  
   - **2. Parameters:**  
     - `flow_coeffs = [2543, 1657, 1892, 1466]`: Arrival rates for each ship type.  
     - `cycle_time = 93`: Total fixed duration of the berthing cycle (minutes).  
     - `lb_time = 10`, `ub_time = 93`: Lower/upper bounds for berthing times.  
   - **3. Objective Function:**  
     - Minimize total waiting time:  
       `Minimize: sum(flow_coeffs[i] * (cycle_time - t_i) for all ship types i)`.  
   - **4. Constraints:**  
     - Total berthing times must equal the cycle: `sum(t_i for all ship types i) = 93`.  
     - Bounds: `10 ≤ t_i ≤ 93` for each ship type.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_ship_types = 4
lb_time = 10          # Lower bound for berthing time
ub_time = 93          # Upper bound for berthing time
cycle_time = 93   # Total cycle time (set equal to ub_time)
flow_coeffs = [2543, 1657, 1892, 1466] # Arrival rates per ship type
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_ship_types:
    print("Error: flow_coeffs length mismatch with num_ship_types")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_ship_types}-Type Berthing Scheduling", env=env)

        # --- Decision variables (dynamic based on num_ship_types) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_ship_types, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for ship type i is proportional to flow * non-berthing time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_ship_types)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_ship_types)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_ship_types)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_ship_types):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 492535.00
------------------------------
Optimal berthing times (minutes):
  t1: 63.00, t2: 10.00, t3: 10.00, t4: 10.00


```

================================================================================



--- Problem 336 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy maritime port, the port authority is tasked with coordinating the berthing times for three distinct types of ships to minimize total waiting time. Each type of ship (e.g., container, bulk carrier, and tanker) has different arrival rates, quantified by flow coefficients of 1441, 1200, and 2913 ships per hour, respectively. The berthing system operates under strict constraints: berthing times for each type must fall between 8 and 71 minutes, and the sum of all berthing times must exactly match the fixed cycle time of 71 minutes. The core optimization task is to allocate berthing times strategically, balancing the competing demands of high-traffic ship types while ensuring minimal waiting time across the port. The question at hand: *What combination of type-specific berthing times achieves the lowest possible total waiting time, given the ship flows and cycle constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `t_i`: Continuous variable representing the berthing time (in minutes) allocated to ship type `i` (for `i = 1, 2, 3`), with bounds `8 ≤ t_i ≤ 71`.  
   - **2. Parameters:**  
     - `flow_coeffs = [1441, 1200, 2913]`: Ship flow coefficients for each type.  
     - `cycle_time = 71`: Total cycle time (minutes).  
   - **3. Objective Function:**  
     - Minimize total waiting time:  
       `Minimize: sum(flow_coeffs[i] * (cycle_time - t_i) for all i)`  
       *(Waiting time for ship type `i` is proportional to its flow multiplied by its non-berthing time, `cycle_time - t_i`.)*  
   - **4. Constraints:**  
     - **Total cycle time:** `t_1 + t_2 + t_3 = 71`.  
     - **Bounds:** `8 ≤ t_i ≤ 71` for each type.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_types = 3
lb_time = 8          # Lower bound for berthing time
ub_time = 71          # Upper bound for berthing time
cycle_time = 71   # Total cycle time (set equal to ub_time)
flow_coeffs = [1441, 1200, 2913] # Ship flow coefficients per type
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_types:
    print("Error: flow_coeffs length mismatch with num_types")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_types}-Type Berthing Time", env=env)

        # --- Decision variables (dynamic based on num_types) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_types, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for ship type i is proportional to flow * non-berthing_time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_types)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_types)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_types)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_types):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 212991.00
------------------------------
Optimal berthing times (minutes):
  t1: 8.00, t2: 8.00, t3: 55.00


```

================================================================================



--- Problem 337 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy port handles ship traffic from two primary directions: Direction A with a modest flow of 110 ships per hour and Direction B with a significantly heavier flow of 377 ships per hour. The berthing slots at this port must be carefully timed to balance efficiency and safety. The total cycle time for the berthing slots is fixed at 176 minutes, which includes berthing times for both directions as well as lost time (15 minutes per phase, accounting for preparation and clearance intervals). Each direction must receive a minimum berthing time of 30 minutes to ensure safe passage. The challenge is to allocate the available berthing time between the two directions in a way that maximizes the overall flow-weighted efficiency—prioritizing the heavier traffic flow while adhering to the cycle time and minimum berthing constraints. The core question is: *How should the berthing times be distributed between Directions A and B to maximize the total flow-weighted berthing time, given the fixed cycle time and operational rules?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `b_A`: Berthing time allocated to Direction A (in minutes), continuous, with a lower bound of 30.  
   - `b_B`: Berthing time allocated to Direction B (in minutes), continuous, with a lower bound of 30.  

   **2. Parameters:**  
   - `cycle_time = 176`: Total berthing cycle time (minutes).  
   - `lost_time = 15`: Lost time per phase (minutes).  
   - `min_berth = 30`: Minimum berthing time for any direction (minutes).  
   - `flow_A = 110`: Ship flow rate for Direction A (ships/hour).  
   - `flow_B = 377`: Ship flow rate for Direction B (ships/hour).  

   **3. Objective Function:**  
   Maximize the flow-weighted berthing time:  
   `Maximize: flow_A * b_A + flow_B * b_B`.  

   **4. Constraints:**  
   - **Cycle time constraint:** The sum of berthing times and lost times must equal the total cycle time:  
     `b_A + lost_time + b_B + lost_time = cycle_time`.  
   - **Minimum berthing time:**  
     `b_A >= min_berth`, `b_B >= min_berth`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cycle_time = 176 # minutes
lost_time = 15 # minutes per phase (preparation + clearance)
min_berth = 30 # minutes
flow_A = 110 # ships per hour
flow_B = 377 # ships per hour
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTHING_SLOT_TIMING", env=env)

    # --- Decision Variables ---
    # b_A: berthing time for direction A (minutes)
    b_A = m.addVar(lb=min_berth, vtype=GRB.CONTINUOUS, name="b_A")
    # b_B: berthing time for direction B (minutes)
    b_B = m.addVar(lb=min_berth, vtype=GRB.CONTINUOUS, name="b_B")

    # --- Objective Function: Maximize flow-weighted berthing time ---
    m.setObjective(flow_A * b_A + flow_B * b_B, GRB.MAXIMIZE)

    # --- Constraints ---
    # Cycle time constraint: sum of berthing times + lost times = cycle time
    m.addConstr(b_A + lost_time + b_B + lost_time == cycle_time, "CycleTimeConstraint")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['b_A_sol'] = b_A.X # Not needed for output
        # results_dict['b_B_sol'] = b_B.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}") # Weighted value
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the berthing times for both directions
if m.Status == GRB.OPTIMAL:
    print(f"Optimal objective value: {obj_val_print:.2f}")
    print(f"Berthing time for Direction A: {b_A.X:.2f} minutes")
    print(f"Berthing time for Direction B: {b_B.X:.2f} minutes")
```
Answer:
Optimal objective value: 47032.00
Optimal objective value: 47032.00
Berthing time for Direction A: 30.00 minutes
Berthing time for Direction B: 116.00 minutes


```

================================================================================



--- Problem 338 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A port manager is tasked with optimizing the allocation of crane time at a busy container terminal to minimize the total waiting time for ships. The terminal operates with a fixed cycle time of 54 minutes, divided into two distinct phases. Each phase has a crane operation time that must fall between a minimum of 19 minutes and a maximum of 54 minutes. The ship traffic during these phases is significant, with coefficients of 1278 and 672 containers per hour for phases 1 and 2, respectively. The waiting time experienced by ships is directly proportional to the idle time they face, which is the cycle time minus the crane operation time allocated to their phase. The manager must determine the optimal crane operation time allocation for each phase such that the sum of crane operation times equals the total cycle time, while minimizing the cumulative waiting time across all ships. The core challenge is: *What crane operation durations for each phase will result in the least total waiting time for all ships at the terminal?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `t_i`: Continuous variable representing the crane operation time (in minutes) allocated to phase `i`, where `i ∈ {1, 2}`.  
   - Bounds: `19 ≤ t_i ≤ 54` for each phase.  

   **2. Parameters:**  
   - `flow_coeffs = [1278, 672]`: Container flow coefficients (containers/hour) for phases 1 and 2.  
   - `cycle_time = 54`: Total cycle time (minutes).  
   - `lb_time = 19`, `ub_time = 54`: Lower and upper bounds for crane operation times (minutes).  

   **3. Objective Function:**  
   Minimize the total waiting time, calculated as:  
   `Minimize: sum(flow_coeffs[i] * (cycle_time - t_i) for i in phases)`  

   **4. Constraints:**  
   - The sum of crane operation times must equal the cycle time:  
     `t_1 + t_2 = 54`  
   - Variable bounds:  
     `19 ≤ t_1 ≤ 54`, `19 ≤ t_2 ≤ 54`  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 2
lb_time = 19          # Lower bound for crane operation time
ub_time = 54          # Upper bound for crane operation time
cycle_time = 54   # Total cycle time (set equal to ub_time)
flow_coeffs = [1278, 672] # Container flow coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Crane Operation Timing", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for phase i is proportional to flow * idle_time = flow * (cycle_time - crane_operation_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of crane operation times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal crane operation times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 47802.00
------------------------------
Optimal crane operation times (minutes):
  t1: 35.00, t2: 19.00


```

================================================================================



--- Problem 339 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
At a busy port, the operations manager needs to optimize the allocation of crane time between two berths, Berth A and Berth B. The cranes operate on a fixed 90-minute cycle, but not all of this time is usable for loading and unloading—each phase incurs a 5-minute lost time for setup and transition, totaling 10 minutes per cycle. This leaves 80 minutes of effective crane time to allocate between the two berths.

Berth A experiences a high demand of 981.13 containers per hour, supported by a crane handling rate of 1780.78 containers per hour. Meanwhile, Berth B sees a lower but still significant demand of 664.80 containers per hour, with a crane handling rate of 1609.93 containers per hour. To prevent congestion, the Berth B phase must maintain a saturation level below 0.901, ensuring smooth operations without overloading the berth. Additionally, each phase must grant at least 5 minutes of crane time to allow safe and efficient container handling.

The core question is: *How should the 80 minutes of effective crane time be split between Berth A and Berth B to maximize the Berth A crane time while ensuring the Berth B phase meets its saturation constraint?*
**

**Modeling Process:**
**
- **Decision Variables:**  
     - `t_a`: Effective crane time allocated to Berth A (minutes).  
     - `t_b`: Effective crane time allocated to Berth B (minutes).  

   - **Parameters:**  
     - `cycle_length = 90`: Total cycle duration (minutes).  
     - `total_lost_time = 10`: Lost time per cycle (minutes).  
     - `effective_crane_total = 80`: Total usable crane time (minutes).  
     - `demand_a = 981.13`: Berth A demand (containers/hr).  
     - `handling_rate_a = 1780.78`: Berth A handling rate (containers/hr).  
     - `demand_b = 664.80`: Berth B demand (containers/hr).  
     - `handling_rate_b = 1609.93`: Berth B handling rate (containers/hr).  
     - `max_saturation_b = 0.901`: Maximum allowed Berth B saturation level.  
     - `min_crane_time = 5`: Minimum crane time per phase (minutes).  

   - **Objective Function:**  
     Maximize the Berth A crane time:  
     `Maximize: t_a`.  

   - **Constraints:**  
     1. Total crane time allocation:  
        `t_a + t_b == 80`.  
     2. Berth B saturation constraint (derived from demand and handling rates):  
        `t_b >= (demand_b * cycle_length) / (handling_rate_b * max_saturation_b)`.  
     3. Minimum crane time for both phases:  
        `t_a >= 5`, `t_b >= 5`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
cycle_length = 90  # minutes
lost_time_per_phase = 5  # minutes
total_lost_time = 2 * lost_time_per_phase
effective_crane_total = cycle_length - total_lost_time

demand_a = 981.1338939968712  # containers/hr
handling_rate_a = 1780.7754059268286  # containers/hr
demand_b = 664.800107912022  # containers/hr
handling_rate_b = 1609.9278056816502  # containers/hr

max_saturation_b = 0.9013631311399295  # Service level constraint for Berth B
min_crane_time = 5  # Minimum crane time per phase

# --- Model Creation ---
model = gp.Model("Crane_Time_Cycle_LP")

# --- Decision Variables ---
t_a = model.addVar(name="crane_a", lb=min_crane_time)
t_b = model.addVar(name="crane_b", lb=min_crane_time)

# --- Objective Function ---
model.setObjective(t_a, sense=GRB.MAXIMIZE)

# --- Constraints ---
# Total effective crane time equals available time in cycle
model.addConstr(t_a + t_b == effective_crane_total, name="total_crane_time")

# Berth B saturation constraint
min_t_b_for_saturation = (demand_b * cycle_length) / (handling_rate_b * max_saturation_b)
model.addConstr(t_b >= min_t_b_for_saturation, name="b_saturation_limit")

# --- Optimization ---
model.optimize()

# --- Output Results ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    print(f"Optimal Berth A Effective Crane Time: {t_a.X:.2f} minutes")
    print(f"Optimal Berth B Effective Crane Time: {t_b.X:.2f} minutes")

    # Calculate actual saturation levels achieved
    sat_a = (demand_a * cycle_length) / (handling_rate_a * t_a.X) if t_a.X > 0 else float('inf')
    sat_b = (demand_b * cycle_length) / (handling_rate_b * t_b.X) if t_b.X > 0 else float('inf')

    print(f"\nSaturation Analysis:")
    print(f"  Berth A Saturation: {sat_a:.3f}")
    print(f"  Berth B Saturation: {sat_b:.3f} (Constraint <= 0.9013631311399295)")

    print(f"\nTiming Summary:")
    print(f"  Total Cycle Length: 90 minutes")
    print(f"  Total Lost Time: {total_lost_time} minutes")
    print(f"  Total Effective Crane: {effective_crane_total} minutes")
    print(f"  Minimum Required Berth B Crane: {min_t_b_for_saturation:.2f} minutes")
elif model.status == GRB.INFEASIBLE:
    print(f"Optimization Status: Infeasible")
    print(f"Minimum required Berth B crane time for saturation limit: {min_t_b_for_saturation:.2f} min")
    print(f"Minimum required Berth A crane time: {min_crane_time:.2f} min")
    print(f"Total required minimum crane: {min_t_b_for_saturation + min_crane_time:.2f} min")
    print(f"Total available effective crane: {effective_crane_total:.2f} min")
else:
    print(f"Optimization Status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 2 rows, 2 columns and 3 nonzeros
Model fingerprint: 0x4c19b6a9
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [5e+00, 5e+00]
  RHS range        [4e+01, 8e+01]
Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    3.8768665e+01   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  3.876866474e+01

--- Optimization Results ---
Optimization Status: Optimal
Optimal Berth A Effective Crane Time: 38.77 minutes
Optimal Berth B Effective Crane Time: 41.23 minutes

Saturation Analysis:
  Berth A Saturation: 1.279
  Berth B Saturation: 0.901 (Constraint <= 0.9013631311399295)

Timing Summary:
  Total Cycle Length: 90 minutes
  Total Lost Time: 10 minutes
  Total Effective Crane: 80 minutes
  Minimum Required Berth B Crane: 41.23 minutes



================================================================================



--- Problem 340 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A single-lane bridge serves as a critical bottleneck for northbound (NB) and southbound (SB) truck traffic, requiring careful coordination to maximize throughput while ensuring fairness. The bridge operates on a fixed cycle of 207 seconds, with 96 seconds lost to switching directions and only 111 seconds of effective green time available for actual vehicle flow. The challenge is to allocate this limited green time between the two directions to maximize total throughput while respecting lane capacity constraints and ensuring that the flow of trucks is proportional to the demand from each direction. 

Northbound traffic demands 264 trucks per hour, while southbound traffic demands 104 trucks per hour. The lane can handle up to 701 trucks per hour under ideal conditions, but the actual capacity is determined by the allocated green time, with each second of green time providing 3.3865 trucks per hour of capacity. The goal is to find the optimal split of green time (g_n for NB, g_s for SB) that maximizes total throughput (t_n + t_s) while ensuring that the throughput for each direction does not exceed its demand or its allocated capacity, and that the flows remain proportional to the demand ratios. 

The central question is: *How should the 111 seconds of effective green time be divided between northbound and southbound truck traffic to maximize total throughput while maintaining proportional fairness and respecting lane capacity constraints?*

---

**

Modeling Process:**
**
**1. Decision Variables:**
- `g_n`: Green time allocated to northbound truck traffic (seconds), continuous ≥ 0.
- `g_s`: Green time allocated to southbound truck traffic (seconds), continuous ≥ 0.
- `t_n`: Throughput of northbound truck traffic (trucks/hour), continuous ≥ 0.
- `t_s`: Throughput of southbound truck traffic (trucks/hour), continuous ≥ 0.

**2. Parameters:**
- `effective_green_total = 111`: Total effective green time available (seconds).
- `capacity_factor = 3.3865`: Capacity conversion factor (trucks/hour per second of green time).
- `demand_n_trucks_per_hr = 264`: Northbound demand (trucks/hour).
- `demand_s_trucks_per_hr = 104`: Southbound demand (trucks/hour).

**3. Objective Function:**
Maximize total throughput:  
`Maximize: t_n + t_s`

**4. Constraints:**
- Total green time constraint:  
  `g_n + g_s == effective_green_total`
- Capacity limits for each direction:  
  `t_n <= capacity_factor * g_n`  
  `t_s <= capacity_factor * g_s`
- Demand limits for each direction:  
  `t_n <= demand_n_trucks_per_hr`  
  `t_s <= demand_s_trucks_per_hr`
- Proportional flow fairness (if both demands are non-zero):  
  `t_n * demand_s_trucks_per_hr == t_s * demand_n_trucks_per_hr`  
  (If northbound demand is zero: `t_n == 0`; if southbound demand is zero: `t_s == 0`)

---

**

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cycle_length_sec = 207
lost_time_per_switch = 48
total_lost_time = 96
effective_green_total = 111
lane_capacity_trucks_per_hr = 701
demand_n_trucks_per_hr = 264
demand_s_trucks_per_hr = 104
capacity_factor = 3.3865 # trucks/hr per second of green
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m28 = gp.Model("SINGLE_LANE_BRIDGE_LP", env=env)

    # --- Decision Variables ---
    g_n = m28.addVar(name="green_north", lb=0)
    g_s = m28.addVar(name="green_south", lb=0)
    t_n = m28.addVar(name="throughput_north", lb=0)
    t_s = m28.addVar(name="throughput_south", lb=0)

    # --- Objective Function ---
    # Maximize total throughput
    m28.setObjective(t_n + t_s, sense=GRB.MAXIMIZE)

    # --- Constraints ---
    # Total green time equals effective green time
    m28.addConstr(g_n + g_s == effective_green_total, name="total_green_time")

    # Throughput limited by capacity (proportional to green time)
    m28.addConstr(t_n <= capacity_factor * g_n, name="north_capacity_limit")
    m28.addConstr(t_s <= capacity_factor * g_s, name="south_capacity_limit")

    # Throughput limited by demand
    m28.addConstr(t_n <= demand_n_trucks_per_hr, name="north_demand_limit")
    m28.addConstr(t_s <= demand_s_trucks_per_hr, name="south_demand_limit")

    # Proportional flow constraint (ensure fairness based on demand ratio)
    # Avoid division by zero if demand is 0
    if demand_n_trucks_per_hr > 1e-6 and demand_s_trucks_per_hr > 1e-6:
         m28.addConstr(t_n * demand_s_trucks_per_hr == t_s * demand_n_trucks_per_hr, name="proportional_flow")
    elif demand_n_trucks_per_hr <= 1e-6: # If north demand is zero, north throughput must be zero
         m28.addConstr(t_n == 0, name="proportional_flow_n0")
    elif demand_s_trucks_per_hr <= 1e-6: # If south demand is zero, south throughput must be zero
         m28.addConstr(t_s == 0, name="proportional_flow_s0")


    # --- Optimization ---
    m28.optimize()

    # --- Store results ---
    results_dict['status'] = m28.status
    if m28.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m28.ObjVal
        results_dict['g_n_sol'] = g_n.X
        results_dict['g_s_sol'] = g_s.X
        results_dict['t_n_sol'] = t_n.X
        results_dict['t_s_sol'] = t_s.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- SINGLE_LANE_BRIDGE: Single-Lane Bridge Alternating Flow (LP) ---")
    if m28.status == GRB.OPTIMAL:
        g_n_sol = results_dict.get('g_n_sol', 0)
        g_s_sol = results_dict.get('g_s_sol', 0)
        t_n_sol = results_dict.get('t_n_sol', 0)
        t_s_sol = results_dict.get('t_s_sol', 0)
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Optimal NB Green Time (g_n): {g_n_sol:.1f} sec")
        print(f"Optimal SB Green Time (g_s): {g_s_sol:.1f} sec")
        print(f"Total Effective Green: {g_n_sol + g_s_sol:.1f} / {effective_green_total} sec (Cycle: {cycle_length_sec}s, Lost: {total_lost_time}s)")
        print(f"Maximized NB Throughput (t_n): {t_n_sol:.1f} trucks/hr (Demand: {demand_n_trucks_per_hr})")
        print(f"Maximized SB Throughput (t_s): {t_s_sol:.1f} trucks/hr (Demand: {demand_s_trucks_per_hr})")
        print(f"Total Maximized Throughput: {obj_val_print:.1f} trucks/hr")

        # Check capacity needed vs provided
        cap_n_provided = capacity_factor * g_n_sol
        cap_s_provided = capacity_factor * g_s_sol
        print(f"NB Capacity Provided: {cap_n_provided:.1f} trucks/hr (Lane Capacity: {lane_capacity_trucks_per_hr} trucks/hr)")
        print(f"SB Capacity Provided: {cap_s_provided:.1f} trucks/hr")

        # Check proportionality
        prop_n = t_n_sol / demand_n_trucks_per_hr if demand_n_trucks_per_hr > 1e-6 else 0
        prop_s = t_s_sol / demand_s_trucks_per_hr if demand_s_trucks_per_hr > 1e-6 else 0
        if abs(prop_n - prop_s) < 1e-4:
             print(f"Flow is proportional to demand (Ratio ~ {prop_n:.3f}).")
        else:
             # Check if one demand was zero
             if demand_n_trucks_per_hr <= 1e-6 and abs(t_n_sol) < 1e-6:
                  print("Flow proportional (North demand/throughput is zero).")
             elif demand_s_trucks_per_hr <= 1e-6 and abs(t_s_sol) < 1e-6:
                  print("Flow proportional (South demand/throughput is zero).")
             else:
                  print(f"Flow proportionality check failed: N={prop_n:.3f}, S={prop_s:.3f}")

    elif m28.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible.")
         # Check if total demand <= total capacity in cycle
         # Effective capacity calculation might be subtle. Use model capacity factor approach.
         total_demand_ph = demand_n_trucks_per_hr + demand_s_trucks_per_hr
         total_effective_capacity_ph = capacity_factor * effective_green_total
         print(f"Total Demand: {total_demand_ph:.1f} trucks/hr")
         print(f"Total Effective Capacity per hour (using factor*effective_green): {total_effective_capacity_ph:.1f} trucks/hr")
         print("(Infeasibility often due to proportionality constraint conflicting with capacity/demand limits).")

    elif m28.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m28.ObjVal is not None and abs(m28.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m28.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m28.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2


```
Answer:
--- SINGLE_LANE_BRIDGE: Single-Lane Bridge Alternating Flow (LP) ---
Optimization Status: Optimal
Optimal NB Green Time (g_n): 78.0 sec
Optimal SB Green Time (g_s): 33.0 sec
Total Effective Green: 111.0 / 111 sec (Cycle: 207s, Lost: 96s)
Maximized NB Throughput (t_n): 264.0 trucks/hr (Demand: 264)
Maximized SB Throughput (t_s): 104.0 trucks/hr (Demand: 104)
Total Maximized Throughput: 368.0 trucks/hr
NB Capacity Provided: 264.0 trucks/hr (Lane Capacity: 701 trucks/hr)
SB Capacity Provided: 111.9 trucks/hr
Flow is proportional to demand (Ratio ~ 1.000).



================================================================================



--- Problem 341 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy port, 12 ships (labeled 0 through 11) must be assigned to one of two berthing areas: *Berth_A* or *Berth_B*. Each berth has a strict capacity limit—36 spots in *Berth_A* and 25 in *Berth_B*. The challenge arises from the preferences of the ship captains: each ship has a documented likelihood (ranging from 0.12 to 0.88) of favoring *Berth_A* over *Berth_B*, derived from historical data or captain surveys. Forcing a ship into its non-preferred berth incurs a dissatisfaction cost: \$1.76 per ship for *Berth_A* and \$2.94 for *Berth_B*. The system aims to minimize total dissatisfaction by strategically assigning ships while respecting capacity constraints. The core question is: *How should ships be distributed between the two berths to minimize the overall cost of captain dissatisfaction?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable \(x(i, j)\) for each ship \(i\) (0 to 11) and berth \(j\) (*Berth_A* or *Berth_B*), where \(x(i, j) = 1\) if ship \(i\) is assigned to berth \(j\), and 0 otherwise.  
   - **2. Parameters:**  
     - \(pref(i)\): Probability ship \(i\) prefers *Berth_A* (e.g., \(pref(0) = 0.39\)).  
     - \(dissatisfaction\_cost(j)\): Cost per ship assigned to berth \(j\) against preference (*Berth_A*: 1.76, *Berth_B*: 2.94).  
     - \(capacity(j)\): Maximum ships per berth (*Berth_A*: 36, *Berth_B*: 25).  
   - **3. Objective Function:**  
     - Minimize total dissatisfaction:  
       \(\text{Minimize: } \sum_{i,j} \left[ dissatisfaction\_cost(j) \times \begin{cases} 
       1 - pref(i) & \text{if } j = \text{Berth\_A} \\ 
       pref(i) & \text{if } j = \text{Berth\_B} 
       \end{cases} \right] \times x(i, j)\).  
   - **4. Constraints:**  
     - Each ship assigned to exactly one berth: \(\sum_j x(i, j) = 1 \quad \forall i\).  
     - Berth capacities: \(\sum_i x(i, j) \leq capacity(j) \quad \forall j\).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
berths = ['Berth_A', 'Berth_B']
capacity = {'Berth_A': 36, 'Berth_B': 25}
# Preferences defined for the first berth (e.g., Berth_A)
preferences = {0: 0.39, 1: 0.75, 2: 0.13, 3: 0.14, 4: 0.88, 5: 0.16, 6: 0.28, 7: 0.43, 8: 0.26, 9: 0.12, 10: 0.18, 11: 0.69} # Dict: ship_id -> preference for first berth
dissatisfaction_cost = {'Berth_A': 1.76, 'Berth_B': 2.94} # Dict: berth -> cost if forced here when preferred elsewhere
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_GUIDANCE", env=env)

    # --- Calculate Assignment Costs ---
    # Assumes preference is for the *first* berth in the list
    cost = {}
    if berths: # Check if berths list is not empty
        first_berth = berths[0]
        for i in ships:
            pref_first = preferences.get(i, 0.5) # Default to 0.5 if missing
            for berth_idx, berth_name in enumerate(berths):
                if berth_name == first_berth:
                    # Cost if assigned first_berth = cost_A * prob_prefers_other
                    # Assuming preference for 'other' is (1 - pref_first)
                    cost[i, berth_name] = dissatisfaction_cost.get(berth_name, 1.0) * (1.0 - pref_first)
                else:
                    # Cost if assigned other_berth = cost_other * prob_prefers_first
                    cost[i, berth_name] = dissatisfaction_cost.get(berth_name, 1.0) * pref_first
    # print(f"Calculated costs: {cost}") # Debug print

    # --- Decision Variables ---
    # x[i, j] = 1 if ship i is guided to berth j, 0 otherwise
    # Use tuplelist of valid (ship, berth) pairs
    assign_keys = [(i,j) for i in ships for j in berths]
    x = m.addVars(assign_keys, vtype=GRB.BINARY, name="x")

    # --- Objective Function: Minimize total dissatisfaction cost ---
    # Use .get() on cost dict for safety
    m.setObjective(gp.quicksum(cost.get((i, j), 0) * x[i, j] for i, j in assign_keys), GRB.MINIMIZE)

    # --- Constraints ---
    # Each ship must be guided to exactly one berth
    if ships and berths:
        m.addConstrs((gp.quicksum(x[i, j] for j in berths) == 1 for i in ships), "ShipAssignment")

        # Capacity constraint for each Berth
        for berth_name, berth_cap in capacity.items():
            if berth_name in berths: # Check if berth exists
                m.addConstr(gp.quicksum(x[i, berth_name] for i in ships) <= berth_cap, f"Capacity_{berth_name}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show decimals
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the assignment of ships to berths
if m.Status == GRB.OPTIMAL:
    for i in ships:
        for j in berths:
            if x[i, j].X > 0.5:
                print(f"Ship {i} is assigned to {j}")
```
Answer:
Optimal objective value: 7.0074
Ship 0 is assigned to Berth_A
Ship 1 is assigned to Berth_A
Ship 2 is assigned to Berth_B
Ship 3 is assigned to Berth_B
Ship 4 is assigned to Berth_A
Ship 5 is assigned to Berth_B
Ship 6 is assigned to Berth_B
Ship 7 is assigned to Berth_A
Ship 8 is assigned to Berth_B
Ship 9 is assigned to Berth_B
Ship 10 is assigned to Berth_B
Ship 11 is assigned to Berth_A


```

================================================================================



--- Problem 342 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
A busy port's crane dispatch center faces the challenge of efficiently allocating its fleet of 110 cranes between two high-demand zones, A and B. Zone A, a densely packed container yard, can accommodate a maximum of 49 cranes due to limited space and operational regulations. Meanwhile, Zone B, a larger but less congested area, has a higher capacity of 80 cranes but is less efficient due to longer travel distances. The dispatch manager aims to minimize the number of cranes assigned to Zone B while ensuring all 110 cranes are deployed and neither zone exceeds its capacity. The core question is: *How can the cranes be distributed between the two zones to meet demand while keeping the number of cranes in Zone B as low as possible?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n_A`: Integer number of cranes assigned to Zone A.  
     - `n_B`: Integer number of cranes assigned to Zone B.  
   - **2. Parameters:**  
     - Total cranes: 110.  
     - Zone A capacity: 49.  
     - Zone B capacity: 80.  
   - **3. Objective Function:**  
     - Minimize `n_B` (cranes in Zone B).  
   - **4. Constraints:**  
     - All cranes must be assigned: `n_A + n_B = 110`.  
     - Zone A capacity: `n_A ≤ 49`.  
     - Zone B capacity: `n_B ≤ 80`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_cranes = 110
capacity_A = 49
capacity_B = 80
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("CRANE_DISPATCH_MANAGEMENT", env=env)

    # --- Decision Variables ---
    # n_A: number of cranes assigned to area A
    n_A = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_A")
    # n_B: number of cranes assigned to area B
    n_B = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_B")

    # --- Objective Function: Minimize the number of cranes in area B ---
    m.setObjective(n_B, GRB.MINIMIZE)

    # --- Constraints ---
    # All cranes must be assigned
    m.addConstr(n_A + n_B == total_cranes, "TotalCranes")

    # Capacity constraint for area A
    m.addConstr(n_A <= capacity_A, "CapacityA")

    # Capacity constraint for area B
    m.addConstr(n_B <= capacity_B, "CapacityB")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_A_sol'] = n_A.X # Not needed for output
        # results_dict['n_B_sol'] = n_B.X # Not needed for output (obj_val)

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is number of cranes, should be integer
             print(f"Optimal objective value: {int(round(obj_val_print))}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the number of cranes assigned to each zone
if m.Status == GRB.OPTIMAL:
    n_A_sol = int(round(n_A.X))
    n_B_sol = int(round(n_B.X))
    print(f"Number of cranes in Zone A: {n_A_sol}")
    print(f"Number of cranes in Zone B: {n_B_sol}")
```
Answer:
Optimal objective value: 61
Number of cranes in Zone A: 49
Number of cranes in Zone B: 61


```

================================================================================



--- Problem 343 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port authority is tasked with scheduling a set of 34 ships to berths for unloading. Each ship has a specific weight and value, where the weight represents the unloading time in hours and the value represents the revenue generated from the cargo. The goal is to maximize the total revenue while adhering to strict time constraints. The berths available for use are limited to six, each with a maximum unloading time capacity of 48 hours. The challenge is to strategically assign ships to berths such that no berth exceeds its time limit, each ship is assigned to at most one berth, and the total revenue is as high as possible.  

The ships vary significantly in unloading times and revenue—some have short unloading times but generate high revenue (e.g., ship 1: unloading time 40, revenue 33), while others have longer unloading times but generate less revenue (e.g., ship 2: unloading time 27, revenue 96). The port authority must carefully balance these trade-offs to extract the maximum possible revenue from the available berth time. The central question is: *How should the ships be distributed across the berths to achieve the highest possible total revenue without violating any time or placement constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether ship `i` is assigned to berth `j` (1 if assigned, 0 otherwise).  
   - `y[j]`: Binary variable indicating whether berth `j` is used (1 if used, 0 otherwise).  

   **2. Parameters:**  
   - `ships`: List of tuples `(unloading_time[i], revenue[i])` for each ship `i`.  
   - `berth_capacity = 48`: Maximum unloading time each berth can handle.  
   - `num_berths = 6`: Total berths available.  
   - `num_ships = 34`: Total ships to schedule.  

   **3. Objective Function:**  
   Maximize the total revenue from scheduled ships:  
   \[
   \text{Maximize: } \sum_{i=1}^{34} \sum_{j=1}^{6} \text{revenue}[i] \cdot x[i, j]
   \]  

   **4. Constraints:**  
   - **Berth Time Limit:** For each berth `j`, the total unloading time of assigned ships must not exceed its capacity:  
     \[
     \sum_{i=1}^{34} \text{unloading_time}[i] \cdot x[i, j] \leq \text{berth\_capacity} \cdot y[j] \quad \forall j \in \{1, \dots, 6\}
     \]  
   - **Ship-Berth Link:** If a ship `i` is assigned to berth `j`, the berth must be marked as used:  
     \[
     x[i, j] \leq y[j] \quad \forall i \in \{1, \dots, 34\}, \forall j \in \{1, \dots, 6\}
     \]  
   - **Ship Placement:** Each ship can be assigned to at most one berth:  
     \[
     \sum_{j=1}^{6} x[i, j] \leq 1 \quad \forall i \in \{1, \dots, 34\}
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Data Definition (Embedded) ---
ships = [(40, 33), (27, 96), (42, 6), (12, 45), (9, 28), (3, 71), (13, 95), (13, 70), (47, 63), (12, 49), (42, 17), (33, 55), (7, 85), (18, 48), (30, 2), (29, 75), (29, 22), (25, 54), (27, 99), (43, 20), (22, 44), (43, 78), (21, 69), (13, 60), (4, 15), (1, 36), (47, 29), (19, 31), (8, 33), (32, 38), (37, 27), (35, 19), (7, 46), (21, 56)]          # List of (unloading_time, revenue) tuples
berth_capacity = 48      # Maximum unloading time per berth
num_berths = 6          # Maximum number of available berths (parameter)
num_ships = 34          # len(ships) derived correctly
# --- End Data Definition ---

GUROBI_TIME_LIMIT = 60 # Time limit parameter

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi log in captured output
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Max-Revenue BPP", env=env)

    # --- Decision variables ---
    x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")  # x[i, j] -> ship i assigned to berth j
    y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")  # y[j] -> berth j is used

    # --- Objective: Maximize total revenue of scheduled ships ---
    # Sum over all ships i and the berth j they are assigned to
    model.setObjective(gp.quicksum(ships[i][1] * x[i, j] for i in range(num_ships) for j in range(num_berths)), GRB.MAXIMIZE)

    # --- Constraint 1: Berth time limit ---
    for j in range(num_berths):
        model.addConstr(gp.quicksum(ships[i][0] * x[i, j] for i in range(num_ships)) <= berth_capacity * y[j], name=f"Berth_{j}_Time")

    # --- Constraint 2: If a ship is assigned to a berth, that berth must be considered used ---
    # (This is often implied by C1 if capacity > 0, but good practice)
    for i in range(num_ships):
        for j in range(num_berths):
            model.addConstr(x[i, j] <= y[j], name=f"Ship_{i}_Triggers_Berth_{j}")

    # --- Constraint 3: Each ship can be assigned to at most one berth ---
    # (Ships not assigned contribute 0 to objective and constraints)
    for i in range(num_ships):
        model.addConstr(x.sum(i, '*') <= 1, name=f"Ship_{i}_AtMostOneBerth")

    # --- Solve the model ---
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal # Best solution found

    # --- Output results (for capture) ---
    if model.status == GRB.OPTIMAL:
        print(f"Optimal total revenue: {model.objVal:.2f}") # Format value
        print("-" * 30)
        printed_berth_count = 0
        for j in range(num_berths):
            try:
                 if y[j].x > 0.5:  # Berth is used
                     printed_berth_count += 1
                     assigned_ships = [i for i in range(num_ships) if x[i, j].x > 0.5]
                     assigned_times = [ships[i][0] for i in assigned_ships]
                     berth_load = sum(assigned_times)
                     print(f"Berth {printed_berth_count} (Index {j}):")
                     print(f"  Load: {berth_load} / {berth_capacity}")
                     print(f"  Ships (indices): {sorted(assigned_ships)}")
                     # Optional: print ship details
                     # print(f"  Ships (t,r): {[ships[i] for i in sorted(assigned_ships)]}")
                     print("-" * 10)
            except AttributeError:
                 pass # Skip berths not used or if .X missing
    elif model.status == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare if ships fit capacity
    else:
        print(f"\nOptimization finished with status: {model.status}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total revenue: 1159.00
------------------------------
Berth 1 (Index 0):
  Load: 48 / 48
  Ships (indices): [1, 5, 13]
----------
Berth 2 (Index 1):
  Load: 48 / 48
  Ships (indices): [9, 12, 15]
----------
Berth 3 (Index 2):
  Load: 48 / 48
  Ships (indices): [18, 33]
----------
Berth 4 (Index 3):
  Load: 48 / 48
  Ships (indices): [4, 6, 7, 23]
----------
Berth 5 (Index 4):
  Load: 48 / 48
  Ships (indices): [17, 20, 25]
----------
Berth 6 (Index 5):
  Load: 48 / 48
  Ships (indices): [3, 22, 28, 32]
----------


```

================================================================================



--- Problem 344 ---
**Difficulty:** easy
**Category:** MIP

**Problem Description:**
A logistics company is tasked with optimizing the delivery route for a single truck serving a small network of locations. The depot (node 0) must dispatch the truck to visit a single customer (node 1) with a demand of 45 units, while the truck’s capacity is capped at 60 units. The distances between locations are asymmetric: traveling from the depot to the customer takes 120 units of distance, and the return trip is equally long. The challenge is to design a route that starts and ends at the depot, serves the customer exactly once without exceeding capacity, and minimizes the total travel distance. The company aims to balance operational efficiency with resource constraints, ensuring timely deliveries while keeping costs low.

**Modeling Process:**
- **1. Decision Variables:**  
     - Binary variable \(x_{i,j,k}\): Equals 1 if vehicle \(k\) travels directly from node \(i\) to node \(j\); 0 otherwise.  
     - Continuous variable \(u_i\) (for subtour elimination): Represents the sequence of node \(i\) in the route.  
   - **2. Parameters:**  
     - \(N = 2\): Total nodes (depot 0 and customer 1).  
     - \(K = 1\): Single vehicle available.  
     - \(Q = [60]\): Vehicle capacity.  
     - \(q = [0, 45]\): Demand at nodes (0 for depot, 45 for customer).  
     - \(d = [[0, 120], [120, 0]]\): Distance matrix.  
   - **3. Objective Function:**  
     Minimize total distance: \(\sum_{k=0}^{0} \sum_{i=0}^{1} \sum_{j=0}^{1} d[i][j] \cdot x_{i,j,k}\) (for \(i \neq j\)).  
   - **4. Constraints:**  
     - **Visit Once:** Customer 1 must be visited exactly once: \(\sum_{k=0}^{0} \sum_{j=0}^{1} x_{1,j,k} = 1\).  
     - **Flow Conservation:** Inflow equals outflow for each node and vehicle.  
     - **Depot Departure/Return:** Vehicle must leave and return to the depot once.  
     - **Capacity:** Total demand served (45) must not exceed capacity (60).  
     - **Subtour Elimination:** MTZ constraints ensure a single continuous route (though redundant here for \(N=2\)).

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 2
K = 1
Q = [60]
q = [0, 45]
d = [
    [0, 120],
    [120, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Vehicle Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for vehicle {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for vehicle {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")


```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 240.00

Route for vehicle 1 (Capacity: 60):
0 -> 1 -> 0
Route Load: 45 / 60



================================================================================



--- Problem 345 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port terminal is managing the berthing of ships during a period of high traffic. The main berth, which can normally handle up to 4,766 TEUs (Twenty-foot Equivalent Units) per hour, has its capacity reduced to 2,642 TEUs per hour due to an ongoing maintenance activity, which lasts approximately 0.976 hours. An alternative berth is available, but it adds an extra 0.116 hours of handling time and can only accommodate up to 1,902 TEUs per hour. With a total arrival rate of 2,423 TEUs per hour, the terminal must decide the optimal fraction of ships to divert (10%, 30%, 50%, or 70%) to balance congestion on the main berth and avoid overwhelming the alternative. The challenge is to compute the total delay—combining queueing delays on the main berth and added handling time on the alternative—and select the diversion ratio that minimizes this delay while respecting capacity constraints.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `y[k]` for each diversion option `k` (0 to 3), where `y[k] = 1` if the option is selected, else `0`.  
   - **2. Parameters:**  
     - `capacity_main_normal = 4766`, `capacity_main_reduced = 2642`, `capacity_alt = 1902` (TEUs/h).  
     - `arrival_rate_total = 2423` (TEUs/h), `maintenance_duration = 0.976` (h), `alt_berth_extra_time = 0.116` (h).  
     - `diversion_options = [0.1, 0.3, 0.5, 0.7]` (possible ratios).  
     - `option_delays[k]`: Precomputed total delay (queue + diversion) for each feasible option `k`.  
   - **3. Objective Function:**  
     - Minimize total delay: `Minimize sum(y[k] * option_delays[k] for all feasible k)`.  
   - **4. Constraints:**  
     - Exactly one feasible diversion option must be chosen: `sum(y[k] for feasible k) = 1`.  
     - Infeasible options (exceeding alternative berth capacity) are forced to 0: `y[k] = 0` for infeasible `k`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
capacity_main_normal = 4766 # TEUs/h
capacity_main_reduced = 2642 # TEUs/h
capacity_alt = 1902 # TEUs/h
arrival_rate_total = 2423 # TEUs/h
maintenance_duration = 0.9756413519577939 # h
alt_berth_extra_time = 0.1161554284831396 # h
diversion_options = [0.1, 0.3, 0.5, 0.7] # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option ---
option_delays = {}
option_feasible = {}

for k in range(num_options):
    p_k = diversion_options[k]
    flow_alt_k = arrival_rate_total * p_k
    flow_main_k = arrival_rate_total * (1 - p_k)

    # 1. Check Alternative Berth Capacity Feasibility
    if flow_alt_k > capacity_alt + EPSILON:
        option_feasible[k] = False
        option_delays[k] = LARGE_DELAY
        continue

    option_feasible[k] = True

    # 2. Calculate Alternative Berth Delay
    delay_alt_k = flow_alt_k * maintenance_duration * alt_berth_extra_time

    # 3. Calculate Main Berth Queue Delay
    delay_queue_main_k = 0
    max_queue_main_k = 0

    if flow_main_k > capacity_main_reduced + EPSILON:
        max_queue_main_k = (flow_main_k - capacity_main_reduced) * maintenance_duration
        if flow_main_k >= capacity_main_normal - EPSILON:
            delay_queue_main_k = LARGE_DELAY
        else:
            dissipation_rate_k = capacity_main_normal - flow_main_k
            if dissipation_rate_k < EPSILON:
                 delay_queue_main_k = LARGE_DELAY
            else:
                 dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                 total_influence_time_k = maintenance_duration + dissipation_time_main_k
                 delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

    # 4. Calculate Total Delay for this option
    total_delay_k = delay_alt_k + delay_queue_main_k
    option_delays[k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("Port_BerthingStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
feasible_indices = [k for k in range(num_options) if option_feasible[k]]
if not feasible_indices:
     exit()

m.addConstr(gp.quicksum(y[k] for k in feasible_indices) == 1, name="SelectOneFeasibleOption")

for k in range(num_options):
    if not option_feasible[k]:
        m.addConstr(y[k] == 0, name="ForbidInfeasibleOption_{0}".format(k))

# --- Objective Function ---
m.setObjective(gp.quicksum(y[k] * option_delays[k] for k in feasible_indices), GRB.MINIMIZE)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    chosen_option_index = -1
    chosen_diversion_ratio = -1.0
    for k in range(num_options):
        if k in feasible_indices and y[k].X > 0.5:
            chosen_option_index = k
            chosen_diversion_ratio = diversion_options[k]
            break

    if chosen_option_index != -1:
         print("Optimal Diversion Option: Index {0}, Ratio {1:.0f}%".format(chosen_option_index, chosen_diversion_ratio*100))
```
Answer:
Optimal Diversion Option: Index 0, Ratio 10%



================================================================================



--- Problem 346 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A busy container terminal is managed by a three-phase crane scheduling system, where each phase must allocate operational time to different loading and unloading tasks while minimizing overall delay. The terminal manager faces the challenge of balancing operational times across these phases to ensure smooth operations without exceeding the strict cycle time of 43 minutes. Each phase serves a distinct task with varying demand intensities: Phase 1 handles the heaviest flow (2,697 containers per hour), followed by Phase 2 (2,432), and Phase 3 (1,671). The operational time for each phase cannot drop below 12 minutes or exceed 43 minutes, and the sum of all operational times must exactly match the cycle time. The core question is: *How should the 43-minute cycle be distributed among the three phases to minimize the total delay experienced by all containers?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( t_i \) represent the operational time (in minutes) allocated to phase \( i \), where \( i \in \{1, 2, 3\} \). Each \( t_i \) is a continuous variable bounded between 12 and 43.  
   - **2. Parameters:**  
     - \( \text{flow_coeffs} = [2697, 2432, 1671] \): Container flow coefficients for each phase.  
     - \( \text{cycle_time} = 43 \): Total fixed cycle duration (minutes).  
     - \( \text{lb_time} = 12 \), \( \text{ub_time} = 43 \): Lower/upper bounds for operational times.  
   - **3. Objective Function:**  
     - Minimize the total delay: \( \sum_{i=1}^3 \text{flow_coeffs}_i \times (\text{cycle_time} - t_i) \).  
   - **4. Constraints:**  
     - Total operational time must equal the cycle: \( t_1 + t_2 + t_3 = 43 \).  
     - Bounds: \( 12 \leq t_i \leq 43 \) for all \( i \).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 3
lb_time = 12          # Lower bound for operational time
ub_time = 43          # Upper bound for operational time
cycle_time = 43       # Total cycle time (set equal to ub_time)
flow_coeffs = [2697, 2432, 1671] # Container flow coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Crane Scheduling", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for phase i is proportional to flow * red_time = flow * (cycle_time - green_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of operational times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal operational times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
Optimal total delay: 191921.00
------------------------------
Optimal operational times (minutes):
  t1: 19.00, t2: 12.00, t3: 12.00



================================================================================



--- Problem 347 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
At a busy port, the operations manager faces the critical task of managing limited berthing time to maximize ship throughput while ensuring fair allocation between two docks. The port operates on a fixed cycle length of 113 minutes, with 30 minutes lost to transition phases (e.g., moving cranes), leaving only 83 minutes of effective berthing time to split between the docks. Dock A has a demand surge of 1,096 ships per day, while Dock B has a lighter demand of 516 ships per day. Each dock can process up to 1,527 ships per day under ideal conditions. The challenge is to allocate berthing time *precisely*—balancing capacity constraints against actual demand—while ensuring throughput proportions match demand ratios to prevent congestion imbalances. The core question: *How should the 83 minutes of berthing time be divided between the docks to maximize total throughput without exceeding dock capacities or violating demand proportionality?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `g_a`: Berthing time allocated to Dock A (min), continuous ≥ 0.  
     - `g_b`: Berthing time allocated to Dock B (min), continuous ≥ 0.  
     - `t_a`: Dock A throughput (ships/day), continuous ≥ 0.  
     - `t_b`: Dock B throughput (ships/day), continuous ≥ 0.  

   - **2. Parameters:**  
     - Cycle length = 113 min; lost time = 30 min → Effective berthing = 83 min.  
     - Dock capacity rate = 1,527 ships/day → Capacity factor = 1,527/1,440 ships/min.  
     - Demands: Dock A = 1,096 ships/day; Dock B = 516 ships/day.  

   - **3. Objective Function:**  
     Maximize total throughput: `t_a + t_b`.  

   - **4. Constraints:**  
     - Total berthing time: `g_a + g_b = 83`.  
     - Dock capacity limits:  
       `t_a ≤ (1,527/1,440) * g_a * 1,440` (converted to ships/day).  
       `t_b ≤ (1,527/1,440) * g_b * 1,440`.  
     - Demand limits: `t_a ≤ 1,096`, `t_b ≤ 516`.  
     - Proportional flow: `t_a * 516 = t_b * 1,096` (ensures throughput ratios match demand ratios).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
cycle_length_min = 113; lost_time_min = 30; dock_capacity_ships_per_day = 1527
demand_a_ships_per_day = 1096; demand_b_ships_per_day = 516
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    effective_berthing_total = cycle_length_min - lost_time_min
    if effective_berthing_total < 1e-6: raise ValueError("Effective berthing time is non-positive")
    capacity_factor = dock_capacity_ships_per_day / 1440 if 1440 > 1e-6 else 0
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m13 = gp.Model("Port_Berthing_Flow_LP", env=env)
    # Vars
    g_a = m13.addVar(name="berthing_a", lb=0); g_b = m13.addVar(name="berthing_b", lb=0)
    t_a = m13.addVar(name="throughput_a", lb=0); t_b = m13.addVar(name="throughput_b", lb=0)
    # Objective
    m13.setObjective(t_a + t_b, sense=GRB.MAXIMIZE)
    # Constraints
    m13.addConstr(g_a + g_b == effective_berthing_total, "total_berthing_time")
    m13.addConstr(t_a <= capacity_factor * g_a, "a_capacity_limit")
    m13.addConstr(t_b <= capacity_factor * g_b, "b_capacity_limit")
    m13.addConstr(t_a <= demand_a_ships_per_day, "a_demand_limit")
    m13.addConstr(t_b <= demand_b_ships_per_day, "b_demand_limit")
    # Proportional flow constraint (handle division by zero)
    if demand_a_ships_per_day > 1e-6 and demand_b_ships_per_day > 1e-6:
         m13.addConstr(t_a * demand_b_ships_per_day == t_b * demand_a_ships_per_day, "proportional_flow")
    elif demand_a_ships_per_day <= 1e-6: m13.addConstr(t_a == 0, "zero_demand_a") # Force zero throughput if zero demand
    elif demand_b_ships_per_day <= 1e-6: m13.addConstr(t_b == 0, "zero_demand_b") # Force zero throughput if zero demand
    # Optimize
    m13.optimize()
    # Store results
    results_dict['status'] = m13.status
    if m13.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m13.objVal; results_dict['g_a_opt'] = g_a.X; results_dict['g_b_opt'] = g_b.X
        results_dict['t_a_opt'] = t_a.X; results_dict['t_b_opt'] = t_b.X
    # Output Results
    print("--- Problem 13: Port Berthing Management (LP) ---")
    if m13.status == GRB.OPTIMAL:
        ga = results_dict.get('g_a_opt',0); gb = results_dict.get('g_b_opt',0)
        ta = results_dict.get('t_a_opt',0); tb = results_dict.get('t_b_opt',0)
        print(f"Optimization Status: Optimal")
        print(f"Optimal Dock A Berthing Time (g_a): {ga:.1f} min"); print(f"Optimal Dock B Berthing Time (g_b): {gb:.1f} min")
        print(f"Total Effective Berthing: {ga + gb:.1f} / {effective_berthing_total} min")
        print(f"Maximized Dock A Throughput (t_a): {ta:.1f} ships/day (Demand: {demand_a_ships_per_day})")
        print(f"Maximized Dock B Throughput (t_b): {tb:.1f} ships/day (Demand: {demand_b_ships_per_day})")
        print(f"Total Maximized Throughput: {m13.objVal:.1f} ships/day")
        prop_a = ta / demand_a_ships_per_day if demand_a_ships_per_day > 1e-6 else 0
        prop_b = tb / demand_b_ships_per_day if demand_b_ships_per_day > 1e-6 else 0
        if abs(prop_a - prop_b) < 1e-4: print(f"Flow is proportional to demand.")
        else: print(f"Flow proportionality check: A={prop_a:.3f}, B={prop_b:.3f}")
    elif m13.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    else: print(f"Optimization Status: {m13.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_BERTHING
```
Answer:
--- Problem 13: Port Berthing Management (LP) ---
Optimization Status: Optimal
Optimal Dock A Berthing Time (g_a): 56.4 min
Optimal Dock B Berthing Time (g_b): 26.6 min
Total Effective Berthing: 83.0 / 83 min
Maximized Dock A Throughput (t_a): 59.8 ships/day (Demand: 1096)
Maximized Dock B Throughput (t_b): 28.2 ships/day (Demand: 516)
Total Maximized Throughput: 88.0 ships/day
Flow is proportional to demand.



================================================================================



--- Problem 348 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy truck depot is facing the challenge of maximizing its daily revenue while operating within a strict time constraint. The depot has a list of nine trucks (labeled 0 through 8) waiting to be serviced, each with unique characteristics: some are quick to service but yield modest profits, while others require more time but promise higher returns. For instance, Truck 1 demands 41 minutes of service time but contributes a hefty $73 to the revenue, whereas Truck 4 takes just 8 minutes but only brings in $21. The depot operates under a tight schedule—its total available service window is just 202 minutes.  

   The core challenge lies in selecting the optimal subset of trucks to service, ensuring their combined service times fit within the 202-minute limit while maximizing total revenue. Additionally, the depot enforces a strict first-come-first-served policy: trucks must be serviced in the order they arrived (0, 1, 2, ..., 8). If a truck is skipped, the next one cannot start until the previous one’s service is completed—unless it’s also skipped. The manager must
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `x[i]` for each truck `i`: 1 if truck `i` is serviced, 0 otherwise.  
   - Continuous variable `s[i]`: Start time of service for truck `i` (if serviced).  
   - Continuous variable `C[i]`: Completion time of service for truck `i` (if serviced).  

   **2. Parameters:**  
   - `service_times[i]`: Time required to service truck `i` (e.g., 11 minutes for Truck 0).  
   - `revenues[i]`: Revenue earned from servicing truck `i` (e.g., $33 for Truck 0).  
   - `time_horizon = 202`: Total available service time in minutes.  
   - `M = 366`: A large constant ("Big-M") to enforce logical constraints.  

   **3. Objective Function:**  
   Maximize total revenue:  
   `Maximize: sum(revenues[i] * x[i] for all trucks i)`  

   **4. Constraints:**  
   - **Time Limit:** If serviced (`x[i] = 1`), completion time `C[i]` must not exceed 202 minutes.  
     `C[i] ≤ time_horizon + M * (1 - x[i])` for all `i`.  
   - **Start/Completion Time Definition:**  
     - If `x[i] = 0`, force `s[i] = 0` and `C[i] = 0`:  
       `s[i] ≤ M * x[i]`, `C[i] ≤ M * x[i]`.  
     - If `x[i] = 1`, ensure `C[i] = s[i] + service_times[i]`:  
       `C[i] ≥ s[i] + service_times[i] - M * (1 - x[i])`,  
       `C[i] ≤ s[i] + service_times[i] + M * (1 - x[i])`.  
   - **Sequencing:** For consecutive trucks `i-1` and `i`, if both are serviced, `i` cannot start until `i-1` finishes:  
     `s[i] ≥ C[i-1] - M * (1 - x[i])`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [0, 1, 2, 3, 4, 5, 6, 7, 8]
service_times = {0: 11, 1: 41, 2: 15, 3: 44, 4: 8, 5: 8, 6: 13, 7: 8, 8: 15} # Dict truck: time
revenues = {0: 33, 1: 73, 2: 22, 3: 65, 4: 21, 5: 40, 6: 21, 7: 38, 8: 23}     # Dict truck: revenue
time_horizon = 202 # minutes
M = 366 # Big M
# --- End Parameters ---

GUROBI_TIME_LIMIT = 60

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("TRUCK_DEPOT_SCHEDULING", env=env)

    # --- Basic Input Validation ---
    if not trucks:
        raise ValueError("Empty trucks list")

    # --- Decision Variables ---
    # x[i] = 1 if truck i is served, 0 otherwise
    x = m.addVars(trucks, vtype=GRB.BINARY, name="x")
    # C[i] = completion time of truck i (if served)
    C = m.addVars(trucks, vtype=GRB.CONTINUOUS, lb=0, name="C")
    # s[i] = start time of truck i (if served)
    s = m.addVars(trucks, vtype=GRB.CONTINUOUS, lb=0, name="s")

    # --- Objective Function: Maximize total revenue ---
    m.setObjective(gp.quicksum(revenues.get(i, 0) * x[i] for i in trucks), GRB.MAXIMIZE)

    # --- Constraints ---
    # Completion time within horizon if served (Relax if not served using Big-M)
    m.addConstrs((C[i] <= time_horizon + M * (1 - x[i]) for i in trucks), "TimeLimit")

    # Start and Completion time definition & relationship (only if x[i]=1)
    # If x[i]=0, force s[i]=0 and C[i]=0
    m.addConstrs((s[i] <= M * x[i] for i in trucks), "StartZero")
    m.addConstrs((C[i] <= M * x[i] for i in trucks), "CompletionZero")
    # If x[i]=1, ensure C[i] >= s[i] + service_time[i]
    m.addConstrs((C[i] >= s[i] + service_times.get(i, 0) - M * (1 - x[i]) for i in trucks), "CompletionDefLower")
    # If x[i]=1, ensure C[i] <= s[i] + service_time[i] (optional, prevents C[i] being arbitrarily large)
    m.addConstrs((C[i] <= s[i] + service_times.get(i, 0) + M * (1 - x[i]) for i in trucks), "CompletionDefUpper")

    # Sequencing constraint (assuming fixed sequence 0, 1, 2...)
    # Truck i can only start after truck i-1 is completed, *if both are served*
    # Original model assumes fixed sequence, implement that.
    if trucks: # Check list not empty
        # s[0] >= 0 (handled by lb=0)
        # C[0] definition handled above
        for i in range(1, len(trucks)):
            # If x[i]=1, then s[i] >= C[i-1]. Use Big-M.
            # s[i] must be >= C[i-1] if x[i]=1.
            # s[i] >= C[i-1] - M*(1-x[i])
            # This forces s[i] >= C[i-1] if x[i]=1. If x[i]=0, s[i]>=C[i-1]-M (redundant).
            m.addConstr(s[i] >= C[i-1] - M * (1 - x[i]), f"Seq_{i}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output
        # results_dict['C_sol'] = m.getAttr('X', C) # Not needed for output
        # results_dict['s_sol'] = m.getAttr('X', s) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible") # Matches example
    elif m.Status == GRB.TIME_LIMIT:
         print(f"Optimization ended with status {m.Status}") # Matches example's generic else
    else: # Other statuses
        print(f"Optimization ended with status {m.Status}") # Matches example's generic else

except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the decision variables and schedules
if m.Status == GRB.OPTIMAL:
    obj_val_print = results_dict.get('obj_val', 'N/A')
    if isinstance(obj_val_print, (int, float)):
        print(f"Optimal objective value: {obj_val_print:.2f}")
    
    # Print the selected trucks and their start and completion times
    for i in trucks:
        if x[i].X > 0.5:
            print(f"Truck {i} is serviced: Start time = {s[i].X:.2f}, Completion time = {C[i].X:.2f}")
        else:
            print(f"Truck {i} is not serviced")
```
Answer:
Optimal objective value: 336.00
Optimal objective value: 336.00
Truck 0 is serviced: Start time = 0.00, Completion time = 11.00
Truck 1 is serviced: Start time = 11.00, Completion time = 52.00
Truck 2 is serviced: Start time = 52.00, Completion time = 67.00
Truck 3 is serviced: Start time = 67.00, Completion time = 111.00
Truck 4 is serviced: Start time = 111.00, Completion time = 119.00
Truck 5 is serviced: Start time = 119.00, Completion time = 127.00
Truck 6 is serviced: Start time = 127.00, Completion time = 140.00
Truck 7 is serviced: Start time = 140.00, Completion time = 148.00
Truck 8 is serviced: Start time = 148.00, Completion time = 163.00


```

================================================================================



--- Problem 349 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
In a busy port, the maritime logistics team faces the challenge of managing ship berthing at two key docks. The scenario involves a total of **2,246 ships per day** arriving at the port. The port consists of three key segments: **Dock A→B** (capacity: 2,047 ships/day), **Dock A→C** (capacity: 1,571 ships/day), and **Dock C→B** (capacity: 2,435 ships/day). The primary bottleneck is segment **A→B**, where the demand risks exceeding capacity, potentially causing delays. To mitigate this, the team must reroute excess flow through the alternative path **A→C→B** while respecting all dock capacities. The goal is to minimize any overflow on **A→B**—ensuring the system operates as efficiently as possible without exceeding physical limits. The central question is: *How should the ship flow be distributed between these routes to achieve zero overflow on the congested link while fully utilizing available capacities?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `f_AB`: Flow (ships/day) from **A→B**.  
   - `f_AC`: Flow (ships/day) from **A→C**.  
   - `f_CB`: Flow (ships/day) from **C→B**.  
   - `overflow_AB`: Excess flow (ships/day) beyond capacity on **A→B** (minimized).  

   **2. Parameters:**  
   - `total_flow_originating_A = 2,246` ships/day.  
   - Segment capacities: `AB = 2,047`, `AC = 1,571`, `CB = 2,435` ships/day.  

   **3. Objective Function:**  
   Minimize the overflow on **A→B**:  
   ```  
   Minimize: overflow_AB  
   ```  

   **4. Constraints:**  
   - **Flow conservation at A:** `f_AB + f_AC = 2,246`.  
   - **Flow conservation at C:** `f_AC = f_CB`.  
   - **Overflow calculation for A→B:** `f_AB ≤ 2,047 + overflow_AB`.  
   - **Capacity limits:**  
     - `f_AC ≤ 1,571` (A→C).  
     - `f_CB ≤ 2,435` (C→B).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_flow_originating_A = 2246 # ships/day
capacity = {'AB': 2047, 'AC': 1571, 'CB': 2435} # Dict segment: capacity (ships/day)
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m33 = gp.Model("SHIP_BERTHING_LP", env=env)

    # --- Decision Variables ---
    # Flows on each segment
    f_AB = m33.addVar(name="flow_A_B", lb=0)
    f_AC = m33.addVar(name="flow_A_C", lb=0)
    f_CB = m33.addVar(name="flow_C_B", lb=0)
    # Overflow variable for the congested link AB
    overflow_AB = m33.addVar(name="overflow_A_B", lb=0)

    # --- Objective Function ---
    # Minimize the overflow on segment A->B
    m33.setObjective(overflow_AB, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Total flow conservation leaving node A
    m33.addConstr(f_AB + f_AC == total_flow_originating_A, name="flow_out_A")

    # Constraint 2: Flow conservation at node C
    m33.addConstr(f_AC == f_CB, name="flow_at_C")

    # Constraint 3: Calculate overflow for A->B link
    # overflow = max(0, f_AB - capacity_AB)
    cap_ab = capacity.get('AB', 0) # Get capacity safely
    m33.addConstr(f_AB <= cap_ab + overflow_AB, name="overflow_calc")

    # Constraint 4: Capacity constraint for A->C link
    cap_ac = capacity.get('AC', 0)
    m33.addConstr(f_AC <= cap_ac, name="capacity_AC")

    # Constraint 5: Capacity constraint for C->B link
    cap_cb = capacity.get('CB', 0)
    m33.addConstr(f_CB <= cap_cb, name="capacity_CB")

    # --- Optimization ---
    m33.optimize()

    # --- Store results ---
    results_dict['status'] = m33.status
    if m33.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m33.ObjVal # = overflow_AB.X
        results_dict['f_AB_sol'] = f_AB.X
        results_dict['f_AC_sol'] = f_AC.X
        results_dict['f_CB_sol'] = f_CB.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 33: Ship Berthing Rerouting (LP) ---") # Original problem number
    if m33.status == GRB.OPTIMAL:
        overflow_sol = results_dict.get('obj_val', 'N/A')
        f_ab_sol = results_dict.get('f_AB_sol', 'N/A')
        f_ac_sol = results_dict.get('f_AC_sol', 'N/A')
        f_cb_sol = results_dict.get('f_CB_sol', 'N/A')
        cap_ab_print = capacity.get('AB', 'N/A')
        cap_ac_print = capacity.get('AC', 'N/A')
        cap_cb_print = capacity.get('CB', 'N/A')

        print(f"Optimization Status: Optimal")
        # Format numerical output
        print(f"Minimum Overflow on A->B: {float(overflow_sol):.1f} ships/day")
        print("Optimal Flow Distribution:")
        print(f"  Flow A -> B: {float(f_ab_sol):.1f} (Capacity: {cap_ab_print})")
        print(f"  Flow A -> C: {float(f_ac_sol):.1f} (Capacity: {cap_ac_print})")
        print(f"  Flow C -> B: {float(f_cb_sol):.1f} (Capacity: {cap_cb_print})")
        # Check total flow matches original
        total_flow_out = float(f_ab_sol) + float(f_ac_sol) if isinstance(f_ab_sol, (int, float)) and isinstance(f_ac_sol, (int, float)) else 'N/A'
        print(f"Total Flow from A: {total_flow_out:.1f} (Initial: {total_flow_originating_A})")

    elif m33.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible. Check capacities vs total flow.")
         print(f"Total Flow: {total_flow_originating_A}, Capacity AC+CB path: {capacity.get('AC', 0) + capacity.get('CB', 0)}?") # Simple check example
    else:
        print(f"Optimization Status: {m33.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 33: Ship Berthing Rerouting (LP) ---
Optimization Status: Optimal
Minimum Overflow on A->B: 0.0 ships/day
Optimal Flow Distribution:
  Flow A -> B: 675.0 (Capacity: 2047)
  Flow A -> C: 1571.0 (Capacity: 1571)
  Flow C -> B: 1571.0 (Capacity: 2435)
Total Flow from A: 2246.0 (Initial: 2246)


```

================================================================================



--- Problem 350 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
A logistics company is tasked with efficiently loading a set of five packages with varying weights (42, 93, 58, 12, and 89 units) onto a selection of eight available trucks. Each truck has a unique capacity and associated cost, defined as pairs: (94, $22), (99, $19), (98, $68), (95, $44), (98, $63), (95, $33), (100, $4), and (95, $91). The challenge is to assign each package to exactly one truck while respecting the truck capacities and minimizing the total cost incurred from using the trucks. The goal is to find the most cost-effective loading strategy, ensuring no truck exceeds its capacity and that all packages are placed.

The core question is: **What is the optimal assignment of packages to trucks that minimizes the total cost while satisfying all capacity constraints?**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether package `i` is assigned to truck `j` (1 if assigned, 0 otherwise).  
   - `y[j]`: Binary variable indicating whether truck `j` is used (1 if used, 0 otherwise).  

   **2. Parameters:**  
   - `packages[i]`: Weight of package `i` (values: [42, 93, 58, 12, 89]).  
   - `trucks[j]`: Tuple `(capacity, cost)` for truck `j` (values: [(94, 22), (99, 19), ..., (95, 91)]).  

   **3. Objective Function:**  
   Minimize the total cost of used trucks:  
   \[
   \text{Minimize: } \sum_{j} y[j] \times \text{trucks}[j][1]
   \]  

   **4. Constraints:**  
   - **Package Assignment:** Each package must be assigned to exactly one truck:  
     \[
     \sum_{j} x[i, j] = 1 \quad \forall i
     \]  
   - **Truck Capacity:** The total weight of packages in a truck must not exceed its capacity (if the truck is used):  
     \[
     \sum_{i} \text{packages}[i] \times x[i, j] \leq \text{trucks}[j][0] \times y[j] \quad \forall j
     \]  
   - **Linking Constraint:** A package can only be assigned to a truck if the truck is used:  
     \[
     x[i, j] \leq y[j] \quad \forall i, j
     \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys # Make sys available inside exec if needed, e.g. for print traceback
import traceback

# --- Data Definition (Embedded) ---
packages = [42, 93, 58, 12, 89]      # Package weights
trucks = [(94, 22), (99, 19), (98, 68), (95, 44), (98, 63), (95, 33), (100, 4), (95, 91)]        # List of (Capacity, Cost) tuples
num_packages = 5       # len(packages)
num_trucks = 8         # len(trucks)
# --- End Data Definition ---

# Time limit (passed from outer scope via globals if needed, or hardcoded)
GUROBI_TIME_LIMIT = 60

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Keep output clean for saving
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Cost-Sensitive Truck Loading", env=env)

    # --- Decision Variables ---
    x = model.addVars(num_packages, num_trucks, vtype=GRB.BINARY, name="x")
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")

    # --- Objective: Minimize total cost ---
    model.setObjective(gp.quicksum(y[j] * trucks[j][1] for j in range(num_trucks)), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Each package assignment
    for i in range(num_packages):
        model.addConstr(x.sum(i, '*') == 1, name=f"Package_{i}_Assignment")

    # 2. Truck capacity
    for j in range(num_trucks):
        truck_capacity = trucks[j][0]
        if truck_capacity < 0: truck_capacity = 0
        model.addConstr(gp.quicksum(packages[i] * x[i, j] for i in range(num_packages)) <= truck_capacity * y[j], name=f"Truck_{j}_Capacity")

    # 3. Linking package to truck usage
    for i in range(num_packages):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Package_{i}_Triggers_Truck_{j}")

    # --- Solve ---
    # print("Solving CS-TL instance...") # Comment out or keep for debug inside output
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal

    # --- Output results (This will be captured) ---
    # This logic needs to be *inside* the template now
    if model.status == GRB.OPTIMAL:
        print(f"Minimum cost: ${model.objVal:.2f}") # Use model.objVal directly
        print("-" * 30) # Add separator for clarity
        printed_truck_count = 0
        for j in range(num_trucks):
            # Use try-except for safety when accessing .X
            try:
                 if y[j].x > 0.5:
                     printed_truck_count += 1
                     truck_capacity_out, truck_cost_out = trucks[j]
                     assigned_packages = [i for i in range(num_packages) if x[i, j].x > 0.5]
                     truck_load_out = sum(packages[i] for i in assigned_packages)
                     # Format output exactly as desired for the log file
                     print(f"Truck {printed_truck_count} (Type Index {j}, Capacity: {truck_capacity_out}, Cost: ${truck_cost_out:.2f}):")
                     print(f"  Load: {truck_load_out} / {truck_capacity_out}")
                     print(f"  Packages (indices): {sorted(assigned_packages)}") # Sort for consistency
                     print("-" * 10) # Separator between trucks
            except AttributeError:
                 pass # Ignore trucks not used or if .X attribute missing
    elif model.status == GRB.TIME_LIMIT:
        print("\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: ${model.ObjVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {model.status}")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}") # Print errors to captured output
    results_dict['status'] = -1 # Use dict to signal error type to main loop
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:") # Print errors
    traceback.print_exc(file=sys.stdout) # Print traceback to captured stdout
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Minimum cost: $78.00
------------------------------
Truck 1 (Type Index 0, Capacity: 94, Cost: $22.00):
  Load: 89 / 94
  Packages (indices): [4]
----------
Truck 2 (Type Index 1, Capacity: 99, Cost: $19.00):
  Load: 93 / 99
  Packages (indices): [1]
----------
Truck 3 (Type Index 5, Capacity: 95, Cost: $33.00):
  Load: 12 / 95
  Packages (indices): [3]
----------
Truck 4 (Type Index 6, Capacity: 100, Cost: $4.00):
  Load: 100 / 100
  Packages (indices): [0, 2]
----------


```

================================================================================



--- Problem 351 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
At a busy port, the operations team is tasked with coordinating the berthing of ships at four different docks to minimize the total waiting time for all vessels. Each dock can handle a specific number of ships per hour, with varying capacities—817, 1274, 782, and 575 ships per hour for docks 1 through 4, respectively. The berthing schedule must adhere to strict timing rules: each dock's berthing time cannot be less than 15 minutes or more than 78 minutes, and the total berthing cycle—the sum of all berthing times—must exactly match the upper limit of 78 minutes. Waiting times increase when ships are idle, so the team aims to allocate berthing time strategically, prioritizing docks with higher ship traffic. The core question is: *How should the 78-minute cycle be divided among the four docks to minimize the total waiting time across all approaching ships?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Let \( t_i \) represent the berthing time (in minutes) allocated to dock \( i \), where \( i \in \{1, 2, 3, 4\} \). Each \( t_i \) is a continuous variable bounded between 15 and 78 minutes.  
   - **2. Parameters:**  
     - \( \text{ship_coeffs} = [817, 1274, 782, 575] \): Ship arrival rates (ships/hour) for each dock.  
     - \( \text{cycle_time} = 78 \): Fixed total cycle duration (minutes).  
     - \( \text{lb_time} = 15 \), \( \text{ub_time} = 78 \): Lower/upper bounds for berthing times.  
   - **3. Objective Function:**  
     Minimize the total waiting time:  
     \[
     \text{Minimize: } \sum_{i=1}^4 \text{ship_coeffs}_i \times (\text{cycle_time} - t_i)
     \]  
     Here, \( (\text{cycle_time} - t_i) \) is the waiting time for dock \( i \), and waiting time is assumed proportional to ship volume and waiting time.  
   - **4. Constraints:**  
     - **Total cycle constraint:** \( t_1 + t_2 + t_3 + t_4 = 78 \).  
     - **Bounds:** \( 15 \leq t_i \leq 78 \) for all \( i \).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_docks = 4
lb_time = 15          # Lower bound for berthing time
ub_time = 78          # Upper bound for berthing time
cycle_time = 78   # Total cycle time (set equal to ub_time)
ship_coeffs = [817, 1274, 782, 575] # Ship arrival coefficients per dock
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(ship_coeffs) != num_docks:
    print("Error: ship_coeffs length mismatch with num_docks")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: ship_coeffs length"
    # raise ValueError("ship_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_docks}-Dock Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_docks) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_docks, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for dock i is proportional to ship * waiting_time = ship * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(ship_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_docks)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_docks)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_docks)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_docks):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 194292.00
------------------------------
Optimal berthing times (minutes):
  t1: 15.00, t2: 33.00, t3: 15.00, t4: 15.00


```

================================================================================



--- Problem 352 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy maritime port, seven cargo ships arrive at varying times, each requiring a berth for unloading and processing. The port operates two berths, and the challenge is to assign each ship to a berth and schedule their start times to minimize the total time all ships spend in port (from arrival to departure). The ships arrive at hours 5, 8, 12, 16, 20, 25, and 30, respectively, and their processing times range from 3 to 7 hours. The port manager must ensure that no two ships assigned to the same berth overlap in their processing times, respecting their arrival times. Additionally, the port has a policy that no ship should wait more than 4 hours after its arrival before starting the unloading process. The goal is to find the optimal assignment and scheduling that minimizes the cumulative time all ships spend docked, balancing efficiency and resource constraints.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable indicating whether ship `i` is assigned to berth `j`.  
   - `start_time(i)`: Continuous variable representing the start time of ship `i`'s processing.  
   - `completion_time(i)`: Continuous variable representing the completion time of ship `i`'s processing.  
   - `precedes(i, k, j)`: Binary variable indicating whether ship `i` precedes ship `k` at berth `j`.  

   **2. Parameters:**  
   - `ships`: List of ships `[1, 2, 3, 4, 5, 6, 7]`.  
   - `berths`: List of berths `[1, 2]`.  
   - `arrival_times`: Dictionary mapping ships to their arrival times (e.g., `{1: 5, 2: 8, ...}`).  
   - `processing_times`: Dictionary mapping ships to their processing times (e.g., `{1: 3, 2: 6, ...}`).  
   - `H`: A large constant (100) used for logical constraints.  
   - `max_wait_time`: Maximum waiting time for any ship (4 hours).

   **3. Objective Function:**  
   Minimize the total time ships spend in port:  
   `Minimize: sum(completion_time(i) - arrival_times(i) for all ships i)`.  

   **4. Constraints:**  
   - Each ship must be assigned to exactly one berth:  
     `sum(assign(i, j) for all j) = 1` for each ship `i`.  
   - Start time of a ship cannot be earlier than its arrival time:  
     `start_time(i) >= arrival_times(i)` for each ship `i`.  
   - Completion time is the sum of start time and processing time:  
     `completion_time(i) = start_time(i) + processing_times(i)` for each ship `i`.  
   - Non-overlapping constraints for ships assigned to the same berth:  
     If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
     If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.  
     Logical linking of assignment and precedence:  
     `assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))`.  
   - Maximum waiting time constraint:  
     `start_time(i) - arrival_times(i) <= max_wait_time` for each ship `i`.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3, 4, 5, 6, 7]
berths = [1, 2]
arrival_times = {1: 5, 2: 8, 3: 12, 4: 16, 5: 20, 6: 25, 7: 30}
processing_times = {1: 3, 2: 6, 3: 7, 4: 5, 5: 6, 6: 4, 7: 3}
H = 100 # Big M
max_wait_time = 4 # Maximum waiting time for any ship
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_11_MIN_TOTAL_TIME")

    if not ships or not berths: raise ValueError("Empty ships or berths")

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in ships for k in ships if i < k for j in berths],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(completion_time[i] - arrival_times.get(i, 0) for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Maximum waiting time
    m.addConstrs((start_time[i] - arrival_times.get(i, 0) <= max_wait_time for i in ships), name="max_wait_time")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Total time in port
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Ensure All Outputs are Printed ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in ships:
        for j in berths:
            if assign[i, j].x > 0.5:
                print(f"Ship {i} is assigned to Berth {j}")
                print(f"  Start Time: {start_time[i].x:.2f}")
                print(f"  Completion Time: {completion_time[i].x:.2f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Infeasible
No optimal solution found.


```

================================================================================



--- Problem 353 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently loading a set of irregularly shaped items into standardized containers for shipping. The items vary significantly in size, with dimensions ranging from (1, 28) to (47, 38), and the containers have fixed dimensions of 50 units in width and 91 units in height. The challenge is to minimize the number of containers used while ensuring that no items overlap and all items fit entirely within their assigned containers.  

   The items include a mix of small, medium, and large objects, such as a tiny 1x28 unit item and a bulky 22x86 unit item. The company aims to optimize space utilization to reduce shipping costs and improve operational efficiency. The core question is: *What is the minimum number of containers required to pack all items without violating placement constraints, and how should the items be arranged within these containers?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether item `i` is assigned to container `j`.  
   - `y[j]`: Binary variable indicating whether container `j` is used.  
   - `px[i, j]`: Continuous variable representing the x-coordinate of the bottom-left corner of item `i` in container `j`.  
   - `py[i, j]`: Continuous variable representing the y-coordinate of the bottom-left corner of item `i` in container `j`.  
   - `left[i, k, j]`, `right[i, k, j]`, `below[i, k, j]`, `above[i, k, j]`: Binary variables enforcing non-overlapping constraints between items `i` and `k` in container `j`.  

   **2. Parameters:**  
   - `items`: List of item dimensions (e.g., `(14, 14)` for item 0).  
   - `container_size`: Fixed container dimensions `(50, 91)`.  
   - `num_items = 11`: Total number of items.  
   - `num_containers = 11`: Upper bound on containers (one per item).  

   **3. Objective Function:**  
   Minimize the total number of containers used:  
   \[
   \text{Minimize: } \sum_{j} y[j]
   \]  

   **4. Constraints:**  
   - **Item Assignment:** Each item must be assigned to exactly one container:  
     \[
     \sum_{j} x[i, j] = 1 \quad \forall i
     \]  
   - **Container Boundaries:** Items must fit within their assigned container:  
     \[
     px[i, j] + \text{item}_i\text{.width} \leq \text{container\_width} \quad \text{if } x[i, j] = 1  
     \]  
     \[
     py[i, j] + \text{item}_i\text{.height} \leq \text{container\_height} \quad \text{if } x[i, j] = 1  
     \]  
   - **Non-Overlapping:** Items in the same container must not overlap:  
     \[
     \text{left}[i, k, j] + \text{right}[i, k, j] + \text{below}[i, k, j] + \text{above}[i, k, j] \geq x[i, j] + x[k, j] - 1 \quad \forall i < k, j  
     \]  
   - **Container Activation:** A container is used if any item is assigned to it:  
     \[
     x[i, j] \leq y[j] \quad \forall i, j  
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
items = [(14, 14), (6, 45), (6, 65), (47, 38), (36, 11), (13, 1), (22, 86), (37, 15), (1, 28), (40, 25), (35, 9)]  # (width, height) of items
container_size = (50, 91)  # (width, height) of each container
num_items = 11 # len(items)
# Maximum containers needed (worst case: one item per container)
# Can sometimes be reduced with lower bounds, but num_items is safe
num_containers = num_items
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using container dimensions is common and valid)
M_w = container_size[0]
M_h = container_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Container Packing", env=env)

# --- Decision Variables ---
# x[i,j]: item i assigned to container j
x = model.addVars(num_items, num_containers, vtype=GRB.BINARY, name="x")
# y[j]: container j is used
y = model.addVars(num_containers, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of item i if in container j
px = model.addVars(num_items, num_containers, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_items, num_containers, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of items *within the same container*
left  = model.addVars(num_items, num_items, num_containers, vtype=GRB.BINARY, name="left")
right = model.addVars(num_items, num_items, num_containers, vtype=GRB.BINARY, name="right")
below = model.addVars(num_items, num_items, num_containers, vtype=GRB.BINARY, name="below")
above = model.addVars(num_items, num_items, num_containers, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of containers used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_containers))

# --- Constraints ---

# 1. Each item must be assigned to exactly one container
for i in range(num_items):
    model.addConstr(x.sum(i, '*') == 1, name=f"Item_{i}_Assignment")

# 2. Item placement constraints within container boundaries (Big-M formulation)
for j in range(num_containers):
    for i in range(num_items):
        item_w, item_h = items[i] # Get dimensions for item i

        # Position variables must be 0 if item i is not in container j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Item's right edge <= container width IF item is placed in container (x[i,j]=1)
        model.addConstr(px[i, j] + item_w <= container_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Item's top edge <= container height IF item is placed in container (x[i,j]=1)
        model.addConstr(py[i, j] + item_h <= container_size[1] + M_h * (1 - x[i, j]), name=f"Height_Limit_{i}_{j}")

# 3. Non-overlapping constraints for items within the same container
for j in range(num_containers):
    for i in range(num_items):
        for k in range(i + 1, num_items): # Iterate over distinct pairs (i < k)
            item_i_w, item_i_h = items[i]
            item_k_w, item_k_h = items[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => item i is to the left of item k
            model.addConstr(px[i, j] + item_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => item i is to the right of item k (k is left of i)
            model.addConstr(px[k, j] + item_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => item i is below item k
            model.addConstr(py[i, j] + item_i_h <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => item i is above item k (k is below i)
            model.addConstr(py[k, j] + item_k_h <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH item i and item k are in container j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link item assignment to container usage: If any item i is in container j, then container j must be used (y[j]=1)
#    This can be done per item or aggregated. Per item is often tighter.
for j in range(num_containers):
    for i in range(num_items):
        model.addConstr(x[i, j] <= y[j], name=f"Item_Container_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_items * y[j], name=f"Container_Activation_{j}")


# --- Solve ---
print("Solving 2DCP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of containers used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    container_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_containers):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Container {j_sol + 1} (Used):")
            items_in_container_info = []
            for i_sol in range(num_items):
                if x[i_sol, j_sol].X > 0.5:
                    item_data = {
                        "id": i_sol,
                        "dims": items[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    items_in_container_info.append(item_data)
                    print(f"  Item {item_data['id']} {item_data['dims']} at {item_data['pos']}")
            container_details.append({'container_index': j_sol, 'items': items_in_container_info})
            print("-" * 10)
    results_dict['container_details'] = container_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 2DCP instance...
Gurobi Error code 10010: Model too large for size-limited license; visit https://gurobi.com/unrestricted for more information

Optimization finished with status: -1. No optimal solution found.


```

================================================================================



--- Problem 354 ---
**Difficulty:** easy
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with optimizing the delivery route for a single truck serving a small network of locations. The depot (node 0) is the starting and ending point, while node 1 represents a customer requiring a delivery of 58 units. The truck has a capacity of 71.9 units, ensuring it can handle the demand without exceeding its limit. The distance matrix reveals that traveling from the depot to the customer (node 1) takes 59 units of distance, and the return trip is equally costly. The challenge is to determine the most efficient route that visits the customer exactly once, respects the truck’s capacity, and returns to the depot while minimizing the total travel distance. The core question is: *What is the shortest possible route that fulfills the delivery demand without overloading the truck?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `x[i, j, k]`: Equals 1 if truck `k` travels directly from node `i` to node `j`; 0 otherwise.  
     - Continuous variable `u[i]`: Auxiliary variable for subtour elimination (MTZ constraint), ensuring node sequencing.  
   - **2. Parameters:**  
     - `N = 2`: Total nodes (depot + 1 customer).  
     - `K = 1`: Single truck available.  
     - `Q = [71.9]`: Truck capacity.  
     - `q = [0, 58]`: Demand at nodes (0 for depot, 58 for customer).  
     - `d[i][j]`: Distance matrix (e.g., `d[0][1] = 59`).  
   - **3. Objective Function:**  
     Minimize total distance:  
     \[
     \text{Minimize: } \sum_{k=0}^{K-1} \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} d[i][j] \cdot x[i,j,k] \quad (i \neq j)
     \]  
   - **4. Constraints:**  
     - **Visit Once:** Customer (node 1) must be visited exactly once.  
     - **Flow Conservation:** Inflow equals outflow for each node and truck.  
     - **Depot Departure/Return:** Truck must leave and return to the depot (node 0).  
     - **Capacity:** Total demand on the route ≤ truck capacity (71.9).  
     - **Subtour Elimination (MTZ):** Ensures no disjoint cycles (redundant here for `N=2`).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 2
K = 1
Q = [71.9]
q = [0, 58]
d = [
    [0, 59],
    [59, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Truck Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for truck {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for truck {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 118.00

Route for truck 1 (Capacity: 71.9):
0 -> 1 -> 0
Route Load: 58 / 71.9


```

================================================================================



--- Problem 355 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy maritime port, the logistics team faces a critical challenge: efficiently scheduling a fleet of 10 cargo ships at just 2 available berths. Each ship arrives at a specific time—Ship 1 at hour 3, Ship 2 at hour 8, and so on, with the last vessel, Ship 10, arriving at hour 26. The processing times vary significantly; for instance, Ship 1 requires 5 hours to unload, while Ship 7 needs 8 hours. The port authority aims to minimize the total delay in the system, defined as the sum of the delays for each ship. A ship's delay is calculated as the difference between its completion time and its ideal completion time (arrival time + processing time). The core question is: *What is the optimal schedule that minimizes the total delay for all ships, given their arrival and handling times?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable (1 if ship *i* is assigned to berth *j*, 0 otherwise).  
   - `start_time(i)`: Continuous variable for the time ship *i* begins processing.  
   - `completion_time(i)`: Continuous variable for the time ship *i* finishes (start time + processing time).  
   - `precedes(i, k, j)`: Binary variable (1 if ship *i* is scheduled before ship *k* on berth *j*).  
   - `berth_used(j)`: Binary variable (1 if berth *j* is used, 0 otherwise).  

   **2. Parameters:**  
   - `ships`: List of 10 ships (1 to 10).  
   - `berths`: List of 2 berths (1 and 2).  
   - `arrival_times`: Dictionary mapping ships to arrival times (e.g., Ship 1 arrives at hour 3).  
   - `processing_times`: Dictionary mapping ships to handling durations (e.g., Ship 1 takes 5 hours).  
   - `H`: A large constant (100) for linearization.  

   **3. Objective Function:**  
   Minimize the total delay:  
   `Minimize: sum(max(0, completion_time[i] - (arrival_times[i] + processing_times[i])) for i in ships)`.  

   **4. Constraints:**  
   - Each ship must be assigned to exactly one berth:  
     `For each ship i: sum(assign[i, j] for j in berths) = 1`.  
   - Ships cannot start before their arrival time:  
     `For each ship i: start_time[i] >= arrival_times[i]`.  
   - Completion time is start time plus processing time:  
     `For each ship i: completion_time[i] = start_time[i] + processing_times[i]`.  
   - No overlapping schedules on the same berth (enforced via precedence variables):  
     `For each berth j and ships i < k: If precedes[i, k, j] = 1, then start_time[k] >= completion_time[i]`.  
   - Berth usage linked to assignments:  
     `For each ship i and berth j: assign[i, j] <= berth_used[j]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

num_ships = 10
num_berths = 2

arrival_times = [3, 8, 10, 12, 14, 18, 20, 21, 24, 26]

processing_times = [5, 6, 4, 7, 5, 6, 8, 3, 4, 6]

m = gp.Model("ship_scheduling")

start = m.addVars(num_ships, name="start", lb=0)

berth = m.addVars(num_ships, vtype=GRB.BINARY, name="berth")

completion = m.addVars(num_ships, name="completion")

delay = m.addVars(num_ships, name="delay")

precedence = m.addVars(num_ships, num_ships, vtype=GRB.BINARY, name="precedence")

same_berth = m.addVars(num_ships, num_ships, vtype=GRB.BINARY, name="same_berth")

M = 1e5  

m.setObjective(gp.quicksum(delay[i] for i in range(num_ships)), GRB.MINIMIZE)

for i in range(num_ships):
    m.addConstr(start[i] >= arrival_times[i], name=f"release_{i}")

for i in range(num_ships):
    m.addConstr(completion[i] == start[i] + processing_times[i], name=f"completion_{i}")

for i in range(num_ships):
    m.addConstr(delay[i] >= completion[i] - (arrival_times[i] + processing_times[i]), name=f"delay_{i}")

for i in range(num_ships):
    for j in range(i+1, num_ships):
        m.addConstr(same_berth[i, j] >= berth[i] - berth[j])
        m.addConstr(same_berth[i, j] >= berth[j] - berth[i])
        m.addConstr(same_berth[i, j] <= 1 - (berth[i] - berth[j]))

        m.addConstr(start[i] + processing_times[i] <= start[j] + M * (1 - precedence[i, j] + (1 - same_berth[i, j])),
                    name=f"seq1_{i}_{j}")
        m.addConstr(start[j] + processing_times[j] <= start[i] + M * (precedence[i, j] + (1 - same_berth[i, j])),
                    name=f"seq2_{i}_{j}")

        m.addConstr(precedence[i, j] + precedence[j, i] <= 1 + (1 - same_berth[i, j]), name=f"pre_order_{i}_{j}")


m.setParam("OutputFlag", 1)
m.optimize()


if m.status == GRB.OPTIMAL:
    print("\nOptimal Schedule:")
    for i in range(num_ships):
        print(f"Ship {i+1}: Berth {int(berth[i].x)} | Start: {start[i].x:.1f} | Completion: {completion[i].x:.1f} | Delay: {delay[i].x:.1f}")
    print(f"\nTotal Delay: {m.objVal:.1f}")
else:
    print("No optimal solution found.")

# --- End of Supplemental Code Block ---
```
Answer:
Set parameter Username
Set parameter LicenseID to value 2635455
Academic license - for non-commercial use only - expires 2026-03-12
Set parameter OutputFlag to value 1
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (win64 - Windows 10.0 (19045.2))

CPU model: AMD Ryzen 7 4800H with Radeon Graphics, instruction set [SSE2|AVX|AVX2]
Thread count: 8 physical cores, 16 logical processors, using up to 16 threads

Optimize a model with 300 rows, 240 columns and 950 nonzeros
Model fingerprint: 0x64975cf5
Variable types: 30 continuous, 210 integer (210 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+05]
  Objective range  [1e+00, 1e+00]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 2e+05]
Found heuristic solution: objective 0.0000000

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 16 available processors)

Solution count 1: 0

Optimal solution found (tolerance 1.00e-04)
Best objective 0.000000000000e+00, best bound 0.000000000000e+00, gap 0.0000%

Optimal Schedule:
Ship 1: Berth 0 | Start: 3.0 | Completion: 8.0 | Delay: 0.0
Ship 2: Berth 0 | Start: 8.0 | Completion: 14.0 | Delay: 0.0
Ship 3: Berth 0 | Start: 10.0 | Completion: 14.0 | Delay: 0.0
Ship 4: Berth 0 | Start: 12.0 | Completion: 19.0 | Delay: 0.0
Ship 5: Berth 0 | Start: 14.0 | Completion: 19.0 | Delay: 0.0
Ship 6: Berth 0 | Start: 18.0 | Completion: 24.0 | Delay: 0.0
Ship 7: Berth 0 | Start: 20.0 | Completion: 28.0 | Delay: 0.0
Ship 8: Berth 0 | Start: 21.0 | Completion: 24.0 | Delay: 0.0
Ship 9: Berth 0 | Start: 24.0 | Completion: 28.0 | Delay: 0.0
Ship 10: Berth 0 | Start: 26.0 | Completion: 32.0 | Delay: 0.0

```

================================================================================



--- Problem 356 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy logistics hub, five delivery trucks arrive at staggered times, each requiring immediate unloading at one of the available depots. The hub has three depots, and the challenge is to efficiently assign trucks to depots to minimize their cumulative waiting time before unloading begins. Truck 1 arrives at 4 hours, followed by Truck 2 at 7 hours, Truck 3 at 10 hours, Truck 4 at 14 hours, and Truck 5 at 17 hours. Each truck has a fixed unloading time: Truck 1 takes 6 hours, Truck 2 takes 4 hours, Truck 3 takes 8 hours, Truck 4 takes 7 hours, and Truck 5 takes 5 hours. The hub manager must ensure that no two trucks are assigned to the same depot simultaneously, and each truck must start unloading no earlier than its arrival time. The central question is: *How can the trucks be assigned to depots to minimize the total time they spend waiting before their unloading begins?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to depot *j*, 0 otherwise).  
     - `start_time(i)`: Continuous variable representing the time truck *i* begins unloading.  
     - `completion_time(i)`: Continuous variable representing the time truck *i* finishes unloading.  
     - `precedes(i, k, j)`: Binary variable (1 if truck *i* is processed before truck *k* on depot *j*, 0 otherwise).  

   - **2. Parameters:**  
     - `trucks = [1, 2, 3, 4, 5]`, `depots = [1, 2, 3]`.  
     - `arrival_times`: {1: 4, 2: 7, 3: 10, 4: 14, 5: 17}.  
     - `unloading_times`: {1: 6, 2: 4, 3: 8, 4: 7, 5: 5}.  
     - `H = 100`: A large constant (big-M) for logical constraints.  

   - **3. Objective Function:**  
     Minimize the total waiting time:  
     `Minimize: sum(start_time[i] - arrival_times[i] for all trucks i)`.  

   - **4. Constraints:**  
     - **Assignment:** Each truck must be assigned to exactly one depot:  
       `sum(assign(i, j) for all j) = 1` for each truck *i*.  
     - **Arrival Time:** Trucks cannot start before arrival:  
       `start_time[i] >= arrival_times[i]` for each truck *i*.  
     - **Completion Time:** Unloading ends after start + unloading time:  
       `completion_time[i] = start_time[i] + unloading_times[i]` for each truck *i*.  
     - **Non-Overlapping:** If two trucks *i* and *k* share a depot *j*, one must precede the other:  
       - If `precedes(i, k, j) = 1`, then `start_time[k] >= completion_time[i]`.  
       - If `precedes(i, k, j) = 0`, then `start_time[i] >= completion_time[k]`.  
       - Logical link: `assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2, 3]
arrival_times = {1: 4, 2: 7, 3: 10, 4: 14, 5: 17}
unloading_times = {1: 6, 2: 4, 3: 8, 4: 7, 5: 5}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_1_MIN_WAIT")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes") # y[i,k,j] = 1 if i before k on j

    # --- Objective Function ---
    m.setObjective(gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + unloading_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    # Link precedence var: if both assigned, one must precede
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]), name=f"link_prec_{i}_{k}_{j}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Wait time can have decimals
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded") # Should not happen
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.4f}")
                print(f"  Completion Time: {completion_time[i].x:.4f}")
                print(f"  Waiting Time: {start_time[i].x - arrival_times[i]:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
23.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 1
  Start Time: 4.0000
  Completion Time: 10.0000
  Waiting Time: 0.0000
Truck 2 is assigned to Depot 1
  Start Time: 10.0000
  Completion Time: 14.0000
  Waiting Time: 3.0000
Truck 3 is assigned to Depot 1
  Start Time: 26.0000
  Completion Time: 34.0000
  Waiting Time: 16.0000
Truck 4 is assigned to Depot 1
  Start Time: 14.0000
  Completion Time: 21.0000
  Waiting Time: 0.0000
Truck 5 is assigned to Depot 1
  Start Time: 21.0000
  Completion Time: 26.0000
  Waiting Time: 4.0000


```

================================================================================



--- Problem 357 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
A maritime port is tasked with efficiently scheduling a diverse set of 13 ships into berths, each with a strict weight limit of 48 units. The ships vary significantly in weight, ranging from as light as 1 unit to as heavy as 48 units, and each belongs to one of 11 distinct shipping companies (e.g., 'T', 'Y', 'I', etc.). The challenge is compounded by a critical operational rule: no berth may contain ships from more than two different shipping companies. This constraint ensures streamlined sorting and handling downstream but complicates the scheduling process.  

The port manager must determine the minimal number of berths required to accommodate all ships while respecting both weight and company diversity limits. For instance, a berth could hold two ships weighing 24 and 12 units (totaling 36) from companies 'A' and 'C', but a third ship from company 'B' would violate the company constraint even if weight permits. The goal is to find the most space-efficient arrangement that adheres to these rules, minimizing logistical costs and resource usage.  

**Core Question:** What is the smallest number of berths needed to schedule all ships without exceeding weight or company constraints?  

---

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable `x[i, j]`: Equals 1 if ship *i* (with weight `ships[i]` and company `companies[i]`) is assigned to berth *j*; 0 otherwise.  
- Binary variable `y[j]`: Equals 1 if berth *j* is used (contains at least one ship); 0 otherwise.  
- Binary variable `z[c, j]`: Equals 1 if company *c* is present in berth *j*; 0 otherwise.  

**2. Parameters:**  
- `ships`: List of ship weights (e.g., `[24, 42, ..., 27]`).  
- `companies`: List of ship companies (e.g., `['T', 'Y', ..., 'P']`).  
- `capacity`: Maximum weight per berth (48 units).  
- `unique_companies_list`: Sorted list of distinct companies (e.g., `['A', 'B', ..., 'Y']`).  

**3. Objective Function:**  
Minimize the total number of berths used:  
```
Minimize: sum(y[j] for all j)
```

**4. Constraints:**  
- **Ship Assignment:** Each ship must be placed in exactly one berth:  
  `sum(x[i, j] for all j) = 1` for every ship *i*.  
- **Berth Capacity:** The total weight in berth *j* cannot exceed `capacity` if the berth is used:  
  `sum(ships[i] * x[i, j] for all i) <= capacity * y[j]` for every berth *j*.  
- **Company Linking:** If any ship of company *c* is in berth *j*, `z[c, j]` must be 1:  
  `x[i, j] <= z[companies[i], j]` for every ship *i* and berth *j*.  
- **Company Limit:** Each used berth may contain at most 2 distinct companies:  
  `sum(z[c, j] for all c) <= 2 * y[j]` for every berth *j*.  

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
ships = [24, 42, 13, 8, 48, 12, 16, 26, 31, 1, 3, 18, 27]      # Weights of ships
companies = ['T', 'Y', 'I', 'J', 'E', 'A', 'C', 'Z', 'B', 'G', 'L', 'B', 'P']    # Companies of ships
capacity = 48         # Berth capacity
num_ships = 13       # len(ships) - derived correctly below
num_berths = num_ships      # Maximum berths (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(ships) != len(companies) or len(ships) != num_ships:
    print("Error: Data inconsistency (ships/companies/num_ships length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_companies_list = sorted(list(set(companies))) # Get unique companies deterministically
ship_indices_by_company = {company: [i for i, c in enumerate(companies) if c == company] for company in unique_companies_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Company-Constrained Berth Scheduling", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")  # x[i,j] -> ship i in berth j
        y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")              # y[j] -> whether berth j is used
        # z[c,j] -> whether company c is PRESENT in berth j (Use unique_companies_list for keys)
        z = model.addVars(unique_companies_list, num_berths, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of berths used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each ship must be assigned to exactly one berth ---
        for i in range(num_ships):
            model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

        # --- Constraint 2: Berth capacity constraint ---
        for j in range(num_berths):
            model.addConstr(gp.quicksum(ships[i] * x[i, j] for i in range(num_ships)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

        # --- Constraint 3: Company constraint (at most 2 *different* companies per berth) ---

        # Part 3a: Link x (ship in berth) and z (company in berth).
        for j in range(num_berths):
            for company in unique_companies_list:
                indices_of_this_company = ship_indices_by_company.get(company, []) # Use .get for safety

                if not indices_of_this_company:
                    # If no ships of this company exist, z[company, j] must be 0.
                    model.addConstr(z[company, j] == 0, name=f"NoShips_{company}_Berth_{j}")
                    continue

                # If any ship 'i' of this 'company' is placed in berth 'j' (x[i,j]=1),
                # then the presence indicator for that 'company' in berth 'j' (z[company,j]) must be 1.
                for i in indices_of_this_company:
                    model.addConstr(x[i, j] <= z[company, j], name=f"Link_x{i}_z{company}_Berth{j}")

                # Ensure z[company, j] is 0 if no ships of that company are in the berth.
                # This helps tighten the formulation.
                model.addConstr(z[company, j] <= gp.quicksum(x[i, j] for i in indices_of_this_company), name=f"Link_z{company}_SumX_Berth{j}")


        # Part 3b: Limit the number of distinct companies (sum of z[c,j] for berth j) to 2 for USED berths.
        for j in range(num_berths):
            # sum(z[c,j] for c in unique_companies_list) gives the count of distinct companies in berth j.
            # This sum must be <= 2 *IF* the berth is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Companies_Berth_{j}")

        # --- Solve ---
        print("Solving CCBP instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of berths used: {optimal_berths}")
    print("-" * 30)

    berth_details = []
    printed_berth_count = 0
    for j_sol in range(num_berths): # Iterate through all potential berth indices
        try:
             # Check if this berth was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_berth_count += 1
                 assigned_ships_indices = [i for i in range(num_ships) if x[i, j_sol].X > 0.5]
                 assigned_ships_weights = [ships[i] for i in assigned_ships_indices]
                 assigned_ships_companies = [companies[i] for i in assigned_ships_indices]
                 distinct_companies_in_berth = sorted(list(set(assigned_ships_companies))) # Sort for consistent output
                 berth_load = sum(assigned_ships_weights)

                 print(f"Berth {printed_berth_count} (Internal Index {j_sol}):")
                 print(f"  Ships (indices): {assigned_ships_indices}")
                 # print(f"  Ships (weights): {assigned_ships_weights}") # Optional details
                 # print(f"  Ships (companies):  {assigned_ships_companies}") # Optional details
                 print(f"  Distinct Companies: {distinct_companies_in_berth} (Count: {len(distinct_companies_in_berth)})")
                 print(f"  Total weight:    {berth_load} / {capacity}")
                 print("-" * 10)

                 berth_data = {
                     'berth_index_internal': j_sol,
                     'berth_index_printed': printed_berth_count,
                     'ship_indices': assigned_ships_indices,
                     'distinct_companies': distinct_companies_in_berth,
                     'load': berth_load
                 }
                 berth_details.append(berth_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for berth index {j_sol}: {e_print}")


    results_dict['berth_details'] = berth_details # Store details

    # Final sanity check
    if printed_berth_count != optimal_berths:
         print(f"Warning: Number of printed used berths ({printed_berth_count}) does not match objective value ({optimal_berths}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# The provided code already prints the key outputs, including the optimal number of berths used and detailed information for each berth.
# No additional print statements are necessary.
```
Answer:
Solving CCBP instance...
------------------------------

Optimal solution found.
Optimal number of berths used: 7
------------------------------
Berth 1 (Internal Index 0):
  Ships (indices): [5, 6]
  Distinct Companies: ['A', 'C'] (Count: 2)
  Total weight:    28 / 48
----------
Berth 2 (Internal Index 2):
  Ships (indices): [3, 8]
  Distinct Companies: ['B', 'J'] (Count: 2)
  Total weight:    39 / 48
----------
Berth 3 (Internal Index 3):
  Ships (indices): [9, 12]
  Distinct Companies: ['G', 'P'] (Count: 2)
  Total weight:    28 / 48
----------
Berth 4 (Internal Index 5):
  Ships (indices): [4]
  Distinct Companies: ['E'] (Count: 1)
  Total weight:    48 / 48
----------
Berth 5 (Internal Index 8):
  Ships (indices): [0, 11]
  Distinct Companies: ['B', 'T'] (Count: 2)
  Total weight:    42 / 48
----------
Berth 6 (Internal Index 9):
  Ships (indices): [2, 7]
  Distinct Companies: ['I', 'Z'] (Count: 2)
  Total weight:    39 / 48
----------
Berth 7 (Internal Index 11):
  Ships (indices): [1, 10]
  Distinct Companies: ['L', 'Y'] (Count: 2)
  Total weight:    45 / 48
----------


```

================================================================================



--- Problem 358 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently loading 23 items onto the fewest possible trucks for transport. Each item has a specific weight, ranging from as light as 9 units to as heavy as 48 units. The trucks have a strict capacity limit of 48 units each, meaning the combined weight of items in any truck cannot exceed this threshold. The challenge is to assign each item to exactly one truck while minimizing the total number of trucks used, ensuring no truck is overloaded.  

The items vary significantly in weight, with some being large enough to occupy an entire truck on their own (e.g., the 48-unit item), while others can be combined strategically to maximize space utilization. For instance, smaller items like the 6-unit and 18-unit ones can be paired with mid-sized items to fill trucks efficiently. The company must determine the optimal arrangement to reduce shipping costs, as fewer trucks mean lower transportation expenses.  

The core question is: *What is the smallest number of trucks required to load all 23 items without exceeding the 48-unit capacity per truck, and how should the items be distributed across these trucks?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `x[i, j]` indicates whether item `i` is assigned to truck `j` (1 if assigned, 0 otherwise).  
   - Binary variable `y[j]` indicates whether truck `j` is used (1 if used, 0 otherwise).  

   **2. Parameters:**  
   - `items`: List of item weights (e.g., `[41, 6, 39, ..., 9]`).  
   - `capacity`: Maximum weight per truck (48 units).  
   - `num_items`: Total number of items (23).  
   - `num_trucks`: Maximum possible trucks (23, one per item in the worst case).  

   **3. Objective Function:**  
   Minimize the total number of trucks used:  
   \[
   \text{Minimize: } \sum_{j=1}^{\text{num\_trucks}} y[j]
   \]  

   **4. Constraints:**  
   - **Item Assignment:** Each item must be placed in exactly one truck:  
     \[
     \sum_{j=1}^{\text{num\_trucks}} x[i, j] = 1 \quad \text{for all items } i.
     \]  
   - **Truck Capacity:** The total weight in any truck `j` must not exceed its capacity if the truck is used:  
     \[
     \sum_{i=1}^{\text{num\_items}} \text{items}[i] \cdot x[i, j] \leq \text{capacity} \cdot y[j] \quad \text{for all trucks } j.
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB

# --- Data Definition ---
items = [41, 6, 39, 43, 22, 15, 43, 21, 40, 37, 48, 18, 42, 42, 14, 25, 16, 45, 19, 18, 28, 13, 9]      # Weights of items
capacity = 48           # Truck capacity
num_items = 23     # len(items) - Corrected from original template
num_trucks = num_items    # Maximum number of trucks (worst case: one item per truck)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Time limit
# env.setParam('TimeLimit', 30)
env.start()

# Create Model
model = Model("Truck Loading Problem", env=env)

# --- Decision Variables ---
# x[i,j]: item i is assigned to truck j
x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")
# y[j]: truck j is used
y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")

# --- Objective: Minimize the number of trucks used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)

# --- Constraints ---
# 1. Each item must be assigned to exactly one truck
for i in range(num_items):
    model.addConstr(x.sum(i, '*') == 1, name=f"Item_{i}_Assignment")

# 2. Truck capacity constraint: sum of weights in truck j <= capacity IF truck j is used (y[j]=1)
for j in range(num_trucks):
    model.addConstr(gp.quicksum(items[i] * x[i, j] for i in range(num_items)) <= capacity * y[j], name=f"Truck_{j}_Capacity")

# --- Solve ---
print("Solving Truck Loading Problem...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_trucks = int(results_dict.get('obj_val', -1))
    print(f"\nOptimal number of trucks used: {optimal_trucks}")
    print("-" * 30)
    truck_details = []
    for j_sol in range(num_trucks): # Loop through potential trucks
        # Check if the truck variable y[j_sol] exists and is set to 1
        # Using .X requires Gurobi v9+ and that the variable is in the solution
        try:
            if y[j_sol].X > 0.5: # Check if truck j_sol is used
                # Find items assigned to this truck j_sol
                # ***** CORRECTED LINE BELOW *****
                assigned_items_indices = [i for i in range(num_items) if x[i, j_sol].X > 0.5]
                # ***** END OF CORRECTION *****

                assigned_items_weights = [items[i] for i in assigned_items_indices]
                truck_load = sum(assigned_items_weights)
                print(f"Truck {j_sol + 1} (Load: {truck_load}/{capacity}): Items (indices): {assigned_items_indices}")
                # Optional: Print weights too
                # print(f"  Weights: {assigned_items_weights}")
                truck_details.append({'truck_index': j_sol, 'item_indices': assigned_items_indices, 'load': truck_load})
        except AttributeError:
            # This might happen if y[j_sol] was optimized to 0 and doesn't have an .X value
            # Or if the model was infeasible/not solved optimally.
            # Since we check for OPTIMAL status first, this is less likely for y,
            # but could happen if x[i, j_sol] is 0. The check x[i,j_sol].X > 0.5 handles this.
            pass # Just skip if variable/attribute doesn't exist for unused trucks/items
    results_dict['truck_details'] = truck_details # Store details
    print("-" * 30)

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount to see if a feasible solution was found
     if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
     else: print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving Truck Loading Problem...

Optimal number of trucks used: 15
------------------------------
Truck 1 (Load: 42/48): Items (indices): [12]
Truck 2 (Load: 48/48): Items (indices): [10]
Truck 3 (Load: 39/48): Items (indices): [2]
Truck 4 (Load: 45/48): Items (indices): [4, 14, 22]
Truck 9 (Load: 42/48): Items (indices): [13]
Truck 13 (Load: 43/48): Items (indices): [6]
Truck 14 (Load: 41/48): Items (indices): [0]
Truck 15 (Load: 48/48): Items (indices): [16, 18, 21]
Truck 16 (Load: 37/48): Items (indices): [9]
Truck 17 (Load: 43/48): Items (indices): [5, 20]
Truck 18 (Load: 40/48): Items (indices): [8]
Truck 19 (Load: 45/48): Items (indices): [1, 7, 19]
Truck 21 (Load: 43/48): Items (indices): [3]
Truck 22 (Load: 43/48): Items (indices): [11, 15]
Truck 23 (Load: 45/48): Items (indices): [17]
------------------------------


```

================================================================================



--- Problem 359 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
At a busy port, the operations manager needs to decide on the most efficient and cost-effective method for handling container ships. The choice is between using a *dedicated crane* (which guarantees faster unloading but incurs a fixed hourly cost) or a *shared crane* (which avoids the fixed cost but introduces delays due to shared usage). Each option has distinct trade-offs. The dedicated crane ensures quick turnaround but costs $41.00 per hour in operational overhead. On the other hand, the shared crane avoids this cost but introduces delays, estimated at a penalty of $73.00 per hour due to congestion and reduced throughput. The challenge is to determine which crane configuration minimizes the total cost while balancing efficiency and operational costs.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y_dedicated`: Binary variable where `1` indicates selecting the dedicated crane, and `0` selects the shared crane.  
   - **2. Parameters:**  
     - `cost_dedicated_cranes = 41`: Hourly cost of the dedicated crane ($).  
     - `cost_shared_delay = 73`: Hourly penalty for delays under the shared crane ($).  
   - **3. Objective Function:**  
     - Minimize the total cost:  
       ```  
       Minimize: y_dedicated * cost_dedicated_cranes + (1 - y_dedicated) * cost_shared_delay  
       ```  
   - **4. Constraints:**  
     - None (unconstrained binary decision).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
cost_dedicated_cranes = 41 # Proxy cost/hr
cost_shared_delay = 73 # Proxy penalty/hr
# --- End Parameters ---

GUROBI_TIME_LIMIT = 5

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m36 = gp.Model("CRANE_SELECTION_IP", env=env)

    # --- Decision Variables ---
    # Binary: y_dedicated = 1 if dedicated crane is chosen, 0 otherwise
    y_dedicated = m36.addVar(vtype=GRB.BINARY, name="use_dedicated_cranes")

    # --- Objective Function ---
    # Minimize total cost = cost of chosen crane
    m36.setObjective(y_dedicated * cost_dedicated_cranes + (1 - y_dedicated) * cost_shared_delay, sense=GRB.MINIMIZE)

    # --- Constraints: None ---

    # --- Optimization ---
    m36.optimize()

    # --- Store results ---
    results_dict['status'] = m36.status
    if m36.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m36.ObjVal
        results_dict['y_dedicated_sol'] = y_dedicated.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 36: Port Crane Selection (IP) ---") # Original problem number
    if m36.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        use_dedicated = results_dict.get('y_dedicated_sol', 0) > 0.5

        print(f"Optimization Status: Optimal")
        print(f"Optimal Decision: {'Use Dedicated Crane' if use_dedicated else 'Use Shared Crane'}")
        print(f"  Cost of Dedicated Crane: ${float(cost_dedicated_cranes):.2f}")
        print(f"  Estimated Cost of Shared Crane (due to delay): ${float(cost_shared_delay):.2f}")
        print(f"Minimum Estimated Cost: ${float(obj_val_print):.2f}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m36.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (No additional code needed, as the provided code already prints all required outputs)
```
Answer:
--- Problem 36: Port Crane Selection (IP) ---
Optimization Status: Optimal
Optimal Decision: Use Dedicated Crane
  Cost of Dedicated Crane: $41.00
  Estimated Cost of Shared Crane (due to delay): $73.00
Minimum Estimated Cost: $41.00


```

================================================================================



--- Problem 360 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A maritime logistics company operates a fleet of 8 ships to deliver goods from a central port (Node 0) to 8 customer ports (Nodes 1–8). Each ship has a unique capacity, ranging from 18 to 97 units, and each customer port has a specific demand, such as 23 units for Node 1 or 74 units for Node 8. The distances between ports are asymmetric—for example, traveling from Node 0 to Node 1 takes 27 units of distance, but the return trip (Node 1 to Node 0) also takes 27 units. The challenge is to assign routes to ships so that every customer port is visited exactly once, no ship exceeds its capacity, and the total distance traveled by all ships is minimized. The solution must also prevent subtours (illogical loops that exclude the central port) and ensure each ship starts and ends at the central port.  

The core question: *How can the company allocate deliveries to ships while respecting capacity and operational constraints to achieve the lowest possible total travel distance?*  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable \(x_{i,j,k}\): Equals 1 if ship \(k\) travels directly from port \(i\) to port \(j\); 0 otherwise.  
- Continuous variable \(u_i\): Auxiliary variable for subtour elimination (MTZ constraint), representing the order of port \(i\) in a route.  

**2. Parameters:**  
- \(N = 9\): Total ports (1 central port + 8 customer ports).  
- \(K = 8\): Number of ships.  
- \(Q_k\): Capacity of ship \(k\) (e.g., 97 for \(k=0\)).  
- \(q_i\): Demand at port \(i\) (e.g., 23 for \(i=1\)).  
- \(d_{i,j}\): Distance from port \(i\) to \(j\) (e.g., \(d_{0,1} = 27\)).  

**3. Objective Function:**  
Minimize the total distance:  
\[
\text{Minimize} \sum_{k=0}^{7} \sum_{i=0}^{8} \sum_{j=0}^{8} d_{i,j} \cdot x_{i,j,k} \quad \text{(for \(i \neq j\))}.
\]  

**4. Constraints:**  
- **Visit each customer port once:** \(\sum_{k=0}^{7} \sum_{j=0}^{8} x_{i,j,k} = 1\) for all \(i \in \{1, \dots, 8\}\).  
- **Flow conservation:** Inflow equals outflow for each port and ship.  
- **Central port departure/return:** Each ship leaves and returns to the central port at most once.  
- **Capacity:** Total demand on ship \(k\)'s route \(\leq Q_k\).  
- **Subtour elimination (MTZ):** \(u_i - u_j + (8) \cdot x_{i,j,k} \leq 7\) for \(i,j \geq 1, i \neq j\).  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 9
K = 8
Q = [97, 18, 93, 82, 58, 50, 76, 28]
q = [0, 23, 71, 50, 28, 16, 4, 23, 74]
d = [
    [0, 27, 48, 33, 45, 11, 83, 56, 98],
    [27, 0, 93, 36, 99, 90, 22, 53, 43],
    [48, 93, 0, 73, 14, 6, 83, 9, 99],
    [33, 36, 73, 0, 19, 20, 98, 40, 95],
    [45, 99, 14, 19, 0, 66, 59, 49, 7],
    [11, 90, 6, 20, 66, 0, 29, 82, 95],
    [83, 22, 83, 98, 59, 29, 0, 73, 36],
    [56, 53, 9, 40, 49, 82, 73, 0, 39],
    [98, 43, 99, 95, 7, 95, 36, 39, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer port (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Ship Departure/Return from Central Port (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartPort_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnPort_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for ship {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for ship {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 475.00

Route for ship 1 (Capacity: 97):
0 -> 7 -> 8 -> 0
Route Load: 97 / 97

Route for ship 3 (Capacity: 93):
0 -> 2 -> 0
Route Load: 71 / 93

Route for ship 4 (Capacity: 82):
0 -> 3 -> 4 -> 0
Route Load: 78 / 82

Route for ship 6 (Capacity: 50):
0 -> 5 -> 6 -> 1 -> 0
Route Load: 43 / 50


```

================================================================================



--- Problem 361 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
A logistics company is tasked with loading a collection of 40 valuable items into two trucks for delivery. Each item has a specific weight and value, and the trucks have a strict weight capacity of 80 units. The goal is to maximize the total value of the items loaded while ensuring that no truck exceeds its weight limit. The challenge is compounded by the fact that items cannot be split—each must either be placed entirely in one truck or left out entirely.  

The items vary widely in weight and value, ranging from lightweight but high-value pieces (e.g., item 3 weighing 2 units but worth 84) to heavier but less valuable ones (e.g., item 5 weighing 43 units but worth only 1). The company must strategically select which items to include and how to distribute them between the two trucks to achieve the highest possible total value without violating the weight constraints.  

The critical question is: *Which items should be loaded into which trucks to maximize the total shipment value while staying within the weight limits?*

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `x[i, j]`: Equals 1 if item `i` is placed in truck `j`, and 0 otherwise.  
   - Binary variable `y[j]`: Equals 1 if truck `j` is used (i.e., at least one item is placed in it), and 0 otherwise.  

   **2. Parameters:**  
   - `items[i]`: A list of tuples where each tuple contains `(weight, value)` for item `i`.  
   - `truck_capacity = 80`: Maximum allowable weight per truck.  
   - `num_trucks = 2`: Total number of available trucks.  

   **3. Objective Function:**  
   Maximize the total value of loaded items:  
   \[
   \text{Maximize: } \sum_{i=0}^{39} \sum_{j=0}^{1} \text{items[i][1]} \cdot x[i, j]
   \]  

   **4. Constraints:**  
   - **Truck Weight Limit:** For each truck `j`, the total weight of items placed in it must not exceed its capacity:  
     \[
     \sum_{i=0}^{39} \text{items[i][0]} \cdot x[i, j] \leq \text{truck\_capacity} \cdot y[j] \quad \forall j \in \{0, 1\}
     \]  
   - **Item-Truck Link:** If an item `i` is placed in truck `j`, the truck must be marked as used:  
     \[
     x[i, j] \leq y[j] \quad \forall i \in \{0, \dots, 39\}, \forall j \in \{0, 1\}
     \]  
   - **Item Assignment:** Each item can be placed in at most one truck:  
     \[
     \sum_{j=0}^{1} x[i, j] \leq 1 \quad \forall i \in \{0, \dots, 39\}
     \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Data Definition (Embedded) ---
items = [(12, 78), (35, 25), (16, 33), (2, 84), (6, 11), (43, 1), (11, 15), (4, 63), (51, 70), (20, 10), (74, 70), (4, 68), (67, 4), (27, 51), (17, 55), (71, 77), (41, 78), (34, 48), (71, 40), (12, 48), (56, 36), (2, 43), (54, 34), (1, 45), (28, 2), (75, 83), (36, 45), (21, 28), (69, 42), (2, 32), (13, 96), (32, 6), (76, 59), (60, 95), (11, 87), (72, 62), (2, 13), (75, 64), (41, 26), (52, 50)]          # List of (weight, value) tuples
truck_capacity = 80      # Maximum weight per truck
num_trucks = 2          # Maximum number of available trucks (parameter)
num_items = 40          # len(items) derived correctly
# --- End Data Definition ---

GUROBI_TIME_LIMIT = 60 # Time limit parameter

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi log in captured output
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Max-Value BPP", env=env)

    # --- Decision variables ---
    x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")  # x[i, j] -> item i placed in truck j
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")  # y[j] -> truck j is used

    # --- Objective: Maximize total value of selected items ---
    # Sum over all items i and the truck j they are placed in
    model.setObjective(gp.quicksum(items[i][1] * x[i, j] for i in range(num_items) for j in range(num_trucks)), GRB.MAXIMIZE)

    # --- Constraint 1: Truck weight limit ---
    for j in range(num_trucks):
        model.addConstr(gp.quicksum(items[i][0] * x[i, j] for i in range(num_items)) <= truck_capacity * y[j], name=f"Truck_{j}_Weight")

    # --- Constraint 2: If an item is placed in a truck, that truck must be considered used ---
    # (This is often implied by C1 if capacity > 0, but good practice)
    for i in range(num_items):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Item_{i}_Triggers_Truck_{j}")

    # --- Constraint 3: Each item can be placed in at most one truck ---
    # (Items not placed contribute 0 to objective and constraints)
    for i in range(num_items):
        model.addConstr(x.sum(i, '*') <= 1, name=f"Item_{i}_AtMostOneTruck")

    # --- Solve the model ---
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal # Best solution found

    # --- Output results (for capture) ---
    if model.status == GRB.OPTIMAL:
        print(f"Optimal total value: {model.objVal:.2f}") # Format value
        print("-" * 30)
        printed_truck_count = 0
        for j in range(num_trucks):
            try:
                 if y[j].x > 0.5:  # Truck is used
                     printed_truck_count += 1
                     assigned_items = [i for i in range(num_items) if x[i, j].x > 0.5]
                     assigned_weights = [items[i][0] for i in assigned_items]
                     truck_load = sum(assigned_weights)
                     print(f"Truck {printed_truck_count} (Index {j}):")
                     print(f"  Load: {truck_load} / {truck_capacity}")
                     print(f"  Items (indices): {sorted(assigned_items)}")
                     # Optional: print item details
                     # print(f"  Items (w,v): {[items[i] for i in sorted(assigned_items)]}")
                     print("-" * 10)
            except AttributeError:
                 pass # Skip trucks not used or if .X missing
    elif model.status == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare if items fit capacity
    else:
        print(f"\nOptimization finished with status: {model.status}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total value: 852.00
------------------------------
Truck 1 (Index 0):
  Load: 80 / 80
  Items (indices): [0, 3, 7, 11, 14, 19, 23, 29, 30, 34, 36]
----------
Truck 2 (Index 1):
  Load: 76 / 80
  Items (indices): [4, 13, 16, 21]
----------


```

================================================================================



--- Problem 362 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A logistics company operates a fleet of two trucks to serve three locations: a central depot (Location 0) and two customer sites (Locations 1 and 2). The trucks have distinct capacities: Truck 1 can carry up to 24 units, while Truck 2 can handle up to 93.8 units. The customer demands are precise—Location 1 requires 4 units, and Location 2 needs a substantial 92 units. The distances between locations are carefully measured: from the depot to Location 1 is 77 units, to Location 2 is 19 units, and the inter-customer distance between Locations 1 and 2 is 31 units.  

The challenge is to assign routes to the trucks such that:  
- Each customer is visited exactly once.  
- Trucks start and end at the depot.  
- No truck exceeds its capacity.  
- The total travel distance is minimized.  

The stakes are high—efficient routing ensures timely deliveries while conserving fuel and reducing wear on the fleet. The core question is: *What is the most efficient way to assign routes to these trucks to meet all demands while minimizing total distance traveled?*  

---
**

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variables `x(i, j, k)` indicate whether truck `k` travels directly from location `i` to `j` (1 if yes, 0 otherwise).  
- Continuous variables `u(i)` enforce subtour elimination for customer locations (Miller-Tucker-Zemlin constraints).  

**2. Parameters:**  
- `N = 3`: Total locations (depot + 2 customers).  
- `K = 2`: Number of trucks.  
- `Q = [24, 93.8]`: Truck capacities.  
- `q = [0, 4, 92]`: Demands (depot has 0 demand).  
- `d`: Distance matrix (e.g., `d[0][1] = 77`).  

**3. Objective Function:**  
Minimize the total distance traveled by all trucks:  
```  
Minimize: sum(d[i][j] * x[i, j, k] for all i, j, k where i ≠ j)  
```  

**4. Constraints:**  
- **Visit each customer once:**  
  `sum(x[i, j, k] for all j, k where i ≠ j) = 1` for each customer `i`.  
- **Flow conservation:**  
  Inflow equals outflow for each location and truck.  
- **Depot departure/return:**  
  Each truck leaves and returns to the depot at most once.  
- **Capacity limits:**  
  `sum(q[j] * x[i, j, k] for all i, j where i ≠ j) ≤ Q[k]` for each truck `k`.  
- **Subtour elimination (MTZ):**  
  `u[i] - u[j] + (N-1) * x[i, j, k] ≤ N-2` for all customer pairs `i, j` and truck `k`.  

---

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 3
K = 2
Q = [24, 93.80000000000001]
q = [0, 4, 92]
d = [
    [0, 77, 19],
    [77, 0, 31],
    [19, 31, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Vehicle Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for truck {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for truck {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 192.00

Route for truck 1 (Capacity: 24):
0 -> 1 -> 0
Route Load: 4 / 24

Route for truck 2 (Capacity: 93.80000000000001):
0 -> 2 -> 0
Route Load: 92 / 93.80000000000001


```

================================================================================



--- Problem 363 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy port, two tugboats are available to assist in the berthing and unberthing of ships. The central harbor (Node 0) serves as the starting and ending point for all tugboat routes, while a single ship (Node 1) requires assistance. Each tugboat has a limited capacity—Tugboat 1 can handle up to 11 units of work, and Tugboat 2 can handle up to 10 units. The ship at Node 1 requires 6 units of work, posing a challenge: how to assign routes efficiently to minimize total travel distance while respecting tugboat capacities.  

The distances between nodes are precisely measured: traveling from the harbor to Node 1 (or vice versa) covers 63 units of distance. The port management team must devise a plan ensuring the ship is served exactly once, tugboats return to the harbor after their tasks, and no tugboat exceeds its capacity. The core question is: *What is the most efficient routing strategy to minimize total distance traveled while meeting all operational constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `x[i, j, k]`: Equals 1 if tugboat `k` travels directly from node `i` to node `j` (where `i ≠ j`), and 0 otherwise.  
     - Continuous variable `u[i]`: Used for subtour elimination (MTZ constraint), representing the order of node `i` in the route (only for customer nodes).  

   - **2. Parameters:**  
     - `N = 2`: Total nodes (harbor = 0, ship = 1).  
     - `K = 2`: Number of tugboats.  
     - `Q = [11, 10]`: Capacities of tugboats 1 and 2.  
     - `q = [0, 6]`: Work required at nodes (harbor = 0, ship = 6).  
     - `d = [[0, 63], [63, 0]]`: Distance matrix (harbor to ship = 63 units).  

   - **3. Objective Function:**  
     Minimize total distance:  
     `Minimize: sum(d[i][j] * x[i, j, k] for all i, j, k where i ≠ j)`.  

   - **4. Constraints:**  
     1. **Ship Visit:** Node 1 must be visited exactly once:  
        `sum(x[1, j, k] for all j, k where 1 ≠ j) = 1`.  
     2. **Flow Conservation:** For each tugboat `k` and node `i`, incoming flow equals outgoing flow:  
        `sum(x[i, j, k] for all j) = sum(x[j, i, k] for all j)`.  
     3. **Harbor Departure/Return:** Each tugboat `k` must leave and return to the harbor at most once:  
        `sum(x[0, j, k] for j = 1) = sum(x[j, 0, k] for j = 1) ≤ 1`.  
     4. **Capacity:** Total work served by tugboat `k` cannot exceed its capacity:  
        `sum(q[j] * x[i, j, k] for all i, j where j ≠ 0) ≤ Q[k]`.  
     5. **Subtour Elimination (MTZ):** For `i, j ≥ 1`, ensure no invalid loops:  
        `u[i] - u[j] + (N-1) * x[i, j, k] ≤ N-2`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 2
K = 2
Q = [11, 10]
q = [0, 6]
d = [
    [0, 63],
    [63, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each ship (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Tugboat Departure/Return from Harbor (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartHarbor_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnHarbor_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for tugboat {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for tugboat {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 126.00

Route for tugboat 1 (Capacity: 11):
0 -> 1 -> 0
Route Load: 6 / 11


```

================================================================================



--- Problem 364 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A fleet of seven delivery trucks (T1 to T7) arrives at a logistics depot equipped with three distinct charging stations (S1, S2, and S3), each offering different power outputs (36.5 kW, 47.7 kW, and 51.0 kW, respectively). The trucks have varying energy demands, ranging from 25 kWh for T4 to 76 kWh for T2. The charging duration for each truck depends on the station's power—higher-power stations reduce charging time but must be allocated strategically to minimize total charging time across the fleet.  

The depot manager faces the challenge of assigning each truck to exactly one charging station such that the sum of all charging times is minimized. For instance, assigning T2 to station S1 would take 2.082 hours, while using station S3 reduces this to 1.490 hours. However, station S3’s higher efficiency must be balanced against competing demands from other trucks. The core question is: *How should the trucks be assigned to charging stations to achieve the shortest possible cumulative charging time for the entire fleet?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable \( x(t, s) \) for each truck \( t \) (T1–T7) and station \( s \) (S1–S3), where \( x(t, s) = 1 \) if truck \( t \) is assigned to station \( s \), and 0 otherwise.  
   - **2. Parameters:**  
     - \( \text{charge\_duration}(t, s) \): Precomputed time (hours) for truck \( t \) to charge on station \( s \) (e.g., 1.589 hours for T1 on station S1).  
   - **3. Objective Function:**  
     - Minimize the total charging time:  
       \[
       \text{Minimize: } \sum_{t \in \text{trucks}} \sum_{s \in \text{stations}} x(t, s) \cdot \text{charge\_duration}(t, s)
       \]  
   - **4. Constraints:**  
     - Each truck must be assigned to exactly one station:  
       \[
       \sum_{s \in \text{stations}} x(t, s) = 1 \quad \forall t \in \text{trucks}
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError, tupledict; import sys; import traceback; import math

# --- Parameters ---
trucks = ['T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7']
stations = [1, 2, 3]
demand_kWh = {'T1': 58, 'T2': 76, 'T3': 42, 'T4': 25, 'T5': 43, 'T6': 44, 'T7': 45} # For context
power_kW = {1: 36.5, 2: 47.7, 3: 51.0}     # For context
# Calculated charge durations (truck, station): duration_in_hours
charge_duration = {('T1', 1): 1.5890410958904109, ('T1', 2): 1.2159329140461215, ('T1', 3): 1.1372549019607843, ('T2', 1): 2.0821917808219177, ('T2', 2): 1.5932914046121591, ('T2', 3): 1.4901960784313726, ('T3', 1): 1.1506849315068493, ('T3', 2): 0.880503144654088, ('T3', 3): 0.8235294117647058, ('T4', 1): 0.684931506849315, ('T4', 2): 0.5241090146750523, ('T4', 3): 0.49019607843137253, ('T5', 1): 1.178082191780822, ('T5', 2): 0.9014675052410901, ('T5', 3): 0.8431372549019608, ('T6', 1): 1.2054794520547945, ('T6', 2): 0.9224318658280922, ('T6', 3): 0.8627450980392157, ('T7', 1): 1.2328767123287672, ('T7', 2): 0.9433962264150942, ('T7', 3): 0.8823529411764706}
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("Truck_CHARGING_ASSIGN_SUM_Sum", env=env)

    # --- Input Validation ---
    if not trucks or not stations: raise ValueError("Empty trucks or stations list")
    if any(t == float('inf') for t in charge_duration.values()):
         print("Warning: Some station has zero power or invalid duration.")

    # --- Decision Variables ---
    # x[i, j] = 1 if truck i is assigned to station j
    # Use tupledict for easier handling of potentially invalid pairs
    assign_keys = tupledict({(t, s): 1 for t, s in charge_duration if charge_duration[t,s] != float('inf')})
    if not assign_keys: raise ValueError("No valid truck-station assignments possible.")
    x = m.addVars(assign_keys.keys(), vtype=GRB.BINARY, name="x")

    # --- Objective Function: Minimize the sum of charging times ---
    # Use tupledict prod method
    m.setObjective(x.prod(charge_duration), GRB.MINIMIZE)

    # --- Constraints ---
    # Each truck must be assigned to exactly one station
    # Use tupledict sum method
    for t in trucks:
        m.addConstr(x.sum(t, '*') == 1, f"TruckAssignment_{t}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is sum of durations in hours
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show more precision
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.") # Matches example
    else: # Other statuses
        print("No optimal solution found.") # Matches example

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code to print the assignment of trucks to stations
if m.Status == GRB.OPTIMAL:
    for t in trucks:
        for s in stations:
            if x[t, s].X > 0.5:
                print(f"Truck {t} is assigned to Station S{s}")
```
Answer:
Optimal objective value: 6.5294
Truck T1 is assigned to Station S3
Truck T2 is assigned to Station S3
Truck T3 is assigned to Station S3
Truck T4 is assigned to Station S3
Truck T5 is assigned to Station S3
Truck T6 is assigned to Station S3
Truck T7 is assigned to Station S3


```

================================================================================



--- Problem 365 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy container terminal faces the daily challenge of maximizing revenue while balancing two distinct customer segments: long-term storage and short-term transshipment. The terminal has 59 available slots and operates for 9.5 hours daily, offering a total of 560.5 slot-hours of capacity. Long-term storage reservations, priced at $36 per container, typically occupy a slot for 3.4 hours, with demand ranging between a minimum requirement of 37 reservations and a maximum potential of 114. Meanwhile, short-term transshipments, which pay $19.80 per container, stay for an average of 3.3 hours, with demand capped at 271 containers.  

The terminal manager must strategically allocate slots to these two groups to maximize daily revenue without exceeding the total slot-hour capacity. The challenge lies in determining the optimal mix of long-term storage and short-term transshipments—ensuring the minimum long-term storage demand is met while exploiting the higher revenue potential from short-term transshipments where possible. The question is: *How many long-term storage reservations and short-term transshipments should the terminal accept to achieve the highest possible daily revenue without violating operational constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `x_long_term`: Integer number of long-term storage reservations to accept (≥ 0).  
- `x_short_term`: Integer number of short-term transshipments to accept (≥ 0).  

**2. Parameters:**  
- `total_slot_hours = 560.5`: Total available slot-hours.  
- `long_term_price = 36`: Revenue per long-term storage reservation.  
- `long_term_stay = 3.4`: Slot-hours consumed per long-term storage reservation.  
- `long_term_max_demand = 114`: Upper limit on long-term storage reservations.  
- `long_term_min_required = 37`: Minimum required long-term storage reservations.  
- `short_term_revenue_per_container = 19.80`: Revenue per short-term transshipment.  
- `short_term_stay = 3.3`: Slot-hours consumed per short-term transshipment.  
- `short_term_max_demand = 271`: Upper limit on short-term transshipments.  

**3. Objective Function:**  
Maximize total daily revenue:  
`Maximize: (long_term_price * x_long_term) + (short_term_revenue_per_container * x_short_term)`  

**4. Constraints:**  
- **Slot-hour capacity:** `(x_long_term * long_term_stay) + (x_short_term * short_term_stay) ≤ total_slot_hours`  
- **Long-term demand bounds:** `long_term_min_required ≤ x_long_term ≤ min(long_term_max_demand, total_slots)`  
- **Short-term demand bound:** `x_short_term ≤ short_term_max_demand`  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_slots = 59
op_hours = 9.5
total_slot_hours = 560.5
long_term_price = 36
long_term_stay = 3.4
long_term_max_demand = 114
long_term_min_required = 37
short_term_rate = 6
short_term_stay = 3.3
short_term_revenue_per_container = 19.80
short_term_max_demand = 271
# --- End Parameters ---

GUROBI_TIME_LIMIT = 45

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m27 = gp.Model("CONTAINER_TERMINAL_REVENUE_MGT_MIP", env=env)

    # --- Decision Variables ---
    # Integer: Number of long-term storage reservations and short-term transshipments accepted
    x_long_term = m27.addVar(vtype=GRB.INTEGER, name="num_long_term_reservations", lb=0)
    x_short_term = m27.addVar(vtype=GRB.INTEGER, name="num_short_term_transshipments", lb=0)

    # --- Objective Function ---
    # Maximize total daily revenue
    m27.setObjective(long_term_price * x_long_term + short_term_revenue_per_container * x_short_term, sense=GRB.MAXIMIZE)

    # --- Constraints ---
    # Constraint 1: Total slot-hour usage capacity
    m27.addConstr(x_long_term * long_term_stay + x_short_term * short_term_stay <= total_slot_hours, name="slot_hour_capacity")

    # Constraint 2: Long-term demand upper bound
    m27.addConstr(x_long_term <= long_term_max_demand, name="long_term_demand_max")

    # Constraint 3: Long-term minimum requirement
    m27.addConstr(x_long_term >= long_term_min_required, name="long_term_demand_min")

    # Constraint 4: Short-term demand upper bound
    m27.addConstr(x_short_term <= short_term_max_demand, name="short_term_demand_max")

    # Constraint 5: Physical slot limit (optional, but good check)
    m27.addConstr(x_long_term <= total_slots, name="long_term_slot_limit")
    # Physical limit for short-term is trickier, rely on slot hours

    # --- Optimization ---
    m27.optimize()

    # --- Store results ---
    results_dict['status'] = m27.status
    if m27.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m27.ObjVal
        results_dict['x_long_term_sol'] = x_long_term.X
        results_dict['x_short_term_sol'] = x_short_term.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- CONTAINER_TERMINAL_REVENUE_MGT: Container Terminal Revenue Management (MIP) ---")
    if m27.status == GRB.OPTIMAL:
        opt_long_term = int(round(results_dict.get('x_long_term_sol', 0))) # Round and convert to int
        opt_short_term = int(round(results_dict.get('x_short_term_sol', 0)))
        slot_hours_used = opt_long_term * long_term_stay + opt_short_term * short_term_stay
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Maximum Total Daily Revenue: ${obj_val_print:.2f}")
        print(f"Optimal number of Long-Term Reservations: {opt_long_term} (Demand: {long_term_min_required}-{long_term_max_demand})")
        print(f"Optimal number of Short-Term Transshipments: {opt_short_term} (Demand: {short_term_max_demand})")
        print(f"Total Slot-Hours Used: {slot_hours_used:.1f} / {total_slot_hours:.1f}")
        # Calculate breakdown based on optimal integer values
        revenue_long_term = opt_long_term * long_term_price
        revenue_short_term = opt_short_term * short_term_revenue_per_container
        print(f"Revenue Breakdown: Long-Term=${revenue_long_term:.2f}, Short-Term=${revenue_short_term:.2f}")

    elif m27.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible.")
         print(f"Check constraints: Min Long-Term Required ({long_term_min_required}) vs Max Demand ({long_term_max_demand}), Slot Hours ({total_slot_hours:.1f}), Slots ({total_slots}).")
         print(f"Min long-term requires {long_term_min_required * long_term_stay:.1f} slot-hours.")

    elif m27.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         # Try to get objective if available (MIPs might have feasible before timeout)
         if m27.ObjVal is not None and abs(m27.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m27.ObjVal:.2f} (Solution may be suboptimal or non-integer)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m27.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2


```
Answer:
--- CONTAINER_TERMINAL_REVENUE_MGT: Container Terminal Revenue Management (MIP) ---
Optimization Status: Optimal
Maximum Total Daily Revenue: $4282.20
Optimal number of Long-Term Reservations: 59 (Demand: 37-114)
Optimal number of Short-Term Transshipments: 109 (Demand: 271)
Total Slot-Hours Used: 560.3 / 560.5
Revenue Breakdown: Long-Term=$2124.00, Short-Term=$2158.20



================================================================================



--- Problem 366 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling six incoming trucks (T1 to T6) across three available depots (D1 to D3). Each truck arrives at a specific time: T1 at 5 hours, T2 at 8, T3 at 9, T4 at 10, T5 at 12, and T6 at 16. The hub incurs two types of costs: *waiting costs* (penalties for delays before servicing) and *service costs* (operational expenses during handling). For example, T1 incurs a waiting cost of $114 per hour if it idles, while servicing it at D1 costs $45 per hour. Processing times vary—T1 takes 5 hours, T2 takes 7, and so on.  

   The hub aims to balance two competing priorities: minimizing the *total weighted cost* (combining waiting and service costs) and reducing the *makespan* (total time to complete all operations). A weight of 0.41 is assigned to makespan and 0.59 to total cost, reflecting managerial preference. The core question: *How should trucks be assigned to depots and sequenced to achieve the optimal trade-off between cost and efficiency?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i,j]`: Binary (1 if truck *i* is assigned to depot *j*).  
   - `start_time[i]`: Continuous (when truck *i* begins service).  
   - `completion_time[i]`: Continuous (when truck *i* finishes).  
   - `precedes[i,k,j]`: Binary (1 if truck *i* is serviced before truck *k* on depot *j*).  
   - `makespan`: Continuous (maximum completion time across all trucks).  

   **2. Parameters:**  
   - `arrival_times[i]`, `processing_times[i]`, `waiting_costs[i]`: Per-truck data.  
   - `service_costs[i,j]`: Cost rate for servicing truck *i* at depot *j*.  
   - `alpha=0.41`, `beta=0.59`: Objective weights.  
   - `H=100`: A large constant for logical constraints.  

   **3. Objective Function:**  
   Minimize:  
   `0.41 * makespan + 0.59 * (sum(waiting_costs[i] * (start_time[i] - arrival_times[i]) + sum(service_costs[i,j] * processing_times[i] * assign[i,j]))`  

   **4. Constraints:**  
   - Each truck assigned to exactly one depot: `sum(assign[i,j] for j in depots) = 1` for all *i*.  
   - Start time ≥ arrival time: `start_time[i] ≥ arrival_times[i]` for all *i*.  
   - Completion time definition: `completion_time[i] = start_time[i] + processing_times[i]`.  
   - Non-overlapping on depots: If `assign[i,j] = assign[k,j] = 1`, enforce `start_time[k] ≥ completion_time[i]` OR vice versa via `precedes[i,k,j]`.  
   - Makespan bounds: `makespan ≥ completion_time[i]` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
depots = [1, 2, 3]
arrival_times = {1: 5, 2: 8, 3: 9, 4: 10, 5: 12, 6: 16}
processing_times = {1: 5, 2: 7, 3: 5, 4: 7, 5: 7, 6: 5}
waiting_costs = {1: 114, 2: 135, 3: 131, 4: 142, 5: 138, 6: 104} # Cost per hour waiting
service_costs = {(1, 1): 45, (1, 2): 48, (1, 3): 50, (2, 1): 65, (2, 2): 61, (2, 3): 51, (3, 1): 67, (3, 2): 68, (3, 3): 49, (4, 1): 59, (4, 2): 64, (4, 3): 64, (5, 1): 69, (5, 2): 45, (5, 3): 47, (6, 1): 70, (6, 2): 66, (6, 3): 45} # Cost rate per hour servicing {(truck, depot): cost}
alpha = 0.41 # Weight for Makespan
beta = 0.59  # Weight for Total Cost
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    waiting_cost_expr = gp.quicksum(waiting_costs.get(i, 0) * (start_time[i] - arrival_times.get(i, 0)) for i in trucks)
    service_cost_expr = gp.quicksum(service_costs.get((i,j), 0) * processing_times.get(i, 0) * assign[i,j]
                                   for i in trucks for j in depots)
    total_cost = waiting_cost_expr + service_cost_expr
    m.setObjective(alpha * makespan + beta * total_cost, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Weighted objective
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.2f}, Completion Time: {completion_time[i].x:.2f}")
    print(f"Makespan: {makespan.x:.2f}")
    print(f"Total Cost: {total_cost.getValue():.2f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
5223.5600
Optimal Solution Found:
Truck 1 assigned to Depot 1
Start Time: 5.00, Completion Time: 10.00
Truck 2 assigned to Depot 3
Start Time: 34.00, Completion Time: 41.00
Truck 3 assigned to Depot 3
Start Time: 10.00, Completion Time: 15.00
Truck 4 assigned to Depot 1
Start Time: 15.00, Completion Time: 22.00
Truck 5 assigned to Depot 2
Start Time: 27.00, Completion Time: 34.00
Truck 6 assigned to Depot 3
Start Time: 22.00, Completion Time: 27.00
Makespan: 41.00
Total Cost: 8825.00


```

================================================================================



--- Problem 367 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy trucking depot, ten delivery trucks arrive at staggered times, each requiring a loading dock for unloading and processing. The depot has only three docks available, creating a complex scheduling challenge. Trucks cannot be processed before their arrival, and once assigned to a dock, each truck occupies it for a specific duration. The goal is to minimize the total waiting time—the cumulative difference between when a truck arrives and when it actually starts processing—across all trucks.  

For instance, Truck 1 arrives at time 1 and takes 5 hours to process, while Truck 2 arrives at time 2 but requires 10 hours. The depot manager must carefully assign trucks to docks to avoid overlaps and ensure no truck starts before its arrival. The challenge is compounded by the varying processing times and the limited dock capacity. The central question is: *How can the trucks be assigned to docks to minimize the total waiting time while respecting arrival times and dock availability?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to dock *j*, 0 otherwise).  
   - `start_time(i)`: Continuous variable representing the time truck *i* starts processing.  
   - `completion_time(i)`: Continuous variable representing the time truck *i* finishes processing.  
   - `precedes(i, k, j)`: Binary variable (1 if truck *i* is processed before truck *k* on dock *j*, 0 otherwise).  

   **2. Parameters:**  
   - `trucks = [1, 2, ..., 10]`: List of trucks.  
   - `docks = [1, 2, 3]`: List of docks.  
   - `arrival_times`: Dictionary mapping each truck to its arrival time (e.g., Truck 1 arrives at time 1).  
   - `processing_times`: Dictionary mapping each truck to its processing duration (e.g., Truck 1 takes 5 hours).  
   - `H = 200`: A large constant (Big-M) for enforcing precedence constraints.  

   **3. Objective Function:**  
   Minimize the total waiting time:  
   \[
   \text{Minimize: } \sum_{i \in \text{trucks}} (\text{start_time}(i) - \text{arrival_times}(i))
   \]  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one dock:  
     \[
     \sum_{j \in \text{docks}} \text{assign}(i, j) = 1 \quad \forall i \in \text{trucks}.
     \]  
   - **Arrival Time:** A truck cannot start processing before it arrives:  
     \[
     \text{start_time}(i) \geq \text{arrival_times}(i) \quad \forall i \in \text{trucks}.
     \]  
   - **Completion Time:** The completion time is the start time plus processing time:  
     \[
     \text{completion_time}(i) = \text{start_time}(i) + \text{processing_times}(i) \quad \forall i \in \text{trucks}.
     \]  
   - **Non-Overlapping:** If two trucks are assigned to the same dock, one must precede the other:  
     \[
     \text{If } \text{precedes}(i, k, j) = 1, \text{ then } \text{start_time}(k) \geq \text{completion_time}(i) \quad \forall i < k, j \in \text{docks}.
     \]  
     \[
     \text{If } \text{precedes}(i, k, j) = 0, \text{ then } \text{start_time}(i) \geq \text{completion_time}(k) \quad \forall i < k, j \in \text{docks}.
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
docks = [1, 2, 3]
arrival_times = {1: 1, 2: 2, 3: 6, 4: 8, 5: 12, 6: 14, 7: 18, 8: 19, 9: 21, 10: 24}
processing_times = {1: 5, 2: 10, 3: 8, 4: 7, 5: 5, 6: 5, 7: 6, 8: 8, 9: 7, 10: 7}
H = 200 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DOCKING_PROBLEM_17_LARGE_WAIT")

    if not trucks or not docks: raise ValueError("Empty trucks or docks")

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in docks:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")
        # Print best objective if available on timeout etc.
        if m.SolCount > 0 and abs(m.ObjVal) < GRB.INFINITY :
             print(f"{m.ObjVal:.4f}")
        elif m.status != GRB.INFEASIBLE and m.status != GRB.UNBOUNDED:
             print("No feasible solution found.")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in docks:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} assigned to Dock {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
160.0000
Optimal Solution Found:
Truck 1 assigned to Dock 1
Start Time: 1.0000, Completion Time: 6.0000
Truck 2 assigned to Dock 1
Start Time: 59.0000, Completion Time: 69.0000
Truck 3 assigned to Dock 1
Start Time: 6.0000, Completion Time: 14.0000
Truck 4 assigned to Dock 1
Start Time: 30.0000, Completion Time: 37.0000
Truck 5 assigned to Dock 1
Start Time: 19.0000, Completion Time: 24.0000
Truck 6 assigned to Dock 1
Start Time: 14.0000, Completion Time: 19.0000
Truck 7 assigned to Dock 1
Start Time: 24.0000, Completion Time: 30.0000
Truck 8 assigned to Dock 1
Start Time: 51.0000, Completion Time: 59.0000
Truck 9 assigned to Dock 1
Start Time: 44.0000, Completion Time: 51.0000
Truck 10 assigned to Dock 1
Start Time: 37.0000, Completion Time: 44.0000


```

================================================================================



--- Problem 368 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, a critical berth operates with a three-phase ship berthing system. Each phase must allocate berthing time to different types of ships, balancing efficiency and fairness. The port managers face the challenge of minimizing total ship waiting time across all phases while adhering to strict operational constraints.  

   The berth has a fixed cycle time of 77 hours, meaning the sum of all berthing times must equal this value. Each phase has a minimum berthing time of 19 hours and a maximum of 77 hours, ensuring no phase is unfairly short or excessively long. The ship traffic for the three phases is quantified by coefficients: 2614, 1768, and 2289 ships per month, respectively. These coefficients represent the relative importance of minimizing waiting time for each phase.  

   The core optimization problem is to determine the exact berthing time allocation for each phase such that the total waiting time—calculated as the sum of flow-weighted non-berthing times (cycle time minus berthing time)—is minimized. The question is: *What is the optimal distribution of berthing times across the three phases to achieve the lowest possible total waiting time while respecting the cycle time and berthing time bounds?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `t_i`: Continuous variable representing the berthing time (in hours) allocated to phase `i` (where `i = 1, 2, 3`).  
   - Bounds: `19 ≤ t_i ≤ 77` for each phase.  

   **2. Parameters:**  
   - `flow_coeffs = [2614, 1768, 2289]`: Ship traffic coefficients for phases 1, 2, and 3, respectively.  
   - `cycle_time = 77`: Total fixed cycle time (hours).  
   - `lb_time = 19`, `ub_time = 77`: Lower and upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize the total waiting time, calculated as:  
   `Minimize: sum(flow_coeffs[i] * (cycle_time - t_i) for all phases i`.  

   **4. Constraints:**  
   - The sum of berthing times must equal the cycle time:  
     `t_1 + t_2 + t_3 = 77`.  
   - Berthing time bounds for each phase:  
     `19 ≤ t_1 ≤ 77`, `19 ≤ t_2 ≤ 77`, `19 ≤ t_3 ≤ 77`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 3
lb_time = 19          # Lower bound for berthing time
ub_time = 77          # Upper bound for berthing time
cycle_time = 77       # Total cycle time (set equal to ub_time)
flow_coeffs = [2614, 1768, 2289] # Ship traffic coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_phases:
    print("Error: flow_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for phase i is proportional to flow * non-berthing time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 334638.00
------------------------------
Optimal berthing times (hours):
  t1: 39.00, t2: 19.00, t3: 19.00


```

================================================================================



--- Problem 369 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A port terminal is tasked with efficiently assigning 16 ships to 7 berths to minimize the total service time. Each ship must be assigned to exactly one berth, and the service time varies depending on the ship-berth combination. For instance, Ship 0 takes 43 minutes if assigned to Berth 0 but only 21 minutes if assigned to Berth 6. The challenge is to find the optimal assignment that ensures every ship is serviced while keeping the cumulative service time as low as possible.  

The terminal manager faces a combinatorial puzzle: with 16 ships and 7 berths, the number of possible assignments is enormous. However, the goal is clear—assign each ship to the berth where it can be serviced the fastest, avoiding inefficiencies that could delay operations. The problem mirrors real-world scenarios like airport gate assignments or warehouse docking, where minimizing idle time is critical for throughput.  

The core question is: *What is the optimal ship-to-berth assignment that minimizes the total service time while ensuring every ship is serviced exactly once?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable \( x(i, j) \) for each ship \( i \) and berth \( j \), where:  
     - \( x(i, j) = 1 \) if ship \( i \) is assigned to berth \( j \).  
     - \( x(i, j) = 0 \) otherwise.  

   **2. Parameters:**  
   - \( \text{ships} = [0, 1, \dots, 15] \): List of ships.  
   - \( \text{berths} = [0, 1, \dots, 6] \): List of berths.  
   - \( \text{service_times}(i, j) \): Predefined service time for ship \( i \) on berth \( j \) (e.g., 21 minutes for Ship 0 on Berth 6).  

   **3. Objective Function:**  
   Minimize the total service time:  
   \[
   \text{Minimize: } \sum_{i \in \text{ships}} \sum_{j \in \text{berths}} \text{service_times}(i, j) \cdot x(i, j)
   \]  

   **4. Constraints:**  
   - Each ship must be assigned to exactly one berth:  
     \[
     \sum_{j \in \text{berths}} x(i, j) = 1 \quad \forall i \in \text{ships}
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] # List of ship indices
berths = [0, 1, 2, 3, 4, 5, 6]       # List of berth indices
service_times = {(0, 0): 43, (0, 1): 55, (0, 2): 99, (0, 3): 91, (0, 4): 88, (0, 5): 43, (0, 6): 21, (1, 0): 25, (1, 1): 31, (1, 2): 68, (1, 3): 27, (1, 4): 34, (1, 5): 21, (1, 6): 50, (2, 0): 83, (2, 1): 59, (2, 2): 96, (2, 3): 61, (2, 4): 56, (2, 5): 45, (2, 6): 50, (3, 0): 38, (3, 1): 29, (3, 2): 58, (3, 3): 73, (3, 4): 85, (3, 5): 71, (3, 6): 51, (4, 0): 98, (4, 1): 82, (4, 2): 26, (4, 3): 69, (4, 4): 39, (4, 5): 34, (4, 6): 64, (5, 0): 56, (5, 1): 27, (5, 2): 61, (5, 3): 75, (5, 4): 53, (5, 5): 26, (5, 6): 74, (6, 0): 91, (6, 1): 38, (6, 2): 48, (6, 3): 20, (6, 4): 67, (6, 5): 38, (6, 6): 40, (7, 0): 32, (7, 1): 88, (7, 2): 99, (7, 3): 65, (7, 4): 78, (7, 5): 36, (7, 6): 99, (8, 0): 97, (8, 1): 71, (8, 2): 84, (8, 3): 43, (8, 4): 77, (8, 5): 45, (8, 6): 45, (9, 0): 26, (9, 1): 29, (9, 2): 73, (9, 3): 90, (9, 4): 91, (9, 5): 55, (9, 6): 89, (10, 0): 65, (10, 1): 96, (10, 2): 74, (10, 3): 78, (10, 4): 86, (10, 5): 78, (10, 6): 91, (11, 0): 63, (11, 1): 28, (11, 2): 39, (11, 3): 96, (11, 4): 58, (11, 5): 71, (11, 6): 79, (12, 0): 91, (12, 1): 42, (12, 2): 79, (12, 3): 85, (12, 4): 77, (12, 5): 63, (12, 6): 65, (13, 0): 80, (13, 1): 90, (13, 2): 21, (13, 3): 35, (13, 4): 79, (13, 5): 87, (13, 6): 66, (14, 0): 87, (14, 1): 91, (14, 2): 62, (14, 3): 43, (14, 4): 59, (14, 5): 60, (14, 6): 52, (15, 0): 22, (15, 1): 86, (15, 2): 67, (15, 3): 91, (15, 4): 69, (15, 5): 50, (15, 6): 65} # Dict of (ship, berth): time
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("SHIP_BERTH_ASSIGNMENT", env=env)

    # --- Decision Variables ---
    # x[i, j] = 1 if ship i is assigned to berth j, 0 otherwise
    # Use tuplelist for keys if service_times keys are tuples
    assignment_keys = list(service_times.keys())
    x = m.addVars(assignment_keys, vtype=GRB.BINARY, name="x")

    # --- Objective Function: Minimize total service time ---
    m.setObjective(gp.quicksum(service_times[i, j] * x[i, j] for i, j in assignment_keys), GRB.MINIMIZE)

    # --- Constraints ---
    # Each ship must be assigned to exactly one berth
    for i in ships:
        # Ensure we sum only existing keys for ship i
        m.addConstr(gp.quicksum(x[i, j] for j in berths if (i, j) in x) == 1, name=f"ShipAssignment_{i}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        results_dict['x_sol'] = m.getAttr('X', x) # Store variable values

    # --- Output Results ---
    print(f"--- SHIP_BERTH_ASSIGNMENT Results ---")
    if m.Status == GRB.OPTIMAL:
        x_sol = results_dict.get('x_sol', {})
        print(f"Optimization Status: Optimal")
        print(f"Minimum Total Service Time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("Optimal Assignment (Ship -> Berth):")
        assigned_count = 0
        for i in ships:
            for j in berths:
                 key = (i, j)
                 # Use .get on x_sol dictionary
                 if key in x_sol and x_sol.get(key, 0) > 0.5:
                     print(f"  Ship {i} -> Berth {j} (Service Time: {service_times.get(key, 'N/A')})")
                     assigned_count += 1
                     break # Move to next ship once assigned
        print(f"Total ships assigned: {assigned_count} / {len(ships)}")

    elif m.Status == GRB.INFEASIBLE:
        print(f"Optimization Status: Infeasible (This should not happen for assignment problems if setup correctly).")
    elif m.Status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         if m.ObjVal is not None and abs(m.ObjVal) < float('inf'):
              print(f"Best Objective Found: {m.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m.Status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- SHIP_BERTH_ASSIGNMENT Results ---
Optimization Status: Optimal
Minimum Total Service Time: 510.00
Optimal Assignment (Ship -> Berth):
  Ship 0 -> Berth 6 (Service Time: 21)
  Ship 1 -> Berth 5 (Service Time: 21)
  Ship 2 -> Berth 5 (Service Time: 45)
  Ship 3 -> Berth 1 (Service Time: 29)
  Ship 4 -> Berth 2 (Service Time: 26)
  Ship 5 -> Berth 5 (Service Time: 26)
  Ship 6 -> Berth 3 (Service Time: 20)
  Ship 7 -> Berth 0 (Service Time: 32)
  Ship 8 -> Berth 3 (Service Time: 43)
  Ship 9 -> Berth 0 (Service Time: 26)
  Ship 10 -> Berth 0 (Service Time: 65)
  Ship 11 -> Berth 1 (Service Time: 28)
  Ship 12 -> Berth 1 (Service Time: 42)
  Ship 13 -> Berth 2 (Service Time: 21)
  Ship 14 -> Berth 3 (Service Time: 43)
  Ship 15 -> Berth 0 (Service Time: 22)
Total ships assigned: 16 / 16


```

================================================================================



--- Problem 370 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
A highway network with five distinct segments faces recurring traffic disruptions due to incidents, each lasting between 0.66 to 1.94 hours. To mitigate congestion, traffic managers must dynamically reroute vehicles to alternative pathways during these incidents. Each segment has unique characteristics: mainline capacities under normal (4166–4416 veh/h) and reduced conditions (1546–2275 veh/h), alternative route capacities (1068–1659 veh/h), and varying arrival rates (2065–4966 veh/h) across eight 30-minute time periods. The challenge lies in selecting diversion ratios (10%, 30%, 50%, or 70%) for each segment and time period to minimize total delay, while ensuring flows do not exceed alternative route capacities and diversion changes between periods are smooth (limited to ±20% shifts). Additionally, the optimization must balance queue delays on the mainline (caused by reduced capacity during incidents) against added travel time on alternative routes, all while adapting to fluctuating demand and incident durations.

**Modeling Process:**
- **1. Decision Variables:**  
     Binary variables `y(i,t,k)` for each segment `i` (1–5), time period `t` (1–8), and diversion option `k` (0–3, representing 10%, 30%, 50%, 70%). `y(i,t,k)=1` if option `k` is selected for segment `i` in period `t`.  
   - **2. Parameters:**  
     - `capacities_main_normal[i]`, `capacities_main_reduced[i]`: Mainline capacities (veh/h).  
     - `capacities_alt[i]`: Alternative route capacities (veh/h).  
     - `arrival_rates[i][t]`: Demand (veh/h) for segment `i` in period `t`.  
     - `alt_route_extra_times[i]`: Additional travel time (hours) for alternative routes.  
     - `MAX_DIVERSION_CHANGE=0.2`: Maximum allowed diversion ratio change between periods.  
   - **3. Objective Function:**  
     Minimize total delay:  
     `Sum over i,t,k of [y(i,t,k) * (delay_alt_k + delay_queue_main_k)]`, where:  
     - `delay_alt_k = arrival_rates[i][t] * p_k * TIME_PERIOD_LENGTH * alt_route_extra_times[i]` (alternative route delay).  
     - `delay_queue_main_k` is calculated based on queue dissipation logic when mainline flow exceeds reduced capacity.  
   - **4. Constraints:**  
     - **Feasibility:** For each `(i,t)`, exactly one feasible diversion option must be selected (if flow ≤ alternative capacity).  
     - **Smooth Transitions:** If `|p_k1 - p_k2| > 0.2`, prevent consecutive selections of `k1` and `k2` in adjacent periods.  
     - **Infeasibility:** Force `y(i,t,k)=0` if the option violates alternative route capacity.  
     - **New Constraint:** Ensure that the total flow on the mainline does not exceed 90% of its normal capacity during any time period to avoid extreme congestion.

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_SEGMENTS = 5
NUM_TIME_PERIODS = 8
TIME_PERIOD_LENGTH = 0.5  # h
MAX_DIVERSION_CHANGE = 0.2  # Maximum allowed change in diversion ratio
capacities_main_normal = [4166, 3373, 4250, 3800, 4416]  # veh/h
capacities_main_reduced = [2101, 1959, 1867, 1546, 2275]  # veh/h
capacities_alt = [1122, 1575, 1659, 1294, 1068]  # veh/h
arrival_rates = [[4685, 2760, 2382, 2245, 4755, 4916, 2834, 4775], [2760, 4939, 4106, 2918, 4857, 4147, 2431, 3556], [4202, 3192, 4894, 4772, 4065, 3153, 2609, 3363], [2056, 3752, 4684, 3373, 3939, 3603, 2086, 3096], [2994, 3604, 2077, 3345, 4574, 2065, 4966, 4445]]  # veh/h
incident_durations = [1.299590400842582, 1.9417141538733476, 1.4053565699700399, 0.6553160362335735, 1.2795017154636952]  # h
alt_route_extra_times = [0.09664093519270532, 0.10126365355054633, 0.3220846963869224, 0.250521596105668, 0.2035924505067898]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Segment and Time Period ---
segment_period_option_delays = {}
segment_period_option_feasible = {}

for i in range(NUM_SEGMENTS):
    segment_period_option_delays[i] = {}
    segment_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        segment_period_option_delays[i][t] = {}
        segment_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Route Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                segment_period_option_feasible[i][t][k] = False
                segment_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            segment_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Route Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_route_extra_times[i]

            # 3. Calculate Main Route Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            segment_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiSegment_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_SEGMENTS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_SEGMENTS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if segment_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Segment{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not segment_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Segment{0}_Period{1}_Option{2}".format(i,t,k))

        # Add smooth transition constraints between periods
        if t > 0:
            for k1 in range(num_options):
                for k2 in range(num_options):
                    if abs(diversion_options[k1] - diversion_options[k2]) > MAX_DIVERSION_CHANGE:
                        m.addConstr(y[i,t-1,k1] + y[i,t,k2] <= 1,
                                  name="SmoothTransition_Segment{0}_Period{1}_Options{2}{3}".format(i,t,k1,k2))

        # New Constraint: Ensure that the total flow on the mainline does not exceed 90% of its normal capacity
        m.addConstr(gp.quicksum(arrival_rates[i][t] * (1 - diversion_options[k]) * y[i,t,k] for k in range(num_options)) <= 0.9 * capacities_main_normal[i],
                    name="MainlineCapacityLimit_Segment{0}_Period{1}".format(i,t))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * segment_period_option_delays[i][t][k]
        for i in range(NUM_SEGMENTS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if segment_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Segment Dynamic Diversion Strategy:")
    for i in range(NUM_SEGMENTS):
        print("\nSegment {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:



================================================================================



--- Problem 371 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently packing a set of 14 items into trucks for delivery. Each item has a specific weight and is labeled with a unique color code. The trucks have a strict weight capacity of 72 units, and an additional operational rule complicates the packing: no truck can contain items of more than two distinct colors. The challenge is to minimize the number of trucks used while adhering to both the weight limit and the color diversity constraint.  

   The items vary significantly in weight, ranging from as light as 13 units to as heavy as 58 units. Their colors span a diverse set, including 'A', 'B', 'C', 'D', 'G', 'H', 'I', 'L', 'V', 'X', and 'Y'. Some colors, like 'B', appear multiple times, while others are unique. The company must ensure that no truck is overloaded and that the color constraint is strictly enforced—meaning, for example, a truck cannot simultaneously contain items of colors 'A', 'B', and 'C', but it can accommodate 'A' and 'B'.  

   The core question is: *What is the smallest number of trucks required to pack all items without violating the weight or color constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether item `i` is assigned to truck `j`.  
   - `y[j]`: Binary variable indicating whether truck `j` is used.  
   - `z[c, j]`: Binary variable indicating whether color `c` is present in truck `j`.  

   **2. Parameters:**  
   - `items`: List of item weights (e.g., `[28, 26, 39, ..., 17]`).  
   - `colors`: List of item colors (e.g., `['I', 'H', 'A', ..., 'B']`).  
   - `capacity`: Maximum weight per truck (72).  
   - `num_items`: Total items (14).  
   - `num_trucks`: Maximum possible trucks (14, one per item in the worst case).  

   **3. Objective Function:**  
   Minimize the total number of trucks used:  
   ```  
   Minimize: sum(y[j] for all j)  
   ```  

   **4. Constraints:**  
   - **Item Assignment:** Each item must be placed in exactly one truck:  
     ```  
     For each item i: sum(x[i, j] for all j) == 1  
     ```  
   - **Truck Capacity:** The total weight in a truck cannot exceed its capacity:  
     ```  
     For each truck j: sum(items[i] * x[i, j] for all i) <= capacity * y[j]  
     ```  
   - **Color Linking:** If an item of color `c` is in truck `j`, `z[c, j]` must be 1:  
     ```  
     For each color c and truck j: x[i, j] <= z[c, j] for all i of color c  
     ```  
   - **Color Limit:** Each used truck can have at most 2 distinct colors:  
     ```  
     For each truck j: sum(z[c, j] for all c) <= 2 * y[j]  
     ```  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
items = [28, 26, 39, 13, 33, 50, 28, 39, 37, 27, 15, 56, 58, 17]      # Weights of items
colors = ['I', 'H', 'A', 'Y', 'D', 'G', 'V', 'B', 'B', 'D', 'L', 'C', 'X', 'B']    # Colors of items
capacity = 72         # Truck capacity
num_items = 14       # len(items) - derived correctly below
num_trucks = num_items      # Maximum trucks (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(items) != len(colors) or len(items) != num_items:
    print("Error: Data inconsistency (items/colors/num_items length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_colors_list = sorted(list(set(colors))) # Get unique colors deterministically
item_indices_by_color = {color: [i for i, c in enumerate(colors) if c == color] for color in unique_colors_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Color-Constrained Truck Packing", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")  # x[i,j] -> item i in truck j
        y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")              # y[j] -> whether truck j is used
        # z[c,j] -> whether color c is PRESENT in truck j (Use unique_colors_list for keys)
        z = model.addVars(unique_colors_list, num_trucks, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of trucks used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each item must be assigned to exactly one truck ---
        for i in range(num_items):
            model.addConstr(x.sum(i, '*') == 1, name=f"Item_{i}_Assignment")

        # --- Constraint 2: Truck capacity constraint ---
        for j in range(num_trucks):
            model.addConstr(gp.quicksum(items[i] * x[i, j] for i in range(num_items)) <= capacity * y[j], name=f"Truck_{j}_Capacity")

        # --- Constraint 3: Color constraint (at most 2 *different* colors per truck) ---

        # Part 3a: Link x (item in truck) and z (color in truck).
        for j in range(num_trucks):
            for color in unique_colors_list:
                indices_of_this_color = item_indices_by_color.get(color, []) # Use .get for safety

                if not indices_of_this_color:
                    # If no items of this color exist, z[color, j] must be 0.
                    model.addConstr(z[color, j] == 0, name=f"NoItems_{color}_Truck_{j}")
                    continue

                # If any item 'i' of this 'color' is placed in truck 'j' (x[i,j]=1),
                # then the presence indicator for that 'color' in truck 'j' (z[color,j]) must be 1.
                for i in indices_of_this_color:
                    model.addConstr(x[i, j] <= z[color, j], name=f"Link_x{i}_z{color}_Truck{j}")

                # Ensure z[color, j] is 0 if no items of that color are in the truck.
                # This helps tighten the formulation.
                model.addConstr(z[color, j] <= gp.quicksum(x[i, j] for i in indices_of_this_color), name=f"Link_z{color}_SumX_Truck{j}")


        # Part 3b: Limit the number of distinct colors (sum of z[c,j] for truck j) to 2 for USED trucks.
        for j in range(num_trucks):
            # sum(z[c,j] for c in unique_colors_list) gives the count of distinct colors in truck j.
            # This sum must be <= 2 *IF* the truck is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Colors_Truck_{j}")

        # --- Solve ---
        print("Solving CCTP instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_trucks = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of trucks used: {optimal_trucks}")
    print("-" * 30)

    truck_details = []
    printed_truck_count = 0
    for j_sol in range(num_trucks): # Iterate through all potential truck indices
        try:
             # Check if this truck was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_truck_count += 1
                 assigned_items_indices = [i for i in range(num_items) if x[i, j_sol].X > 0.5]
                 assigned_items_weights = [items[i] for i in assigned_items_indices]
                 assigned_items_colors = [colors[i] for i in assigned_items_indices]
                 distinct_colors_in_truck = sorted(list(set(assigned_items_colors))) # Sort for consistent output
                 truck_load = sum(assigned_items_weights)

                 print(f"Truck {printed_truck_count} (Internal Index {j_sol}):")
                 print(f"  Items (indices): {assigned_items_indices}")
                 # print(f"  Items (weights): {assigned_items_weights}") # Optional details
                 # print(f"  Items (colors):  {assigned_items_colors}") # Optional details
                 print(f"  Distinct Colors: {distinct_colors_in_truck} (Count: {len(distinct_colors_in_truck)})")
                 print(f"  Total weight:    {truck_load} / {capacity}")
                 print("-" * 10)

                 truck_data = {
                     'truck_index_internal': j_sol,
                     'truck_index_printed': printed_truck_count,
                     'item_indices': assigned_items_indices,
                     'distinct_colors': distinct_colors_in_truck,
                     'load': truck_load
                 }
                 truck_details.append(truck_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for truck index {j_sol}: {e_print}")


    results_dict['truck_details'] = truck_details # Store details

    # Final sanity check
    if printed_truck_count != optimal_trucks:
         print(f"Warning: Number of printed used trucks ({printed_truck_count}) does not match objective value ({optimal_trucks}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# The provided code already prints the required outputs, so no additional print statements are needed.
```
Answer:
Solving CCTP instance...
------------------------------

Optimal solution found.
Optimal number of trucks used: 7
------------------------------
Truck 1 (Internal Index 2):
  Items (indices): [5, 13]
  Distinct Colors: ['B', 'G'] (Count: 2)
  Total weight:    67 / 72
----------
Truck 2 (Internal Index 4):
  Items (indices): [3, 12]
  Distinct Colors: ['X', 'Y'] (Count: 2)
  Total weight:    71 / 72
----------
Truck 3 (Internal Index 5):
  Items (indices): [10, 11]
  Distinct Colors: ['C', 'L'] (Count: 2)
  Total weight:    71 / 72
----------
Truck 4 (Internal Index 6):
  Items (indices): [4, 8]
  Distinct Colors: ['B', 'D'] (Count: 2)
  Total weight:    70 / 72
----------
Truck 5 (Internal Index 8):
  Items (indices): [1, 7]
  Distinct Colors: ['B', 'H'] (Count: 2)
  Total weight:    65 / 72
----------
Truck 6 (Internal Index 9):
  Items (indices): [6, 9]
  Distinct Colors: ['D', 'V'] (Count: 2)
  Total weight:    55 / 72
----------
Truck 7 (Internal Index 11):
  Items (indices): [0, 2]
  Distinct Colors: ['A', 'I'] (Count: 2)
  Total weight:    67 / 72
----------


```

================================================================================



--- Problem 372 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port operator is tasked with efficiently managing ship berthing across two types of berths: Automated Berthing (AB) and Manual Berthing (MB). The port has 3 AB berths and 2 MB berths, each with distinct processing times—5 minutes per ship for AB and 38 minutes for MB. During a 358-minute observation period, 95 ships arrive, with 54% (51 ships) equipped for AB and 46% (44 ships) requiring MB. The AB berths collectively handle up to 214.80 ships per period, while MB berths manage only 18.84.  

The challenge lies in balancing berth usage to minimize congestion, measured by the maximum volume-to-capacity (V/C) ratio across berths. AB ships may use either berth type, but MB ships are restricted to MB berths. The operator must decide how many AB ships to divert to MB berths (if any) to prevent overloading either berth type, ensuring smooth traffic flow while adhering to berth capacities.  

**Core Question:** What is the optimal distribution of AB ships between berth types to minimize the worst-case congestion (V/C ratio) across all berths?  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
   - `n_ab_ab`: Integer, number of AB ships assigned to AB berths (≥0).  
   - `n_ab_mb`: Integer, number of AB ships assigned to MB berths (≥0).  
   - `n_mb_mb`: Integer, number of MB ships (fixed to 44, must use MB berths).  
   - `MaxVC`: Continuous, maximum V/C ratio across berths (≥0).  

   **2. Parameters:**  
   - `num_ab_ships = 51`, `num_mb_ships = 44` (ship counts).  
   - `cap_ab = 214.80`, `cap_mb = 18.84` (berth capacities).  
   - `epsilon = 1e-6` (small value to avoid division by zero).  

   **3. Objective Function:**  
   Minimize `MaxVC` (the worst V/C ratio across berths).  

   **4. Constraints:**  
   - **Ship Conservation:**  
     - AB ships: `n_ab_ab + n_ab_mb = 51`.  
     - MB ships: `n_mb_mb = 44`.  
   - **V/C Ratio Bounds:**  
     - For AB berths: `MaxVC * (cap_ab + epsilon) ≥ n_ab_ab`.  
     - For MB berths: `MaxVC * (cap_mb + epsilon) ≥ n_ab_mb + n_mb_mb`.  
   - **Non-negativity:** All variables ≥0.  

---

**

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_ab_berths = 3
num_mb_berths = 2
time_ab_mins = 5
time_mb_mins = 38
period_mins = 358
total_arrivals = 95
pct_ab = 0.54
pct_mb = 0.46
# Calculated values
num_ab_ships = 51
num_mb_ships = 44
cap_ab = 214.80
cap_mb = 18.84
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTH_BALANCING", env=env)

    # --- Decision Variables ---
    # n_ab_ab: Number of AB ships using AB berths
    n_ab_ab = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_ab_ab")
    # n_ab_mb: Number of AB ships using MB berths
    n_ab_mb = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_ab_mb")
    # n_mb_mb: Number of MB ships using MB berths (fixed by input)
    # This can be treated as data, but keep as variable for consistency if needed
    n_mb_mb = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_mb_mb")
    # MaxVC: Maximum V/C ratio across berth types
    MaxVC = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="MaxVC") # V/C >= 0

    # --- Objective Function: Minimize the maximum V/C ratio ---
    m.setObjective(MaxVC, GRB.MINIMIZE)

    # --- Constraints ---
    # Conservation of AB ships
    m.addConstr(n_ab_ab + n_ab_mb == num_ab_ships, "ABConserve")

    # Fix MB ships (must use MB berths)
    m.addConstr(n_mb_mb == num_mb_ships, "MBConserve")

    # Calculate flows
    flow_ab = n_ab_ab
    flow_mb = n_ab_mb + n_mb_mb

    # Max V/C calculation (using linear form MaxVC * Capacity >= Flow)
    # Use epsilon to avoid issues if capacity is exactly zero
    epsilon = 1e-6
    if cap_ab > 0:
        m.addConstr(MaxVC * (cap_ab + epsilon) >= flow_ab, "VC_AB")
    else:
         # If AB capacity is zero, no AB ships can use AB berths
         m.addConstr(n_ab_ab == 0, "ZeroCapAB")

    if cap_mb > 0:
        m.addConstr(MaxVC * (cap_mb + epsilon) >= flow_mb, "VC_MB")
    else:
        # If MB capacity is zero, no ships can use MB berths
        m.addConstr(n_ab_mb == 0, "ZeroCapMB_AB")
        m.addConstr(n_mb_mb == 0, "ZeroCapMB_MB") # Will likely make infeasible if num_mb > 0

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_ab_ab_sol'] = n_ab_ab.X # Not needed for output
        # results_dict['n_ab_mb_sol'] = n_ab_mb.X
        # results_dict['n_mb_mb_sol'] = n_mb_mb.X

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is Max V/C ratio
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show precision
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the decision variables
if m.Status == GRB.OPTIMAL:
    print(f"Optimal objective value: {obj_val_print:.4f}")
    print(f"Number of AB ships assigned to AB berths: {n_ab_ab.X}")
    print(f"Number of AB ships assigned to MB berths: {n_ab_mb.X}")
    print(f"Number of MB ships assigned to MB berths: {n_mb_mb.X}")
```
Answer:
Optimal objective value: 2.3355
Optimal objective value: 2.3355
Number of AB ships assigned to AB berths: 51.0
Number of AB ships assigned to MB berths: 0.0
Number of MB ships assigned to MB berths: 44.0


```

================================================================================



--- Problem 373 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling the unloading of five incoming trucks at two available depots. Each truck, labeled 1 through 5, arrives at staggered times (Truck 1 at 5 hours, Truck 2 at 9 hours, etc.) and requires varying processing durations (Truck 1 needs 8 hours, Truck 2 needs 5 hours, etc.). The trucks belong to different types (A, B, or C), and a setup time of 0.5 hours is imposed when transitioning from unloading a Type A truck to a Type B truck at the same depot. The hub manager must assign each truck to a depot and schedule their start times to minimize the total makespan—the time when the last truck completes unloading—while respecting arrival times, processing durations, and setup constraints. The core question is: *What is the optimal depot assignment and schedule to minimize the total makespan, given these operational rules and truck-specific requirements?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable indicating whether truck `i` is assigned to depot `j`.  
   - `start_time(i)`: Continuous variable representing the start time of truck `i`.  
   - `completion_time(i)`: Continuous variable representing the completion time of truck `i` (start time + processing time).  
   - `precedes(i, k, j)`: Binary variable indicating whether truck `i` precedes truck `k` on depot `j`.  
   - `setup(i, k, j)`: Continuous variable representing the setup time between trucks `i` and `k` on depot `j`.  
   - `makespan`: Continuous variable representing the total makespan.  

   **2. Parameters:**  
   - `trucks`: [1, 2, 3, 4, 5] (list of trucks).  
   - `depots`: [1, 2] (list of depots).  
   - `arrival_times`: {1: 5, 2: 9, 3: 11, 4: 12, 5: 14} (arrival time for each truck).  
   - `processing_times`: {1: 8, 2: 5, 3: 3, 4: 8, 5: 4} (processing time for each truck).  
   - `truck_types`: {1: 'A', 2: 'C', 3: 'B', 4: 'B', 5: 'A'} (type of each truck).  
   - `setup_time_value`: 0.5 (setup time for A → B transition).  
   - `H`: 100 (a large constant for big-M constraints).  

   **3. Objective Function:**  
   Minimize `makespan`.  

   **4. Constraints:**  
   - Each truck must be assigned to exactly one depot: `sum(assign(i, j) for j in depots) = 1` for all `i` in `trucks`.  
   - Start time must not precede arrival time: `start_time(i) >= arrival_times[i]` for all `i` in `trucks`.  
   - Completion time is start time plus processing time: `completion_time(i) = start_time(i) + processing_times[i]` for all `i` in `trucks`.  
   - Precedence and setup constraints:  
     - If `precedes(i, k, j) = 1`, then `setup(i, k, j) >= setup_time_value` if transitioning from A to B, else `setup(i, k, j) = 0`.  
     - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i) + setup(i, k, j)`.  
     - For pairs of trucks on the same depot, enforce mutual exclusion of precedence: `precedes(i, k, j) + precedes(k, i, j) >= assign(i, j) + assign(k, j) - 1` and `precedes(i, k, j) + precedes(k, i, j) <= 1`.  
   - Makespan is the maximum completion time: `makespan >= completion_time(i)` for all `i` in `trucks`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2]
arrival_times = {1: 5, 2: 9, 3: 11, 4: 12, 5: 14}
processing_times = {1: 8, 2: 5, 3: 3, 4: 8, 5: 4}
truck_types = {1: 'A', 2: 'C', 3: 'B', 4: 'B', 5: 'A'} # Dict {truck_id: type_str}
setup_time_value = 0.5 # Hours for A -> B setup
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")
    setup = m.addVars(trucks, trucks, depots, lb=0.0, vtype=GRB.CONTINUOUS, name="setup")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping and Setup Time Calculation (Copied from Problem 61)
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i == k: continue
                is_setup_needed = 1 if truck_types.get(i) == 'A' and truck_types.get(k) == 'B' else 0
                m.addGenConstrIndicator(precedes[i,k,j], True, setup[i,k,j] >= setup_time_value * is_setup_needed, name=f"setup_lower_{i}_{k}_{j}")
                m.addConstr(setup[i,k,j] <= setup_time_value * precedes[i,k,j], name=f"setup_upper_{i}_{k}_{j}")
                if not is_setup_needed:
                     m.addConstr(setup[i,k,j] == 0, name=f"setup_zero_{i}_{k}_{j}")
                m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i] + setup[i,k,j], name=f"overlap_with_setup_{i}_{k}_{j}")
                if i < k:
                     m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                     m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Ensure All Outputs are Printed ---

if m.status == GRB.OPTIMAL:
    print(f"Optimal Makespan: {results_dict['obj_val']:.4f}")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time for Truck {i}: {start_time[i].x:.4f}")
                print(f"Completion Time for Truck {i}: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
21.5000
Optimal Makespan: 21.5000
Truck 1 is assigned to Depot 2
Start Time for Truck 1: 5.0000
Completion Time for Truck 1: 13.0000
Truck 2 is assigned to Depot 1
Start Time for Truck 2: 9.0000
Completion Time for Truck 2: 14.0000
Truck 3 is assigned to Depot 1
Start Time for Truck 3: 14.0000
Completion Time for Truck 3: 17.0000
Truck 4 is assigned to Depot 2
Start Time for Truck 4: 13.5000
Completion Time for Truck 4: 21.5000
Truck 5 is assigned to Depot 1
Start Time for Truck 5: 17.0000
Completion Time for Truck 5: 21.0000


```

================================================================================



--- Problem 374 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port with five distinct berths faces recurring congestion due to varying arrival rates of ships, requiring dynamic allocation strategies to minimize total delay. Each berth has unique characteristics: normal and reduced capacities for the main berth, alternative berth capacities, and varying arrival rates across eight 30-minute time periods. The challenge is to determine the optimal proportion of ships to divert to alternative berths during each period, choosing from predefined diversion ratios (10%, 30%, 50%, or 70%).  

The system must balance competing priorities: diverting too many ships risks overwhelming alternative berths, while diverting too few exacerbates queues on the main berth, especially during incidents when its capacity drops. Additionally, the solution must ensure smooth transitions between time periods, limiting changes in diversion ratios to no more than 20% to avoid operational confusion. The goal is to compute a dynamic strategy—berth by berth, period by period—that minimizes the total delay, factoring in both alternative berth service times and main berth queueing delays.
**

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variables `y(i, t, k)` for each berth `i`, time period `t`, and diversion option `k` (where `k` corresponds to 10%, 30%, 50%, or 70%).  
  - `y(i, t, k) = 1` if option `k` is selected for berth `i` in period `t`; otherwise, `0`.  

**2. Parameters:**  
- **Berth capacities:**  
  - `capacities_main_normal[i]`: Normal main berth capacity (ships/h) for berth `i`.  
  - `capacities_main_reduced[i]`: Reduced main berth capacity during incidents (ships/h).  
  - `capacities_alt[i]`: Alternative berth capacity (ships/h).  
- **Arrival rates:** `arrival_rates[i][t]` (ships/h) for berth `i` in period `t`.  
- **Diversion options:** `diversion_options = [0.1, 0.3, 0.5, 0.7]`.  
- **Other:**  
  - `TIME_PERIOD_LENGTH = 0.5` (hours).  
  - `MAX_DIVERSION_CHANGE = 0.2` (maximum allowed change between consecutive periods).  
  - Precomputed delays `berth_period_option_delays[i][t][k]` for each feasible option.  

**3. Objective Function:**  
Minimize the total delay across all berths and time periods:  
```
Minimize: sum(y(i, t, k) * berth_period_option_delays[i][t][k] for all i, t, k)
```

**4. Constraints:**  
- **Feasibility:** Only feasible diversion options (those not exceeding alternative berth capacity) can be selected:  
  `y(i, t, k) = 0` if `berth_period_option_feasible[i][t][k]` is `False`.  
- **Single selection:** Exactly one diversion option must be chosen per berth and period:  
  `sum(y(i, t, k) for feasible k) = 1` for all `i, t`.  
- **Smooth transitions:** The change in diversion ratio between consecutive periods cannot exceed 20%:  
  `y(i, t-1, k1) + y(i, t, k2) <= 1` if `|diversion_options[k1] - diversion_options[k2]| > 0.2`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 5
NUM_TIME_PERIODS = 8
TIME_PERIOD_LENGTH = 0.5  # h
MAX_DIVERSION_CHANGE = 0.2  # Maximum allowed change in diversion ratio
capacities_main_normal = [5394, 4162, 3104, 3466, 3787]  # ships/h
capacities_main_reduced = [1641, 1903, 2040, 2032, 1725]  # ships/h
capacities_alt = [1410, 1341, 1634, 1749, 1613]  # ships/h
arrival_rates = [[2358, 3374, 3670, 2805, 4849, 3513, 3129, 4122], [3288, 3260, 2024, 2213, 2844, 4464, 2673, 3435], [4915, 3598, 4388, 2846, 2835, 3932, 3535, 4507], [2445, 2444, 2396, 4005, 3114, 3304, 2364, 2294], [3953, 2702, 3112, 4033, 4643, 2914, 4428, 2997]]  # ships/h
incident_durations = [0.6931938825726629, 1.9715851009747083, 1.8587793194537405, 0.6031170991866323, 1.0714912952235907]  # h
alt_berth_extra_times = [0.20534824142408692, 0.170284854543916, 0.2531757234520796, 0.31628711531263753, 0.2688370920195384]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

        # Add smooth transition constraints between periods
        if t > 0:
            for k1 in range(num_options):
                for k2 in range(num_options):
                    if abs(diversion_options[k1] - diversion_options[k2]) > MAX_DIVERSION_CHANGE:
                        m.addConstr(y[i,t-1,k1] + y[i,t,k2] <= 1,
                                  name="SmoothTransition_Berth{0}_Period{1}_Options{2}{3}".format(i,t,k1,k2))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:

Berth 1:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)

Berth 2:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)

Berth 3:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 0 (10%)

Berth 4:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 0 (10%)

Berth 5:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)



================================================================================



--- Problem 375 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling the arrival and unloading of trucks at two available depots to minimize operational costs while adhering to strict scheduling constraints. Five trucks, labeled 1 through 5, arrive at the hub at specified times: Truck 1 at hour 3, Truck 2 at hour 7, Truck 3 at hour 9, Truck 4 at hour 11, and Truck 5 at hour 15. Each truck requires a specific processing time to unload and service: 4 hours for Truck 1, 3 hours for Truck 2, and 5 hours for Trucks 3, 4, and 5. The hub has two depots available, each capable of handling one truck at a time.

The hub incurs two types of costs:
- **Waiting Costs:** If a truck cannot start servicing immediately upon arrival, it incurs a waiting cost per hour: $123 for Truck 1, $107 for Truck 2, $102 for Truck 3, $84 for Truck 4, and $108 for Truck 5.
- **Service Costs:** The cost of servicing a truck at a depot varies. For example, servicing Truck 1 at Depot 1 costs $52 per hour, while at Depot 2, it costs $60 per hour. Similar costs are defined for all truck-depot combinations.

The hub manager must assign each truck to a depot and schedule their start times to minimize the total cost, which includes both waiting and service costs. The challenge is to determine the optimal assignment and scheduling that avoids overlaps at the same depot while respecting arrival times and processing durations.

**Key Question:** What is the optimal depot assignment and start time schedule that minimizes the total cost of waiting and servicing for all trucks?
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `assign[i, j]`: Binary variable indicating whether Truck *i* is assigned to Depot *j* (1 if assigned, 0 otherwise).
   - `start_time[i]`: Continuous variable representing the start time of servicing for Truck *i*.
   - `completion_time[i]`: Continuous variable representing the completion time of servicing for Truck *i*.
   - `precedes[i, k, j]`: Binary variable indicating whether Truck *i* precedes Truck *k* on Depot *j* (1 if *i* precedes *k*, 0 otherwise).

**2. Parameters:**
   - `trucks`: [1, 2, 3, 4, 5]
   - `depots`: [1, 2]
   - `arrival_times`: {1: 3, 2: 7, 3: 9, 4: 11, 5: 15}
   - `processing_times`: {1: 4, 2: 3, 3: 5, 4: 5, 5: 5}
   - `waiting_costs`: {1: 123, 2: 107, 3: 102, 4: 84, 5: 108}
   - `service_costs`: {(1,1):52, (1,2):60, (2,1):66, (2,2):59, (3,1):64, (3,2):65, (4,1):69, (4,2):70, (5,1):61, (5,2):43}
   - `H`: A large constant (100) used for logical constraints.

**3. Objective Function:**
   Minimize the total cost:
   ```
   Total Cost = Sum over all trucks (waiting_cost[i] * (start_time[i] - arrival_time[i]))
               + Sum over all trucks and depots (service_cost[i,j] * processing_time[i] * assign[i,j])
   ```

**4. Constraints:**
   - **Assignment:** Each truck must be assigned to exactly one depot.
     ```
     For each truck i: Sum over all depots j (assign[i,j]) = 1
     ```
   - **Arrival Time:** A truck cannot start servicing before its arrival time.
     ```
     For each truck i: start_time[i] >= arrival_time[i]
     ```
   - **Completion Time:** The completion time is the start time plus processing time.
     ```
     For each truck i: completion_time[i] = start_time[i] + processing_time[i]
     ```
   - **Non-Overlapping:** Trucks assigned to the same depot must not overlap in time.
     ```
     For each depot j and trucks i, k where i < k:
       If precedes[i,k,j] = 1, then start_time[k] >= completion_time[i]
       If precedes[i,k,j] = 0, then start_time[i] >= completion_time[k]
       assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j])
     ```
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2]
arrival_times = {1: 3, 2: 7, 3: 9, 4: 11, 5: 15}
processing_times = {1: 4, 2: 3, 3: 5, 4: 5, 5: 5}
waiting_costs = {1: 123, 2: 107, 3: 102, 4: 84, 5: 108} # Cost per hour waiting
service_costs = {(1, 1): 52, (1, 2): 60, (2, 1): 66, (2, 2): 59, (3, 1): 64, (3, 2): 65, (4, 1): 69, (4, 2): 70, (5, 1): 61, (5, 2): 43} # Cost rate per hour servicing {(truck, depot): cost}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_3_MIN_COST")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes") # y[i,k,j] = 1 if i before k on j

    # --- Objective Function ---
    waiting_cost_expr = gp.quicksum(waiting_costs.get(i, 0) * (start_time[i] - arrival_times.get(i, 0)) for i in trucks)
    service_cost_expr = gp.quicksum(service_costs.get((i,j), 0) * processing_times.get(i, 0) * assign[i,j]
                                   for i in trucks for j in depots)
    m.setObjective(waiting_cost_expr + service_cost_expr, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] -1 <= precedes[i,k,j] + (1-precedes[i,k,j])) # Link precedence if both assigned

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Print Missing Outputs ---

if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.2f}, Completion Time: {completion_time[i].x:.2f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
2123.0000
Optimal Solution Found:
Truck 1 assigned to Depot 1
Start Time: 3.00, Completion Time: 7.00
Truck 2 assigned to Depot 2
Start Time: 7.00, Completion Time: 10.00
Truck 3 assigned to Depot 1
Start Time: 10.00, Completion Time: 15.00
Truck 4 assigned to Depot 1
Start Time: 20.00, Completion Time: 25.00
Truck 5 assigned to Depot 2
Start Time: 15.00, Completion Time: 20.00


```

================================================================================



--- Problem 376 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A port management system is tasked with optimizing the berthing times for two ships at a busy port. The goal is to minimize the total waiting time experienced by the ships, which is influenced by the berthing duration and the time ships spend waiting for their turn. The port operates on a fixed cycle time of 54 minutes, meaning the sum of berthing times for both ships must exactly match this duration. Each ship has a minimum berthing time of 23 minutes and a maximum of 54 minutes to ensure smooth operations while adhering to safety standards.

The traffic flow coefficients—2300 for the first ship and 337 for the second—reflect the relative congestion levels during each berthing. Higher flow implies more ships are affected by delays, making it crucial to allocate berthing time efficiently. The challenge is to determine the optimal berthing durations for both ships such that the total waiting time, calculated as the weighted sum of non-berthing times (cycle time minus berthing time), is minimized while respecting the cycle time constraint.

**Core Question:** What is the optimal allocation of berthing times between the two ships to minimize the total waiting time for ships at the port?  

---

**

Modeling Process:**
**
1. Decision Variables:  
- \( t_i \): Continuous variable representing the berthing time (in minutes) allocated to ship \( i \), where \( i \in \{1, 2\} \).  
  - Bounds: \( 23 \leq t_i \leq 54 \).  

2. Parameters:  
- \( \text{flow_coeffs} = [2300, 337] \): Traffic flow coefficients for ships 1 and 2, respectively.  
- \( \text{cycle_time} = 54 \): Total cycle time (minutes).  
- \( \text{lb_time} = 23 \), \( \text{ub_time} = 54 \): Lower and upper bounds for berthing times.  

3. Objective Function:  
Minimize the total waiting time:  
\[ \text{Minimize: } 2300 \cdot (54 - t_1) + 337 \cdot (54 - t_2) \]  

4. Constraints:  
- **Cycle Time Constraint:** The sum of berthing times must equal the cycle time:  
  \[ t_1 + t_2 = 54 \]  
- **Variable Bounds:**  
  \[ 23 \leq t_1 \leq 54 \]  
  \[ 23 \leq t_2 \leq 54 \]  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_ships = 2
lb_time = 23          # Lower bound for berthing time
ub_time = 54          # Upper bound for berthing time
cycle_time = 54   # Total cycle time (set equal to ub_time)
flow_coeffs = [2300, 337] # Traffic flow coefficients per ship
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(flow_coeffs) != num_ships:
    print("Error: flow_coeffs length mismatch with num_ships")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: flow_coeffs length"
    # raise ValueError("flow_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_ships}-Ship Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_ships) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_ships, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for ship i is proportional to flow * non-berthing_time = flow * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(flow_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_ships)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_ships)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_ships)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_ships):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 63347.00
------------------------------
Optimal berthing times (minutes):
  t1: 31.00, t2: 23.00


```

================================================================================



--- Problem 377 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A port manager is tasked with optimizing the allocation of berthing times for two ships at a busy port to minimize total waiting time. The port operates with a fixed cycle time of 21 hours, divided into two distinct berthing slots. Each slot must allocate a berthing time between 5 and 21 hours, ensuring smooth operations while adhering to the strict cycle constraint.  

The challenge lies in balancing the competing demands of ship arrivals: Slot 1 handles a lighter flow of 204 ships, while Slot 2 deals with a heavier volume of 870 ships. Waiting time is directly proportional to the non-berthing time (cycle time minus berthing time) multiplied by the number of ships. The manager must determine the exact berthing time allocation for each slot to minimize the cumulative waiting time experienced by all ships.  

The critical question is: *What is the optimal distribution of berthing times within the 21-hour cycle to minimize total waiting time, given the ship flows and operational constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - \( t_i \): Continuous variable representing the berthing time (in hours) allocated to slot \( i \), where \( i \in \{1, 2\} \).  
   - Bounds: \( 5 \leq t_i \leq 21 \).  

   **2. Parameters:**  
   - \( \text{ship_coeffs} = [204, 870] \): Number of ships for each slot.  
   - \( \text{cycle_time} = 21 \): Total cycle time (fixed).  
   - \( \text{lb_time} = 5 \), \( \text{ub_time} = 21 \): Lower and upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize the total waiting time:  
   \[
   \text{Minimize: } 204 \cdot (21 - t_1) + 870 \cdot (21 - t_2)
   \]  

   **4. Constraints:**  
   - The sum of berthing times must equal the cycle time:  
     \[
     t_1 + t_2 = 21
     \]  
   - Variable bounds:  
     \[
     5 \leq t_1 \leq 21, \quad 5 \leq t_2 \leq 21
     \]  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_slots = 2
lb_time = 5          # Lower bound for berthing time
ub_time = 21          # Upper bound for berthing time
cycle_time = 21   # Total cycle time (set equal to ub_time)
ship_coeffs = [204, 870] # Number of ships per slot
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(ship_coeffs) != num_slots:
    print("Error: ship_coeffs length mismatch with num_slots")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: ship_coeffs length"
    # raise ValueError("ship_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_slots}-Slot Berthing Time Allocation", env=env)

        # --- Decision variables (dynamic based on num_slots) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_slots, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for slot i is proportional to ships * non-berthing_time = ships * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(ship_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_slots)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_slots)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_slots)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_slots):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 7614.00
------------------------------
Optimal berthing times (hours):
  t1: 5.00, t2: 16.00


```

================================================================================



--- Problem 378 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy port, a maritime logistics manager is tasked with efficiently assigning 24 uniquely colored containers to berths for loading onto ships. Each container has a specific weight and belongs to one of 16 distinct colors, ranging from common shades like 'B' (Blue) and 'R' (Red) to rarer ones like 'Z' and 'U'. The berths have a strict weight limit of 29 units, and to simplify the loading process, no berth can contain containers from more than 2 different colors. The manager must determine the minimal number of berths required to assign all containers while respecting both the weight and color diversity constraints.

The containers vary significantly in weight, from lightweight 2-unit objects to heavier 27-unit ones, adding complexity to the assignment strategy. For instance, a berth could hold two medium-weight containers (e.g., 18 and 11 units) of different colors, but combining three containers, even if their total weight is under 29, might violate the color rule. The core question is: *What is the smallest number of berths needed to assign all containers without exceeding weight limits or color constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `x[i, j]`: Binary variable indicating whether container `i` is assigned to berth `j` (1 if yes, 0 otherwise).
   - `y[j]`: Binary variable indicating whether berth `j` is used (1 if yes, 0 otherwise).
   - `z[c, j]`: Binary variable indicating whether color `c` is present in berth `j` (1 if yes, 0 otherwise).

**2. Parameters:**
   - `containers[i]`: Weight of container `i` (given as [17, 13, ..., 19]).
   - `colors[i]`: Color of container `i` (e.g., 'J', 'B', ..., 'S').
   - `capacity`: Maximum weight per berth (29 units).
   - `unique_colors_list`: List of all distinct colors (16 unique values).

**3. Objective Function:**
   - Minimize the total number of berths used:  
     `Minimize: sum(y[j] for all j)`.

**4. Constraints:**
   - **Container Assignment:** Each container must be assigned to exactly one berth:  
     `For each container i: sum(x[i, j] for all j) = 1`.
   - **Berth Capacity:** The total weight in a berth cannot exceed its capacity:  
     `For each berth j: sum(containers[i] * x[i, j] for all i) <= capacity * y[j]`.
   - **Color Linking:** If any container of color `c` is in berth `j`, `z[c, j]` must be 1:  
     `For each color c and berth j: x[i, j] <= z[c, j] for all i of color c`.
   - **Color Count:** No berth can have more than 2 distinct colors:  
     `For each berth j: sum(z[c, j] for all c) <= 2 * y[j]`.

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
containers = [17, 13, 18, 22, 27, 4, 16, 6, 11, 14, 20, 22, 18, 2, 2, 25, 7, 11, 9, 19, 9, 23, 18, 18]      # Weights of containers
colors = ['J', 'B', 'J', 'B', 'R', 'R', 'F', 'G', 'Y', 'W', 'Z', 'U', 'A', 'I', 'D', 'J', 'W', 'O', 'C', 'I', 'R', 'C', 'L', 'S']    # Colors of containers
capacity = 29         # Berth capacity
num_containers = 24       # len(containers) - derived correctly below
num_berths = num_containers      # Maximum berths (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(containers) != len(colors) or len(containers) != num_containers:
    print("Error: Data inconsistency (containers/colors/num_containers length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_colors_list = sorted(list(set(colors))) # Get unique colors deterministically
container_indices_by_color = {color: [i for i, c in enumerate(colors) if c == color] for color in unique_colors_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Color-Constrained Berth Packing", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_containers, num_berths, vtype=GRB.BINARY, name="x")  # x[i,j] -> container i in berth j
        y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")              # y[j] -> whether berth j is used
        # z[c,j] -> whether color c is PRESENT in berth j (Use unique_colors_list for keys)
        z = model.addVars(unique_colors_list, num_berths, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of berths used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each container must be assigned to exactly one berth ---
        for i in range(num_containers):
            model.addConstr(x.sum(i, '*') == 1, name=f"Container_{i}_Assignment")

        # --- Constraint 2: Berth capacity constraint ---
        for j in range(num_berths):
            model.addConstr(gp.quicksum(containers[i] * x[i, j] for i in range(num_containers)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

        # --- Constraint 3: Color constraint (at most 2 *different* colors per berth) ---

        # Part 3a: Link x (container in berth) and z (color in berth).
        for j in range(num_berths):
            for color in unique_colors_list:
                indices_of_this_color = container_indices_by_color.get(color, []) # Use .get for safety

                if not indices_of_this_color:
                    # If no containers of this color exist, z[color, j] must be 0.
                    model.addConstr(z[color, j] == 0, name=f"NoContainers_{color}_Berth_{j}")
                    continue

                # If any container 'i' of this 'color' is placed in berth 'j' (x[i,j]=1),
                # then the presence indicator for that 'color' in berth 'j' (z[color,j]) must be 1.
                for i in indices_of_this_color:
                    model.addConstr(x[i, j] <= z[color, j], name=f"Link_x{i}_z{color}_Berth{j}")

                # Ensure z[color, j] is 0 if no containers of that color are in the berth.
                # This helps tighten the formulation.
                model.addConstr(z[color, j] <= gp.quicksum(x[i, j] for i in indices_of_this_color), name=f"Link_z{color}_SumX_Berth{j}")


        # Part 3b: Limit the number of distinct colors (sum of z[c,j] for berth j) to 2 for USED berths.
        for j in range(num_berths):
            # sum(z[c,j] for c in unique_colors_list) gives the count of distinct colors in berth j.
            # This sum must be <= 2 *IF* the berth is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Colors_Berth_{j}")

        # --- Solve ---
        print("Solving CCBP instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of berths used: {optimal_berths}")
    print("-" * 30)

    berth_details = []
    printed_berth_count = 0
    for j_sol in range(num_berths): # Iterate through all potential berth indices
        try:
             # Check if this berth was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_berth_count += 1
                 assigned_containers_indices = [i for i in range(num_containers) if x[i, j_sol].X > 0.5]
                 assigned_containers_weights = [containers[i] for i in assigned_containers_indices]
                 assigned_containers_colors = [colors[i] for i in assigned_containers_indices]
                 distinct_colors_in_berth = sorted(list(set(assigned_containers_colors))) # Sort for consistent output
                 berth_load = sum(assigned_containers_weights)

                 print(f"Berth {printed_berth_count} (Internal Index {j_sol}):")
                 print(f"  Containers (indices): {assigned_containers_indices}")
                 # print(f"  Containers (weights): {assigned_containers_weights}") # Optional details
                 # print(f"  Containers (colors):  {assigned_containers_colors}") # Optional details
                 print(f"  Distinct Colors: {distinct_colors_in_berth} (Count: {len(distinct_colors_in_berth)})")
                 print(f"  Total weight:    {berth_load} / {capacity}")
                 print("-" * 10)

                 berth_data = {
                     'berth_index_internal': j_sol,
                     'berth_index_printed': printed_berth_count,
                     'container_indices': assigned_containers_indices,
                     'distinct_colors': distinct_colors_in_berth,
                     'load': berth_load
                 }
                 berth_details.append(berth_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for berth index {j_sol}: {e_print}")


    results_dict['berth_details'] = berth_details # Store details

    # Final sanity check
    if printed_berth_count != optimal_berths:
         print(f"Warning: Number of printed used berths ({printed_berth_count}) does not match objective value ({optimal_berths}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving CCBP instance...
------------------------------

Optimal solution found.
Optimal number of berths used: 14
------------------------------
Berth 1 (Internal Index 0):
  Containers (indices): [18, 19]
  Distinct Colors: ['C', 'I'] (Count: 2)
  Total weight:    28 / 29
----------
Berth 2 (Internal Index 1):
  Containers (indices): [10]
  Distinct Colors: ['Z'] (Count: 1)
  Total weight:    20 / 29
----------
Berth 3 (Internal Index 4):
  Containers (indices): [0, 7]
  Distinct Colors: ['G', 'J'] (Count: 2)
  Total weight:    23 / 29
----------
Berth 4 (Internal Index 5):
  Containers (indices): [15]
  Distinct Colors: ['J'] (Count: 1)
  Total weight:    25 / 29
----------
Berth 5 (Internal Index 9):
  Containers (indices): [20, 23]
  Distinct Colors: ['R', 'S'] (Count: 2)
  Total weight:    27 / 29
----------
Berth 6 (Internal Index 10):
  Containers (indices): [9, 17]
  Distinct Colors: ['O', 'W'] (Count: 2)
  Total weight:    25 / 29
----------
Berth 7 (Internal Index 11):
  Containers (indices): [11, 14]
  Distinct Colors: ['D', 'U'] (Count: 2)
  Total weight:    24 / 29
----------
Berth 8 (Internal Index 12):
  Containers (indices): [3, 16]
  Distinct Colors: ['B', 'W'] (Count: 2)
  Total weight:    29 / 29
----------
Berth 9 (Internal Index 14):
  Containers (indices): [1, 6]
  Distinct Colors: ['B', 'F'] (Count: 2)
  Total weight:    29 / 29
----------
Berth 10 (Internal Index 15):
  Containers (indices): [5, 21]
  Distinct Colors: ['C', 'R'] (Count: 2)
  Total weight:    27 / 29
----------
Berth 11 (Internal Index 18):
  Containers (indices): [2]
  Distinct Colors: ['J'] (Count: 1)
  Total weight:    18 / 29
----------
Berth 12 (Internal Index 20):
  Containers (indices): [4, 13]
  Distinct Colors: ['I', 'R'] (Count: 2)
  Total weight:    29 / 29
----------
Berth 13 (Internal Index 21):
  Containers (indices): [8, 22]
  Distinct Colors: ['L', 'Y'] (Count: 2)
  Total weight:    29 / 29
----------
Berth 14 (Internal Index 23):
  Containers (indices): [12]
  Distinct Colors: ['A'] (Count: 1)
  Total weight:    18 / 29
----------


```

================================================================================



--- Problem 379 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy trucking terminal, two delivery trucks arrive at different times, each requiring immediate unloading. Truck 1 arrives at 2 hours into the operating day, while Truck 2 arrives at 4 hours. The terminal has three available depots, each with varying service costs depending on which truck is assigned. The goal is to minimize the total cost, which consists of two components: the cost of trucks waiting to be serviced and the cost of servicing them at the depots.  

   Each truck must be assigned to exactly one depot, and their unloading cannot overlap on the same depot. Truck 1 takes 6 hours to unload, and Truck 2 also takes 6 hours. Waiting costs are significant—Truck 1 incurs a cost of $124 per hour of delay, while Truck 2 incurs $146 per hour. The service costs vary by truck-depot combination, ranging from $42 to $58 per hour of processing.  

   The challenge is to determine the optimal assignment of trucks to depots and their start times to minimize the total cost while respecting arrival times and avoiding overlapping schedules.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary variable (1 if truck `i` is assigned to depot `j`, 0 otherwise).  
   - `start_time[i]`: Continuous variable representing the start time of truck `i`.  
   - `completion_time[i]`: Continuous variable representing the completion time of truck `i`.  
   - `precedes[i, k, j]`: Binary variable (1 if truck `i` precedes truck `k` on depot `j`, 0 otherwise).  

   **2. Parameters:**  
   - `trucks = [1, 2]`: List of trucks.  
   - `depots = [1, 2, 3]`: List of depots.  
   - `arrival_times = {1: 2, 2: 4}`: Arrival times for each truck.  
   - `processing_times = {1: 6, 2: 6}`: Processing times for each truck.  
   - `waiting_costs = {1: 124, 2: 146}`: Cost per hour of waiting for each truck.  
   - `service_costs = {(1,1):50, (1,2):58, (1,3):51, (2,1):55, (2,2):42, (2,3):47}`: Service cost per hour for each truck-depot pair.  
   - `H = 100`: A large constant (Big-M) for constraint formulation.  

   **3. Objective Function:**  
   Minimize:  
   \[
   \sum_{i} \text{waiting\_costs}[i] \cdot (\text{start\_time}[i] - \text{arrival\_times}[i]) + \sum_{i,j} \text{service\_costs}[(i,j)] \cdot \text{processing\_times}[i] \cdot \text{assign}[i,j]
   \]  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot:  
     \[
     \sum_{j} \text{assign}[i,j] = 1 \quad \forall i \in \text{trucks}
     \]  
   - **Arrival Time:** Start time cannot be earlier than arrival time:  
     \[
     \text{start\_time}[i] \geq \text{arrival\_times}[i] \quad \forall i \in \text{trucks}
     \]  
   - **Completion Time:** Completion time is start time plus processing time:  
     \[
     \text{completion\_time}[i] = \text{start\_time}[i] + \text{processing\_times}[i] \quad \forall i \in \text{trucks}
     \]  
   - **Non-Overlapping:** If two trucks are assigned to the same depot, one must precede the other:  
     \[
     \text{precedes}[i,k,j] = 1 \implies \text{start\_time}[k] \geq \text{completion\_time}[i] \quad \forall i < k, j
     \]  
     \[
     \text{precedes}[i,k,j] = 0 \implies \text{start\_time}[i] \geq \text{completion\_time}[k] \quad \forall i < k, j
     \]  
     \[
     \text{assign}[i,j] + \text{assign}[k,j] - 1 \leq \text{precedes}[i,k,j] + (1 - \text{precedes}[i,k,j])
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2]
depots = [1, 2, 3]
arrival_times = {1: 2, 2: 4}
processing_times = {1: 6, 2: 6}
waiting_costs = {1: 124, 2: 146} # Cost per hour waiting
service_costs = {(1, 1): 50, (1, 2): 58, (1, 3): 51, (2, 1): 55, (2, 2): 42, (2, 3): 47} # Cost rate per hour servicing {(truck, depot): cost}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_3_MIN_COST")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes") # y[i,k,j] = 1 if i before k on j

    # --- Objective Function ---
    waiting_cost_expr = gp.quicksum(waiting_costs.get(i, 0) * (start_time[i] - arrival_times.get(i, 0)) for i in trucks)
    service_cost_expr = gp.quicksum(service_costs.get((i,j), 0) * processing_times.get(i, 0) * assign[i,j]
                                   for i in trucks for j in depots)
    m.setObjective(waiting_cost_expr + service_cost_expr, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
    for i in trucks:
        print(f"Start time for Truck {i}: {start_time[i].x:.4f}")
        print(f"Completion time for Truck {i}: {completion_time[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
1136.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 1
Truck 2 is assigned to Depot 2
Start time for Truck 1: 2.0000
Completion time for Truck 1: 8.0000
Start time for Truck 2: 8.0000
Completion time for Truck 2: 14.0000


```

================================================================================



--- Problem 380 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port facility operates two dedicated berths: Berth 1 for small cargo ships and Berth 2 for large cargo ships. The port manager faces the challenge of maximizing daily profit while adhering to strict time constraints and ship availability. Small cargo ships take 5 minutes each to load/unload and yield $16 in profit, while large cargo ships require 10 minutes but generate $31 in profit. With a total operational window of 171 minutes, the facility can serve up to 20 small cargo ships and 15 large cargo ships based on demand. The core question is: *How many small and large cargo ships should be scheduled at their respective berths to maximize total profit without exceeding time or ship limits?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x_s1`: Integer, number of small cargo ships assigned to Berth 1.  
     - `x_l2`: Integer, number of large cargo ships assigned to Berth 2.  
   - **2. Parameters:**  
     - Time horizon: 171 minutes.  
     - Small cargo ship service time: 5 min/ship; large cargo ship service time: 10 min/ship.  
     - Small cargo ship profit: $16/ship; large cargo ship profit: $31/ship.  
     - Ship limits: 20 small, 15 large.  
   - **3. Objective Function:**  
     Maximize total profit: `16 * x_s1 + 31 * x_l2`.  
   - **4. Constraints:**  
     - Berth 1 time limit: `5 * x_s1 ≤ 171`.  
     - Berth 2 time limit: `10 * x_l2 ≤ 171`.  
     - Small cargo ship limit: `x_s1 ≤ 20`.  
     - Large cargo ship limit: `x_l2 ≤ 15`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
time_horizon_minutes = 171; small_service_time = 5
large_service_time = 10; small_profit = 16; large_profit = 31
num_small_ships = 20; num_large_ships = 15
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m6 = gp.Model("Port_Berth_Assignment_MIP", env=env)
    # Vars
    x_s1 = m6.addVar(vtype=GRB.INTEGER, name="small_ships_berth1", lb=0)
    x_l2 = m6.addVar(vtype=GRB.INTEGER, name="large_ships_berth2", lb=0)
    # Objective
    m6.setObjective(small_profit * x_s1 + large_profit * x_l2, sense=GRB.MAXIMIZE)
    # Constraints
    m6.addConstr(small_service_time * x_s1 <= time_horizon_minutes, "berth1_time_capacity")
    m6.addConstr(large_service_time * x_l2 <= time_horizon_minutes, "berth2_time_capacity")
    m6.addConstr(x_s1 <= num_small_ships, "small_ship_limit")
    m6.addConstr(x_l2 <= num_large_ships, "large_ship_limit")
    # Optimize
    m6.optimize()
    # Store results
    results_dict['status'] = m6.status
    if m6.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m6.objVal; results_dict['x_s1_opt'] = x_s1.X; results_dict['x_l2_opt'] = x_l2.X
    # Output Results
    print("--- Problem 6: Port Berth Assignment (MIP) ---")
    if m6.status == GRB.OPTIMAL:
        xs1 = results_dict.get('x_s1_opt', 0); xl2 = results_dict.get('x_l2_opt', 0)
        print(f"Optimization Status: Optimal"); print(f"Optimal number of Small cargo ships (Berth 1): {int(round(xs1))}")
        print(f"Optimal number of Large cargo ships (Berth 2): {int(round(xl2))}"); print(f"Maximum total profit: ${m6.objVal:.2f}")
        print(f"Berth 1 time used: {small_service_time * xs1:.1f} / {time_horizon_minutes} min")
        print(f"Berth 2 time used: {large_service_time * xl2:.1f} / {time_horizon_minutes} min")
    else: print(f"Optimization Status: {m6.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_BERTH
```
Answer:
--- Problem 6: Port Berth Assignment (MIP) ---
Optimization Status: Optimal
Optimal number of Small cargo ships (Berth 1): 20
Optimal number of Large cargo ships (Berth 2): 15
Maximum total profit: $785.00
Berth 1 time used: 100.0 / 171 min
Berth 2 time used: 150.0 / 171 min



================================================================================



--- Problem 381 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A regional trucking company is facing the challenge of efficiently assigning its fleet of 14 trucks to 8 distinct delivery routes while minimizing total operational costs. Each truck has a unique cost associated with its deployment, reflecting factors like fuel efficiency, maintenance, or contractual agreements. The company must ensure that every route is covered by exactly one truck, and no truck is overburdened by being assigned to multiple routes simultaneously. With costs ranging from \$250 to \$392 per truck, the dispatcher faces a combinatorial puzzle: How can they assign trucks to routes in a way that satisfies all operational constraints while keeping the total cost as low as possible? The stakes are high—every dollar saved translates directly into improved profitability for the company’s tight-margin operations.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x(t, r)`: Binary variable indicating whether truck `t` (from the list `[0, 1, ..., 13]`) is assigned to route `r` (from `[0, 1, ..., 7]`).  
   - **2. Parameters:**  
     - `costs[t]`: Fixed cost of assigning truck `t` (e.g., `costs[0] = 250`, `costs[1] = 278`, etc.).  
   - **3. Objective Function:**  
     - Minimize the total cost:  
       `Minimize: sum(costs[t] * x(t, r) for all t in trucks, r in routes)`.  
   - **4. Constraints:**  
     - **Route Coverage:** Each route must have exactly one truck:  
       `For each route r: sum(x(t, r) for all t in trucks) = 1`.  
     - **Truck Limit:** No truck can be assigned to more than one route:  
       `For each truck t: sum(x(t, r) for all r in routes) <= 1`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13] # List of truck indices
routes = [0, 1, 2, 3, 4, 5, 6, 7]   # List of route indices
costs = [250, 278, 285, 377, 280, 289, 252, 392, 357, 275, 295, 261, 300, 356]     # List of costs per truck index
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Model Creation ---
    m = gp.Model("TRUCK_ROUTE_SCHED_COST")

    # --- Input Validation ---
    if not trucks or not routes: raise ValueError("Empty trucks or routes list")
    if len(costs) != len(trucks): raise ValueError("Costs list length mismatch")

    # --- Variables ---
    # x[t, r]: 1 if truck t is assigned to route r, 0 otherwise
    x = m.addVars(trucks, routes, vtype=GRB.BINARY, name="assign")

    # --- Objective Function ---
    # Minimize total truck cost - Ensure cost access is safe
    m.setObjective(gp.quicksum(costs[t] * x[t, r] for t in trucks for r in routes), GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Each route must be covered by exactly one truck
    m.addConstrs((gp.quicksum(x[t, r] for t in trucks) == 1 for r in routes), name="RouteCoverage")

    # Constraint 2: Each truck can be assigned to at most one route
    m.addConstrs((gp.quicksum(x[t, r] for r in routes) <= 1 for t in trucks), name="TruckAssignmentLimit")

    # --- Optimization ---
    m.setParam('OutputFlag', 0) # Suppress Gurobi output
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.1f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
         print("Model Infeasible")
    else:
         print(f"Status: {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except AttributeError as ae:
    print(f"Attribute error: {ae}")
    results_dict['status'] = -2
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the assignment of trucks to routes
if m.status == GRB.OPTIMAL:
    for r in routes:
        for t in trucks:
            if x[t, r].x > 0.5:
                print(f"Truck {t} is assigned to Route {r}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
2170.0
Truck 5 is assigned to Route 0
Truck 2 is assigned to Route 1
Truck 6 is assigned to Route 2
Truck 1 is assigned to Route 3
Truck 0 is assigned to Route 4
Truck 9 is assigned to Route 5
Truck 11 is assigned to Route 6
Truck 4 is assigned to Route 7


```

================================================================================



--- Problem 382 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
A major port experiences a sudden reduction in the number of available berths due to an unexpected maintenance issue, reducing its capacity for three hours. During this incident, port managers must decide how to reroute ships between the main port (now operating at reduced capacity) and an alternative port to minimize total delay. The main port normally operates with two berths, each handling up to 2,139 ships per hour, but during the incident, only one berth remains available. Meanwhile, the alternative port can accommodate up to 1,985 ships per hour but adds an extra 24 minutes of travel time per ship due to its longer distance. The total arrival rate of ships during the incident is 4,402 ships per hour. The challenge is to determine the optimal split of traffic between the two ports—balancing the congestion delay on the main port against the fixed extra time on the alternative port—to minimize the total delay experienced by all ships during the incident.
**

**Modeling Process:**
**
**1. Decision Variables:**
- `flow_alt`: The number of ships per hour diverted to the alternative port (continuous, ≥ 0).
- `flow_main`: The number of ships per hour remaining on the main port (continuous, ≥ 0).
- `delay_alt`: The total delay (ship-hours) incurred by ships taking the alternative port (continuous, ≥ 0).
- `delay_main_approx`: The total delay (ship-hours) on the main port, approximated using a piecewise linear function (continuous, ≥ 0).

**2. Parameters:**
- `arrival_rate_total = 4,402`: Total ship arrival rate (ships/h).
- `capacity_main_normal = 4,278`: Main port capacity under normal conditions (2 berths × 2,139 ships/h/berth).
- `capacity_main_reduced = 2,139`: Main port capacity during the incident (1 berth × 2,139 ships/h/berth).
- `alt_port_capacity = 1,985`: Maximum flow capacity of the alternative port (ships/h).
- `incident_duration = 3.0`: Duration of the berth closure (hours).
- `alt_port_extra_time = 0.4`: Additional travel time per ship on the alternative port (hours, converted from 24 minutes).

**3. Objective Function:**
Minimize the total delay:  
`delay_main_approx + delay_alt`.

**4. Constraints:**
- **Flow Conservation:** `flow_main + flow_alt = arrival_rate_total`.
- **Alternative Port Capacity:** `flow_alt ≤ alt_port_capacity`.
- **Alternative Port Delay Calculation:** `delay_alt = flow_alt × incident_duration × alt_port_extra_time`.
- **Main Port Delay Approximation:** A piecewise linear function maps `flow_main` to `delay_main_approx` using precomputed points to model congestion delays.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB, GurobiError
import math
import numpy as np # Needed for linspace
import sys
import traceback

# --- Parameters (Embedded) ---
capacity_per_berth = 2139  # ships/h/berth
num_berths_normal = 2      # Number of berths under normal conditions
num_berths_reduced = 1     # Number of berths during incident
arrival_rate_total = 4402 # ships/h
incident_duration = 3.00   # h (Duration of the capacity reduction)
alt_port_capacity = 1985 # ships/h
# Extra time originally in minutes, convert to hours here
alt_port_extra_min = 24
alt_port_extra_time = alt_port_extra_min / 60.0 # h
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit
NUM_PWL_POINTS = 20 # PWL points

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# --- Calculated Parameters ---
capacity_main_reduced = num_berths_reduced * capacity_per_berth # ships/h
capacity_main_normal = num_berths_normal * capacity_per_berth   # ships/h

# --- Helper Function for Main Delay Calculation ---
def calculate_main_delay(flow_main_val, cap_reduced, cap_normal, inc_duration):
    # Calculates main port delay based on flow.
    flow_main_val = max(0.0, flow_main_val)
    cap_reduced = max(0.0, cap_reduced)
    cap_normal = max(0.0, cap_normal)
    inc_duration = max(0.0, inc_duration)
    if flow_main_val <= cap_reduced + 1e-6: return 0.0
    if cap_normal <= cap_reduced + 1e-6: return 1e10
    queue_growth_rate = flow_main_val - cap_reduced
    max_queue = queue_growth_rate * inc_duration
    dissipation_rate = cap_normal - flow_main_val
    if dissipation_rate <= 1e-6: return 1e10
    else:
        dissipation_time = max_queue / dissipation_rate
        total_queue_time = inc_duration + dissipation_time
        delay = 0.5 * max_queue * total_queue_time
        return delay

# --- Generate Points for Piecewise Linear Approximation ---
flow_points = []
delay_points = []
pwl_error_flag = False
try:
    min_flow_main = 0.0
    max_flow_main = float(arrival_rate_total)
    if max_flow_main < min_flow_main: max_flow_main = min_flow_main + 1.0 # Handle edge case

    flow_points = np.linspace(min_flow_main, max_flow_main, NUM_PWL_POINTS).tolist() # Use constant from globals
    crit_reduced = float(capacity_main_reduced)
    crit_normal_minus_1 = float(capacity_main_normal - 1.0)

    if crit_reduced > min_flow_main + 1e-6 and not np.isclose(flow_points, crit_reduced).any():
         flow_points.append(crit_reduced)
    if capacity_main_normal > capacity_main_reduced + 1e-6 and crit_normal_minus_1 < max_flow_main - 1e-6 and crit_normal_minus_1 > min_flow_main and not np.isclose(flow_points, crit_normal_minus_1).any():
         flow_points.append(crit_normal_minus_1)

    flow_points = sorted(list(set(p for p in flow_points if p >= 0)))
    if not flow_points: flow_points = [0.0] # Ensure not empty

    delay_points = [calculate_main_delay(f, capacity_main_reduced, capacity_main_normal, incident_duration) for f in flow_points]
    delay_points = [max(0.0, d) for d in delay_points]

    if len(flow_points) < 2 or len(flow_points) != len(delay_points):
        print(f"Error: Invalid points generated for PWL. flow={len(flow_points)}, delay={len(delay_points)}")
        results_dict['status'] = -4
        results_dict['error_message'] = "Invalid PWL points generated"
        pwl_error_flag = True

except Exception as pwl_e:
    print(f"An unexpected error occurred during PWL point generation:")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -5
    results_dict['error_message'] = f"PWL Generation Error: {pwl_e}"
    pwl_error_flag = True

# --- Gurobi Model ---
try:
    if pwl_error_flag:
        print("Skipping model build due to PWL error.")
    else:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi output
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        m = gp.Model("BerthRerouting_PWL", env=env)

        # --- Decision Variables ---
        flow_alt = m.addVar(name="flow_alternative", lb=0.0, ub=arrival_rate_total)
        # --- Intermediate Variables ---
        flow_main = m.addVar(name="flow_main", lb=0.0)
        delay_alt = m.addVar(name="delay_alt", lb=0.0)
        delay_main_approx = m.addVar(name="delay_main_approx", lb=0.0)

        # --- Constraints ---
        m.addConstr(flow_main + flow_alt == arrival_rate_total, name="FlowConservation")
        m.addConstr(flow_alt <= alt_port_capacity, name="AltPortCapacity")
        m.addConstr(delay_alt == flow_alt * incident_duration * alt_port_extra_time, name="CalcAltDelay")
        # Add PWL constraint only if points are valid
        if len(flow_points) > 1 and len(flow_points) == len(delay_points):
             max_delay = max(delay_points) if delay_points else 0
             if max_delay > 1e9: print("Warning: Very large delay calculated for PWL points.")
             m.addGenConstrPWL(flow_main, delay_main_approx, flow_points, delay_points, name="PWL_MainDelay")
        else:
            # Should not be reached if pwl_error_flag logic is correct
            print("Error: Cannot add PWL constraint (points invalid).")
            if results_dict.get('status') is None: results_dict['status'] = -4
            raise ValueError("Invalid PWL points for constraint")

        # --- Objective Function ---
        m.setObjective(delay_main_approx + delay_alt, GRB.MINIMIZE)

        # --- Optimize ---
        m.optimize()

        # --- Store results ---
        results_dict['status'] = m.status
        if m.status == GRB.OPTIMAL:
            results_dict['obj_val'] = m.objVal
            results_dict['flow_alt_optimal'] = flow_alt.X # Store the result

except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"

# --- Output results (for capture) ---
current_status_for_output = results_dict.get('status')
if current_status_for_output == GRB.OPTIMAL:
    optimal_flow_alt = results_dict.get('flow_alt_optimal', 'N/A')
    if isinstance(optimal_flow_alt, (int, float)):
         print(f"{optimal_flow_alt:.2f}") # Output only the value
    else:
         print(f"Error: Optimal flow_alt not found in results.")
elif current_status_for_output == GRB.INFEASIBLE:
    print("Infeasible")
elif current_status_for_output == GRB.UNBOUNDED:
    print("Unbounded")
elif current_status_for_output == GRB.TIME_LIMIT:
     print(f"TimeLimit_{GUROBI_TIME_LIMIT}s")
elif current_status_for_output == -4 or current_status_for_output == -5: # PWL error
     print(f"PWLError: {results_dict.get('error_message', 'Unknown PWL error')}")
else:
    print(f"NonOptimalStatus_{current_status_for_output}")



# --- Supplemental Code Block to Ensure All Key Outputs are Printed ---

if current_status_for_output == GRB.OPTIMAL:
    optimal_flow_alt = results_dict.get('flow_alt_optimal', 'N/A')
    if isinstance(optimal_flow_alt, (int, float)):
        print(f"Optimal flow to alternative port: {optimal_flow_alt:.2f}")
        # Calculate and print the flow to the main port
        flow_main_optimal = arrival_rate_total - optimal_flow_alt
        print(f"Optimal flow to main port: {flow_main_optimal:.2f}")
        # Calculate and print the total delay
        delay_main_approx_optimal = results_dict.get('delay_main_approx', 0.0)
        delay_alt_optimal = optimal_flow_alt * incident_duration * alt_port_extra_time
        total_delay = delay_main_approx_optimal + delay_alt_optimal
        print(f"Total delay: {total_delay:.2f}")
    else:
        print(f"Error: Optimal flow_alt not found in results.")
elif current_status_for_output == GRB.INFEASIBLE:
    print("Infeasible")
elif current_status_for_output == GRB.UNBOUNDED:
    print("Unbounded")
elif current_status_for_output == GRB.TIME_LIMIT:
    print(f"TimeLimit_{GUROBI_TIME_LIMIT}s")
elif current_status_for_output == -4 or current_status_for_output == -5: # PWL error
    print(f"PWLError: {results_dict.get('error_message', 'Unknown PWL error')}")
else:
    print(f"NonOptimalStatus_{current_status_for_output}")
```
Answer:
Warning: Very large delay calculated for PWL points.
1985.00
Optimal flow to alternative port: 1985.00
Optimal flow to main port: 2417.00
Total delay: 2382.00


```

================================================================================



--- Problem 383 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port with five distinct berths is experiencing recurring delays due to maintenance activities, each reducing the capacity of the main berths. Port managers must dynamically reroute ships to alternative berths during these delays to minimize total delay across all berths and time periods. Each berth has unique characteristics: normal and reduced main berth capacities (e.g., Berth 1’s normal capacity is 4,687 ship/h, dropping to 3,233 ship/h during delays), alternative berth capacities (e.g., 1,328 ship/h for Berth 1), and delay durations (e.g., 1.76 hours for Berth 1). Ships diverted to alternative berths incur additional travel time (e.g., 0.31 hours for Berth 1). The available diversion ratios are 10%, 30%, 50%, and 70% of arriving ships. The challenge is to determine the optimal diversion strategy for each berth and 30-minute time period over a 4-hour horizon, ensuring smooth transitions (no more than a 20% change in diversion ratios between consecutive periods) while respecting alternative berth capacities. The goal is to minimize the total system delay, balancing queue delays on the main berths and added travel time on alternative berths.
**

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variables \( y[i,t,k] \):  
  - \( =1 \) if diversion option \( k \) (e.g., 10%, 30%) is selected for berth \( i \) in time period \( t \).  
  - \( =0 \) otherwise.  

**2. Parameters:**  
- \( \text{arrival_rates}[i][t] \): Ship arrival rate (ship/h) for berth \( i \), period \( t \).  
- \( \text{capacities_main_normal}[i], \text{capacities_main_reduced}[i] \): Normal/reduced main berth capacities (ship/h).  
- \( \text{capacities_alt}[i] \): Alternative berth capacity (ship/h).  
- \( \text{alt_berth_extra_times}[i] \): Additional travel time (hours) for alternative berths.  
- \( \text{diversion_options} = [0.1, 0.3, 0.5, 0.7] \): Available diversion ratios.  
- \( \text{MAX_DIVERSION_CHANGE} = 0.2 \): Maximum allowed change in diversion ratio between periods.  

**3. Objective Function:**  
Minimize total delay:  
\[
\sum_{i,t,k} y[i,t,k] \cdot \text{delay}(i,t,k),
\]  
where \( \text{delay}(i,t,k) \) combines:  
- Alternative berth delay: \( \text{arrival_rates}[i][t] \cdot p_k \cdot \text{TIME_PERIOD_LENGTH} \cdot \text{alt_berth_extra_times}[i] \).  
- Main berth queue delay (if flow exceeds reduced capacity).  

**4. Constraints:**  
- **Feasibility:** For each berth \( i \) and period \( t \), exactly one feasible diversion option \( k \) is selected.  
- **Smooth Transitions:** If \( |p_{k1} - p_{k2}| > 0.2 \), \( y[i,t-1,k1] + y[i,t,k2] \leq 1 \).  
- **Binary Variables:** \( y[i,t,k] \in \{0,1\} \).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 5
NUM_TIME_PERIODS = 8
TIME_PERIOD_LENGTH = 0.5  # h
MAX_DIVERSION_CHANGE = 0.2  # Maximum allowed change in diversion ratio
capacities_main_normal = [4687, 3495, 3710, 5408, 3177]  # ship/h
capacities_main_reduced = [3233, 1644, 1957, 2582, 2213]  # ship/h
capacities_alt = [1328, 1887, 1889, 931, 1353]  # ship/h
arrival_rates = [[2075, 3776, 3520, 2397, 3177, 4650, 4498, 4023], [2046, 3466, 4483, 3206, 4574, 4473, 2794, 3124], [3055, 3083, 2842, 4917, 3369, 4952, 2269, 2649], [4904, 3879, 4255, 4554, 4371, 2109, 3200, 4175], [3474, 4862, 2462, 3918, 4882, 4276, 2406, 2966]]  # ship/h
delay_durations = [1.762993806003497, 1.4017399137085398, 1.664063700341527, 1.7374400931674745, 1.3403655017250897]  # h
alt_berth_extra_times = [0.3137070528492873, 0.27604893414973863, 0.27984594418445735, 0.15196475203336157, 0.1491067873839751]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

        # Add smooth transition constraints between periods
        if t > 0:
            for k1 in range(num_options):
                for k2 in range(num_options):
                    if abs(diversion_options[k1] - diversion_options[k2]) > MAX_DIVERSION_CHANGE:
                        m.addConstr(y[i,t-1,k1] + y[i,t,k2] <= 1,
                                  name="SmoothTransition_Berth{0}_Period{1}_Options{2}{3}".format(i,t,k1,k2))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:

Berth 1:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 0 (10%)

Berth 2:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 2 (50%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 2 (50%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 2 (50%)

Berth 3:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 0 (10%)

Berth 4:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 0 (10%)

Berth 5:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 1 (30%)



================================================================================



--- Problem 384 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A major urban port is experiencing recurring congestion across five critical berths, causing severe delays for ships. Port managers must dynamically manage ship diversions to alternative berths during these incidents to minimize total delay across the network. Each berth has unique characteristics: normal and reduced mainline capacities (e.g., Berth 1 handles 4,777 TEUs/hour normally but drops to 1,713 TEUs/hour during incidents), alternative berth capacities (Berth 5's alternate can only manage 1,391 TEUs/hour), and varying incident durations (from 0.52 to 0.90 hours). The challenge unfolds over eight 30-minute periods, with arrival rates fluctuating dramatically - Berth 4 sees peaks of 4,667 TEUs/hour while Berth 2 experiences lows of 2,101 TEUs/hour.

Managers can implement four diversion strategies (10%, 30%, 50%, or 70% of traffic redirected), but must balance competing factors: alternative berths add 0.16-0.30 hours of handling time, sudden strategy changes beyond 20% difference are prohibited for operational safety, and no berth can exceed its capacity. The optimization must find the perfect rhythm of diversion adjustments across all berths and time periods - like conducting an orchestra of ship movements - to minimize the symphony of delays caused by queuing and detours. The core question emerges: What precise combination of diversion strategies, varying by berth and time period, will yield the absolute minimum total delay across this complex, dynamic system?
**

**Modeling Process:**
**
**1. Decision Variables:**
- y(i,t,k): Binary variable where:
  - i ∈ {0,...,4} represents the 5 berths
  - t ∈ {0,...,7} represents the 8 time periods
  - k ∈ {0,1,2,3} represents the 4 diversion options (10%,30%,50%,70%)
  - y(i,t,k)=1 if option k is selected for berth i in period t

**2. Parameters:**
- capacities_main_normal[i]: Normal mainline capacity per berth (e.g., [4777,5006,...])
- capacities_main_reduced[i]: Reduced capacity during incidents (e.g., [1713,2632,...])
- capacities_alt[i]: Alternative berth capacities (e.g., [1809,1692,...])
- arrival_rates[i][t]: Demand per berth/period (e.g., Berth 0 Period 0: 4306 TEUs/h)
- TIME_PERIOD_LENGTH = 0.5 hours
- MAX_DIVERSION_CHANGE = 0.2 (maximum allowed ratio change between periods)
- Precomputed delay values segment_period_option_delays[i][t][k] for each feasible combination

**3. Objective Function:**
Minimize: sum(y(i,t,k)*segment_period_option_delays[i][t][k] for all feasible i,t,k)

**4. Constraints:**
- Single option selection: For each berth i and period t, sum(y(i,t,k) for feasible k) = 1
- Infeasible option prohibition: y(i,t,k)=0 when alternative berth capacity would be exceeded
- Smooth transitions: For consecutive periods, if |option_k1 - option_k2| > 0.2, then y(i,t-1,k1) + y(i,t,k2) ≤ 1
- Binary nature: All y(i,t,k) ∈ {0,1}
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 5
NUM_TIME_PERIODS = 8
TIME_PERIOD_LENGTH = 0.5  # h
MAX_DIVERSION_CHANGE = 0.2  # Maximum allowed change in diversion ratio
capacities_main_normal = [4777, 5006, 3501, 3101, 3224]  # TEUs/h
capacities_main_reduced = [1713, 2632, 2269, 1226, 2036]  # TEUs/h
capacities_alt = [1809, 1692, 1475, 1964, 1391]  # TEUs/h
arrival_rates = [[4306, 3054, 3235, 2125, 3421, 2365, 2256, 3122], [2101, 3275, 2662, 2502, 3370, 4855, 2344, 2278], [2546, 3769, 4536, 2251, 2426, 3808, 2839, 4437], [4132, 4667, 3746, 4673, 2698, 4478, 2097, 3745], [3368, 4356, 4756, 3470, 2489, 4025, 2875, 3881]]  # TEUs/h
incident_durations = [0.89663491669402, 0.5915285445297411, 0.6948211262765893, 0.6649589641757949, 0.5175682546835059]  # h
alt_berth_extra_times = [0.2079299604490552, 0.22688161837286314, 0.3028929460946819, 0.2557230702811369, 0.1628333062093727]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

        # Add smooth transition constraints between periods
        if t > 0:
            for k1 in range(num_options):
                for k2 in range(num_options):
                    if abs(diversion_options[k1] - diversion_options[k2]) > MAX_DIVERSION_CHANGE:
                        m.addConstr(y[i,t-1,k1] + y[i,t,k2] <= 1,
                                  name="SmoothTransition_Berth{0}_Period{1}_Options{2}{3}".format(i,t,k1,k2))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:

Berth 1:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 2 (50%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 2 (50%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 2 (50%)

Berth 2:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 0 (10%)

Berth 3:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 1 (30%)

Berth 4:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 2 (50%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 0 (10%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 2 (50%)

Berth 5:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 1 (30%)



================================================================================



--- Problem 385 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port experiences varying ship arrival and departure demands throughout the day, with distinct peaks during the morning, midday, and evening periods. The port has two berths—Berth A and Berth B—each with fixed cranes: Berth A has one dedicated crane, while Berth B has two. To adapt to dynamic ship handling patterns, a single mobile crane is available, which can be allocated to either berth as needed. The goal is to minimize congestion by strategically assigning this mobile crane during each period, ensuring the highest possible efficiency in ship handling.  

Ship handling volumes vary significantly: in the morning, Berth A handles 1,697 containers per hour (cont/h), while Berth B handles 451 cont/h. Midday demands surge to 2,498 cont/h for A and 544 cont/h for B, and evening flows taper slightly to 2,386 cont/h (A) and 429 cont/h (B). Each crane, whether fixed or mobile, has a capacity of 807 cont/h. The challenge is to determine the optimal mobile crane assignments—whether to allocate it to A or B in each period—to minimize the worst-case volume-to-capacity (V/C) ratio across all scenarios, ensuring no berth becomes excessively congested.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable \( y(t) \): Equals 1 if the mobile crane is assigned to Berth A in period \( t \) (Morning, Midday, Evening), and 0 if assigned to Berth B.  

   **2. Parameters:**  
   - \( \text{flows}[t][d] \): Ship handling volume (cont/h) for berth \( d \) (A or B) in period \( t \).  
   - \( \text{crane\_capacity} = 807 \): Capacity per crane (cont/h).  
   - \( \text{num\_fixed\_cranes\_A} = 1 \): Fixed cranes for Berth A.  
   - \( \text{num\_fixed\_cranes\_B} = 2 \): Fixed cranes for Berth B.  
   - \( \text{num\_mobile\_cranes} = 1 \): Mobile crane to allocate.  

   **3. Objective Function:**  
   Minimize the maximum V/C ratio across all periods and berths:  
   \[
   \text{Minimize: } \text{Max\_VC\_Ratio}
   \]  

   **4. Constraints:**  
   - For each period \( t \), the V/C ratio for Berth A must satisfy:  
     \[
     \text{Max\_VC\_Ratio} \times (\text{num\_fixed\_cranes\_A} + y(t)) \times \text{crane\_capacity} \geq \text{flows}[t][A]
     \]  
   - For Berth B:  
     \[
     \text{Max\_VC\_Ratio} \times (\text{num\_fixed\_cranes\_B} + (1 - y(t))) \times \text{crane\_capacity} \geq \text{flows}[t][B]
     \]  
   - \( y(t) \) is binary for all \( t \).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
periods = ['Morning', 'Midday', 'Evening']
flows = {'Morning': {'A': 1697, 'B': 451}, 'Midday': {'A': 2498, 'B': 544}, 'Evening': {'A': 2386, 'B': 429}} # Dict period: {'A': flow, 'B': flow}
crane_capacity = 807 # cont/h/crane
num_fixed_cranes_A = 1
num_fixed_cranes_B = 2
num_mobile_cranes = 1
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("MOBILE_CRANE_ASSIGN", env=env)

    # --- Input Validation ---
    if not periods: raise ValueError("Empty periods list")
    if crane_capacity <= 0: raise ValueError("Crane capacity must be positive")

    # --- Decision Variables ---
    # y[t] = 1 if mobile crane goes to A in period t, 0 if to B
    y = m.addVars(periods, vtype=GRB.BINARY, name="MobileCraneToA")
    # Max_VC_Ratio: the maximum V/C ratio across all periods and berths
    Max_VC_Ratio = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="Max_VC_Ratio") # V/C must be >= 0

    # --- Objective Function: Minimize the maximum V/C ratio ---
    m.setObjective(Max_VC_Ratio, GRB.MINIMIZE)

    # --- Constraints ---
    for t in periods:
        flow_A = flows.get(t, {}).get('A', 0)
        flow_B = flows.get(t, {}).get('B', 0)

        # Calculate capacity for each berth using linear expressions
        cap_A_expr = (num_fixed_cranes_A + y[t]) * crane_capacity
        cap_B_expr = (num_fixed_cranes_B + (num_mobile_cranes - y[t])) * crane_capacity

        # Ensure capacity expressions are non-negative (should be true if inputs valid)
        # Add constraints linking Max_VC_Ratio to V/C for each berth/period
        # Max_VC_Ratio >= Flow / Capacity  <=>  Max_VC_Ratio * Capacity >= Flow
        # Use small epsilon for capacity to avoid potential division by zero if capacity=0 allowed
        epsilon = 1e-6
        m.addConstr(Max_VC_Ratio * (cap_A_expr + epsilon) >= flow_A, f"VC_A_{t}")
        m.addConstr(Max_VC_Ratio * (cap_B_expr + epsilon) >= flow_B, f"VC_B_{t}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['y_sol'] = m.getAttr('X', y) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is Max V/C ratio
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show precision
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the mobile crane assignments for each period
if m.Status == GRB.OPTIMAL:
    obj_val_print = results_dict.get('obj_val', 'N/A')
    if isinstance(obj_val_print, (int, float)):
        print(f"Optimal objective value: {obj_val_print:.4f}") # Show precision
    else:
        print(f"Optimal objective value: {obj_val_print}")

    # Print the mobile crane assignments for each period
    for t in periods:
        if y[t].X > 0.5:
            print(f"Mobile crane assigned to Berth A in period {t}")
        else:
            print(f"Mobile crane assigned to Berth B in period {t}")
```
Answer:
Optimal objective value: 1.5477
Optimal objective value: 1.5477
Mobile crane assigned to Berth A in period Morning
Mobile crane assigned to Berth A in period Midday
Mobile crane assigned to Berth A in period Evening


```

================================================================================



--- Problem 386 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
A logistics company is tasked with optimizing the delivery route for a single truck serving two customer locations from a central depot. The depot (Node 0) is the starting and ending point for the truck, which has a strict capacity limit of 25 units. The customers (Node 1 with a demand of 10 units and Node 2 with a demand of 15 units) must each be visited exactly once. The distances between locations are fixed: 70 units between the depot and Node 1, 38 units between the depot and Node 2, and 41 units between the two customers. The challenge is to determine the most efficient route that minimizes total travel distance while respecting the truck’s capacity and ensuring all deliveries are completed. The key question is: *What is the shortest possible route that serves both customers without exceeding the truck’s capacity?*

**Modeling Process:**
- **1. Decision Variables:**  
     - Binary variable \(x_{i,j,k}\) for each arc \((i,j)\) traversed by vehicle \(k\) (1 if used, 0 otherwise).  
     - Continuous variable \(u_i\) for each customer node \(i\) (used for subtour elimination).  
   - **2. Parameters:**  
     - \(N = 3\) (nodes: depot + 2 customers).  
     - \(K = 1\) (single vehicle).  
     - \(Q = 25\) (vehicle capacity).  
     - \(q = [0, 10, 15]\) (demands: depot = 0, Node 1 = 10, Node 2 = 15).  
     - Distance matrix \(d\):  
       - \(d_{0,1} = 70\), \(d_{0,2} = 38\), \(d_{1,2} = 41\) (symmetric).  
   - **3. Objective Function:**  
     - Minimize total distance: \(\sum_{k=0}^{K-1} \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} d_{i,j} \cdot x_{i,j,k}\).  
   - **4. Constraints:**  
     - **Visit each customer once:** \(\sum_{k=0}^{K-1} \sum_{j=0}^{N-1} x_{i,j,k} = 1\) for \(i = 1, 2\).  
     - **Flow conservation:** Inflow equals outflow for each node and vehicle.  
     - **Depot departure/return:** Vehicle starts/ends at the depot.  
     - **Capacity:** Total demand on the route \(\leq 25\).  
     - **Subtour elimination (MTZ):** \(u_i - u_j + (N-1) \cdot x_{i,j,k} \leq N-2\) for \(i,j \geq 1, i \neq j\).  

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 3
K = 1
Q = [25]
q = [0, 10, 15]
d = [
    [0, 70, 38],
    [70, 0, 41],
    [38, 41, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Vehicle Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for vehicle {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for vehicle {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 149.00

Route for vehicle 1 (Capacity: 25):
0 -> 2 -> 1 -> 0
Route Load: 25 / 25


```

================================================================================



--- Problem 387 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port experiences varying ship arrival rates throughout the day, with distinct peaks during morning, midday, and evening periods. The port has two fixed berths, each capable of handling a certain number of ships per hour. Additionally, there is one flexible berth that can be dynamically allocated to either direction to alleviate congestion. The goal is to strategically assign this flexible berth during each time period to minimize the worst-case congestion, measured as the maximum volume-to-capacity (V/C) ratio across all periods and berths. 

Ship arrivals vary significantly: in the morning, Berth A handles 2,131 ships per hour while Berth B carries 1,736; midday sees 1,626 and 1,122 ships per hour for Berth A and B, respectively; and the evening rush brings 2,412 ships to Berth A and 701 to Berth B. Each berth can accommodate up to 937 ships per hour. The challenge is to determine the optimal allocation of the flexible berth—whether it should be assigned to A or B during each period—to ensure the smoothest possible flow of ships, avoiding bottlenecks where demand overwhelms capacity. The central question is: How should the flexible berth be assigned throughout the day to minimize the highest V/C ratio encountered?
**

**Modeling Process:**
**
**1. Decision Variables:**
- `y[t]`: Binary variable for each period `t` (Morning, Midday, Evening). `y[t] = 1` if the flexible berth is assigned to Berth A in period `t`, and `0` if assigned to B.
- `Max_VC_Ratio`: Continuous variable representing the maximum V/C ratio across all periods and berths.

**2. Parameters:**
- `periods`: List of time periods (`['Morning', 'Midday', 'Evening']`).
- `flows[t]['A']` and `flows[t]['B']`: Ship arrival rate (ships/hour) for Berth A and B in period `t`.
- `berth_capacity`: Capacity of a single berth (937 ships/hour).
- `num_fixed_berths_A`: Fixed berths for Berth A (2).
- `num_fixed_berths_B`: Fixed berths for Berth B (2).
- `num_flexible_berths`: Flexible berths available (1).
- `epsilon`: Small constant (1e-6) to avoid division by zero.

**3. Objective Function:**
- Minimize `Max_VC_Ratio`.

**4. Constraints:**
- For each period `t`:
  - Capacity for Berth A: `(num_fixed_berths_A + y[t]) * berth_capacity`.
  - Capacity for Berth B: `(num_fixed_berths_B + (1 - y[t])) * berth_capacity`.
  - `Max_VC_Ratio * (capacity_A + epsilon) >= flow_A`.
  - `Max_VC_Ratio * (capacity_B + epsilon) >= flow_B`.

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
periods = ['Morning', 'Midday', 'Evening']
flows = {'Morning': {'A': 2131, 'B': 1736}, 'Midday': {'A': 1626, 'B': 1122}, 'Evening': {'A': 2412, 'B': 701}} # Dict period: {'A': flow, 'B': flow}
berth_capacity = 937 # ships/h/berth
num_fixed_berths_A = 2
num_fixed_berths_B = 2
num_flexible_berths = 1
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("FLEXIBLE_BERTH_ASSIGN", env=env)

    # --- Input Validation ---
    if not periods: raise ValueError("Empty periods list")
    if berth_capacity <= 0: raise ValueError("Berth capacity must be positive")

    # --- Decision Variables ---
    # y[t] = 1 if flexible berth goes to A in period t, 0 if to B
    y = m.addVars(periods, vtype=GRB.BINARY, name="FlexibleBerthToA")
    # Max_VC_Ratio: the maximum V/C ratio across all periods and berths
    Max_VC_Ratio = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="Max_VC_Ratio") # V/C must be >= 0

    # --- Objective Function: Minimize the maximum V/C ratio ---
    m.setObjective(Max_VC_Ratio, GRB.MINIMIZE)

    # --- Constraints ---
    for t in periods:
        flow_A = flows.get(t, {}).get('A', 0)
        flow_B = flows.get(t, {}).get('B', 0)

        # Calculate capacity for each berth using linear expressions
        cap_A_expr = (num_fixed_berths_A + y[t]) * berth_capacity
        cap_B_expr = (num_fixed_berths_B + (num_flexible_berths - y[t])) * berth_capacity

        # Ensure capacity expressions are non-negative (should be true if inputs valid)
        # Add constraints linking Max_VC_Ratio to V/C for each berth/period
        # Max_VC_Ratio >= Flow / Capacity  <=>  Max_VC_Ratio * Capacity >= Flow
        # Use small epsilon for capacity to avoid potential division by zero if capacity=0 allowed
        epsilon = 1e-6
        m.addConstr(Max_VC_Ratio * (cap_A_expr + epsilon) >= flow_A, f"VC_A_{t}")
        m.addConstr(Max_VC_Ratio * (cap_B_expr + epsilon) >= flow_B, f"VC_B_{t}")


    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['y_sol'] = m.getAttr('X', y) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is Max V/C ratio
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show precision
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the flexible berth assignment for each period
if m.Status == GRB.OPTIMAL:
    y_sol = m.getAttr('X', y)
    for t in periods:
        if y_sol[t] == 1:
            print(f"Flexible berth assigned to Berth A in {t}")
        else:
            print(f"Flexible berth assigned to Berth B in {t}")
```
Answer:
Optimal objective value: 0.9264
Flexible berth assigned to Berth A in Morning
Flexible berth assigned to Berth A in Midday
Flexible berth assigned to Berth A in Evening


```

================================================================================



--- Problem 388 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
A logistics company is tasked with efficiently scheduling 14 delivery trucks of varying sizes into standardized parking slots to minimize the number of slots used. Each truck has a unique width and length, ranging from compact (3x24) to sizable (90x29). The parking slots themselves measure 91 units in width and 62 units in length, and the goal is to fit all trucks while using as few slots as possible. The challenge lies not only in assigning trucks to slots but also in arranging them without overlaps, ensuring each truck's placement respects the slot's boundaries. This problem mirrors real-world parking scenarios, where optimizing space directly translates to reduced material costs and improved operational efficiency. The central question is: *What is the minimal number of parking slots required to accommodate all trucks, and how should they be arranged to achieve this?*

2. **Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether truck *i* is assigned to parking slot *j*.  
   - `y[j]`: Binary variable indicating whether parking slot *j* is used.  
   - `px[i, j]`, `py[i, j]`: Continuous variables representing the bottom-left coordinates of truck *i* in parking slot *j*.  
   - `left[i, k, j]`, `right[i, k, j]`, `below[i, k, j]`, `above[i, k, j]`: Binary variables enforcing non-overlapping constraints between trucks *i* and *k* in parking slot *j*.  

   **2. Parameters:**  
   - `trucks`: List of tuples specifying each truck's (width, length).  
   - `slot_size`: Tuple (91, 62) defining parking slot dimensions.  
   - `num_trucks = 14`, `num_slots = 14` (worst-case upper bound).  

   **3. Objective Function:**  
   Minimize the total number of parking slots used:  
   \[
   \text{Minimize: } \sum_{j} y[j]
   \]  

   **4. Constraints:**  
   - **Assignment:** Each truck *i* must be placed in exactly one parking slot:  
     \[
     \sum_{j} x[i, j] = 1 \quad \forall i
     \]  
   - **Slot Boundaries:** Trucks must fit within their assigned parking slot:  
     \[
     px[i, j] + \text{truck}_i\text{.width} \leq 91 \quad \text{if } x[i, j] = 1, \quad \forall i, j
     \]  
     (Analogous for length.)  
   - **Non-Overlapping:** For any two trucks *i*, *k* in parking slot *j*, enforce at least one spatial relation (left/right/below/above):  
     \[
     \text{left}[i, k, j] + \text{right}[i, k, j] + \text{below}[i, k, j] + \text{above}[i, k, j] \geq x[i, j] + x[k, j] - 1 \quad \forall i < k, j
     \]  
   - **Slot Activation:** If any truck is assigned to parking slot *j*, mark it as used:  
     \[
     x[i, j] \leq y[j] \quad \forall i, j
     \]  
**

3. **Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
trucks = [(55, 13), (43, 34), (39, 27), (19, 20), (9, 27), (49, 40), (62, 16), (78, 54), (10, 3), (62, 15), (3, 24), (33, 42), (41, 43), (90, 29)]  # (width, length) of trucks
slot_size = (91, 62)  # (width, length) of each parking slot
num_trucks = 14 # len(trucks)
# Maximum slots needed (worst case: one truck per slot)
# Can sometimes be reduced with lower bounds, but num_trucks is safe
num_slots = num_trucks
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using slot dimensions is common and valid)
M_w = slot_size[0]
M_h = slot_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Parking Slot Packing", env=env)

# --- Decision Variables ---
# x[i,j]: truck i assigned to parking slot j
x = model.addVars(num_trucks, num_slots, vtype=GRB.BINARY, name="x")
# y[j]: parking slot j is used
y = model.addVars(num_slots, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of truck i if in parking slot j
px = model.addVars(num_trucks, num_slots, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_trucks, num_slots, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of trucks *within the same parking slot*
left  = model.addVars(num_trucks, num_trucks, num_slots, vtype=GRB.BINARY, name="left")
right = model.addVars(num_trucks, num_trucks, num_slots, vtype=GRB.BINARY, name="right")
below = model.addVars(num_trucks, num_trucks, num_slots, vtype=GRB.BINARY, name="below")
above = model.addVars(num_trucks, num_trucks, num_slots, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of parking slots used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_slots))

# --- Constraints ---

# 1. Each truck must be assigned to exactly one parking slot
for i in range(num_trucks):
    model.addConstr(x.sum(i, '*') == 1, name=f"Truck_{i}_Assignment")

# 2. Truck placement constraints within parking slot boundaries (Big-M formulation)
for j in range(num_slots):
    for i in range(num_trucks):
        truck_w, truck_l = trucks[i] # Get dimensions for truck i

        # Position variables must be 0 if truck i is not in parking slot j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Truck's right edge <= parking slot width IF truck is placed in parking slot (x[i,j]=1)
        model.addConstr(px[i, j] + truck_w <= slot_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Truck's top edge <= parking slot length IF truck is placed in parking slot (x[i,j]=1)
        model.addConstr(py[i, j] + truck_l <= slot_size[1] + M_h * (1 - x[i, j]), name=f"Length_Limit_{i}_{j}")

# 3. Non-overlapping constraints for trucks within the same parking slot
for j in range(num_slots):
    for i in range(num_trucks):
        for k in range(i + 1, num_trucks): # Iterate over distinct pairs (i < k)
            truck_i_w, truck_i_l = trucks[i]
            truck_k_w, truck_k_l = trucks[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => truck i is to the left of truck k
            model.addConstr(px[i, j] + truck_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => truck i is to the right of truck k (k is left of i)
            model.addConstr(px[k, j] + truck_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => truck i is below truck k
            model.addConstr(py[i, j] + truck_i_l <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => truck i is above truck k (k is below i)
            model.addConstr(py[k, j] + truck_k_l <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH truck i and truck k are in parking slot j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link truck assignment to parking slot usage: If any truck i is in parking slot j, then parking slot j must be used (y[j]=1)
#    This can be done per truck or aggregated. Per truck is often tighter.
for j in range(num_slots):
    for i in range(num_trucks):
        model.addConstr(x[i, j] <= y[j], name=f"Truck_Slot_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_trucks * y[j], name=f"Slot_Activation_{j}")


# --- Solve ---
print("Solving 2D Parking Slot Packing instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of parking slots used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    slot_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_slots):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Parking Slot {j_sol + 1} (Used):")
            trucks_in_slot_info = []
            for i_sol in range(num_trucks):
                if x[i_sol, j_sol].X > 0.5:
                    truck_data = {
                        "id": i_sol,
                        "dims": trucks[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    trucks_in_slot_info.append(truck_data)
                    print(f"  Truck {truck_data['id']} {truck_data['dims']} at {truck_data['pos']}")
            slot_details.append({'slot_index': j_sol, 'trucks': trucks_in_slot_info})
            print("-" * 10)
    results_dict['slot_details'] = slot_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 2D Parking Slot Packing instance...
Gurobi Error code 10010: Model too large for size-limited license; visit https://gurobi.com/unrestricted for more information

Optimization finished with status: -1. No optimal solution found.


```

================================================================================



--- Problem 389 ---
**Difficulty:** easy
**Category:** LP

**Problem Description:**
**
A port management system is tasked with optimizing the flow of container trucks entering a congested terminal via an access gate. The gate currently experiences a demand of **642.27 trucks per hour (trucks/h)**, while the upstream road flow is **2,392.50 trucks/h**. The downstream segment of the terminal has a congested capacity limit of **3,084.04 trucks/h**, meaning any flow exceeding this threshold would cause severe bottlenecks. The challenge is to determine the optimal gate entry rate—the number of trucks allowed to enter the terminal per hour—such that the combined flow from the gate and the upstream road does not exceed the terminal's capacity. The goal is to maximize gate throughput while preventing congestion, ensuring smooth traffic flow. If the gate demand cannot be fully accommodated, any unmet demand translates into a growing queue of trucks waiting to enter the terminal.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `r_gate`: The gate entry rate (trucks/h), bounded between `0` and the gate demand (`lambda_gate_demand_h = 642.27`).  
     - `lambda_road_downstream`: The total flow downstream (trucks/h), representing the sum of upstream road flow and gate entry rate.  

   - **2. Parameters:**  
     - `lambda_road_upstream_h = 2,392.50 trucks/h`: The fixed flow rate from the upstream road.  
     - `C_terminal_congested_h = 3,084.04 trucks/h`: The maximum allowable downstream flow before congestion occurs.  
     - `lambda_gate_demand_h = 642.27 trucks/h`: The maximum potential gate flow if unrestricted.  

   - **3. Objective Function:**  
     - **Maximize:** `r_gate` (the gate entry rate).  

   - **4. Constraints:**  
     - **Downstream Flow Calculation:** `lambda_road_downstream = lambda_road_upstream_h + r_gate`.  
     - **Capacity Limit:** `lambda_road_downstream <= C_terminal_congested_h`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
C_terminal_congested_h = 3084.036333488029
lambda_gate_demand_h = 642.2725709460785
lambda_road_upstream_h = 2392.4970450620717

# --- Gurobi Model ---
model = gp.Model("GateEntryTerminalCongestion")

# --- Decision Variables ---
r_gate = model.addVar(name="GateRate", lb=0.0, ub=lambda_gate_demand_h)
lambda_road_downstream = model.addVar(name="RoadFlowDownstream", lb=0.0)

# --- Constraints ---
model.addConstr(lambda_road_downstream == lambda_road_upstream_h + r_gate, name="DownstreamFlowCalc")
model.addConstr(lambda_road_downstream <= C_terminal_congested_h, name="DownstreamCapacityLimit")

# --- Objective Function ---
model.setObjective(r_gate, GRB.MAXIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    print(f"Optimal Gate Entry Rate: {r_gate.X:.2f} trucks/h")
    print(f"  (Gate Demand was: {lambda_gate_demand_h:.0f} trucks/h)")
    print(f"Resulting Downstream Road Flow: {lambda_road_downstream.X:.2f} trucks/h")
    print(f"  (Downstream Capacity Limit: {C_terminal_congested_h:.0f} trucks/h)")
    gate_queue_growth = lambda_gate_demand_h - r_gate.X
    print(f"Implied Queue Growth Rate at Gate: {gate_queue_growth:.2f} trucks/h")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
    if lambda_road_upstream_h > C_terminal_congested_h:
         print(f"  Reason: Upstream road flow ({lambda_road_upstream_h}) already exceeds downstream capacity ({C_terminal_congested_h}).")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 2 rows, 2 columns and 3 nonzeros
Model fingerprint: 0xf4787679
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [6e+02, 6e+02]
  RHS range        [2e+03, 3e+03]
Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    6.4227257e+02   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  6.422725709e+02

--- Optimization Results ---
Optimization Status: Optimal
Optimal Gate Entry Rate: 642.27 trucks/h
  (Gate Demand was: 642 trucks/h)
Resulting Downstream Road Flow: 3034.77 trucks/h
  (Downstream Capacity Limit: 3084 trucks/h)
Implied Queue Growth Rate at Gate: 0.00 trucks/h



================================================================================



--- Problem 390 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port facility operates two dedicated berths: Berth 1 for standard cargo loading and Berth 2 for premium cargo services. The port manager faces a tactical challenge—maximizing daily profit by strategically allocating ships to each berth while respecting strict time constraints and ship availability. Standard cargo loading takes 13 minutes per ship and yields $7 profit, while premium cargo services require 20 minutes but generate $9 per ship. The facility has a tight operating window of 151 minutes and must serve no more than 4 standard ships and 14 premium ships, reflecting current demand. The core question is: *How many standard and premium cargo operations should be scheduled in each berth to maximize total profit without exceeding time or ship limits?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x_s1`: Integer number of standard cargo operations assigned to Berth 1.  
     - `x_p2`: Integer number of premium cargo operations assigned to Berth 2.  
   - **2. Parameters:**  
     - Time horizon: 151 minutes.  
     - Standard service time: 13 min/ship; premium service time: 20 min/ship.  
     - Standard profit: $7/ship; premium profit: $9/ship.  
     - Ship limits: 4 standard, 14 premium.  
   - **3. Objective Function:**  
     Maximize total profit: `7 * x_s1 + 9 * x_p2`.  
   - **4. Constraints:**  
     - Berth 1 time limit: `13 * x_s1 ≤ 151`.  
     - Berth 2 time limit: `20 * x_p2 ≤ 151`.  
     - Standard ship limit: `x_s1 ≤ 4`.  
     - Premium ship limit: `x_p2 ≤ 14`.  
     - Non-negativity and integer constraints for `x_s1`, `x_p2`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
time_horizon_minutes = 151; standard_service_time = 13
premium_service_time = 20; standard_profit = 7; premium_profit = 9
num_standard_ships = 4; num_premium_ships = 14
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m6 = gp.Model("Port_Berth_Assignment_MIP", env=env)
    # Vars
    x_s1 = m6.addVar(vtype=GRB.INTEGER, name="standard_cargo_berth1", lb=0)
    x_p2 = m6.addVar(vtype=GRB.INTEGER, name="premium_cargo_berth2", lb=0)
    # Objective
    m6.setObjective(standard_profit * x_s1 + premium_profit * x_p2, sense=GRB.MAXIMIZE)
    # Constraints
    m6.addConstr(standard_service_time * x_s1 <= time_horizon_minutes, "berth1_time_capacity")
    m6.addConstr(premium_service_time * x_p2 <= time_horizon_minutes, "berth2_time_capacity")
    m6.addConstr(x_s1 <= num_standard_ships, "standard_ship_limit")
    m6.addConstr(x_p2 <= num_premium_ships, "premium_ship_limit")
    # Optimize
    m6.optimize()
    # Store results
    results_dict['status'] = m6.status
    if m6.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m6.objVal; results_dict['x_s1_opt'] = x_s1.X; results_dict['x_p2_opt'] = x_p2.X
    # Output Results
    print("--- Problem 6: Port Berth Assignment (MIP) ---")
    if m6.status == GRB.OPTIMAL:
        xs1 = results_dict.get('x_s1_opt', 0); xp2 = results_dict.get('x_p2_opt', 0)
        print(f"Optimization Status: Optimal"); print(f"Optimal number of Standard cargo operations (Berth 1): {int(round(xs1))}")
        print(f"Optimal number of Premium cargo operations (Berth 2): {int(round(xp2))}"); print(f"Maximum total profit: ${m6.objVal:.2f}")
        print(f"Berth 1 time used: {standard_service_time * xs1:.1f} / {time_horizon_minutes} min")
        print(f"Berth 2 time used: {premium_service_time * xp2:.1f} / {time_horizon_minutes} min")
    else: print(f"Optimization Status: {m6.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_BERTH
```
Answer:
--- Problem 6: Port Berth Assignment (MIP) ---
Optimization Status: Optimal
Optimal number of Standard cargo operations (Berth 1): 4
Optimal number of Premium cargo operations (Berth 2): 7
Maximum total profit: $91.00
Berth 1 time used: 52.0 / 151 min
Berth 2 time used: 140.0 / 151 min



================================================================================



--- Problem 391 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
In a busy maritime port, the harbor master is tasked with assigning the fastest available tugboat to assist a ship that has just arrived and needs immediate assistance. Two tugboats, labeled T1 and T2, are on standby, each with distinct travel times to the ship: T1 can arrive in 8.39 minutes, while T2 would take 11.12 minutes. The urgency of the situation demands that the harbor master minimize the response time to ensure timely assistance. However, only one tugboat can be dispatched to avoid resource redundancy. The challenge is clear: *Which tugboat should be sent to achieve the shortest possible response time while adhering to the constraint of deploying just one unit?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y[t]`: A binary variable for each tugboat `t` (where `t` can be T1 or T2).  
       - `y[t] = 1` if tugboat `t` is dispatched, `0` otherwise.  

   - **2. Parameters:**  
     - `travel_times[t]`: Predefined time (in minutes) for tugboat `t` to reach the ship.  
       - `travel_times['T1'] = 8.392`, `travel_times['T2'] = 11.123`.  

   - **3. Objective Function:**  
     - Minimize the total response time:  
       \[
       \text{Minimize: } y[\text{T1}] \times 8.392 + y[\text{T2}] \times 11.123
       \]  

   - **4. Constraints:**  
     - **Single dispatch:** Exactly one tugboat must be selected:  
       \[
       y[\text{T1}] + y[\text{T2}] = 1
       \]  
     - **Binary nature:** \( y[t] \in \{0, 1\} \) for all `t`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
travel_times = {'T1': 8.392982113183287, 'T2': 11.122521574999555}
tugboat_ids = list(travel_times.keys())

# --- Model Creation ---
model = gp.Model("Maritime_Tugboat_Dispatch_IP")

# --- Decision Variables ---
# Binary: y[t]=1 if tugboat t is dispatched
y = model.addVars(tugboat_ids, vtype=GRB.BINARY, name="dispatch_choice")

# --- Objective Function ---
# Minimize the response time of the dispatched unit
model.setObjective(gp.quicksum(y[t] * travel_times[t] for t in tugboat_ids), sense=GRB.MINIMIZE)

# --- Constraints ---
# Dispatch exactly one tugboat
model.addConstr(gp.quicksum(y[t] for t in tugboat_ids) == 1, name="dispatch_one")

# --- Optimization ---
model.optimize()

# --- Output Results ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    dispatched_tugboat = [t for t in tugboat_ids if y[t].X > 0.5][0]
    min_response_time = model.ObjVal
    print(f"Optimal Tugboat to Dispatch: {dispatched_tugboat}")
    print(f"Minimum Response Time: {min_response_time:.1f} minutes")
    print("\nAll Travel Times:")
    for t in tugboat_ids:
        print(f"  {t}: {travel_times[t]} minutes")
else:
    print(f"Optimization Status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 2 columns and 2 nonzeros
Model fingerprint: 0x4be210cf
Variable types: 0 continuous, 2 integer (2 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [8e+00, 1e+01]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 8.3929821
Presolve removed 1 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 1: 8.39298 

Optimal solution found (tolerance 1.00e-04)
Best objective 8.392982113183e+00, best bound 8.392982113183e+00, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Tugboat to Dispatch: T1
Minimum Response Time: 8.4 minutes

All Travel Times:
  T1: 8.392982113183287 minutes
  T2: 11.122521574999555 minutes



================================================================================



--- Problem 392 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A maritime logistics company is tasked with optimizing the berthing and unloading schedules for a fleet of six ships at a port. The port has eight berths, each with specific unloading demands (e.g., berth 1 requires 95 units, berth 2 needs 40 units). Each ship has a distinct capacity, ranging from 53 to 100 units, and must unload goods at the berths. The distances between all berths are predefined, with some routes being significantly shorter (e.g., entrance to berth 7 is just 9 units) while others are longer (e.g., entrance to berth 6 is 90 units). The challenge is to assign berths to ships such that every berth is visited exactly once, ship capacities are not exceeded, and the total distance traveled by all ships is minimized. The company aims to reduce fuel costs and improve unloading efficiency while ensuring no ship is overloaded.

The core question is: *What is the most efficient way to assign berths to ships and sequence their visits to minimize the total distance traveled, given the capacity constraints and distance matrix?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variables `x(i, j, k)` indicate whether ship `k` travels directly from berth `i` to berth `j` (1 if yes, 0 otherwise).  
   - Continuous variables `u(i)` (for subtour elimination) track the order of visits to berth `i` (Miller-Tucker-Zemlin constraints).  

   **2. Parameters:**  
   - `N = 9`: Total nodes (1 entrance + 8 berths).  
   - `K = 6`: Number of ships.  
   - `Q[k]`: Capacity of ship `k` (e.g., 53, 92, ..., 91.45).  
   - `q[i]`: Demand at berth `i` (e.g., 95 for berth 1, 40 for berth 2).  
   - `d[i][j]`: Distance from node `i` to `j` (e.g., entrance to berth 7: 9 units).  

   **3. Objective Function:**  
   Minimize the total distance traveled by all ships:  
   `Minimize: sum(d[i][j] * x(i, j, k) for all i, j, k where i ≠ j)`.  

   **4. Constraints:**  
   - **Visit Once:** Each berth is visited exactly once:  
     `sum(x(i, j, k) for all j, k where i ≠ j) = 1` for each berth `i`.  
   - **Flow Conservation:** Ships entering a node must leave it:  
     `sum(x(i, j, k) for all j) = sum(x(j, i, k) for all j)` for each node `i` and ship `k`.  
   - **Entrance Departure/Return:** Each ship starts and ends at the entrance:  
     `sum(x(0, j, k) for all j) ≤ 1` and `sum(x(0, j, k)) = sum(x(j, 0, k))` for each ship `k`.  
   - **Capacity:** Total demand on a ship’s route cannot exceed its capacity:  
     `sum(q[j] * sum(x(i, j, k) for all i) ≤ Q[k]` for each ship `k`.  
   - **Subtour Elimination:** Prevent cycles not including the entrance:  
     `u[i] - u[j] + (N-1) * x(i, j, k) ≤ N-2` for all berths `i, j` and ships `k`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 9
K = 6
Q = [53, 92, 81, 79, 100, 91.45000000000005]
q = [0, 95, 40, 41, 73, 84, 17, 46, 73]
d = [
    [0, 31, 14, 68, 58, 27, 90, 9, 4],
    [31, 0, 97, 55, 83, 17, 61, 93, 17],
    [14, 97, 0, 3, 77, 3, 67, 21, 62],
    [68, 55, 3, 0, 5, 28, 50, 36, 95],
    [58, 83, 77, 5, 0, 17, 82, 56, 42],
    [27, 17, 3, 28, 17, 0, 13, 33, 36],
    [90, 61, 67, 50, 82, 13, 0, 96, 80],
    [9, 93, 21, 36, 56, 33, 96, 0, 37],
    [4, 17, 62, 95, 42, 36, 80, 37, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each berth (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Ship Departure/Return from Entrance (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartEntrance_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnEntrance_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for ship {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for ship {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 457.00

Route for ship 1 (Capacity: 53):
0 -> 7 -> 0
Route Load: 46 / 53

Route for ship 2 (Capacity: 92):
0 -> 5 -> 0
Route Load: 84 / 92

Route for ship 3 (Capacity: 81):
0 -> 3 -> 2 -> 0
Route Load: 81 / 81

Route for ship 4 (Capacity: 79):
0 -> 8 -> 0
Route Load: 73 / 79

Route for ship 5 (Capacity: 100):
0 -> 1 -> 0
Route Load: 95 / 100

Route for ship 6 (Capacity: 91.45000000000005):
0 -> 6 -> 4 -> 0
Route Load: 90 / 91.45000000000005


```

================================================================================



--- Problem 393 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling the unloading of incoming trucks to minimize the total time required to service all vehicles. Three trucks—Truck 1, Truck 2, and Truck 3—arrive at staggered times: Truck 1 at time 2, Truck 2 at time 3, and Truck 3 at time 6. Each truck requires a specific processing duration: Truck 1 takes 3 units of time, Truck 2 takes 6, and Truck 3 takes 4. The hub has only one depot available, meaning trucks must be scheduled sequentially without overlap. The critical question is: *What is the optimal sequence to assign trucks to the depot so that the last truck finishes as early as possible?*  

The logistics manager must ensure that no truck starts before its arrival time and that the depot is never occupied by more than one truck at a time. The goal is to minimize the *makespan*—the total time taken from the start of the first operation to the completion of the last. This optimization directly impacts the hub's efficiency, reducing idle time and maximizing throughput.
**

**Modeling Process:**
**
**1. Decision Variables:**  
- **`assign[i, j]`**: Binary variable (1 if truck *i* is assigned to depot *j*, 0 otherwise).  
- **`start_time[i]`**: Continuous variable representing when truck *i* begins processing.  
- **`completion_time[i]`**: Continuous variable representing when truck *i* finishes (start time + processing time).  
- **`precedes[i, k, j]`**: Binary variable (1 if truck *i* is scheduled before truck *k* on depot *j*, 0 otherwise).  
- **`makespan`**: Continuous variable representing the latest completion time across all trucks.  

**2. Parameters:**  
- **Trucks**: [1, 2, 3]  
- **Depots**: [1]  
- **Arrival times**: {1: 2, 2: 3, 3: 6}  
- **Processing times**: {1: 3, 2: 6, 3: 4}  
- **Big M (H)**: 100 (a sufficiently large constant for logical constraints).  

**3. Objective Function:**  
Minimize:  
- `makespan`  

**4. Constraints:**  
1. **Assignment**: Each truck must be assigned to exactly one depot:  
   - For all *i* in trucks: `sum(assign[i, j] for j in depots) = 1`.  
2. **Arrival time**: Trucks cannot start before their arrival:  
   - For all *i* in trucks: `start_time[i] >= arrival_times[i]`.  
3. **Completion time**: Defined as start time plus processing time:  
   - For all *i* in trucks: `completion_time[i] = start_time[i] + processing_times[i]`.  
4. **Non-overlapping**: If two trucks *i* and *k* share a depot, one must precede the other:  
   - For all *i < k* in trucks and *j* in depots:  
     - If `precedes[i, k, j] = 1`, then `start_time[k] >= completion_time[i]`.  
     - If `precedes[i, k, j] = 0`, then `start_time[i] >= completion_time[k]`.  
     - Logical linking: `assign[i, j] + assign[k, j] - 1 <= precedes[i, k, j] + (1 - precedes[i, k, j])`.  
5. **Makespan definition**: The latest completion time bounds the makespan:  
   - For all *i* in trucks: `makespan >= completion_time[i]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
depots = [1]
arrival_times = {1: 2, 2: 3, 3: 6}
processing_times = {1: 3, 2: 6, 3: 4}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_51_MIN_MAKESPAN")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal makespan: {results_dict['obj_val']:.4f}")
    for i in trucks:
        print(f"Truck {i} start time: {start_time[i].x:.4f}, completion time: {completion_time[i].x:.4f}")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
15.0000
Optimal makespan: 15.0000
Truck 1 start time: 2.0000, completion time: 5.0000
Truck 2 start time: 5.0000, completion time: 11.0000
Truck 3 start time: 11.0000, completion time: 15.0000
Truck 1 is assigned to Depot 1
Truck 2 is assigned to Depot 1
Truck 3 is assigned to Depot 1


```

================================================================================



--- Problem 394 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy inland port, five cargo trucks arrive at staggered times, each requiring immediate unloading at one of the available depots. The port has three depots, but the challenge lies in efficiently assigning trucks to depots while minimizing the total waiting cost—a critical financial consideration for the port authority. The waiting cost isn't linear; it escalates sharply after a threshold. Specifically, the first 2 hours of waiting incur a cost of \$74 per hour, but any additional waiting time beyond this threshold costs \$169 per hour—a steep penalty reflecting the urgency of avoiding prolonged delays.  

Trucks arrive at the following times: Truck 1 at 5 hours, Truck 2 at 10 hours, Truck 3 at 12 hours, Truck 4 at 17 hours, and Truck 5 at 20 hours. Their processing times vary: Trucks 1 and 5 take 3 hours each, while Trucks 2, 3, and 4 require 5 hours. The port manager must decide not only which depot each truck should use but also the exact start time for each truck's processing, ensuring no two trucks occupy the same depot simultaneously. The core question is: *What is the optimal depot assignment and scheduling plan that minimizes the total waiting cost, accounting for the piecewise cost structure?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `assign(i, j)`: 1 if truck *i* is assigned to depot *j*, else 0.  
   - Continuous variable `start_time(i)`: The time truck *i* begins processing.  
   - Continuous variable `completion_time(i)`: The time truck *i* finishes processing.  
   - Binary variable `precedes(i, k, j)`: 1 if truck *i* is processed before truck *k* on depot *j*, else 0.  
   - Continuous variables `wait_part1(i)` and `wait_part2(i)`: The waiting time for truck *i* split into two parts (≤2 hours and >2 hours).  

   **2. Parameters:**  
   - `arrival_times[i]`: Arrival time of truck *i* (e.g., Truck 1 arrives at 5).  
   - `processing_times[i]`: Time to process truck *i* (e.g., Truck 1 takes 3 hours).  
   - `wait_cost_rate1 = 74`: Cost per hour for waiting ≤2 hours.  
   - `wait_cost_rate2 = 169`: Cost per hour for waiting >2 hours.  
   - `wait_threshold = 2`: Threshold for the piecewise cost.  
   - `H = 100`: A large constant for logical constraints.  

   **3. Objective Function:**  
   Minimize the total waiting cost:  
   ```  
   Minimize: sum(74 * wait_part1[i] + 169 * wait_part2[i] for all trucks i)  
   ```  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot.  
     ```  
     For each truck i: sum(assign[i, j] for all depots j) = 1  
     ```  
   - **Arrival Time:** A truck cannot start processing before its arrival.  
     ```  
     For each truck i: start_time[i] ≥ arrival_times[i]  
     ```  
   - **Completion Time:** Processing time is added to start time.  
     ```  
     For each truck i: completion_time[i] = start_time[i] + processing_times[i]  
     ```  
   - **Non-Overlapping:** If two trucks are assigned to the same depot, one must precede the other.  
     ```  
     For each depot j and trucks i < k:  
       If precedes[i, k, j] = 1, then start_time[k] ≥ completion_time[i]  
       Else, start_time[i] ≥ completion_time[k]  
     ```  
   - **Waiting Time Decomposition:** Total waiting time is split into two parts.  
     ```  
     For each truck i: start_time[i] - arrival_times[i] = wait_part1[i] + wait_part2[i]  
     ```  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2, 3]
arrival_times = {1: 5, 2: 10, 3: 12, 4: 17, 5: 20}
processing_times = {1: 3, 2: 5, 3: 5, 4: 5, 5: 3}
wait_cost_rate1 = 74
wait_cost_rate2 = 169
wait_threshold = 2
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_56_PIECEWISE_COST")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    wait_part1 = m.addVars(trucks, lb=0.0, ub=wait_threshold, vtype=GRB.CONTINUOUS, name="WaitPart1")
    wait_part2 = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="WaitPart2")

    # --- Objective Function ---
    total_wait_cost = gp.quicksum(wait_cost_rate1 * wait_part1[i] + wait_cost_rate2 * wait_part2[i] for i in trucks)
    m.setObjective(total_wait_cost, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Link waiting time parts
    m.addConstrs((start_time[i] - arrival_times.get(i, 0) == wait_part1[i] + wait_part2[i] for i in trucks), name="wait_decomposition")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Print Missing Outputs ---

if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.2f}")
                print(f"  Completion Time: {completion_time[i].x:.2f}")
                print(f"  Waiting Time (Part 1): {wait_part1[i].x:.2f}")
                print(f"  Waiting Time (Part 2): {wait_part2[i].x:.2f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
1141.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 1
  Start Time: 5.00
  Completion Time: 8.00
  Waiting Time (Part 1): 0.00
  Waiting Time (Part 2): 0.00
Truck 2 is assigned to Depot 1
  Start Time: 10.00
  Completion Time: 15.00
  Waiting Time (Part 1): 0.00
  Waiting Time (Part 2): 0.00
Truck 3 is assigned to Depot 1
  Start Time: 15.00
  Completion Time: 20.00
  Waiting Time (Part 1): 2.00
  Waiting Time (Part 2): 1.00
Truck 4 is assigned to Depot 1
  Start Time: 23.00
  Completion Time: 28.00
  Waiting Time (Part 1): 2.00
  Waiting Time (Part 2): 4.00
Truck 5 is assigned to Depot 1
  Start Time: 20.00
  Completion Time: 23.00
  Waiting Time (Part 1): 0.00
  Waiting Time (Part 2): 0.00


```

================================================================================



--- Problem 395 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
At a busy urban intersection, traffic lights cycle through a fixed sequence to manage the flow of vehicles. The cycle lasts approximately 101.85 seconds, divided into green phases for the main and side roads (40.79 seconds and 44.13 seconds, respectively), with a total lost time of 10 seconds (5 seconds per transition phase). An emergency vehicle (EV) arrives at the intersection at 58.05 seconds into the cycle, requiring 9.49 seconds to pass through. The challenge is to decide whether to preempt the normal traffic signal sequence to prioritize the EV or let it wait for the next green phase.  

Preempting the signal ensures the EV passes immediately, avoiding delay, but disrupts general traffic, potentially increasing overall delays. Not preempting forces the EV to wait, but keeps traffic flow predictable. The decision hinges on balancing two competing costs: the weighted delay of the EV (10.29 units per second) and the estimated increase in general traffic delay (0.93 units per second). The goal is to choose the strategy—preemption or no preemption—that minimizes the total weighted cost of delays.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `y(s)` for each strategy `s` in `['NoPreemption', 'Preemption']`, where `y(s) = 1` if strategy `s` is selected, else `0`.  
   - **2. Parameters:**  
     - `C_cycle = 101.85` seconds (total cycle time).  
     - `g_main_normal = 40.79` seconds (main road green time).  
     - `g_side_normal = 44.13` seconds (side road green time).  
     - `T_ev_arrival = 58.05` seconds (EV arrival time).  
     - `T_ev_pass_duration = 9.49` seconds (EV passing time).  
     - `W_ev = 10.29` (weight for EV delay).  
     - `W_gen = 0.93` (weight for general traffic delay increase).  
     - `strategy_costs = {'NoPreemption': 450.53, 'Preemption': 466.44}` (precomputed costs).  
   - **3. Objective Function:**  
     - Minimize the total weighted cost:  
       `Minimize: y('NoPreemption') * 450.53 + y('Preemption') * 466.44`.  
   - **4. Constraints:**  
     - Exactly one strategy must be chosen:  
       `y('NoPreemption') + y('Preemption') = 1`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
C_cycle = 101.85496898189308  # s
g_main_normal = 40.78634507009652  # s
g_side_normal = 44.12650553517272  # s
L_lost_time_total = C_cycle - g_main_normal - g_side_normal  # = 10s -> 5s per phase

# Assume phase sequence: Main Green -> Main L -> Side Green -> Side L
main_green_end = g_main_normal
main_lost_end = main_green_end + L_lost_time_total / 2.0
side_green_end = main_lost_end + g_side_normal
side_lost_end = C_cycle

# EV Arrival time
T_ev_arrival = 58.05068219670621  # seconds
T_ev_pass_duration = 9.485168013059775  # seconds
W_ev = 10.285063203187548  # Weight for EV delay
W_gen = 0.9328893257264397  # Weight for general traffic delay increase

strategies = ['NoPreemption', 'Preemption']

# --- Calculate Delays for each strategy ---
strategy_costs = {}
print("--- Cost Calculation per Strategy ---")

# Strategy N: No Preemption
ev_delay_N = 0
current_time_in_cycle = T_ev_arrival % C_cycle
if not (0 <= current_time_in_cycle < main_green_end):  # Check if EV arrives during main green
    # EV arrives during red or side green. Calculate wait time till next main green.
    time_to_next_main_green = C_cycle - current_time_in_cycle
    ev_delay_N = time_to_next_main_green
gen_delay_increase_N = 0  # Baseline
total_cost_N = ev_delay_N * W_ev + gen_delay_increase_N * W_gen
strategy_costs['NoPreemption'] = total_cost_N
print(f" Strategy 'NoPreemption':")
print(f"  EV arrives at {T_ev_arrival:.1f}s. Cycle pos: {current_time_in_cycle:.1f}s.")
print(f"  EV Delay = {ev_delay_N:.1f}s")
print(f"  General Traffic Delay Increase = {gen_delay_increase_N:.1f} veh*s (Baseline)")
print(f"  Total Weighted Cost = {total_cost_N:.2f}")

# Strategy P: Preemption
ev_delay_P = 0  # Preemption ensures green on arrival
# Estimate general traffic delay increase
lost_side_green = 0
if main_lost_end <= current_time_in_cycle < side_green_end:
     lost_side_green = side_green_end - current_time_in_cycle
# Main green gained: T_ev_pass_duration
gained_main_green = T_ev_pass_duration
# Estimate of delay impact
gen_delay_increase_P = 500.0  # Placeholder veh*s
total_cost_P = ev_delay_P * W_ev + gen_delay_increase_P * W_gen
strategy_costs['Preemption'] = total_cost_P
print(f" Strategy 'Preemption':")
print(f"  EV Delay = {ev_delay_P:.1f}s")
print(f"  Estimated General Traffic Delay Increase = {gen_delay_increase_P:.1f} veh*s")
print(f"  Total Weighted Cost = {total_cost_P:.2f}")

# --- Gurobi Model (Simple selection) ---
model = gp.Model("EV_Preemption_Choice")

# --- Decision Variables ---
y = model.addVars(strategies, vtype=GRB.BINARY, name="ChooseStrategy")

# --- Constraints ---
model.addConstr(gp.quicksum(y[s] for s in strategies) == 1, name="SelectOneStrategy")

# --- Objective Function ---
# Minimize the total weighted cost
objective = gp.quicksum(y[s] * strategy_costs[s] for s in strategies)
model.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    chosen_strategy = ""
    for s in strategies:
        if y[s].X > 0.9:
            chosen_strategy = s
            break

    if chosen_strategy:
         print(f"Optimal Preemption Strategy: {chosen_strategy}")
         print(f" Minimum Total Weighted Cost: {model.objVal:.2f}")
    else:
         print("Error: No strategy selected.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- Cost Calculation per Strategy ---
 Strategy 'NoPreemption':
  EV arrives at 58.1s. Cycle pos: 58.1s.
  EV Delay = 43.8s
  General Traffic Delay Increase = 0.0 veh*s (Baseline)
  Total Weighted Cost = 450.53
 Strategy 'Preemption':
  EV Delay = 0.0s
  Estimated General Traffic Delay Increase = 500.0 veh*s
  Total Weighted Cost = 466.44
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 2 columns and 2 nonzeros
Model fingerprint: 0x477f4839
Variable types: 0 continuous, 2 integer (2 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [5e+02, 5e+02]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 450.5298582
Presolve removed 1 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 1: 450.53 

Optimal solution found (tolerance 1.00e-04)
Best objective 4.505298581562e+02, best bound 4.505298581562e+02, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Preemption Strategy: NoPreemption
 Minimum Total Weighted Cost: 450.53



================================================================================



--- Problem 396 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A port management team is tasked with optimizing the flow of container ships through a critical dock where an accident has reduced capacity. The dock operates with a fixed cycle length of 101 minutes, but 23 minutes are lost to transition phases (e.g., safety checks), leaving only 78 minutes of usable docking time to allocate between northbound and southbound shipping lanes. The northbound lane faces a demand of 709 ship arrivals per hour, while the southbound lane must accommodate 556 ship arrivals per hour. Each lane has a maximum capacity of 1,319 ship arrivals per hour under ideal conditions.  

   The challenge is to distribute the limited docking time between the two directions to maximize total throughput while ensuring fairness—specifically, ensuring that the flow of ships from each direction is proportional to their respective demands. This prevents one direction from being disproportionately delayed. The team must determine: *How should the 78 minutes of effective docking time be split between northbound and southbound traffic to achieve the highest possible total throughput while maintaining proportional fairness?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `g_n`: Docking time allocated to the northbound lane (minutes).  
   - `g_s`: Docking time allocated to the southbound lane (minutes).  
   - `t_n`: Throughput (flow rate) of northbound ships (ships/hr).  
   - `t_s`: Throughput (flow rate) of southbound ships (ships/hr).  

   **2. Parameters:**  
   - `cycle_length_min = 101`: Total dock cycle time (minutes).  
   - `lost_time_min = 23`: Time lost to transitions (minutes).  
   - `effective_docking_total = 78`: Usable docking time (cycle_length_min - lost_time_min).  
   - `lane_capacity_ships_per_hr = 1319`: Maximum lane capacity (ships/hr).  
   - `demand_n_ships_per_hr = 709`, `demand_s_ships_per_hr = 556`: Ship demand for each direction (ships/hr).  
   - `capacity_factor = 1319 / 101 ≈ 13.059`: Conversion factor for docking time to throughput (ships/hr per minute).  

   **3. Objective Function:**  
   Maximize the total throughput:  
   ```  
   Maximize: t_n + t_s  
   ```  

   **4. Constraints:**  
   - Total docking time allocation:  
     ```  
     g_n + g_s = 78  
     ```  
   - Lane capacity limits (throughput cannot exceed capacity):  
     ```  
     t_n ≤ (1319 / 101) * g_n  
     t_s ≤ (1319 / 101) * g_s  
     ```  
   - Demand limits (throughput cannot exceed demand):  
     ```  
     t_n ≤ 709  
     t_s ≤ 556  
     ```  
   - Proportional flow fairness (if both demands are positive):  
     ```  
     t_n * 556 = t_s * 709  
     ```  
   - Non-negativity:  
     ```  
     g_n, g_s, t_n, t_s ≥ 0  
     ```  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
cycle_length_min = 101; lost_time_min = 23; lane_capacity_ships_per_hr = 1319
demand_n_ships_per_hr = 709; demand_s_ships_per_hr = 556
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    effective_docking_total = cycle_length_min - lost_time_min
    if effective_docking_total < 1e-6: raise ValueError("Effective docking time is non-positive")
    capacity_factor = lane_capacity_ships_per_hr / cycle_length_min if cycle_length_min > 1e-6 else 0
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m13 = gp.Model("Accident_Scene_Flow_LP", env=env)
    # Vars
    g_n = m13.addVar(name="docking_north", lb=0); g_s = m13.addVar(name="docking_south", lb=0)
    t_n = m13.addVar(name="throughput_north", lb=0); t_s = m13.addVar(name="throughput_south", lb=0)
    # Objective
    m13.setObjective(t_n + t_s, sense=GRB.MAXIMIZE)
    # Constraints
    m13.addConstr(g_n + g_s == effective_docking_total, "total_docking_time")
    m13.addConstr(t_n <= capacity_factor * g_n, "north_capacity_limit")
    m13.addConstr(t_s <= capacity_factor * g_s, "south_capacity_limit")
    m13.addConstr(t_n <= demand_n_ships_per_hr, "north_demand_limit")
    m13.addConstr(t_s <= demand_s_ships_per_hr, "south_demand_limit")
    # Proportional flow constraint (handle division by zero)
    if demand_n_ships_per_hr > 1e-6 and demand_s_ships_per_hr > 1e-6:
         m13.addConstr(t_n * demand_s_ships_per_hr == t_s * demand_n_ships_per_hr, "proportional_flow")
    elif demand_n_ships_per_hr <= 1e-6: m13.addConstr(t_n == 0, "zero_demand_n") # Force zero throughput if zero demand
    elif demand_s_ships_per_hr <= 1e-6: m13.addConstr(t_s == 0, "zero_demand_s") # Force zero throughput if zero demand
    # Optimize
    m13.optimize()
    # Store results
    results_dict['status'] = m13.status
    if m13.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m13.objVal; results_dict['g_n_opt'] = g_n.X; results_dict['g_s_opt'] = g_s.X
        results_dict['t_n_opt'] = t_n.X; results_dict['t_s_opt'] = t_s.X
    # Output Results
    print("--- Problem 13: Accident Scene Lane Management (LP) ---")
    if m13.status == GRB.OPTIMAL:
        gn = results_dict.get('g_n_opt',0); gs = results_dict.get('g_s_opt',0)
        tn = results_dict.get('t_n_opt',0); ts = results_dict.get('t_s_opt',0)
        print(f"Optimization Status: Optimal")
        print(f"Optimal Northbound Docking Time (g_n): {gn:.1f} min"); print(f"Optimal Southbound Docking Time (g_s): {gs:.1f} min")
        print(f"Total Effective Docking: {gn + gs:.1f} / {effective_docking_total} min")
        print(f"Maximized Northbound Throughput (t_n): {tn:.1f} ships/hr (Demand: {demand_n_ships_per_hr})")
        print(f"Maximized Southbound Throughput (t_s): {ts:.1f} ships/hr (Demand: {demand_s_ships_per_hr})")
        print(f"Total Maximized Throughput: {m13.objVal:.1f} ships/hr")
        prop_n = tn / demand_n_ships_per_hr if demand_n_ships_per_hr > 1e-6 else 0
        prop_s = ts / demand_s_ships_per_hr if demand_s_ships_per_hr > 1e-6 else 0
        if abs(prop_n - prop_s) < 1e-4: print(f"Flow is proportional to demand.")
        else: print(f"Flow proportionality check: N={prop_n:.3f}, S={prop_s:.3f}")
    elif m13.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    else: print(f"Optimization Status: {m13.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of ACCIDENT_FLOW
```
Answer:
--- Problem 13: Accident Scene Lane Management (LP) ---
Optimization Status: Optimal
Optimal Northbound Docking Time (g_n): 43.7 min
Optimal Southbound Docking Time (g_s): 34.3 min
Total Effective Docking: 78.0 / 78 min
Maximized Northbound Throughput (t_n): 570.9 ships/hr (Demand: 709)
Maximized Southbound Throughput (t_s): 447.7 ships/hr (Demand: 556)
Total Maximized Throughput: 1018.6 ships/hr
Flow is proportional to demand.



================================================================================



--- Problem 397 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
In a busy port, the maritime logistics team is tasked with coordinating the berthing times for two types of cargo ships to minimize the total waiting time. Each type of ship has a different arrival rate: Type A ships arrive at a rate of 2,190 ships per month, and Type B ships arrive at a rate of 2,820 ships per month. The berthing times for each type must be allocated within strict bounds: no less than 27 hours and no more than 66 hours per type. The total berthing cycle time—the sum of berthing times for both types—must exactly match the upper limit of 66 hours. The core dilemma is determining how to distribute these berthing times to minimize the cumulative waiting time experienced by the ships, which arises when they wait during non-berthing periods. The question is: *What is the optimal allocation of berthing times between the two types to achieve the smallest possible total waiting time?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `t[i]`: Continuous variable representing the berthing time (in hours) allocated to ship type `i`, where `i ∈ {0, 1}` (for Type A and Type B, respectively). Each `t[i]` is bounded between 27 and 66 hours.  

   **2. Parameters:**  
   - `arrival_rates = [2190, 2820]`: Arrival rates (ships/month) for each ship type.  
   - `cycle_time = 66`: Total berthing cycle time (hours), fixed as the sum of berthing times.  
   - `lb_time = 27`, `ub_time = 66`: Lower and upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize the total waiting time, calculated as:  
   `sum(arrival_rates[i] * (cycle_time - t[i]) for i in {0, 1})`.  
   Here, `(cycle_time - t[i])` is the non-berthing time for ship type `i`, and the waiting time is proportional to the product of arrival rate and non-berthing time.  

   **4. Constraints:**  
   - **Total cycle time constraint:** `t[0] + t[1] = cycle_time`.  
   - **Bounds on berthing times:** `27 ≤ t[i] ≤ 66` for each ship type `i`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_types = 2
lb_time = 27          # Lower bound for berthing time
ub_time = 66          # Upper bound for berthing time
cycle_time = 66   # Total berthing cycle time (set equal to ub_time)
arrival_rates = [2190, 2820] # Arrival rates per ship type
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_rates) != num_types:
    print("Error: arrival_rates length mismatch with num_types")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_rates length"
    # raise ValueError("arrival_rates length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_types}-Type Berthing Time Allocation", env=env)

        # --- Decision variables (dynamic based on num_types) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_types, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for ship type i is proportional to arrival_rate * non_berthing_time = arrival_rate * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_rates[i] * (cycle_time - t_vars[i]) for i in range(num_types)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_types)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_types)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_types):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 161550.00
------------------------------
Optimal berthing times (hours):
  t1: 27.00, t2: 39.00


```

================================================================================



--- Problem 398 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A maritime logistics company operates a ship that must visit multiple berths in a single trip, starting and ending at a central port (node 0). The ship must deliver goods to six other berths (nodes 1 through 6), each with varying travel times between them. The challenge is to determine the most efficient route that minimizes the total travel time while ensuring the ship visits each berth exactly once before returning to the central port.  

   The travel times between nodes are asymmetric—meaning the time from node A to node B may differ from the time from node B to node A. For instance, traveling from node 0 to node 1 takes 13 minutes, but the return trip (node 1 to node 0) also takes 13 minutes. However, other pairs, like node 3 to node 4 (5 minutes) versus node 4 to node 3 (5 minutes), are symmetric. The goal is to find the shortest possible round-trip route that covers all nodes without revisiting any except the central port at the end.  

   The problem mirrors the classic Traveling Salesman Problem (TSP) but with real-world constraints: the ship must follow a strict sequence, and subtours (smaller loops that exclude some nodes) are prohibited. The key question is: *What is the optimal route that minimizes the total travel time while ensuring all deliveries are made efficiently?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `x(i, j)` for each pair of nodes `(i, j)` where `i ≠ j`, indicating whether the ship travels directly from node `i` to node `j` (`x(i, j) = 1`) or not (`x(i, j) = 0`).  
   - Continuous variable `u(i)` for each node `i`, representing the order in which node `i` is visited (used to eliminate subtours).  

   **2. Parameters:**  
   - `dist(i, j)`: The travel time (in minutes) from node `i` to node `j`.  
   - `num_nodes = 7`: The total number of nodes (including the central port).  

   **3. Objective Function:**  
   Minimize the total travel time:  
   `Minimize: sum(x(i, j) * dist(i, j) for all valid (i, j))`  

   **4. Constraints:**  
   - **Departure constraint:** The ship must leave each node exactly once:  
     `sum(x(i, j) for all j ≠ i) = 1` for each node `i`.  
   - **Arrival constraint:** The ship must arrive at each node exactly once:  
     `sum(x(j, i) for all j ≠ i) = 1` for each node `i`.  
   - **Subtour elimination (MTZ constraints):** For nodes `i` and `j` (excluding the central port):  
     `u(i) - u(j) + num_nodes * x(i, j) ≤ num_nodes - 1`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import itertools; import math
# Params
num_nodes = 7; nodes = [0, 1, 2, 3, 4, 5, 6]; dist = {(0, 1): 13, (0, 2): 14, (0, 3): 16, (0, 4): 35, (0, 5): 14, (0, 6): 31, (1, 0): 13, (1, 2): 6, (1, 3): 18, (1, 4): 29, (1, 5): 26, (1, 6): 15, (2, 0): 14, (2, 1): 6, (2, 3): 10, (2, 4): 20, (2, 5): 17, (2, 6): 20, (3, 0): 16, (3, 1): 18, (3, 2): 10, (3, 4): 5, (3, 5): 35, (3, 6): 30, (4, 0): 35, (4, 1): 29, (4, 2): 20, (4, 3): 5, (4, 5): 20, (4, 6): 5, (5, 0): 14, (5, 1): 26, (5, 2): 17, (5, 3): 35, (5, 4): 20, (5, 6): 18, (6, 0): 31, (6, 1): 15, (6, 2): 20, (6, 3): 30, (6, 4): 5, (6, 5): 18}
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m17 = gp.Model("Ship_Berth_TSP_MIP", env=env)
    # Check if dist keys are valid tuples
    valid_keys = [(i,j) for i in nodes for j in nodes if i != j]
    # Vars
    x = m17.addVars(valid_keys, vtype=GRB.BINARY, name="travel") # Use valid_keys
    u = m17.addVars(nodes, vtype=GRB.CONTINUOUS, name="order", lb=0.0)
    # Objective
    m17.setObjective(gp.quicksum(x[i, j] * dist.get((i,j), 9999) for i, j in valid_keys), sense=GRB.MINIMIZE) # Use .get
    # Constraints
    m17.addConstrs((gp.quicksum(x[i, j] for j in nodes if i != j) == 1 for i in nodes), name="leave_node")
    m17.addConstrs((gp.quicksum(x[j, i] for j in nodes if i != j) == 1 for i in nodes), name="enter_node")
    # MTZ Subtour Elimination
    for i in nodes:
        for j in nodes:
            if i != j and i != 0 and j != 0 and (i,j) in valid_keys: # Check key exists
                 m17.addConstr(u[i] - u[j] + num_nodes * x[i, j] <= num_nodes - 1, name=f"MTZ_{i}_{j}")
    # Optimize
    m17.optimize()
    # Store results
    results_dict['status'] = m17.status
    if m17.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m17.objVal; results_dict['x_sol'] = m17.getAttr('X', x)
    # Output Results
    print("--- Problem 17: Multi-Stop Ship Berthing Routing (TSP Variation) (MIP) ---")
    if m17.status == GRB.OPTIMAL:
        print(f"Optimization Status: Optimal"); print(f"Minimum Total Travel Time: {m17.objVal:.1f} minutes"); print("Optimal Route:")
        x_sol = results_dict.get('x_sol', {})
        current_node = 0; route = [0]; visited_count=0
        while len(route) < num_nodes and visited_count < num_nodes + 2:
            next_node = -1
            for j in nodes:
                if current_node != j and x_sol.get((current_node, j), 0) > 0.5: next_node = j; break
            if next_node != -1: route.append(next_node); current_node = next_node
            else: break # No next node found
            visited_count += 1
        if current_node != 0: route.append(0) # Add return if not already there
        if len(route) == num_nodes + 1: print(f"  {' -> '.join(map(str, route))}")
        else: print(f"  Error: Could not reconstruct full route. Found: {' -> '.join(map(str, route))}")
    else: print(f"Optimization Status: {m17.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of SHIP_BERTH_TSP
```
Answer:
--- Problem 17: Multi-Stop Ship Berthing Routing (TSP Variation) (MIP) ---
Optimization Status: Optimal
Minimum Total Travel Time: 71.0 minutes
Optimal Route:
  0 -> 1 -> 2 -> 3 -> 4 -> 6 -> 5 -> 0



================================================================================


--- Problem 399 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port authority is tasked with efficiently scheduling a set of eight ships for berthing. Each ship has a specific length and a unique flag, and the berths have a strict length limit of 45 units. The challenge is compounded by a critical operational rule: no berth can contain ships with more than two distinct flags. The ships vary in length, with some being relatively short (e.g., ship 1 is 1 unit long) and others much longer (e.g., ship 2 is 35 units long). The flags are diverse, ranging from 'Z' to 'K', adding another layer of complexity to the berthing process. The primary goal is to determine the minimal number of berths required to accommodate all ships while adhering to both the length capacity and the flag diversity constraints. This problem mirrors real-world scenarios where efficient space utilization and regulatory constraints (like country-specific regulations) must be balanced.
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `x[i, j]`: Binary variable indicating whether ship `i` is placed in berth `j` (1 if yes, 0 otherwise).
   - `y[j]`: Binary variable indicating whether berth `j` is used (1 if yes, 0 otherwise).
   - `z[c, j]`: Binary variable indicating whether flag `c` is present in berth `j` (1 if yes, 0 otherwise).

**2. Parameters:**
   - `ships`: List of ship lengths [24, 1, 35, 7, 15, 28, 19, 37].
   - `flags`: List of ship flags ['Z', 'W', 'J', 'S', 'N', 'I', 'C', 'K'].
   - `capacity`: Maximum length per berth (45 units).
   - `num_ships`: Total number of ships (8).
   - `num_berths`: Maximum possible berths (8, one per ship in the worst case).
   - `unique_flags_list`: Sorted list of unique flags ['C', 'I', 'J', 'K', 'N', 'S', 'W', 'Z'].

**3. Objective Function:**
   - Minimize the total number of berths used: `Minimize sum(y[j] for all j)`.

**4. Constraints:**
   - **Ship Assignment:** Each ship must be placed in exactly one berth: `sum(x[i, j] for all j) == 1` for all ships `i`.
   - **Berth Capacity:** The total length in any berth `j` must not exceed its capacity: `sum(ships[i] * x[i, j] for all i) <= capacity * y[j]` for all berths `j`.
   - **Flag Linking:** If any ship of flag `c` is in berth `j`, then `z[c, j]` must be 1: `x[i, j] <= z[flags[i], j]` for all ships `i` and berths `j`.
   - **Flag Presence:** `z[c, j]` must be 0 if no ships of flag `c` are in berth `j`: `z[c, j] <= sum(x[i, j] for all i where flags[i] == c)` for all flags `c` and berths `j`.
   - **Flag Limit:** Each used berth can have at most two distinct flags: `sum(z[c, j] for all c) <= 2 * y[j]` for all berths `j`.

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
ships = [24, 1, 35, 7, 15, 28, 19, 37]      # Lengths of ships
flags = ['Z', 'W', 'J', 'S', 'N', 'I', 'C', 'K']    # Flags of ships
capacity = 45         # Berth capacity
num_ships = 8       # len(ships) - derived correctly below
num_berths = num_ships      # Maximum berths (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(ships) != len(flags) or len(ships) != num_ships:
    print("Error: Data inconsistency (ships/flags/num_ships length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_flags_list = sorted(list(set(flags))) # Get unique flags deterministically
ship_indices_by_flag = {flag: [i for i, f in enumerate(flags) if f == flag] for flag in unique_flags_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Flag-Constrained Berth Scheduling", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")  # x[i,j] -> ship i in berth j
        y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")              # y[j] -> whether berth j is used
        # z[c,j] -> whether flag c is PRESENT in berth j (Use unique_flags_list for keys)
        z = model.addVars(unique_flags_list, num_berths, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of berths used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each ship must be assigned to exactly one berth ---
        for i in range(num_ships):
            model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

        # --- Constraint 2: Berth capacity constraint ---
        for j in range(num_berths):
            model.addConstr(gp.quicksum(ships[i] * x[i, j] for i in range(num_ships)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

        # --- Constraint 3: Flag constraint (at most 2 *different* flags per berth) ---

        # Part 3a: Link x (ship in berth) and z (flag in berth).
        for j in range(num_berths):
            for flag in unique_flags_list:
                indices_of_this_flag = ship_indices_by_flag.get(flag, []) # Use .get for safety

                if not indices_of_this_flag:
                    # If no ships of this flag exist, z[flag, j] must be 0.
                    model.addConstr(z[flag, j] == 0, name=f"NoShips_{flag}_Berth_{j}")
                    continue

                # If any ship 'i' of this 'flag' is placed in berth 'j' (x[i,j]=1),
                # then the presence indicator for that 'flag' in berth 'j' (z[flag,j]) must be 1.
                for i in indices_of_this_flag:
                    model.addConstr(x[i, j] <= z[flag, j], name=f"Link_x{i}_z{flag}_Berth{j}")

                # Ensure z[flag, j] is 0 if no ships of that flag are in the berth.
                # This helps tighten the formulation.
                model.addConstr(z[flag, j] <= gp.quicksum(x[i, j] for i in indices_of_this_flag), name=f"Link_z{flag}_SumX_Berth{j}")


        # Part 3b: Limit the number of distinct flags (sum of z[c,j] for berth j) to 2 for USED berths.
        for j in range(num_berths):
            # sum(z[c,j] for c in unique_flags_list) gives the count of distinct flags in berth j.
            # This sum must be <= 2 *IF* the berth is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Flags_Berth_{j}")

        # --- Solve ---
        print("Solving FCBP instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of berths used: {optimal_berths}")
    print("-" * 30)

    berth_details = []
    printed_berth_count = 0
    for j_sol in range(num_berths): # Iterate through all potential berth indices
        try:
             # Check if this berth was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_berth_count += 1
                 assigned_ships_indices = [i for i in range(num_ships) if x[i, j_sol].X > 0.5]
                 assigned_ships_lengths = [ships[i] for i in assigned_ships_indices]
                 assigned_ships_flags = [flags[i] for i in assigned_ships_indices]
                 distinct_flags_in_berth = sorted(list(set(assigned_ships_flags))) # Sort for consistent output
                 berth_load = sum(assigned_ships_lengths)

                 print(f"Berth {printed_berth_count} (Internal Index {j_sol}):")
                 print(f"  Ships (indices): {assigned_ships_indices}")
                 # print(f"  Ships (lengths): {assigned_ships_lengths}") # Optional details
                 # print(f"  Ships (flags):  {assigned_ships_flags}") # Optional details
                 print(f"  Distinct Flags: {distinct_flags_in_berth} (Count: {len(distinct_flags_in_berth)})")
                 print(f"  Total length:    {berth_load} / {capacity}")
                 print("-" * 10)

                 berth_data = {
                     'berth_index_internal': j_sol,
                     'berth_index_printed': printed_berth_count,
                     'ship_indices': assigned_ships_indices,
                     'distinct_flags': distinct_flags_in_berth,
                     'load': berth_load
                 }
                 berth_details.append(berth_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for berth index {j_sol}: {e_print}")


    results_dict['berth_details'] = berth_details # Store details

    # Final sanity check
    if printed_berth_count != optimal_berths:
         print(f"Warning: Number of printed used berths ({printed_berth_count}) does not match objective value ({optimal_berths}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# The code provided already prints the key outputs, including the optimal number of berths used and detailed information for each berth.
# No additional print statements are necessary.
```
Answer:
Solving FCBP instance...
------------------------------

Optimal solution found.
Optimal number of berths used: 4
------------------------------
Berth 1 (Internal Index 1):
  Ships (indices): [0, 6]
  Distinct Flags: ['C', 'Z'] (Count: 2)
  Total length:    43 / 45
----------
Berth 2 (Internal Index 3):
  Ships (indices): [1, 7]
  Distinct Flags: ['K', 'W'] (Count: 2)
  Total length:    38 / 45
----------
Berth 3 (Internal Index 6):
  Ships (indices): [2, 3]
  Distinct Flags: ['J', 'S'] (Count: 2)
  Total length:    42 / 45
----------
Berth 4 (Internal Index 7):
  Ships (indices): [4, 5]
  Distinct Flags: ['I', 'N'] (Count: 2)
  Total length:    43 / 45
----------


```

================================================================================



--- Problem 400 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy container terminal is facing the challenge of efficiently managing the flow of containers while minimizing operational costs. With an average of 2,989 containers arriving per hour, the terminal must ensure that its crane scheduling decisions keep wait times manageable without overspending. Each of the 20 available cranes can process up to 150 containers per hour when in operation, but each active crane incurs an hourly cost of $21. The operations team faces a delicate balancing act: they must determine the smallest number of cranes to operate that can handle the incoming containers while staying within the physical limit of available cranes. The core question is: *What is the most cost-effective number of cranes to operate to meet demand without exceeding the terminal’s capacity?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x`: Integer variable representing the number of cranes to operate (must be non-negative).  
   - **2. Parameters:**  
     - `total_cranes = 20`: Maximum number of cranes available.  
     - `arrival_rate = 2989`: Containers arriving per hour.  
     - `service_rate_per_crane = 150`: Containers processed per hour per crane.  
     - `cost_per_crane = 21`: Hourly cost ($) per crane.  
   - **3. Objective Function:**  
     - Minimize the total staffing cost:  
       `Minimize: cost_per_crane * x`  
   - **4. Constraints:**  
     - **Capacity Constraint:** Total processing capacity must meet or exceed arrival rate:  
       `service_rate_per_crane * x >= arrival_rate`  
     - **Crane Availability Constraint:** Cannot operate more cranes than available:  
       `x <= total_cranes`  
     - **Variable Type Constraint:** `x` must be a non-negative integer.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
total_cranes = 20
arrival_rate = 2989 # containers/hour
service_rate_per_crane = 150 # containers/hour/crane
cost_per_crane = 21 # $/hour
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# --- Model Creation ---
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    m1 = gp.Model("Container_Crane_Scheduling", env=env)

    # --- Decision Variables ---
    # Number of cranes to operate (ensure non-negative integer)
    x = m1.addVar(vtype=GRB.INTEGER, name="num_operate_cranes", lb=0)

    # --- Objective Function ---
    # Minimize total staffing cost
    m1.setObjective(cost_per_crane * x, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Total processing capacity must meet arrival rate
    # Ensure service rate is positive before adding constraint
    if service_rate_per_crane > 0:
        m1.addConstr(service_rate_per_crane * x >= arrival_rate, name="capacity_constraint")
    else:
        # Handle case where service rate is zero (problem likely infeasible if arrival > 0)
        if arrival_rate > 0:
            print("Warning: Service rate is zero but arrival rate is positive. Setting model infeasible.")
            # How to force infeasibility? Add contradictory constraint
            m1.addConstr(x >= 1, "ForceInfeasible1")
            m1.addConstr(x <= 0, "ForceInfeasible2")
        else:
             # If arrival is also 0, x=0 is optimal, capacity constraint is 0 >= 0
             m1.addConstr(0 * x >= 0, name="capacity_constraint_zero")

    # Constraint 2: Number of operating cranes cannot exceed total available cranes
    m1.addConstr(x <= total_cranes, name="availability_constraint")

    # --- Optimization ---
    m1.optimize()

    # --- Store results ---
    results_dict['status'] = m1.status
    if m1.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m1.objVal
        results_dict['x_optimal'] = x.X # Store optimal X value

    # --- Output Results (for capture) ---
    if m1.status == GRB.OPTIMAL:
        # Use .X attribute to get the value
        optimal_x = results_dict.get('x_optimal', 'N/A')
        if not isinstance(optimal_x, (int, float)): optimal_x = -1 # Handle case where it wasn't stored

        print(f"Optimization Status: Optimal")
        print(f"Optimal number of cranes to operate: {int(round(optimal_x))}") # Round before int() for safety
        print(f"Minimum total staffing cost: ${m1.objVal:.2f}/hour")
        print(f"Total processing capacity: {service_rate_per_crane * optimal_x:.0f} containers/hour (Arrival rate: {arrival_rate})")
    elif m1.status == GRB.INFEASIBLE:
        print(f"Optimization Status: Infeasible")
    else:
        print(f"Optimization Status: {m1.status}")

except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimization Status: Optimal
Optimal number of cranes to operate: 20
Minimum total staffing cost: $420.00/hour
Total processing capacity: 3000 containers/hour (Arrival rate: 2989)


```

================================================================================



--- Problem 401 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A port authority is facing the challenge of managing 497 container unloading tasks daily while minimizing operational costs. The port has two options: using its own fleet of cranes or outsourcing the unloading to a third-party service. Each crane in the fleet can handle 7 containers per day, but the port is limited to a maximum of 33 cranes. Operating a crane for a day incurs a fixed cost of $139, while outsourcing a single container unloading costs $38. The port must strategically balance the use of its limited crane fleet with outsourcing to ensure all unloading tasks are completed at the lowest possible cost. The critical question is: *How many cranes should the port deploy, and how many container unloadings should be outsourced to minimize the total daily cost while meeting the full demand?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n`: Integer number of cranes to use (0 ≤ `n` ≤ 33).  
     - `outsourced`: Integer number of container unloadings outsourced (`outsourced` ≥ 0).  
   - **2. Parameters:**  
     - `total_unloadings_demand = 497`: Total container unloadings required.  
     - `unloadings_per_cranes_day = 7`: Container unloadings a single crane can handle daily.  
     - `cost_per_cranes_day = 139`: Cost to operate one crane daily.  
     - `cost_per_outsourced_unloading = 38`: Cost per outsourced container unloading.  
     - `max_cranes = 33`: Upper limit on available cranes.  
   - **3. Objective Function:**  
     Minimize total cost:  
     `Minimize: n * cost_per_cranes_day + outsourced * cost_per_outsourced_unloading`.  
   - **4. Constraints:**  
     - Demand fulfillment: `n * unloadings_per_cranes_day + outsourced ≥ total_unloadings_demand`.  
     - Crane limit: `n ≤ max_cranes`.  
     - Non-negativity: `n`, `outsourced` integers ≥ 0.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_unloadings_demand = 497
unloadings_per_cranes_day = 7
cost_per_cranes_day = 139
cost_per_outsourced_unloading = 38
max_cranes = 33
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m37 = gp.Model("CRANE_SIZE_OPTIMIZATION_IP", env=env)

    # --- Decision Variables ---
    # Integer: Number of cranes to use
    n = m37.addVar(vtype=GRB.INTEGER, name="num_cranes", lb=0, ub=max_cranes)
    # Integer: Number of container unloadings outsourced
    outsourced = m37.addVar(vtype=GRB.INTEGER, name="num_outsourced", lb=0)

    # --- Objective Function ---
    # Minimize total cost (crane cost + outsourcing cost)
    m37.setObjective(n * cost_per_cranes_day + outsourced * cost_per_outsourced_unloading, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Ensure total demand is met by own fleet + outsourcing
    # Avoid division by zero for unloadings_per_cranes_day
    if unloadings_per_cranes_day > 0:
        m37.addConstr(n * unloadings_per_cranes_day + outsourced >= total_unloadings_demand, name="demand_met")
    else:
        # If capacity is zero, all demand must be outsourced
        m37.addConstr(outsourced >= total_unloadings_demand, name="demand_met_zero_cap")
        m37.addConstr(n == 0, name="force_zero_cranes") # Cannot use cranes with zero capacity

    # --- Optimization ---
    m37.optimize()

    # --- Store results ---
    results_dict['status'] = m37.status
    if m37.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m37.ObjVal
        results_dict['n_sol'] = n.X
        results_dict['outsourced_sol'] = outsourced.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 37: Crane Fleet Size Optimization (IP) ---") # Original problem number
    if m37.status == GRB.OPTIMAL:
        opt_n = int(round(results_dict.get('n_sol', 0)))
        opt_outsourced = int(round(results_dict.get('outsourced_sol', 0)))
        capacity_own = opt_n * unloadings_per_cranes_day
        cost_own = opt_n * cost_per_cranes_day
        cost_outsource = opt_outsourced * cost_per_outsourced_unloading
        obj_val_print = results_dict.get('obj_val', 'N/A')

        print(f"Optimization Status: Optimal")
        print(f"Optimal Number of Cranes: {opt_n} (Max: {max_cranes})")
        print(f"  Own Fleet Capacity: {capacity_own} unloadings")
        print(f"Number of Outsourced Unloadings: {opt_outsourced}")
        print(f"Total Unloadings Covered: {capacity_own + opt_outsourced} (Demand: {total_unloadings_demand})")
        print(f"\nCosts:")
        print(f"  Own Fleet Cost: ${cost_own:.2f}")
        print(f"  Outsourcing Cost: ${cost_outsource:.2f}")
        print(f"Minimum Total Daily Cost: ${float(obj_val_print):.2f}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m37.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Leave empty as the code is complete and prints all required outputs)
```
Answer:
--- Problem 37: Crane Fleet Size Optimization (IP) ---
Optimization Status: Optimal
Optimal Number of Cranes: 33 (Max: 33)
  Own Fleet Capacity: 231 unloadings
Number of Outsourced Unloadings: 266
Total Unloadings Covered: 497 (Demand: 497)

Costs:
  Own Fleet Cost: $4587.00
  Outsourcing Cost: $10108.00
Minimum Total Daily Cost: $14695.00


```

================================================================================



--- Problem 402 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port management system faces a critical challenge: dynamically rerouting ships during an incident to minimize total delay. Over four consecutive 30-minute periods, ships arrive at varying rates (2547, 3975, 2713, and 4581 ships per hour). The main channel’s capacity drops from 3137 to 2147 ships per hour due to the incident, which lasts 1.34 hours. An alternative route with a fixed capacity of 1454 ships per hour is available but adds an extra 0.30 hours of travel time. Port managers must decide, for each period, what fraction of ships (10%, 30%, 50%, or 70%) to divert to the alternative route, balancing congestion on the main channel against the penalty of the longer detour. The goal is to find the optimal diversion strategy that minimizes the total delay across all ships, accounting for queue buildup on the main channel and the inherent inefficiency of the alternative route.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     Binary variables \( y(t, k) \) for each time period \( t \) (1 to 4) and diversion option \( k \) (0 to 3, representing 10%, 30%, 50%, and 70%). \( y(t, k) = 1 \) if option \( k \) is chosen for period \( t \), else 0.  
   - **2. Parameters:**  
     - Arrival rates: \( \lambda_t \) = [2547, 3975, 2713, 4581] ships/h.  
     - Capacities: Main (normal) = 3137 ships/h, main (reduced) = 2147 ships/h, alternative = 1454 ships/h.  
     - Time period length: \( \Delta t = 0.5 \) h.  
     - Alternative route delay penalty: \( \delta = 0.3038 \) h.  
     - Precomputed delays \( D(t, k) \): Total delay for period \( t \) if option \( k \) is selected (combining queue delay on the main channel and detour delay on the alternative route).  
   - **3. Objective Function:**  
     Minimize total delay: \( \sum_{t=1}^4 \sum_{k=0}^3 y(t, k) \cdot D(t, k) \).  
   - **4. Constraints:**  
     - Exactly one diversion option per period: \( \sum_{k=0}^3 y(t, k) = 1 \) for all \( t \).  
     - Infeasible options forced to 0: \( y(t, k) = 0 \) if the alternative route cannot handle the diverted flow (i.e., \( \lambda_t \cdot p_k > 1454 \)).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_TIME_PERIODS = 4
TIME_PERIOD_LENGTH = 0.5  # h
capacity_main_normal = 3137  # ships/h
capacity_main_reduced = 2147  # ships/h
capacity_alt = 1454  # ships/h
arrival_rates = [2547, 3975, 2713, 4581]  # ships/h
incident_duration = 1.3422083046753337  # h
alt_route_extra_time = 0.30382907248473556  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option and Time Period ---
period_option_delays = {}
period_option_feasible = {}

for t in range(NUM_TIME_PERIODS):
    period_option_delays[t] = {}
    period_option_feasible[t] = {}

    for k in range(num_options):
        p_k = diversion_options[k]
        flow_alt_k = arrival_rates[t] * p_k
        flow_main_k = arrival_rates[t] * (1 - p_k)

        # 1. Check Alternative Route Capacity Feasibility
        if flow_alt_k > capacity_alt + EPSILON:
            period_option_feasible[t][k] = False
            period_option_delays[t][k] = LARGE_DELAY
            continue

        period_option_feasible[t][k] = True

        # 2. Calculate Alternative Route Delay
        delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_route_extra_time

        # 3. Calculate Main Route Queue Delay
        delay_queue_main_k = 0
        max_queue_main_k = 0

        if flow_main_k > capacity_main_reduced + EPSILON:
            max_queue_main_k = (flow_main_k - capacity_main_reduced) * TIME_PERIOD_LENGTH
            if flow_main_k >= capacity_main_normal - EPSILON:
                delay_queue_main_k = LARGE_DELAY
            else:
                dissipation_rate_k = capacity_main_normal - flow_main_k
                if dissipation_rate_k < EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                    total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                    delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

        # 4. Calculate Total Delay for this option
        total_delay_k = delay_alt_k + delay_queue_main_k
        period_option_delays[t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for t in range(NUM_TIME_PERIODS):
    feasible_indices = [k for k in range(num_options) if period_option_feasible[t][k]]
    if not feasible_indices:
        exit()

    m.addConstr(gp.quicksum(y[t,k] for k in feasible_indices) == 1, name="SelectOneFeasibleOption_Period{0}".format(t))

    for k in range(num_options):
        if not period_option_feasible[t][k]:
            m.addConstr(y[t,k] == 0, name="ForbidInfeasibleOption_Period{0}_Option{1}".format(t,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[t,k] * period_option_delays[t][k]
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if period_option_feasible[t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Dynamic Diversion Strategy:")
    for t in range(NUM_TIME_PERIODS):
        for k in range(num_options):
            if y[t,k].X > 0.5:
                print("Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                    t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                ))
                break
```
Answer:
Optimal Dynamic Diversion Strategy:
Period 1 (0.0-0.5h): Option 0 (10%)
Period 2 (0.5-1.0h): Option 1 (30%)
Period 3 (1.0-1.5h): Option 0 (10%)
Period 4 (1.5-2.0h): Option 0 (10%)



================================================================================



--- Problem 403 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
A busy maritime port is facing a logistical challenge: rebalancing its container inventory across three berths (X, Y, and Z) to meet demand while minimizing costs. Berth X currently has a surplus of 58 containers, while Berth Y is short 30 containers and Berth Z lacks 17 containers. The port has three tugboats at its disposal, each with a capacity of 21 containers. Transporting containers from X to Y incurs a cost of \$156 per tugboat used, while sending tugboats from X to Z costs \$169 per tugboat. The goal is to determine how many tugboats to dispatch to each berth and how many containers to load onto them, ensuring that the total transportation cost is minimized while meeting the deficits at Y and Z. The challenge lies in balancing the trade-off between tugboat usage (and associated costs) and the need to fulfill demand efficiently, all within the constraints of available containers and tugboat capacity.

**Modeling Process:**
- **1. Decision Variables:**  
     - `n_Y`: Integer variable representing the number of tugboats sent to Berth Y (range: 0 to 3).  
     - `n_Z`: Integer variable representing the number of tugboats sent to Berth Z (range: 0 to 3).  
     - `x_XY`: Integer variable representing the number of containers transported from X to Y.  
     - `x_XZ`: Integer variable representing the number of containers transported from X to Z.  

   - **2. Parameters:**  
     - `surplus_X = 58`: Containers available at Berth X.  
     - `deficit_Y = 30`: Containers needed at Berth Y.  
     - `deficit_Z = 17`: Containers needed at Berth Z.  
     - `tug_capacity = 21`: Maximum containers a single tugboat can carry.  
     - `num_tugs = 3`: Total tugboats available.  
     - `cost_XY = 156`: Cost per tugboat to Y.  
     - `cost_XZ = 169`: Cost per tugboat to Z.  

   - **3. Objective Function:**  
     Minimize the total transportation cost:  
     \[
     \text{Minimize: } 156 \cdot n_Y + 169 \cdot n_Z
     \]  

   - **4. Constraints:**  
     - Tugboat usage: \( n_Y + n_Z \leq 3 \).  
     - Container capacity per tugboat:  
       - \( x_XY \leq 21 \cdot n_Y \).  
       - \( x_XZ \leq 21 \cdot n_Z \).  
     - Supply limit at X: \( x_XY + x_XZ \leq 58 \).  
     - Demand fulfillment:  
       - \( x_XY \geq 30 \) (Berth Y's deficit).  
       - \( x_XZ \geq 17 \) (Berth Z's deficit).  

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
surplus_X = 58
deficit_Y = 30
deficit_Z = 17
tug_capacity = 21
num_tugs = 3
cost_XY = 156
cost_XZ = 169
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("CONTAINER_REDISTRIBUTION_COST", env=env)

    # --- Decision Variables ---
    # n_Y: number of tugboats going to Y
    n_Y = m.addVar(vtype=GRB.INTEGER, lb=0, ub=num_tugs, name="n_Y")
    # n_Z: number of tugboats going to Z
    n_Z = m.addVar(vtype=GRB.INTEGER, lb=0, ub=num_tugs, name="n_Z")
    # x_XY: number of containers transported from X to Y
    x_XY = m.addVar(vtype=GRB.INTEGER, lb=0, name="x_XY")
    # x_XZ: number of containers transported from X to Z
    x_XZ = m.addVar(vtype=GRB.INTEGER, lb=0, name="x_XZ")

    # --- Objective Function: Minimize transportation cost ---
    m.setObjective(cost_XY * n_Y + cost_XZ * n_Z, GRB.MINIMIZE)

    # --- Constraints ---
    # Total number of tugboats used
    m.addConstr(n_Y + n_Z <= num_tugs, "TotalTugs")

    # Transported amount cannot exceed tugboat capacity
    # Handle tug_capacity = 0 case
    if tug_capacity > 0:
        m.addConstr(x_XY <= tug_capacity * n_Y, "CapacityY")
        m.addConstr(x_XZ <= tug_capacity * n_Z, "CapacityZ")
    else:
        # If capacity is 0, cannot transport containers
        m.addConstr(x_XY == 0, "CapacityY_Zero")
        m.addConstr(x_XZ == 0, "CapacityZ_Zero")

    # Transported amount cannot exceed surplus at X
    m.addConstr(x_XY + x_XZ <= surplus_X, "SupplyX")

    # Transported amount must meet deficit (Original didn't require this, but realistic)
    # Making this optional based on original snippet focusing only on cost.
    # However, without a demand constraint, solution might be trivial (move 0 containers).
    # Let's assume the goal IS to meet demand if possible, while minimizing tugboat cost.
    # Add constraints to meet demand:
    m.addConstr(x_XY >= deficit_Y, "MeetDemandY")
    m.addConstr(x_XZ >= deficit_Z, "MeetDemandZ")
    # Note: The original snippet had these as upper bounds (<= deficit).
    # If the goal is just to minimize cost *given* fixed moves, the model changes.
    # Reverting to original snippet's logic (less realistic but matches code):
    # m.addConstr(x_XY <= deficit_Y, "DemandY_Limit") # Limit containers moved
    # m.addConstr(x_XZ <= deficit_Z, "DemandZ_Limit") # Limit containers moved
    # **Correction:** The goal is likely to meet demand *while* minimizing cost.
    # The model should try to fulfill demand. Keeping the >= constraints.

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_Y_sol'] = n_Y.X # Not needed for output
        # results_dict['n_Z_sol'] = n_Z.X
        # results_dict['x_XY_sol'] = x_XY.X
        # results_dict['x_XZ_sol'] = x_XZ.X

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
         print("Model is infeasible") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the missing outputs
if m.Status == GRB.OPTIMAL:
    print(f"Number of tugboats to Berth Y: {n_Y.X}")
    print(f"Number of tugboats to Berth Z: {n_Z.X}")
    print(f"Containers transported from X to Y: {x_XY.X}")
    print(f"Containers transported from X to Z: {x_XZ.X}")
```
Answer:
Optimal objective value: 481.00
Number of tugboats to Berth Y: 2.0
Number of tugboats to Berth Z: 1.0
Containers transported from X to Y: 30.0
Containers transported from X to Z: 17.0


```

================================================================================



--- Problem 404 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
**
A port operator faces the challenge of dynamically pricing berthing fees during different traffic periods to maximize revenue while respecting berth capacity limits. The port experiences two distinct periods: "off-peak" with a base demand of 966 ships per hour and "peak" with a significantly higher base demand of 2893 ships per hour. The operator can adjust berthing fees up to a maximum of $6 per ship, with demand sensitivity (alpha) set at 38 ships per hour for every dollar increase in berthing fee. The port's capacity is fixed at 1638 ships per hour, meaning the number of ships that can be handled cannot exceed this limit regardless of demand.

The core question is: What berthing fees should be set during off-peak and peak periods to maximize total revenue, ensuring that the resulting traffic flow does not exceed capacity and that demand responds linearly to price changes? The operator must balance higher fees (which reduce demand but increase revenue per ship) against lower fees (which attract more ships but may not fully utilize capacity).
**

**Modeling Process:**
**
1. Decision Variables:
- `fee[p]`: Berthing fee (in $) for period `p` (where `p` is either "off" or "peak"). Bounded between 0 and `max_fee` ($6).
- `demand[p]`: Resulting demand (ships/hr) for period `p`, calculated as `base_demand[p] - alpha * fee[p]`.
- `flow[p]`: Actual traffic flow (ships/hr) for period `p`, constrained by both demand and capacity.

2. Parameters:
- `capacity = 1638`: Maximum flow capacity (ships/hr).
- `base_demand = {'off': 966, 'peak': 2893}`: Base demand (ships/hr) when berthing fees are $0.
- `alpha = 38`: Demand sensitivity (ships/hr per $1 fee increase).
- `max_fee = 6`: Upper bound on berthing fee ($).

3. Objective Function:
Maximize total revenue:
`Maximize: sum(flow[p] * fee[p] for p in periods)`

4. Constraints:
- Demand calculation for each period `p`:
  `demand[p] == base_demand[p] - alpha * fee[p]`
- Flow cannot exceed capacity:
  `flow[p] <= capacity`
- Flow cannot exceed demand:
  `flow[p] <= demand[p]`
- Non-negativity:
  `fee[p], demand[p], flow[p] >= 0`
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 1638; base_demand = {'off': 966, 'peak': 2893}; alpha = 38; max_fee = 6; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berthing_Fees_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berthing Fees (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of TOLL_PRICING
```
Answer:
--- Problem 18: Dynamic Berthing Fees (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $14256.00
  Period: Off
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 738.0 ships/hr (Base: 966)
    Actual Flow (min(Demand, Capacity)): 738.0 ships/hr (Capacity: 1638)
    Revenue this period: $4428.00
  Period: Peak
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 2665.0 ships/hr (Base: 2893)
    Actual Flow (min(Demand, Capacity)): 1638.0 ships/hr (Capacity: 1638)
    Revenue this period: $9828.00
Total ships processed: 2376.0



================================================================================


--- Problem 405 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
A busy container terminal is facing the challenge of maximizing its daily revenue while balancing the competing demands of short-term and long-term container storage. The terminal has a total of 174 storage spots, operating for 16 hours each day. Short-term containers pay $20 for a stay of 2 hours, while long-term containers pay a flat rate of $140 for a 10-hour stay. The terminal faces a maximum demand of 54 short-term containers and 33 long-term containers. However, to ensure availability for short-term customers, at least 66 spots must be reserved for them, limiting the number of long-term containers to a maximum of 108. The terminal manager must determine the optimal mix of short-term and long-term containers to maximize revenue without exceeding the total spot-hour capacity of 2,784 (174 spots * 16 hours). The central question is: *How many short-term and long-term containers should the terminal accept to achieve the highest possible daily revenue while adhering to demand and capacity constraints?*

**Modeling Process:**
- **1. Decision Variables:**  
     - `x_short_term`: Number of short-term containers to accept (continuous, ≥ 0).  
     - `x_long_term`: Number of long-term containers to accept (continuous, ≥ 0).  

   - **2. Parameters:**  
     - `revenue_per_short_term = 20` ($ per short-term container).  
     - `revenue_per_long_term = 140` ($ per long-term container).  
     - `short_term_stay = 2` (hours per short-term container).  
     - `long_term_stay = 10` (hours per long-term container).  
     - `total_spot_hours = 2784` (total available spot-hours).  
     - `max_short_term_demand = 54` (maximum short-term containers).  
     - `max_long_term_demand = 33` (maximum long-term containers).  
     - `max_spots_for_long_term = 108` (maximum long-term containers allowed due to short-term reservation).  

   - **3. Objective Function:**  
     Maximize total daily revenue:  
     `Maximize: 20 * x_short_term + 140 * x_long_term`.  

   - **4. Constraints:**  
     - Spot-hour capacity: `2 * x_short_term + 10 * x_long_term ≤ 2784`.  
     - Short-term demand: `x_short_term ≤ 54`.  
     - Long-term demand: `x_long_term ≤ 33`.  
     - Long-term spot limit: `x_long_term ≤ 108`.  

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
total_spots = 174; op_hours = 16; short_term_rate = 10; short_term_stay = 2
long_term_rate = 140; long_term_stay = 10; max_short_term_demand = 54
max_long_term_demand = 33; min_spots_for_short_term = 66
# Derived Params (passed from generator)
revenue_per_short_term = 20; revenue_per_long_term = 140
total_spot_hours = 2784; max_spots_for_long_term = 108
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m19 = gp.Model("Container_Storage_Price_Differentiation_LP", env=env)
    # Vars
    x_short_term = m19.addVar(name="num_short_term_containers", lb=0)
    x_long_term = m19.addVar(name="num_long_term_containers", lb=0)
    # Objective
    m19.setObjective(revenue_per_short_term * x_short_term + revenue_per_long_term * x_long_term, sense=GRB.MAXIMIZE)
    # Constraints
    m19.addConstr(x_short_term * short_term_stay + x_long_term * long_term_stay <= total_spot_hours, "spot_hour_capacity")
    m19.addConstr(x_short_term <= max_short_term_demand, "short_term_demand")
    m19.addConstr(x_long_term <= max_long_term_demand, "long_term_demand")
    # Ensure long-term containers don't use spots needed for min short-term requirement.
    # This constraint might need re-evaluation: it limits the *number* of long-term containers based on total spots,
    # not directly guaranteeing spot availability *at any given time* for short-term.
    # A simulation or more complex model might be needed for strict guarantee.
    # Keeping user's formulation:
    m19.addConstr(x_long_term <= max_spots_for_long_term, "long_term_spot_limit_for_short_term")
    # Optimize
    m19.optimize()
    # Store results
    results_dict['status'] = m19.status
    if m19.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m19.objVal; results_dict['xst_opt'] = x_short_term.X; results_dict['xlt_opt'] = x_long_term.X
    # Output Results
    print("--- Problem 19: Container Storage Price Differentiation (LP) ---")
    if m19.status == GRB.OPTIMAL:
        xst = results_dict.get('xst_opt', 0); xlt = results_dict.get('xlt_opt', 0)
        spot_hours_used = xst * short_term_stay + xlt * long_term_stay
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Daily Revenue: ${m19.objVal:.2f}")
        print(f"Optimal number of Short-Term Containers to accept: {xst:.2f} (Demand: {max_short_term_demand})")
        print(f"Optimal number of Long-Term Containers to accept: {xlt:.2f} (Demand: {max_long_term_demand}, Max allowed by short-term min: {max_spots_for_long_term})")
        print(f"Total Spot-Hours Used: {spot_hours_used:.1f} / {total_spot_hours}")
    else: print(f"Optimization Status: {m19.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of CONTAINER_STORAGE_PRICE
```
Answer:
--- Problem 19: Container Storage Price Differentiation (LP) ---
Optimization Status: Optimal
Maximum Total Daily Revenue: $5700.00
Optimal number of Short-Term Containers to accept: 54.00 (Demand: 54)
Optimal number of Long-Term Containers to accept: 33.00 (Demand: 33, Max allowed by short-term min: 108)
Total Spot-Hours Used: 438.0 / 2784



================================================================================



--- Problem 406 ---
**Difficulty:** hard
**Category:** LP

**Problem Description:**
**
A regional logistics company operates a centralized hub to streamline the distribution of goods from five suppliers (Src_A to Src_E) to six destinations (Dst_X to Dst_]). Each supplier has a fixed capacity, ranging from 152 units at Src_E to 416 units at Src_C, while destinations have specific demands, such as 369 units for Dst_X and 244 units for Dst_]. The hub acts as an intermediary, where goods are consolidated before being dispatched. Transportation costs vary by route: for instance, moving goods from Src_B to the hub costs $5 per unit, while shipping from the hub to Dst_Z costs only $2 per unit. The company aims to minimize total transportation costs while ensuring all demand is met without exceeding supply limits. Additionally, the company wants to ensure that no single supplier provides more than 50% of the total supply to any destination. The challenge is to determine the optimal flow of goods through the hub, balancing cost efficiency with logistical constraints.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `flow[(i, j)]`: Continuous variable representing the quantity of goods transported from location `i` to location `j`, where `i` is either a source or the hub, and `j` is either the hub or a destination.  
   - **2. Parameters:**  
     - `supply[s]`: Maximum output from source `s` (e.g., Src_A: 325 units).  
     - `demand[d]`: Required input at destination `d` (e.g., Dst_Y: 146 units).  
     - `costs[(i, j)]`: Cost per unit for route `(i, j)` (e.g., (Src_D, Hub): $12).  
   - **3. Objective Function:**  
     - Minimize total cost:  
       \[
       \text{Minimize: } \sum_{(i, j)} \text{flow}[(i, j)] \times \text{costs}[(i, j)]
       \]  
   - **4. Constraints:**  
     - **Supply limits:** For each source `s`, total outflow to the hub cannot exceed its supply:  
       \[
       \text{flow}[(s, \text{Hub})] \leq \text{supply}[s]
       \]  
     - **Demand requirements:** For each destination `d`, inflow from the hub must meet demand:  
       \[
       \text{flow}[(\text{Hub}, d)] \geq \text{demand}[d]
       \]  
     - **Hub balance:** Total inflow to the hub equals total outflow:  
       \[
       \sum_{s} \text{flow}[(s, \text{Hub})] = \sum_{d} \text{flow}[(\text{Hub}, d)]
       \]  
     - **Supplier diversity constraint:** No single supplier can provide more than 50% of the total supply to any destination:  
       \[
       \text{flow}[(\text{Hub}, d)] \leq 0.5 \times \text{demand}[d] \quad \forall s \in \text{sources}
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
sources = ['Src_A', 'Src_B', 'Src_C', 'Src_D', 'Src_E']
destinations = ['Dst_X', 'Dst_Y', 'Dst_Z', 'Dst_[', 'Dst_\\', 'Dst_]']
hub = 'Hub' # Use !r for repr() to keep quotes for the string
supply = {'Src_A': 325, 'Src_B': 353, 'Src_C': 416, 'Src_D': 210, 'Src_E': 152}
demand = {'Dst_X': 369, 'Dst_Y': 146, 'Dst_Z': 335, 'Dst_[': 86, 'Dst_\\': 89, 'Dst_]': 244}
costs = {('Src_A', 'Hub'): 15, ('Src_B', 'Hub'): 5, ('Src_C', 'Hub'): 10, ('Src_D', 'Hub'): 12, ('Src_E', 'Hub'): 7, ('Hub', 'Dst_X'): 14, ('Hub', 'Dst_Y'): 12, ('Hub', 'Dst_Z'): 2, ('Hub', 'Dst_['): 14, ('Hub', 'Dst_\\'): 15, ('Hub', 'Dst_]'): 15}
# --- End Parameters ---

GUROBI_TIME_LIMIT = 60

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi console output within exec
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m25 = gp.Model("Logistics_Hub_Flow_LP", env=env)

    # --- Decision Variables ---
    # Flow variables for each arc
    flow_keys = list(costs.keys()) # Explicitly get keys for var creation
    flow = m25.addVars(flow_keys, name="flow", lb=0) # LP variables default to continuous

    # --- Objective Function ---
    # Minimize total transportation cost
    m25.setObjective(gp.quicksum(flow[i, j] * costs[i, j] for i, j in flow_keys), sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Supply constraints at sources
    for s in sources:
        # Ensure the key exists before adding constraint
        arc_key = (s, hub)
        if arc_key in flow:
            # Use string concatenation for name to avoid f-string formatting issues here
            m25.addConstr(flow[arc_key] <= supply[s], name="supply_" + s)
        # No else needed, if arc doesn't exist, can't use it

    # Demand constraints at destinations
    for d in destinations:
         # Ensure the key exists before adding constraint
         arc_key = (hub, d)
         if arc_key in flow:
            # Use string concatenation for name
            m25.addConstr(flow[arc_key] >= demand[d], name="demand_" + d)
         # No else needed

    # Flow balance at the Hub (Inflow = Outflow)
    # Check if keys exist before summing
    inflow_keys_hub = [k for k in flow_keys if k[1] == hub and k[0] in sources]
    outflow_keys_hub = [k for k in flow_keys if k[0] == hub and k[1] in destinations]

    # Check if lists are non-empty before creating expressions that might be empty
    inflow_hub_expr = gp.quicksum(flow[k] for k in inflow_keys_hub) if inflow_keys_hub else 0
    outflow_hub_expr = gp.quicksum(flow[k] for k in outflow_keys_hub) if outflow_keys_hub else 0
    m25.addConstr(inflow_hub_expr == outflow_hub_expr, name="hub_balance")

    # Supplier diversity constraint
    for d in destinations:
        for s in sources:
            m25.addConstr(flow[hub, d] <= 0.5 * demand[d], name=f"supplier_diversity_{s}_{d}")

    # --- Optimization ---
    m25.optimize()

    # --- Store results ---
    results_dict['status'] = m25.status
    if m25.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m25.objVal
        # Store flow values, converting keys back to tuples if needed
        results_dict['flow_sol'] = {k: v for k, v in m25.getAttr('X', flow).items()}
        # Store expression values IF they are LinExpr (might be 0 if no flows)
        results_dict['inflow_val'] = inflow_hub_expr.getValue() if isinstance(inflow_hub_expr, gp.LinExpr) else inflow_hub_expr
        results_dict['outflow_val'] = outflow_hub_expr.getValue() if isinstance(outflow_hub_expr, gp.LinExpr) else outflow_hub_expr


    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print("--- Problem 25: Logistics Hub Truck Flow (LP) ---")
    if m25.status == GRB.OPTIMAL:
        flow_sol = results_dict.get('flow_sol', {}) # Get solution from dict
        print(f"Optimization Status: Optimal")
        # Use .get with a default for obj_val before formatting
        obj_val_print = results_dict.get('obj_val', 0) # Default to 0 if not found
        print(f"Minimum Total Transportation Cost: ${obj_val_print:.2f}")
        print("Optimal Flows:")
        total_supply_used_calc = 0
        total_demand_met_calc = 0
        # Use .items() for iterating through solution dictionary
        for (i, j), flow_val in flow_sol.items():
            if flow_val > 1e-6: # Print only non-negligible flows
                # Escape i, j, flow_val and braces for costs.get()
                print(f"  Flow from {i} to {j}: {flow_val:.1f} units (Cost/Unit: ${costs.get((i,j), 'N/A')})")
                if i in sources: total_supply_used_calc += flow_val
                if j in destinations: total_demand_met_calc += flow_val

        print("\nSummary:")
        # Use .get with defaults for calculated values before formatting
        inflow_print = results_dict.get('inflow_val', 0)
        outflow_print = results_dict.get('outflow_val', 0)
        # Ensure inflow/outflow values are numbers before formatting
        print(f"Total Flow In Hub: {float(inflow_print):.1f}")
        print(f"Total Flow Out Hub: {float(outflow_print):.1f}")
        # Re-calculate supply/demand usage from solution dict for detailed output
        for s in sources:
             flow_out = flow_sol.get((s, hub), 0)
             # Escape s, flow_out and braces for supply.get()
             print(f"  Supply from {s}: {flow_out:.1f} / {supply.get(s, 'N/A')}")
        for d in destinations:
             flow_in = flow_sol.get((hub, d), 0)
             # Escape d, flow_in and braces for demand.get()
             print(f"  Demand met for {d}: {flow_in:.1f} / {demand.get(d, 'N/A')}")

    elif m25.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible. Check if total supply >= total demand.")
         # Calculate totals directly from input params for this message
         # Escape braces for sum() values
         print(f"Total Supply Available: {sum(supply.values())}")
         print(f"Total Demand Required: {sum(demand.values())}")
    elif m25.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)") # Escape limit
         # If objective value exists (feasible solution found before limit), print it
         if m25.ObjVal is not None and abs(m25.ObjVal) < float('inf'):
              # Escape objval
              print(f"Best Objective Found: ${m25.ObjVal:.2f}")
         else:
              print("No feasible solution found within time limit.")
    else:
        # Handle other statuses like UNBOUNDED, INF_OR_UNBD etc.
        print(f"Optimization Status Code: {m25.status}") # Escape status

except GurobiError as e:
    # Escape errno and e message
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
except Exception as e:
    print(f"Python Error: {e}") # Escape error message
    print("--- Traceback ---")
    traceback.print_exc(file=sys.stdout)
    print("--- End Traceback ---")
    results_dict['status'] = -2 # Indicate Python execution error



# The code provided is complete and prints all necessary outputs.
# No additional print statements are needed.
```
Answer:
--- Problem 25: Logistics Hub Truck Flow (LP) ---
Optimization Status: Infeasible. Check if total supply >= total demand.
Total Supply Available: 1456
Total Demand Required: 1269


```

================================================================================



--- Problem 407 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A port authority is facing the challenge of managing the berthing of 391 ships while minimizing operational costs. The port has two options: using its own berths or outsourcing to a neighboring port. Each berth in the port can handle up to 6 ships per day at a fixed cost of $203 per berth. Outsourcing, while flexible, comes at a higher variable cost of $49 per ship. The port’s capacity is limited to a maximum of 27 berths, and the goal is to find the right balance between utilizing in-house berths and outsourcing to keep costs as low as possible. The central question is: *How many berths should the port use daily, and how many ships should be outsourced, to meet the total demand at the lowest possible cost?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n`: Integer number of berths to use (0 ≤ `n` ≤ 27).  
     - `outsourced`: Integer number of ships outsourced (≥ 0).  

   - **2. Parameters:**  
     - `total_ships_demand = 391`: Total ships requiring berthing.  
     - `ships_per_berth_day = 6`: Ships a single berth can handle daily.  
     - `cost_per_berth_day = 203`: Cost per berth per day.  
     - `cost_per_outsourced_ship = 49`: Cost per outsourced ship.  
     - `max_berths = 27`: Upper limit on available berths.  

   - **3. Objective Function:**  
     Minimize total cost:  
     \[
     \text{Minimize: } 203 \cdot n + 49 \cdot \text{outsourced}
     \]  

   - **4. Constraints:**  
     - Demand fulfillment:  
       \[
       6 \cdot n + \text{outsourced} \geq 391
       \]  
     - Berth limit:  
       \[
       n \leq 27
       \]  
     - Non-negativity:  
       \[
       n \geq 0, \quad \text{outsourced} \geq 0
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_ships_demand = 391
ships_per_berth_day = 6
cost_per_berth_day = 203
cost_per_outsourced_ship = 49
max_berths = 27
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m37 = gp.Model("BERTH_SIZE_OPTIMIZATION_IP", env=env)

    # --- Decision Variables ---
    # Integer: Number of berths to use
    n = m37.addVar(vtype=GRB.INTEGER, name="num_berths", lb=0, ub=max_berths)
    # Integer: Number of ships outsourced
    outsourced = m37.addVar(vtype=GRB.INTEGER, name="num_outsourced", lb=0)

    # --- Objective Function ---
    # Minimize total cost (berth cost + outsourcing cost)
    m37.setObjective(n * cost_per_berth_day + outsourced * cost_per_outsourced_ship, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Ensure total demand is met by own berths + outsourcing
    # Avoid division by zero for ships_per_berth_day
    if ships_per_berth_day > 0:
        m37.addConstr(n * ships_per_berth_day + outsourced >= total_ships_demand, name="demand_met")
    else:
        # If capacity is zero, all demand must be outsourced
        m37.addConstr(outsourced >= total_ships_demand, name="demand_met_zero_cap")
        m37.addConstr(n == 0, name="force_zero_berths") # Cannot use berths with zero capacity

    # --- Optimization ---
    m37.optimize()

    # --- Store results ---
    results_dict['status'] = m37.status
    if m37.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m37.ObjVal
        results_dict['n_sol'] = n.X
        results_dict['outsourced_sol'] = outsourced.X

    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- Problem 37: Berth Size Optimization (IP) ---") # Original problem number
    if m37.status == GRB.OPTIMAL:
        opt_n = int(round(results_dict.get('n_sol', 0)))
        opt_outsourced = int(round(results_dict.get('outsourced_sol', 0)))
        capacity_own = opt_n * ships_per_berth_day
        cost_own = opt_n * cost_per_berth_day
        cost_outsource = opt_outsourced * cost_per_outsourced_ship
        obj_val_print = results_dict.get('obj_val', 'N/A')

        print(f"Optimization Status: Optimal")
        print(f"Optimal Number of Berths: {opt_n} (Max: {max_berths})")
        print(f"  Own Berth Capacity: {capacity_own} ships")
        print(f"Number of Outsourced Ships: {opt_outsourced}")
        print(f"Total Ships Covered: {capacity_own + opt_outsourced} (Demand: {total_ships_demand})")
        print(f"\nCosts:")
        print(f"  Own Berth Cost: ${cost_own:.2f}")
        print(f"  Outsourcing Cost: ${cost_outsource:.2f}")
        print(f"Minimum Total Daily Cost: ${float(obj_val_print):.2f}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m37.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 37: Berth Size Optimization (IP) ---
Optimization Status: Optimal
Optimal Number of Berths: 27 (Max: 27)
  Own Berth Capacity: 162 ships
Number of Outsourced Ships: 229
Total Ships Covered: 391 (Demand: 391)

Costs:
  Own Berth Cost: $5481.00
  Outsourcing Cost: $11221.00
Minimum Total Daily Cost: $16702.00


```

================================================================================



--- Problem 408 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
**
A port operator faces the challenge of dynamically pricing berthing fees during different traffic periods to maximize revenue while respecting berth capacity limits. The operator must set berthing fees for two distinct periods: "off-peak" with a base demand of 1,819 ships per hour and "peak" with a significantly higher base demand of 4,544 ships per hour. The port has a fixed capacity of 1,657 ships per hour, meaning congestion occurs if demand exceeds this limit.  

The pricing strategy must account for demand elasticity—each $1 increase in berthing fee reduces demand by 50 ships per hour. The operator cannot charge more than $6 per ship in either period. The goal is to determine the optimal berthing fees for both periods such that the total revenue from actual ship flow (constrained by both demand and capacity) is maximized.  

The core question is: *What berthing fees should be set for off-peak and peak periods to generate the highest possible revenue without exceeding port capacity?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `fee[p]`: Berthing fee (in $) for period `p` (where `p` is either "off" or "peak"). Bounded between $0 and $6.  
   - `demand[p]`: Resulting demand (ships/hr) for period `p` after accounting for price elasticity. Must be non-negative.  
   - `flow[p]`: Actual ship flow (ships/hr) for period `p`, limited by both demand and capacity.  

   **2. Parameters:**  
   - `base_demand[p]`: Base demand (ships/hr) for period `p` (1819 for off-peak, 4544 for peak).  
   - `alpha = 50`: Demand sensitivity to price (ships/hr per $1 increase).  
   - `capacity = 1657`: Maximum flow capacity (ships/hr).  
   - `max_fee = 6`: Upper bound on berthing fee ($).  

   **3. Objective Function:**  
   Maximize total revenue:  
   ```  
   Maximize: sum(flow[p] * fee[p] for p in periods)  
   ```  

   **4. Constraints:**  
   - **Demand Calculation:** For each period `p`, demand is linearly dependent on fee:  
     ```  
     demand[p] = base_demand[p] - alpha * fee[p]  
     ```  
   - **Flow Capacity:** Actual flow cannot exceed port capacity:  
     ```  
     flow[p] <= capacity  
     ```  
   - **Flow Demand:** Actual flow cannot exceed demand:  
     ```  
     flow[p] <= demand[p]  
     ```  
   - **Non-Negativity:** All variables are non-negative.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 1657; base_demand = {'off': 1819, 'peak': 4544}; alpha = 50; max_fee = 6; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berthing_Fee_Pricing_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berthing Fee Pricing (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of TOLL_PRICING
```
Answer:
--- Problem 18: Dynamic Berthing Fee Pricing (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $19056.00
  Period: Off
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 1519.0 ships/hr (Base: 1819)
    Actual Flow (min(Demand, Capacity)): 1519.0 ships/hr (Capacity: 1657)
    Revenue this period: $9114.00
  Period: Peak
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 4244.0 ships/hr (Base: 4544)
    Actual Flow (min(Demand, Capacity)): 1657.0 ships/hr (Capacity: 1657)
    Revenue this period: $9942.00
Total ships processed: 3176.0



================================================================================


--- Problem 409 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
In a busy port, the operations manager needs to assign the fastest available crane to unload a container ship. Two cranes, C1 and C2, are on standby, each with distinct travel times to reach the ship: C1 takes 8.005 minutes, while C2 requires 11.119 minutes. The urgency of the situation demands that the manager minimize the response time to ensure efficient unloading. However, only one crane can be assigned to avoid resource redundancy. The challenge is clear: Which crane should be assigned to achieve the shortest possible response time while adhering to the constraint of deploying just a single unit?
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y[c]`: A binary variable for each crane `c` (where `c` can be C1 or C2).  
       - `y[c] = 1` if crane `c` is dispatched.  
       - `y[c] = 0` otherwise.  

   - **2. Parameters:**  
     - `travel_times[c]`: The travel time (in minutes) for crane `c` to reach the ship.  
       - `travel_times['C1'] = 8.005163586982274`  
       - `travel_times['C2'] = 11.118851083707758`  

   - **3. Objective Function:**  
     - Minimize the total response time:  
       \[
       \text{Minimize: } \sum_{c} y[c] \cdot \text{travel\_times}[c]
       \]  

   - **4. Constraints:**  
     - **Assign Exactly One Crane:**  
       \[
       \sum_{c} y[c] = 1
       \]  
     - **Binary Constraints:**  
       \[
       y[c] \in \{0, 1\} \quad \forall c
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
travel_times = {'C1': 8.005163586982274, 'C2': 11.118851083707758}
crane_ids = list(travel_times.keys())

# --- Model Creation ---
model = gp.Model("Crane_Assignment_IP")

# --- Decision Variables ---
# Binary: y[c]=1 if crane c is dispatched
y = model.addVars(crane_ids, vtype=GRB.BINARY, name="dispatch_choice")

# --- Objective Function ---
# Minimize the response time of the dispatched unit
model.setObjective(gp.quicksum(y[c] * travel_times[c] for c in crane_ids), sense=GRB.MINIMIZE)

# --- Constraints ---
# Assign exactly one crane
model.addConstr(gp.quicksum(y[c] for c in crane_ids) == 1, name="assign_one")

# --- Optimization ---
model.optimize()

# --- Output Results ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    dispatched_crane = [c for c in crane_ids if y[c].X > 0.5][0]
    min_response_time = model.ObjVal
    print(f"Optimal Crane to Dispatch: {dispatched_crane}")
    print(f"Minimum Response Time: {min_response_time:.1f} minutes")
    print("\nAll Travel Times:")
    for c in crane_ids:
        print(f"  {c}: {travel_times[c]} minutes")
else:
    print(f"Optimization Status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 2 columns and 2 nonzeros
Model fingerprint: 0xb5ed56cc
Variable types: 0 continuous, 2 integer (2 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [8e+00, 1e+01]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 8.0051636
Presolve removed 1 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 1: 8.00516 

Optimal solution found (tolerance 1.00e-04)
Best objective 8.005163586982e+00, best bound 8.005163586982e+00, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Crane to Dispatch: C1
Minimum Response Time: 8.0 minutes

All Travel Times:
  C1: 8.005163586982274 minutes
  C2: 11.118851083707758 minutes



================================================================================



--- Problem 410 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
A port management system faces a critical decision during an incident that reduces the number of available berths. Under normal conditions, the port operates with 5 berths, each handling up to 2,111 containers per hour (cont/h), totaling 10,555 cont/h. However, an incident reduces the available berths to just 1, slashing capacity to 2,111 cont/h for a duration of 2 hours. During this disruption, containers arriving at a total rate of 5,191 cont/h must be rerouted to minimize total delay. An alternative route exists, but it has limited capacity (1,693 cont/h) and adds 21 minutes (0.35 hours) of travel time per container. The challenge is to determine the optimal split of container traffic between the congested main berth and the alternative route, balancing queueing delays at the main berth against the fixed delays of the detour, to minimize the total delay experienced by all containers.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `flow_alt`: Continuous variable representing the flow of containers (cont/h) diverted to the alternative route.  
     - `flow_main`: Derived variable representing the flow remaining at the main berth (`flow_main = arrival_rate_total - flow_alt`).  
   - **2. Parameters:**  
     - `arrival_rate_total = 5,191 cont/h`: Total incoming container flow.  
     - `capacity_main_normal = 10,555 cont/h`: Main berth capacity under normal conditions.  
     - `capacity_main_reduced = 2,111 cont/h`: Main berth capacity during the incident.  
     - `alt_route_capacity = 1,693 cont/h`: Maximum flow the alternative route can handle.  
     - `incident_duration = 2 h`: Duration of the berth reduction.  
     - `alt_route_extra_time = 0.35 h`: Additional travel time per container on the alternative route.  
   - **3. Objective Function:**  
     Minimize the total delay, calculated as:  
     `delay_main_approx + delay_alt`, where:  
     - `delay_main_approx`: Piecewise-linear approximation of main berth delay (based on queue growth and dissipation).  
     - `delay_alt = flow_alt * incident_duration * alt_route_extra_time`: Fixed delay for diverted containers.  
   - **4. Constraints:**  
     - Flow conservation: `flow_main + flow_alt == arrival_rate_total`.  
     - Alternative route capacity: `flow_alt <= alt_route_capacity`.  
     - Piecewise-linear approximation of `delay_main_approx` as a function of `flow_main`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB, GurobiError
import math
import numpy as np # Needed for linspace
import sys
import traceback

# --- Parameters (Embedded) ---
capacity_per_berth = 2111  # cont/h/berth
num_berths_normal = 5      # Number of berths under normal conditions
num_berths_reduced = 1     # Number of berths during incident
arrival_rate_total = 5191 # cont/h
incident_duration = 2.00   # h (Duration of the capacity reduction)
alt_route_capacity = 1693 # cont/h
# Extra time originally in minutes, convert to hours here
alt_route_extra_min = 21
alt_route_extra_time = alt_route_extra_min / 60.0 # h
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit
NUM_PWL_POINTS = 20 # PWL points

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# --- Calculated Parameters ---
capacity_main_reduced = num_berths_reduced * capacity_per_berth # cont/h
capacity_main_normal = num_berths_normal * capacity_per_berth   # cont/h

# --- Helper Function for Main Delay Calculation ---
def calculate_main_delay(flow_main_val, cap_reduced, cap_normal, inc_duration):
    # Calculates main berth delay based on flow.
    flow_main_val = max(0.0, flow_main_val)
    cap_reduced = max(0.0, cap_reduced)
    cap_normal = max(0.0, cap_normal)
    inc_duration = max(0.0, inc_duration)
    if flow_main_val <= cap_reduced + 1e-6: return 0.0
    if cap_normal <= cap_reduced + 1e-6: return 1e10
    queue_growth_rate = flow_main_val - cap_reduced
    max_queue = queue_growth_rate * inc_duration
    dissipation_rate = cap_normal - flow_main_val
    if dissipation_rate <= 1e-6: return 1e10
    else:
        dissipation_time = max_queue / dissipation_rate
        total_queue_time = inc_duration + dissipation_time
        delay = 0.5 * max_queue * total_queue_time
        return delay

# --- Generate Points for Piecewise Linear Approximation ---
flow_points = []
delay_points = []
pwl_error_flag = False
try:
    min_flow_main = 0.0
    max_flow_main = float(arrival_rate_total)
    if max_flow_main < min_flow_main: max_flow_main = min_flow_main + 1.0 # Handle edge case

    flow_points = np.linspace(min_flow_main, max_flow_main, NUM_PWL_POINTS).tolist() # Use constant from globals
    crit_reduced = float(capacity_main_reduced)
    crit_normal_minus_1 = float(capacity_main_normal - 1.0)

    if crit_reduced > min_flow_main + 1e-6 and not np.isclose(flow_points, crit_reduced).any():
         flow_points.append(crit_reduced)
    if capacity_main_normal > capacity_main_reduced + 1e-6 and crit_normal_minus_1 < max_flow_main - 1e-6 and crit_normal_minus_1 > min_flow_main and not np.isclose(flow_points, crit_normal_minus_1).any():
         flow_points.append(crit_normal_minus_1)

    flow_points = sorted(list(set(p for p in flow_points if p >= 0)))
    if not flow_points: flow_points = [0.0] # Ensure not empty

    delay_points = [calculate_main_delay(f, capacity_main_reduced, capacity_main_normal, incident_duration) for f in flow_points]
    delay_points = [max(0.0, d) for d in delay_points]

    if len(flow_points) < 2 or len(flow_points) != len(delay_points):
        print(f"Error: Invalid points generated for PWL. flow={len(flow_points)}, delay={len(delay_points)}")
        results_dict['status'] = -4
        results_dict['error_message'] = "Invalid PWL points generated"
        pwl_error_flag = True

except Exception as pwl_e:
    print(f"An unexpected error occurred during PWL point generation:")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -5
    results_dict['error_message'] = f"PWL Generation Error: {pwl_e}"
    pwl_error_flag = True

# --- Gurobi Model ---
try:
    if pwl_error_flag:
        print("Skipping model build due to PWL error.")
    else:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi output
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        m = gp.Model("BerthRerouting_PWL", env=env)

        # --- Decision Variables ---
        flow_alt = m.addVar(name="flow_alternative", lb=0.0, ub=arrival_rate_total)
        # --- Intermediate Variables ---
        flow_main = m.addVar(name="flow_main", lb=0.0)
        delay_alt = m.addVar(name="delay_alt", lb=0.0)
        delay_main_approx = m.addVar(name="delay_main_approx", lb=0.0)

        # --- Constraints ---
        m.addConstr(flow_main + flow_alt == arrival_rate_total, name="FlowConservation")
        m.addConstr(flow_alt <= alt_route_capacity, name="AltRouteCapacity")
        m.addConstr(delay_alt == flow_alt * incident_duration * alt_route_extra_time, name="CalcAltDelay")
        # Add PWL constraint only if points are valid
        if len(flow_points) > 1 and len(flow_points) == len(delay_points):
             max_delay = max(delay_points) if delay_points else 0
             if max_delay > 1e9: print("Warning: Very large delay calculated for PWL points.")
             m.addGenConstrPWL(flow_main, delay_main_approx, flow_points, delay_points, name="PWL_MainDelay")
        else:
            # Should not be reached if pwl_error_flag logic is correct
            print("Error: Cannot add PWL constraint (points invalid).")
            if results_dict.get('status') is None: results_dict['status'] = -4
            raise ValueError("Invalid PWL points for constraint")

        # --- Objective Function ---
        m.setObjective(delay_main_approx + delay_alt, GRB.MINIMIZE)

        # --- Optimize ---
        m.optimize()

        # --- Store results ---
        results_dict['status'] = m.status
        if m.status == GRB.OPTIMAL:
            results_dict['obj_val'] = m.objVal
            results_dict['flow_alt_optimal'] = flow_alt.X # Store the result

except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"

# --- Output results (for capture) ---
current_status_for_output = results_dict.get('status')
if current_status_for_output == GRB.OPTIMAL:
    optimal_flow_alt = results_dict.get('flow_alt_optimal', 'N/A')
    if isinstance(optimal_flow_alt, (int, float)):
         print(f"{optimal_flow_alt:.2f}") # Output only the value
    else:
         print(f"Error: Optimal flow_alt not found in results.")
elif current_status_for_output == GRB.INFEASIBLE:
    print("Infeasible")
elif current_status_for_output == GRB.UNBOUNDED:
    print("Unbounded")
elif current_status_for_output == GRB.TIME_LIMIT:
     print(f"TimeLimit_{GUROBI_TIME_LIMIT}s")
elif current_status_for_output == -4 or current_status_for_output == -5: # PWL error
     print(f"PWLError: {results_dict.get('error_message', 'Unknown PWL error')}")
else:
    print(f"NonOptimalStatus_{current_status_for_output}")



# (Supplemental code block to ensure all required outputs are printed)
if current_status_for_output == GRB.OPTIMAL:
    optimal_flow_alt = results_dict.get('flow_alt_optimal', 'N/A')
    if isinstance(optimal_flow_alt, (int, float)):
        print(f"Optimal flow to alternative route: {optimal_flow_alt:.2f} cont/h")
        print(f"Flow to main berth: {arrival_rate_total - optimal_flow_alt:.2f} cont/h")
        print(f"Total delay: {results_dict['obj_val']:.2f} hours")
    else:
        print(f"Error: Optimal flow_alt not found in results.")
```
Answer:
1693.00
Optimal flow to alternative route: 1693.00 cont/h
Flow to main berth: 3498.00 cont/h
Total delay: 4508.99 hours


```

================================================================================



--- Problem 411 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
A busy logistics hub is tasked with efficiently scheduling the unloading of incoming trucks to minimize the total time required to service all vehicles. Four trucks, labeled 1 through 4, arrive at staggered times: Truck 1 at time 3, Truck 2 at time 7, Truck 3 at time 10, and Truck 4 at time 13. Each truck requires a specific processing duration once it reaches the depot: Truck 1 needs 4 units of time, Truck 2 takes 8, Truck 3 requires 6, and Truck 4 is the quickest at just 3 units. The hub has three depots available, each capable of handling one truck at a time. The critical question is: *How can the hub assign trucks to depots and schedule their start times to ensure all trucks are processed as quickly as possible, minimizing the total completion time (makespan)?*  

   The challenge lies in balancing arrival times, processing durations, and depot availability. Trucks cannot start processing before their arrival, and no two trucks can occupy the same depot simultaneously. The logistics manager must devise a schedule that avoids overlaps while ensuring the last truck finishes as early as possible, optimizing overall throughput.

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable indicating whether truck `i` is assigned to depot `j`.  
   - `start_time(i)`: Continuous variable representing the time truck `i` begins processing.  
   - `completion_time(i)`: Continuous variable representing the time truck `i` finishes processing.  
   - `precedes(i, k, j)`: Binary variable indicating whether truck `i` is processed before truck `k` on depot `j`.  
   - `makespan`: Continuous variable representing the total completion time (objective).  

   **2. Parameters:**  
   - `trucks = [1, 2, 3, 4]`: List of trucks.  
   - `depots = [1, 2, 3]`: List of depots.  
   - `arrival_times = {1: 3, 2: 7, 3: 10, 4: 13}`: Time each truck arrives.  
   - `processing_times = {1: 4, 2: 8, 3: 6, 4: 3}`: Time each truck requires for processing.  
   - `H = 100`: A large constant (Big-M) for linearization.  

   **3. Objective Function:**  
   Minimize `makespan` (the latest completion time among all trucks).  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot:  
     `sum(assign(i, j) for j in depots) = 1` for all `i` in `trucks`.  
   - **Arrival Time:** Trucks cannot start before their arrival:  
     `start_time(i) >= arrival_times[i]` for all `i` in `trucks`.  
   - **Completion Time:** Processing time is added to start time:  
     `completion_time(i) = start_time(i) + processing_times[i]` for all `i` in `trucks`.  
   - **Non-Overlapping:** If two trucks `i` and `k` share a depot `j`, one must precede the other:  
     - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
     - If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.  
     - `assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))` to link assignment and precedence.  
   - **Makespan Definition:** The latest completion time defines the makespan:  
     `makespan >= completion_time(i)` for all `i` in `trucks`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4]
depots = [1, 2, 3]
arrival_times = {1: 3, 2: 7, 3: 10, 4: 13}
processing_times = {1: 4, 2: 8, 3: 6, 4: 3}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_MIN_MAKESPAN")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
    print(f"Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
24.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 1
Start Time: 3.0000, Completion Time: 7.0000
Truck 2 is assigned to Depot 1
Start Time: 7.0000, Completion Time: 15.0000
Truck 3 is assigned to Depot 1
Start Time: 15.0000, Completion Time: 21.0000
Truck 4 is assigned to Depot 1
Start Time: 21.0000, Completion Time: 24.0000
Makespan: 24.0000


```

================================================================================



--- Problem 412 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port authority is tasked with efficiently scheduling a set of 12 ships to berths for unloading. Each ship has specific width and length dimensions, ranging from small (1x2 units) to large (12x36 units). The berths themselves are constrained to a fixed size of 13x41 units, imposing strict limits on how ships can be arranged. The primary challenge is to minimize the number of berths used while ensuring that no ships overlap and all fit entirely within their assigned berths.  

   The ships vary significantly in size, with some being long and narrow (e.g., 3x25), while others are short and wide (e.g., 9x24). This heterogeneity complicates the scheduling process, as ships must be positioned strategically to avoid wasted space. The port authority aims to optimize berth usage to reduce operational costs and improve efficiency. The core question is: *What is the minimal number of berths required to schedule all ships without violating size or overlap constraints, and how should the ships be arranged within these berths?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether ship `i` is assigned to berth `j`.  
   - `y[j]`: Binary variable indicating whether berth `j` is used.  
   - `px[i, j]`: Continuous variable representing the x-coordinate (horizontal position) of ship `i` in berth `j`.  
   - `py[i, j]`: Continuous variable representing the y-coordinate (vertical position) of ship `i` in berth `j`.  
   - `left[i, k, j]`, `right[i, k, j]`, `below[i, k, j]`, `above[i, k, j]`: Binary variables enforcing non-overlapping constraints between ships `i` and `k` in berth `j`.  

   **2. Parameters:**  
   - `ships`: List of tuples specifying the width and length of each ship (e.g., `(12, 36)` for ship 0).  
   - `berth_size`: Dimensions of each berth (13 units wide, 41 units tall).  
   - `num_ships`: Total number of ships (12).  
   - `num_berths`: Maximum possible berths (12, one per ship).  

   **3. Objective Function:**  
   Minimize the total number of berths used:  
   ```  
   Minimize: sum(y[j] for j in range(num_berths))  
   ```  

   **4. Constraints:**  
   - **Ship Assignment:** Each ship must be assigned to exactly one berth:  
     ```  
     For each ship i: sum(x[i, j] for j in range(num_berths)) == 1  
     ```  
   - **Berth Boundaries:** Ships must fit entirely within their assigned berth:  
     ```  
     For each ship i and berth j:  
       px[i, j] + ship_width[i] <= berth_width + M_w * (1 - x[i, j])  
       py[i, j] + ship_length[i] <= berth_height + M_h * (1 - x[i, j])  
     ```  
   - **Non-Overlapping:** Ships in the same berth must not overlap:  
     ```  
     For each pair of ships (i, k) and berth j:  
       left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1  
     ```  
   - **Berth Activation:** A berth is used if any ship is assigned to it:  
     ```  
     For each ship i and berth j: x[i, j] <= y[j]  
     ```  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum # Include quicksum just in case

# --- Data Definition ---
ships = [(12, 36), (4, 13), (1, 2), (3, 25), (8, 16), (9, 24), (6, 7), (5, 2), (11, 20), (13, 30), (1, 23), (2, 17)]  # (width, length) of ships
berth_size = (13, 41)  # (width, height) of each berth
num_ships = 12 # len(ships)
# Maximum berths needed (worst case: one ship per berth)
# Can sometimes be reduced with lower bounds, but num_ships is safe
num_berths = num_ships
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using berth dimensions is common and valid)
M_w = berth_size[0]
M_h = berth_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Berth Scheduling", env=env)

# --- Decision Variables ---
# x[i,j]: ship i assigned to berth j
x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of ship i if in berth j
px = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of ships *within the same berth*
left  = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="left")
right = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="right")
below = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="below")
above = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_berths))

# --- Constraints ---

# 1. Each ship must be assigned to exactly one berth
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Ship placement constraints within berth boundaries (Big-M formulation)
for j in range(num_berths):
    for i in range(num_ships):
        ship_w, ship_l = ships[i] # Get dimensions for ship i

        # Position variables must be 0 if ship i is not in berth j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Ship's right edge <= berth width IF ship is placed in berth (x[i,j]=1)
        model.addConstr(px[i, j] + ship_w <= berth_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Ship's top edge <= berth height IF ship is placed in berth (x[i,j]=1)
        model.addConstr(py[i, j] + ship_l <= berth_size[1] + M_h * (1 - x[i, j]), name=f"Height_Limit_{i}_{j}")

# 3. Non-overlapping constraints for ships within the same berth
for j in range(num_berths):
    for i in range(num_ships):
        for k in range(i + 1, num_ships): # Iterate over distinct pairs (i < k)
            ship_i_w, ship_i_l = ships[i]
            ship_k_w, ship_k_l = ships[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => ship i is to the left of ship k
            model.addConstr(px[i, j] + ship_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => ship i is to the right of ship k (k is left of i)
            model.addConstr(px[k, j] + ship_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => ship i is below ship k
            model.addConstr(py[i, j] + ship_i_l <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => ship i is above ship k (k is below i)
            model.addConstr(py[k, j] + ship_k_l <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH ship i and ship k are in berth j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link ship assignment to berth usage: If any ship i is in berth j, then berth j must be used (y[j]=1)
#    This can be done per ship or aggregated. Per ship is often tighter.
for j in range(num_berths):
    for i in range(num_ships):
        model.addConstr(x[i, j] <= y[j], name=f"Ship_Berth_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_ships * y[j], name=f"Berth_Activation_{j}")


# --- Solve ---
print("Solving 2DBP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of berths used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    berth_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_berths):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Berth {j_sol + 1} (Used):")
            ships_in_berth_info = []
            for i_sol in range(num_ships):
                if x[i_sol, j_sol].X > 0.5:
                    ship_data = {
                        "id": i_sol,
                        "dims": ships[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    ships_in_berth_info.append(ship_data)
                    print(f"  Ship {ship_data['id']} {ship_data['dims']} at {ship_data['pos']}")
            berth_details.append({'berth_index': j_sol, 'ships': ships_in_berth_info})
            print("-" * 10)
    results_dict['berth_details'] = berth_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 2DBP instance...
Gurobi Error code 10010: Model too large for size-limited license; visit https://gurobi.com/unrestricted for more information

Optimization finished with status: -1. No optimal solution found.


```

================================================================================



--- Problem 413 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
**
A port operator faces the challenge of dynamically pricing berthing fees during different traffic periods to maximize revenue while respecting the port's capacity limits. The operator must set berthing fees for two distinct periods: "off-peak" with a base demand of 1,819 ships per hour and "peak" with a significantly higher base demand of 4,544 ships per hour. The port has a fixed capacity of 1,657 ships per hour, meaning congestion occurs if demand exceeds this limit.  

The pricing strategy must account for demand elasticity—each $1 increase in berthing fee reduces demand by 50 ships per hour. The operator cannot charge more than $6 per ship in either period. The goal is to determine the optimal berthing fees for both periods such that the total revenue from actual ship flow (constrained by both demand and capacity) is maximized.  

The core question is: *What berthing fees should be set for off-peak and peak periods to generate the highest possible revenue without exceeding port capacity?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `fee[p]`: Berthing fee (in $) for period `p` (where `p` is either "off" or "peak"). Bounded between $0 and $6.  
   - `demand[p]`: Resulting demand (ships/hr) for period `p` after accounting for price elasticity. Must be non-negative.  
   - `flow[p]`: Actual ship flow (ships/hr) for period `p`, limited by both demand and capacity.  

   **2. Parameters:**  
   - `base_demand[p]`: Base demand (ships/hr) for period `p` (1819 for off-peak, 4544 for peak).  
   - `alpha = 50`: Demand sensitivity to price (ships/hr per $1 increase).  
   - `capacity = 1657`: Maximum flow capacity (ships/hr).  
   - `max_fee = 6`: Upper bound on berthing fee ($).  

   **3. Objective Function:**  
   Maximize total revenue:  
   ```  
   Maximize: sum(flow[p] * fee[p] for p in periods)  
   ```  

   **4. Constraints:**  
   - **Demand Calculation:** For each period `p`, demand is linearly dependent on fee:  
     ```  
     demand[p] = base_demand[p] - alpha * fee[p]  
     ```  
   - **Flow Capacity:** Actual flow cannot exceed port capacity:  
     ```  
     flow[p] <= capacity  
     ```  
   - **Flow Demand:** Actual flow cannot exceed demand:  
     ```  
     flow[p] <= demand[p]  
     ```  
   - **Non-Negativity:** All variables are non-negative.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 1657; base_demand = {'off': 1819, 'peak': 4544}; alpha = 50; max_fee = 6; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berthing_Fee_Pricing_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berthing Fee Pricing (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of TOLL_PRICING
```
Answer:
--- Problem 18: Dynamic Berthing Fee Pricing (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $19056.00
  Period: Off
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 1519.0 ships/hr (Base: 1819)
    Actual Flow (min(Demand, Capacity)): 1519.0 ships/hr (Capacity: 1657)
    Revenue this period: $9114.00
  Period: Peak
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 4244.0 ships/hr (Base: 4544)
    Actual Flow (min(Demand, Capacity)): 1657.0 ships/hr (Capacity: 1657)
    Revenue this period: $9942.00
Total ships processed: 3176.0



================================================================================


--- Problem 414 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the harbor master needs to coordinate the berthing times for two ships to minimize the total waiting time. The port operates with a fixed cycle time of 56 minutes, divided into two distinct berthing slots. Each slot must allocate a berthing time between 23 and 56 minutes, ensuring smooth operations while adhering to the strict cycle constraint. The waiting time experienced by ships is directly influenced by the non-berthing time—the portion of the cycle when the berth is not available—weighted by ship arrival rates of 1285 and 564 for the respective slots. The core question is: *How should the berthing times be distributed between the two slots to minimize the total waiting time caused by non-berthing times, given the cycle and bounds on berthing durations?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `t_i`: Continuous variable representing the berthing time (in minutes) allocated to slot `i` (where `i = 1, 2`). Each `t_i` must lie between 23 and 56 minutes.  
   - **2. Parameters:**  
     - `arrival_rates = [1285, 564]`: Ship arrival rates for slots 1 and 2, scaling the waiting time impact of non-berthing times.  
     - `cycle_time = 56`: Total cycle duration (minutes).  
     - `lb_time = 23`, `ub_time = 56`: Lower and upper bounds for berthing times.  
   - **3. Objective Function:**  
     Minimize the total waiting time:  
     `Minimize: 1285 * (56 - t1) + 564 * (56 - t2)`.  
   - **4. Constraints:**  
     - The sum of berthing times must equal the cycle time:  
       `t1 + t2 = 56`.  
     - Bounds on berthing times:  
       `23 ≤ t1 ≤ 56`, `23 ≤ t2 ≤ 56`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_slots = 2
lb_time = 23          # Lower bound for berthing time
ub_time = 56          # Upper bound for berthing time
cycle_time = 56   # Total cycle time (set equal to ub_time)
arrival_rates = [1285, 564] # Ship arrival rates per slot
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_rates) != num_slots:
    print("Error: arrival_rates length mismatch with num_slots")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_rates length"
    # raise ValueError("arrival_rates length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_slots}-Slot Berthing Time", env=env)

        # --- Decision variables (dynamic based on num_slots) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_slots, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for slot i is proportional to arrival_rate * non_berthing_time = arrival_rate * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_rates[i] * (cycle_time - t_vars[i]) for i in range(num_slots)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_slots)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_slots)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_slots):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 48167.00
------------------------------
Optimal berthing times (minutes):
  t1: 33.00, t2: 23.00


```

================================================================================



--- Problem 415 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
A logistics company operates two warehouses, A and B, each with a limited inventory of goods. Warehouse A currently has 85 units available, while Warehouse B has 69. However, demand is uneven: Warehouse A expects 72 units to be shipped out, while Warehouse B anticipates 81. To balance supply and demand, the company can relocate units between the two warehouses, but this comes at a cost—$39 per unit moved from A to B and $11 per unit moved from B to A. The challenge is to determine the most cost-effective way to redistribute units so that both warehouses meet their demand without exceeding available inventory. The goal is to minimize the total relocation cost while ensuring no warehouse ends up short of units when customers arrive.

**Modeling Process:**
- **1. Decision Variables:**  
     - `move_AB`: Integer, number of units moved from A to B (≥0).  
     - `move_BA`: Integer, number of units moved from B to A (≥0).  
   - **2. Parameters:**  
     - `available_A = 85`, `available_B = 69`: Initial unit inventories.  
     - `demand_A = 72`, `demand_B = 81`: Required units after relocation.  
     - `cost_AB = 39`, `cost_BA = 11`: Per-unit relocation costs.  
   - **3. Objective Function:**  
     Minimize total cost: `39 * move_AB + 11 * move_BA`.  
   - **4. Constraints:**  
     - Demand at A: `85 - move_AB + move_BA ≥ 72`.  
     - Demand at B: `69 + move_AB - move_BA ≥ 81`.  
     - Supply limits: `move_AB ≤ 85`, `move_BA ≤ 69`.  

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
available_A = 85
available_B = 69
demand_A = 72
demand_B = 81
cost_AB = 39
cost_BA = 11
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("WAREHOUSE_RELOCATION", env=env)

    # --- Decision Variables ---
    # move_AB: number of units moved from A to B
    move_AB = m.addVar(vtype=GRB.INTEGER, lb=0, name="move_AB")
    # move_BA: number of units moved from B to A
    move_BA = m.addVar(vtype=GRB.INTEGER, lb=0, name="move_BA")

    # --- Objective Function: Minimize total relocation cost ---
    m.setObjective(cost_AB * move_AB + cost_BA * move_BA, GRB.MINIMIZE)

    # --- Constraints ---
    # Final number of units at A must meet demand
    m.addConstr(available_A - move_AB + move_BA >= demand_A, "DemandA")

    # Final number of units at B must meet demand
    m.addConstr(available_B + move_AB - move_BA >= demand_B, "DemandB")

    # Cannot move more units than available
    m.addConstr(move_AB <= available_A, "SupplyA")
    m.addConstr(move_BA <= available_B, "SupplyB")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['move_AB_sol'] = move_AB.X # Not needed for output
        # results_dict['move_BA_sol'] = move_BA.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible. Demand cannot be met.") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block to print the decision variables)
if m.Status == GRB.OPTIMAL:
    obj_val_print = results_dict.get('obj_val', 'N/A')
    if isinstance(obj_val_print, (int, float)):
        print(f"Optimal objective value: {obj_val_print:.2f}")
    else:
        print(f"Optimal objective value: {obj_val_print}")

    # Print the decision variables
    print(f"Units moved from A to B: {move_AB.X:.0f}")
    print(f"Units moved from B to A: {move_BA.X:.0f}")
```
Answer:
Optimal objective value: 468.00
Optimal objective value: 468.00
Units moved from A to B: 12
Units moved from B to A: -0


```

================================================================================



--- Problem 416 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently loading a set of six packages with varying weights into the fewest number of trucks possible, each with a fixed capacity of 13 units. The packages weigh 5, 1, 3, 9, 10, and 7 units respectively. The challenge lies in assigning these packages to trucks such that no truck exceeds its capacity, while minimizing the total number of trucks used. This problem mirrors real-world scenarios like delivery routing, where space is limited, and efficient loading can significantly reduce costs. The key question is: *What is the optimal arrangement of these packages into trucks to achieve the smallest possible number of trucks without violating capacity constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[i, j]`: Binary variable indicating whether package `i` is assigned to truck `j` (1 if assigned, 0 otherwise).  
     - `y[j]`: Binary variable indicating whether truck `j` is used (1 if used, 0 otherwise).  
   - **2. Parameters:**  
     - `packages = [5, 1, 3, 9, 10, 7]`: Weights of the packages.  
     - `capacity = 13`: Maximum weight each truck can hold.  
     - `num_packages = 6`: Total number of packages.  
     - `num_trucks = 6`: Maximum possible trucks (one per package in the worst case).  
   - **3. Objective Function:**  
     - Minimize the total number of trucks used: `Minimize: sum(y[j] for all j)`.  
   - **4. Constraints:**  
     - **Assignment Constraint:** Each package must be assigned to exactly one truck:  
       `For each package i: sum(x[i, j] for all j) = 1`.  
     - **Capacity Constraint:** The total weight in any truck `j` must not exceed its capacity if the truck is used:  
       `For each truck j: sum(packages[i] * x[i, j] for all i) <= capacity * y[j]`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB

# --- Data Definition ---
packages = [5, 1, 3, 9, 10, 7]      # Weights of packages
capacity = 13           # Truck capacity
num_packages = 6     # len(packages) - Corrected from original template
num_trucks = num_packages    # Maximum number of trucks (worst case: one package per truck)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Time limit
# env.setParam('TimeLimit', 30)
env.start()

# Create Model
model = Model("Truck Loading Problem", env=env)

# --- Decision Variables ---
# x[i,j]: package i is assigned to truck j
x = model.addVars(num_packages, num_trucks, vtype=GRB.BINARY, name="x")
# y[j]: truck j is used
y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")

# --- Objective: Minimize the number of trucks used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)

# --- Constraints ---
# 1. Each package must be assigned to exactly one truck
for i in range(num_packages):
    model.addConstr(x.sum(i, '*') == 1, name=f"Package_{i}_Assignment")

# 2. Truck capacity constraint: sum of weights in truck j <= capacity IF truck j is used (y[j]=1)
for j in range(num_trucks):
    model.addConstr(gp.quicksum(packages[i] * x[i, j] for i in range(num_packages)) <= capacity * y[j], name=f"Truck_{j}_Capacity")

# --- Solve ---
print("Solving Truck Loading instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_trucks = int(results_dict.get('obj_val', -1))
    print(f"\nOptimal number of trucks used: {optimal_trucks}")
    print("-" * 30)
    truck_details = []
    for j_sol in range(num_trucks): # Loop through potential trucks
        # Check if the truck variable y[j_sol] exists and is set to 1
        # Using .X requires Gurobi v9+ and that the variable is in the solution
        try:
            if y[j_sol].X > 0.5: # Check if truck j_sol is used
                # Find packages assigned to this truck j_sol
                # ***** CORRECTED LINE BELOW *****
                assigned_packages_indices = [i for i in range(num_packages) if x[i, j_sol].X > 0.5]
                # ***** END OF CORRECTION *****

                assigned_packages_weights = [packages[i] for i in assigned_packages_indices]
                truck_load = sum(assigned_packages_weights)
                print(f"Truck {j_sol + 1} (Load: {truck_load}/{capacity}): Packages (indices): {assigned_packages_indices}")
                # Optional: Print weights too
                # print(f"  Weights: {assigned_packages_weights}")
                truck_details.append({'truck_index': j_sol, 'package_indices': assigned_packages_indices, 'load': truck_load})
        except AttributeError:
            # This might happen if y[j_sol] was optimized to 0 and doesn't have an .X value
            # Or if the model was infeasible/not solved optimally.
            # Since we check for OPTIMAL status first, this is less likely for y,
            # but could happen if x[i, j_sol] is 0. The check x[i,j_sol].X > 0.5 handles this.
            pass # Just skip if variable/attribute doesn't exist for unused trucks/packages
    results_dict['truck_details'] = truck_details # Store details
    print("-" * 30)

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount to see if a feasible solution was found
     if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
     else: print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving Truck Loading instance...

Optimal number of trucks used: 3
------------------------------
Truck 2 (Load: 13/13): Packages (indices): [0, 1, 5]
Truck 5 (Load: 10/13): Packages (indices): [4]
Truck 6 (Load: 12/13): Packages (indices): [2, 3]
------------------------------


```

================================================================================



--- Problem 417 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
In a busy port, the operations manager needs to select the fastest available tugboat to assist a ship that has just arrived. Two tugboats, labeled T1 and T2, are on standby, each with distinct travel times to the ship's location. Tugboat T1 can arrive in 8.09 minutes, while T2 takes 12.81 minutes—a significant difference when every second counts. The operations manager must choose exactly one tugboat to send, balancing urgency and resource allocation. The challenge is clear: *Which tugboat should be dispatched to minimize the response time and ensure the fastest possible assistance?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `y[t]`: Binary variable where `y[t] = 1` if tugboat `t` (T1 or T2) is dispatched, and `0` otherwise.  
   - **2. Parameters:**  
     - `travel_times[t]`: Precisely measured travel times (T1: 8.094 minutes, T2: 12.806 minutes).  
   - **3. Objective Function:**  
     - Minimize the total response time:  
       `Minimize: y[T1] * 8.094 + y[T2] * 12.806`.  
   - **4. Constraints:**  
     - Exactly one tugboat must be dispatched:  
       `y[T1] + y[T2] = 1`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
travel_times = {'T1': 8.093600129368665, 'T2': 12.806043347152178}
tugboat_ids = list(travel_times.keys())

# --- Model Creation ---
model = gp.Model("Port_Tugboat_Dispatch_IP")

# --- Decision Variables ---
# Binary: y[t]=1 if tugboat t is dispatched
y = model.addVars(tugboat_ids, vtype=GRB.BINARY, name="dispatch_choice")

# --- Objective Function ---
# Minimize the response time of the dispatched unit
model.setObjective(gp.quicksum(y[t] * travel_times[t] for t in tugboat_ids), sense=GRB.MINIMIZE)

# --- Constraints ---
# Dispatch exactly one tugboat
model.addConstr(gp.quicksum(y[t] for t in tugboat_ids) == 1, name="dispatch_one")

# --- Optimization ---
model.optimize()

# --- Output Results ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    dispatched_tugboat = [t for t in tugboat_ids if y[t].X > 0.5][0]
    min_response_time = model.ObjVal
    print(f"Optimal Tugboat to Dispatch: {dispatched_tugboat}")
    print(f"Minimum Response Time: {min_response_time:.1f} minutes")
    print("\nAll Travel Times:")
    for t in tugboat_ids:
        print(f"  {t}: {travel_times[t]} minutes")
else:
    print(f"Optimization Status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 2 columns and 2 nonzeros
Model fingerprint: 0xf56e8b99
Variable types: 0 continuous, 2 integer (2 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [8e+00, 1e+01]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 8.0936001
Presolve removed 1 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 1: 8.0936 

Optimal solution found (tolerance 1.00e-04)
Best objective 8.093600129369e+00, best bound 8.093600129369e+00, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Tugboat to Dispatch: T1
Minimum Response Time: 8.1 minutes

All Travel Times:
  T1: 8.093600129368665 minutes
  T2: 12.806043347152178 minutes



================================================================================



--- Problem 418 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
**
A port operator faces the challenge of dynamically pricing berthing fees during different traffic periods to maximize revenue while respecting the port's capacity limits. The port experiences two distinct periods: "off-peak" with a base demand of 966 ships per hour and "peak" with a significantly higher base demand of 2893 ships per hour. The operator can adjust berthing fees up to a maximum of $6 per ship, with demand sensitivity (alpha) set at 38 ships per hour for every dollar increase in berthing fee. The port's capacity is fixed at 1638 ships per hour, meaning the number of ships that can be berthed cannot exceed this limit regardless of demand.  

The core question is: What berthing fees should be set during off-peak and peak periods to maximize total revenue, ensuring that the resulting number of ships does not exceed capacity and that demand responds linearly to fee changes? The operator must balance higher fees (which reduce demand but increase revenue per ship) against lower fees (which attract more ships but may not fully utilize capacity).

---
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `fee[p]`: Berthing fee (in $) for period `p` (where `p` is either "off" or "peak"). Bounded between 0 and `max_fee` ($6).  
- `demand[p]`: Resulting demand (ships/hr) for period `p`, calculated as `base_demand[p] - alpha * fee[p]`.  
- `flow[p]`: Actual number of ships berthed (ships/hr) for period `p`, constrained by both demand and capacity.  

**2. Parameters:**  
- `capacity = 1638`: Maximum flow capacity (ships/hr).  
- `base_demand = {'off': 966, 'peak': 2893}`: Base demand (ships/hr) when fees are $0.  
- `alpha = 38`: Demand sensitivity (ships/hr per $1 fee increase).  
- `max_fee = 6`: Upper bound on berthing fee ($).  

**3. Objective Function:**  
Maximize total revenue:  
`Maximize: sum(flow[p] * fee[p] for p in periods)`  

**4. Constraints:**  
- Demand calculation for each period `p`:  
  `demand[p] == base_demand[p] - alpha * fee[p]`  
- Flow cannot exceed capacity:  
  `flow[p] <= capacity`  
- Flow cannot exceed demand:  
  `flow[p] <= demand[p]`  
- Non-negativity:  
  `fee[p], demand[p], flow[p] >= 0`  

---

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 1638; base_demand = {'off': 966, 'peak': 2893}; alpha = 38; max_fee = 6; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berthing_Fee_Pricing_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berthing Fee Pricing (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of TOLL_PRICING
```
Answer:
--- Problem 18: Dynamic Berthing Fee Pricing (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $14256.00
  Period: Off
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 738.0 ships/hr (Base: 966)
    Actual Flow (min(Demand, Capacity)): 738.0 ships/hr (Capacity: 1638)
    Revenue this period: $4428.00
  Period: Peak
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 2665.0 ships/hr (Base: 2893)
    Actual Flow (min(Demand, Capacity)): 1638.0 ships/hr (Capacity: 1638)
    Revenue this period: $9828.00
Total ships processed: 2376.0



================================================================================
--- Problem 419 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
At a busy maritime port, the management faces the challenge of efficiently processing incoming ships—small and large—with limited berthing resources. The port has a total of 5 berths available to accommodate two types of ships: one dedicated to small ships and another to large ships. Each small ship berth requires 1 berth and can process up to 27 small ships per hour, while each large ship berth demands 3 berths and can handle up to 19 large ships per hour. On this particular shift, 109 small ships and 82 large ships are expected to arrive. The goal is to maximize the total number of ships processed by strategically allocating berths to small and large ship berths, ensuring that the number of ships processed does not exceed either the capacity of the opened berths or the actual arrivals. The critical question is: How many small and large ship berths should be opened to process as many ships as possible without exceeding berth availability or arrival volumes?
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `y_small`: Integer, number of small ship berths to open.  
   - `y_large`: Integer, number of large ship berths to open.  
   - `z_small`: Continuous, number of small ships processed.  
   - `z_large`: Continuous, number of large ships processed.  

   **2. Parameters:**  
   - `total_berths = 5`: Total berths available.  
   - `berths_per_small_ship = 1`: Berths needed per small ship berth.  
   - `berths_per_large_ship = 3`: Berths needed per large ship berth.  
   - `capacity_small_ship_berth = 27`: Maximum small ships processed per small ship berth per hour.  
   - `capacity_large_ship_berth = 19`: Maximum large ships processed per large ship berth per hour.  
   - `arriving_small_ships = 109`: Total small ships arriving.  
   - `arriving_large_ships = 82`: Total large ships arriving.  

   **3. Objective Function:**  
   Maximize: `z_small + z_large` (Total ships processed).  

   **4. Constraints:**  
   - Berth limit: `1 * y_small + 3 * y_large <= 5` (Total berths used cannot exceed 5).  
   - Small ship capacity: `z_small <= 27 * y_small` (Small ships processed cannot exceed small ship berth capacity).  
   - Large ship capacity: `z_large <= 19 * y_large` (Large ships processed cannot exceed large ship berth capacity).  
   - Small ship arrivals: `z_small <= 109` (Small ships processed cannot exceed arriving small ships).  
   - Large ship arrivals: `z_large <= 82` (Large ships processed cannot exceed arriving large ships).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_berths = 5
berths_per_small_ship = 1
berths_per_large_ship = 3
capacity_small_ship_berth = 27 # ships per hour
capacity_large_ship_berth = 19 # ships per hour
arriving_small_ships = 109
arriving_large_ships = 82
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_BERTHING_ALLOC", env=env)

    # --- Decision Variables ---
    # y_small: number of small ship berths to open
    y_small = m.addVar(vtype=GRB.INTEGER, lb=0, name="y_small")
    # y_large: number of large ship berths to open
    y_large = m.addVar(vtype=GRB.INTEGER, lb=0, name="y_large")
    # z_small: number of small ships processed
    z_small = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="z_small")
    # z_large: number of large ships processed
    z_large = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="z_large")

    # --- Objective Function: Maximize total ships processed ---
    m.setObjective(z_small + z_large, GRB.MAXIMIZE)

    # --- Constraints ---
    # Berth availability constraint
    # Ensure berth counts are positive before adding constraint
    if berths_per_small_ship > 0 and berths_per_large_ship > 0:
        m.addConstr(berths_per_small_ship * y_small + berths_per_large_ship * y_large <= total_berths, "BerthLimit")
    elif berths_per_small_ship > 0:
         m.addConstr(berths_per_small_ship * y_small <= total_berths, "BerthLimit")
    elif berths_per_large_ship > 0:
         m.addConstr(berths_per_large_ship * y_large <= total_berths, "BerthLimit")

    # Processed ships cannot exceed capacity
    m.addConstr(z_small <= capacity_small_ship_berth * y_small, "SmallShipCapacity")
    m.addConstr(z_large <= capacity_large_ship_berth * y_large, "LargeShipCapacity")

    # Processed ships cannot exceed arrivals
    m.addConstr(z_small <= arriving_small_ships, "SmallShipArrivals")
    m.addConstr(z_large <= arriving_large_ships, "LargeShipArrivals")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['y_small_sol'] = y_small.X # Not needed for output
        # results_dict['y_large_sol'] = y_large.X # Not needed for output
        # results_dict['z_small_sol'] = z_small.X # Not needed for output
        # results_dict['z_large_sol'] = z_large.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Objective is total ships, potentially float if z variables are float
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the number of small and large ship berths to open, and the number of small and large ships processed
if m.Status == GRB.OPTIMAL:
    print(f"Number of small ship berths to open: {y_small.X}")
    print(f"Number of large ship berths to open: {y_large.X}")
    print(f"Number of small ships processed: {z_small.X}")
    print(f"Number of large ships processed: {z_large.X}")
```
Answer:
Optimal objective value: 109.00
Number of small ship berths to open: 5.0
Number of large ship berths to open: -0.0
Number of small ships processed: 109.0
Number of large ships processed: 0.0


```

================================================================================



--- Problem 420 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the operations team needs to coordinate the berthing times for two different types of ships to minimize the total waiting time. The port operates with a fixed cycle time of 72 minutes, divided into two distinct berthing phases. Each phase must allocate a berthing time between 10 and 72 minutes, ensuring smooth ship traffic while adhering to the rigid cycle constraint.

The first phase serves smaller cargo ships, contributing a delay coefficient of 645 per minute of non-berthing time (the portion of the cycle where the berth is not available). The second phase handles larger container ships, with a delay coefficient of 1697. The goal is to distribute the berthing times strategically between these phases to minimize the total waiting time experienced by all ships.

The core question is: *How should the 72-minute cycle be split between the two phases to achieve the smallest possible total waiting time, given their respective ship volumes and timing constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `t_i`: Continuous variable representing the berthing time (in minutes) allocated to phase `i` (where `i ∈ {1, 2}`). Each `t_i` must lie between 10 and 72 minutes.  

   **2. Parameters:**  
   - `delay_coeffs = [645, 1697]`: Delay coefficients for each phase (higher values indicate greater sensitivity to non-berthing time).  
   - `cycle_time = 72`: Total fixed duration (in minutes) of the berthing cycle.  
   - `lb_time = 10`, `ub_time = 72`: Lower and upper bounds for berthing times.  

   **3. Objective Function:**  
   Minimize the total waiting time, calculated as:  
   ```  
   Minimize: (645 × (72 − t₁)) + (1697 × (72 − t₂))  
   ```  

   **4. Constraints:**  
   - **Cycle Constraint:** The sum of berthing times must equal the cycle time:  
     ```  
     t₁ + t₂ = 72  
     ```  
   - **Bounds:** Each berthing time must satisfy:  
     ```  
     10 ≤ t₁ ≤ 72  
     10 ≤ t₂ ≤ 72  
     ```  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_phases = 2
lb_time = 10          # Lower bound for berthing time
ub_time = 72          # Upper bound for berthing time
cycle_time = 72       # Total cycle time (set equal to ub_time)
delay_coeffs = [645, 1697] # Delay coefficients per phase
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(delay_coeffs) != num_phases:
    print("Error: delay_coeffs length mismatch with num_phases")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: delay_coeffs length"
    # raise ValueError("delay_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_phases}-Phase Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_phases) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_phases, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for phase i is proportional to delay * non-berthing_time = delay * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(delay_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_phases)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_phases)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_phases)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_phases):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 56960.00
------------------------------
Optimal berthing times (minutes):
  t1: 10.00, t2: 62.00


```

================================================================================



--- Problem 421 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling six incoming trucks at three available depots. Each truck arrives at a specific time: Truck 1 at 5 hours, Truck 2 at 9 hours, Truck 3 at 10 hours, Truck 4 at 15 hours, Truck 5 at 17 hours, and Truck 6 at 22 hours. The hub must assign each truck to exactly one depot, ensuring that no two trucks are serviced at the same depot simultaneously. The processing time for each truck varies depending on the depot it is assigned to. For example, Truck 1 takes 6 hours at Depot 1, 5 hours at Depot 2, and 7 hours at Depot 3. The hub’s goal is to minimize the total processing time across all depots while respecting arrival times and avoiding overlaps in depot usage. The central question is: What is the optimal assignment of trucks to depots that achieves this goal?
**

**Modeling Process:**
**
**1. Decision Variables:**
- `assign[i, j]`: Binary variable indicating whether Truck `i` is assigned to Depot `j` (1 if assigned, 0 otherwise).
- `start_time[i]`: Continuous variable representing the start time of Truck `i`.
- `completion_time[i]`: Continuous variable representing the completion time of Truck `i`.
- `precedes[i, k, j]`: Binary variable indicating whether Truck `i` precedes Truck `k` at Depot `j` (1 if `i` precedes `k`, 0 otherwise).

**2. Parameters:**
- `trucks`: List of trucks [1, 2, 3, 4, 5, 6].
- `depots`: List of depots [1, 2, 3].
- `arrival_times[i]`: Arrival time of Truck `i` (e.g., Truck 1 arrives at 5 hours).
- `processing_times[i, j]`: Processing time of Truck `i` at Depot `j` (e.g., Truck 1 at Depot 1 takes 6 hours).
- `H`: A large constant (100) used for big-M constraints.

**3. Objective Function:**
Minimize the total processing time:
`Minimize: sum(processing_times[i, j] * assign[i, j] for all i in trucks, j in depots)`.

**4. Constraints:**
- **Assignment:** Each truck must be assigned to exactly one depot:
  `sum(assign[i, j] for j in depots) = 1 for all i in trucks`.
- **Arrival Time:** A truck cannot start processing before its arrival time:
  `start_time[i] >= arrival_times[i] for all i in trucks`.
- **Completion Time:** The completion time of a truck is its start time plus its processing time at the assigned depot:
  `completion_time[i] = start_time[i] + sum(processing_times[i, j] * assign[i, j] for j in depots) for all i in trucks`.
- **Non-overlapping:** For each depot, if two trucks are assigned to it, one must precede the other:
  - If `precedes[i, k, j] = 1`, then `start_time[k] >= completion_time[i]`.
  - If `precedes[i, k, j] = 0`, then `start_time[i] >= completion_time[k]`.
  - `assign[i, j] + assign[k, j] - 1 <= precedes[i, k, j] + (1 - precedes[i, k, j])` for all `i < k` in trucks and `j` in depots.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
depots = [1, 2, 3]
arrival_times = {1: 5, 2: 9, 3: 10, 4: 15, 5: 17, 6: 22}
processing_times = {(1, 1): 6, (1, 2): 5, (1, 3): 7, (2, 1): 9, (2, 2): 8, (2, 3): 8, (3, 1): 3, (3, 2): 3, (3, 3): 2, (4, 1): 4, (4, 2): 3, (4, 3): 7, (5, 1): 5, (5, 2): 3, (5, 3): 6, (6, 1): 2, (6, 2): 2, (6, 3): 3} # Dict {(truck, depot): time}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    # Minimize total actual processing time used
    m.setObjective(gp.quicksum(processing_times.get((i,j), 0) * assign[i,j] for i in trucks for j in depots), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (depot dependent)
    m.addConstrs((completion_time[i] == start_time[i] + gp.quicksum(processing_times.get((i,j), 0) * assign[i,j] for j in depots)
                  for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Total proc time
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the optimal assignment of trucks to depots and their start and completion times
if m.status == GRB.OPTIMAL:
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.2f}, Completion Time: {completion_time[i].x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
23.0000
Truck 1 is assigned to Depot 2
Start Time: 5.00, Completion Time: 10.00
Truck 2 is assigned to Depot 3
Start Time: 10.00, Completion Time: 18.00
Truck 3 is assigned to Depot 3
Start Time: 18.00, Completion Time: 20.00
Truck 4 is assigned to Depot 2
Start Time: 20.00, Completion Time: 23.00
Truck 5 is assigned to Depot 2
Start Time: 23.00, Completion Time: 26.00
Truck 6 is assigned to Depot 1
Start Time: 26.00, Completion Time: 28.00


```

================================================================================



--- Problem 422 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy logistics hub, a single loading dock must accommodate five trucks, each arriving at distinct times with varying processing requirements and deadlines. The logistics manager faces the challenge of scheduling these trucks to minimize total tardiness—the cumulative delay beyond each truck's due time. Truck 1 arrives at 3 hours, needing 6 hours to process, and must depart by hour 15. Truck 2 arrives at hour 4, requires 7 hours, and has a deadline of hour 16. Truck 3, arriving at hour 7, is quicker with a 3-hour processing time but a tight deadline of hour 12. Trucks 4 and 5 arrive at hours 11 and 12, needing 5 and 8 hours respectively, with more lenient deadlines of hours 24 and 26. The core question is: *How can the loading dock schedule these trucks to minimize the total tardiness across all vehicles?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign[i, j]`: Binary (1 if truck *i* is assigned to loading dock *j*; 0 otherwise).  
     - `start_time[i]`: Continuous (start time of truck *i*).  
     - `completion_time[i]`: Continuous (completion time of truck *i*).  
     - `precedes[i, k, j]`: Binary (1 if truck *i* precedes truck *k* on loading dock *j*; 0 otherwise).  
     - `tardiness[i]`: Continuous (delay of truck *i* beyond its due time).  
   - **2. Parameters:**  
     - `arrival_times[i]`: Arrival time of truck *i* (e.g., truck 1: 3).  
     - `processing_times[i]`: Processing duration of truck *i* (e.g., truck 2: 7).  
     - `due_times[i]`: Deadline of truck *i* (e.g., truck 3: 12).  
     - `H=100`: A large constant for logical constraints.  
   - **3. Objective Function:**  
     Minimize total tardiness:  
     `Minimize: sum(tardiness[i] for all trucks i)`.  
   - **4. Constraints:**  
     - Each truck is assigned to the loading dock: `assign[i, j] = 1` for all *i*.  
     - Start time ≥ arrival time: `start_time[i] ≥ arrival_times[i]`.  
     - Completion time definition: `completion_time[i] = start_time[i] + processing_times[i]`.  
     - Non-overlapping: For trucks *i* and *k* on loading dock *j*, either *i* precedes *k* (`start_time[k] ≥ completion_time[i]`) or vice versa.  
     - Tardiness calculation: `tardiness[i] ≥ completion_time[i] - due_times[i]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
loading_docks = [1] # Should be [1]
arrival_times = {1: 3, 2: 4, 3: 7, 4: 11, 5: 12}
processing_times = {1: 6, 2: 7, 3: 3, 4: 5, 5: 8}
due_times = {1: 15, 2: 16, 3: 12, 4: 24, 5: 26}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("LOADING_DOCK_PROBLEM_MIN_TARDINESS")

    if not trucks or not loading_docks or len(loading_docks)!=1: raise ValueError("Invalid trucks/loading_docks")
    the_loading_dock = loading_docks[0]

    # --- Decision Variables ---
    assign = m.addVars(trucks, loading_docks, vtype=GRB.BINARY, name="assign") # Trivial but keep
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in loading_docks],
                         vtype=GRB.BINARY, name="precedes")
    tardiness = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="tardiness")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(tardiness[i] for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_loading_dock] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (on the single loading dock) using Indicators
    j = the_loading_dock
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                # Link precedence var: if both assigned (always true), one must precede
                m.addConstr(precedes[i,k,j] + (1-precedes[i,k,j]) == 1, name=f"link_prec_{i}_{k}_{j}") # Enforce binary explicitly

    # 5. Tardiness definition
    m.addConstrs((tardiness[i] >= completion_time[i] - due_times.get(i, 0) for i in trucks), name="tardiness_calc")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Tardiness
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Print Missing Outputs ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal Objective Value (Total Tardiness): {m.objVal:.4f}")
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}, Tardiness: {tardiness[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
9.0000
Optimal Objective Value (Total Tardiness): 9.0000
Truck 1 - Start Time: 3.0000, Completion Time: 9.0000, Tardiness: 0.0000
Truck 2 - Start Time: 12.0000, Completion Time: 19.0000, Tardiness: 3.0000
Truck 3 - Start Time: 9.0000, Completion Time: 12.0000, Tardiness: 0.0000
Truck 4 - Start Time: 19.0000, Completion Time: 24.0000, Tardiness: 0.0000
Truck 5 - Start Time: 24.0000, Completion Time: 32.0000, Tardiness: 6.0000


```

================================================================================



--- Problem 423 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
In a busy port, ships must choose the optimal berthing path to minimize their waiting and berthing times. The port has three primary berthing paths—A, B, and C—each with unique characteristics. Path A offers the shortest free-flow berthing time (0.25 hours) but has a high capacity (3,729 ships per hour). Path B is slightly slower (0.36 hours) with a moderate capacity (2,729 ships per hour), while Path C is the slowest in free-flow conditions (0.45 hours) but handles a similar volume (2,745 ships per hour). The Bureau of Public Roads (BPR) function models congestion, with parameters α = 0.135 and β = 4.236, reflecting how berthing time worsens as traffic approaches capacity.

The challenge arises when Path A suddenly closes—a common scenario during maintenance or unexpected events. With 7,102 ships vying for the remaining berths (B and C), the system must redistribute the ships to minimize total berthing time across the port. This is a classic *user equilibrium* problem: ship captains selfishly choose the least congested berth until no one can unilaterally improve their berthing time. The optimization task is to compute this equilibrium, quantifying the societal cost—measured in ship-hours—of the closure.

**Core Question:** How does the closure of Path A disrupt berthing flow, and what is the resulting increase in total port berthing time?
**

**Modeling Process:**
**
**1. Decision Variables:**
- `x[p]`: Flow of ships (ships/h) on path `p`, where `p` ∈ {A, B, C} (normal conditions) or {B, C} (closure).

**2. Parameters:**
- `t0[p]`: Free-flow berthing time (hours) for path `p` (e.g., `t0['A'] = 0.252`).
- `capacity[p]`: Maximum flow capacity (ships/h) for path `p` (e.g., `capacity['B'] = 2728.71`).
- `bpr_alpha` (α = 0.135), `bpr_beta` (β = 4.236): BPR function coefficients.
- `total_demand` (7,102.35 ships/h): Total ships to distribute across paths.

**3. Objective Function:**
Minimize the Beckmann transformation of berthing time:
```
Sum over all paths p: [ t0[p] * x[p] + (t0[p] * α / ((β + 1) * capacity[p]^β)) * x[p]^2 ]
```
This approximates the integral of the BPR function to ensure equilibrium.

**4. Constraints:**
- **Demand conservation:** `Sum of x[p] for all p = total_demand`.
- **Non-negativity:** `x[p] ≥ 0` for all paths.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
paths_normal = ['A', 'B', 'C']
paths_closure = ['B', 'C']  # Path A is closed

t0 = {'A': 0.25248343397024015, 'B': 0.3613115850855238, 'C': 0.4473589070535666}  # hours
capacity = {'A': 3729.4530177148567, 'B': 2728.7113927732976, 'C': 2745.4363624412063}  # ships/h
bpr_alpha = 0.13519423152897947
bpr_beta = 4.236209259809038
total_demand = 7102.352545192193

# --- Function to solve UE ---
def solve_user_equilibrium(available_paths, t0_dict, capacity_dict, demand):
    m = gp.Model("UserEquilibrium")
    m.Params.NonConvex = 2

    # Decision Variables: Flow on each available path
    x = m.addVars(available_paths, name="flow", lb=0.0)

    # Constraints
    m.addConstr(gp.quicksum(x[i] for i in available_paths) == demand, name="DemandConservation")

    # Objective Function (Beckmann transformation)
    objective = gp.LinExpr()
    for i in available_paths:
        objective += t0_dict[i] * x[i]
        if capacity_dict[i] > 1e-6:
            coef = (t0_dict[i] * bpr_alpha) / ((bpr_beta + 1.0) * (capacity_dict[i] ** bpr_beta))
            # Using quadratic approximation for demonstration
            objective += coef * x[i] * x[i]

    m.setObjective(objective, GRB.MINIMIZE)
    m.optimize()

    flows = {p: x[p].X for p in available_paths}
    times = {}
    total_delay = 0
    for p in available_paths:
        flow = flows[p]
        t_act = t0_dict[p] * (1 + bpr_alpha * (flow / capacity_dict[p])**bpr_beta) if capacity_dict[p]>0 else float('inf')
        times[p] = t_act
        total_delay += flow * t_act

    return flows, times, total_delay

# --- Analysis ---
print("--- Normal Conditions (A, B, C available) ---")
flows_norm, times_norm, delay_norm = solve_user_equilibrium(paths_normal, t0, capacity, total_demand)
print(f"Flows: {flows_norm}")
print(f"Times: {times_norm}")
print(f"Total Port Time: {delay_norm}")

print("\n--- Berth Closure (B, C available) ---")
flows_closure, times_closure, delay_closure = solve_user_equilibrium(paths_closure, t0, capacity, total_demand)
print(f"Flows: {flows_closure}")
print(f"Times: {times_closure}")
print(f"Total Port Time: {delay_closure}")

delay_increase = delay_closure - delay_norm
print(f"\n--- Impact of Closure ---")
print(f"Increase in Total Port Berthing Time: {delay_increase:.2f} ship-hours")
```
Answer:
--- Normal Conditions (A, B, C available) ---
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 1 rows, 3 columns and 3 nonzeros
Model fingerprint: 0xe92b6efe
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [3e-01, 4e-01]
  Bounds range     [0e+00, 0e+00]
  RHS range        [7e+03, 7e+03]
Presolve removed 1 rows and 3 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    1.7932264e+03   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  1.793226360e+03
Flows: {'A': 7102.352545192193, 'B': 0.0, 'C': 0.0}
Times: {'A': 0.7752413354038165, 'B': 0.3613115850855238, 'C': 0.4473589070535666}
Total Port Time: 5506.03727164349

--- Berth Closure (B, C available) ---
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 1 rows, 2 columns and 2 nonzeros
Model fingerprint: 0xf91a5a25
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [4e-01, 4e-01]
  Bounds range     [0e+00, 0e+00]
  RHS range        [7e+03, 7e+03]
Presolve removed 1 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    2.5661623e+03   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  2.566162256e+03
Flows: {'B': 7102.352545192193, 'C': 0.0}
Times: {'B': 3.171596824112195, 'C': 0.4473589070535666}
Total Port Time: 22525.798776056727

--- Impact of Closure ---
Increase in Total Port Berthing Time: 17019.76 ship-hours



================================================================================



--- Problem 424 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy logistics hub, four delivery trucks arrive at staggered times, each requiring immediate unloading at the single available depot. The arrival times for the trucks are as follows: Truck 1 arrives at 2 hours, Truck 2 at 7 hours, Truck 3 at 11 hours, and Truck 4 at 16 hours. The unloading times vary: Truck 1 takes 3 hours, Trucks 2 and 3 each take 8 hours, and Truck 4 requires 7 hours. The waiting costs per hour are significant—$147 for Truck 1, $86 for Truck 2, $87 for Truck 3, and $89 for Truck 4—reflecting penalties for delays. Meanwhile, service costs per hour differ by truck: $43 for Truck 1, $60 for Truck 2, $55 for Truck 3, and $56 for Truck 4. The logistics manager must sequence the trucks to minimize the total cost, balancing the trade-off between letting trucks idle and paying for their unloading. The core question is: *What is the optimal unloading schedule that minimizes the combined waiting and service costs for all trucks?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary `assign[i, j]`: 1 if truck *i* is assigned to depot *j*, else 0.  
     - Continuous `start_time[i]`: When truck *i* begins unloading.  
     - Continuous `completion_time[i]`: When truck *i* finishes unloading.  
     - Binary `precedes[i, k, j]`: 1 if truck *i* is unloaded before truck *k* on depot *j*, else 0.  

   - **2. Parameters:**  
     - `arrival_times[i]`: Truck *i*'s arrival time (e.g., Truck 1: 2).  
     - `processing_times[i]`: Hours to unload truck *i* (e.g., Truck 1: 3).  
     - `waiting_costs[i]`: Cost per hour of delay for truck *i* (e.g., Truck 1: 147).  
     - `service_costs[i, j]`: Cost per hour to unload truck *i* at depot *j* (e.g., Truck 1 at Depot 1: 43).  
     - `H`: A large constant (100) to enforce precedence constraints.  

   - **3. Objective Function:**  
     Minimize:  
     \[
     \sum_{i} \text{waiting\_costs}[i] \cdot (\text{start\_time}[i] - \text{arrival\_times}[i]) + \sum_{i,j} \text{service\_costs}[i,j] \cdot \text{processing\_times}[i] \cdot \text{assign}[i,j]
     \]  

   - **4. Constraints:**  
     - Each truck is assigned to exactly one depot:  
       \[
       \sum_{j} \text{assign}[i, j] = 1 \quad \forall i
       \]  
     - Unloading starts after arrival:  
       \[
       \text{start\_time}[i] \geq \text{arrival\_times}[i] \quad \forall i
       \]  
     - Completion time calculation:  
       \[
       \text{completion\_time}[i] = \text{start\_time}[i] + \text{processing\_times}[i] \quad \forall i
       \]  
     - No overlapping unloading on the same depot (for trucks *i* and *k*):  
       \[
       \text{precedes}[i, k, j] + \text{precedes}[k, i, j] \geq \text{assign}[i, j] + \text{assign}[k, j] - 1 \quad \forall i < k, j
       \]  
       \[
       \text{If precedes}[i, k, j] = 1, \text{start\_time}[k] \geq \text{completion\_time}[i]
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4]
depots = [1]
arrival_times = {1: 2, 2: 7, 3: 11, 4: 16}
processing_times = {1: 3, 2: 8, 3: 8, 4: 7}
waiting_costs = {1: 147, 2: 86, 3: 87, 4: 89} # Cost per hour waiting
service_costs = {(1, 1): 43, (2, 1): 60, (3, 1): 55, (4, 1): 56} # Cost rate per hour unloading {(truck, depot): cost}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_UNLOADING_PROBLEM_MIN_COST")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    waiting_cost_expr = gp.quicksum(waiting_costs.get(i, 0) * (start_time[i] - arrival_times.get(i, 0)) for i in trucks)
    service_cost_expr = gp.quicksum(service_costs.get((i,j), 0) * processing_times.get(i, 0) * assign[i,j]
                                   for i in trucks for j in depots)
    m.setObjective(waiting_cost_expr + service_cost_expr, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Schedule:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.2f} hours")
                print(f"Completion Time: {completion_time[i].x:.2f} hours")
                print(f"Waiting Cost: {waiting_costs[i] * (start_time[i].x - arrival_times[i]):.2f} CNY")
                print(f"Service Cost: {service_costs[(i, j)] * processing_times[i]:.2f} CNY")
                print(f"Total Cost: {waiting_costs[i] * (start_time[i].x - arrival_times[i]) + service_costs[(i, j)] * processing_times[i]:.2f} CNY")
                print()
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
2412.0000
Optimal Schedule:
Truck 1 assigned to Depot 1
Start Time: 2.00 hours
Completion Time: 5.00 hours
Waiting Cost: 0.00 CNY
Service Cost: 129.00 CNY
Total Cost: 129.00 CNY

Truck 2 assigned to Depot 1
Start Time: 7.00 hours
Completion Time: 15.00 hours
Waiting Cost: 0.00 CNY
Service Cost: 480.00 CNY
Total Cost: 480.00 CNY

Truck 3 assigned to Depot 1
Start Time: 15.00 hours
Completion Time: 23.00 hours
Waiting Cost: 348.00 CNY
Service Cost: 440.00 CNY
Total Cost: 788.00 CNY

Truck 4 assigned to Depot 1
Start Time: 23.00 hours
Completion Time: 30.00 hours
Waiting Cost: 623.00 CNY
Service Cost: 392.00 CNY
Total Cost: 1015.00 CNY



```

================================================================================



--- Problem 425 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy container port, the operations team faces the daily challenge of efficiently assigning a fleet of 25 ships to six available berths. The berths are categorized into two types: four standard berths (B1, B2, B3, B5) and two oversized berths (B4, B6). The ships, labeled S1 through S25, also fall into two categories: 14 standard ships (e.g., S1, S3, S5) and 11 oversized ships (e.g., S2, S4, S6). Standard ships require 50 minutes to process, while oversized ships take 73 minutes due to their larger cargo capacity.  

   The port operates under strict rules: oversized ships cannot be assigned to standard berths, though standard ships may use oversized berths if needed. The primary goal is to minimize the total completion time (makespan) of all ship assignments—the moment the last ship finishes processing. This ensures the fastest possible turnaround for the entire fleet, reducing bottlenecks and maximizing throughput.  

   The challenge lies in balancing the workload across berths while respecting compatibility constraints. For instance, assigning too many oversized ships to a single oversized berth could create a bottleneck, while underutilizing standard berths could lead to inefficiencies. The team must find the optimal assignment that distributes the workload evenly, ensuring no berth becomes a critical delay point.  

   **Key Question:** What is the optimal assignment of ships to berths that minimizes the total completion time, given the processing times and berth compatibility rules?
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `assign[s, b]`: Equals 1 if ship `s` is assigned to berth `b`, otherwise 0.  
   - Continuous variable `berth_makespan[b]`: Total processing time for all ships assigned to berth `b`.  
   - Continuous variable `makespan`: Overall completion time (maximum of all `berth_makespan[b]`).  

   **2. Parameters:**  
   - `berths`: List of berths (B1–B6).  
   - `ships`: List of ships (S1–S25).  
   - `berth_types`: Dict mapping berths to types (Standard/Oversized).  
   - `ship_types`: Dict mapping ships to types (Standard/Oversized).  
   - `process_time`: Processing times (Standard: 50 min, Oversized: 73 min).  

   **3. Objective Function:**  
   Minimize the overall makespan:  
   ```  
   Minimize: makespan  
   ```  

   **4. Constraints:**  
   - **Assignment:** Each ship must be assigned to exactly one berth:  
     ```  
     For each ship s: sum(assign[s, b] for all berths b) == 1  
     ```  
   - **Compatibility:** Oversized ships cannot use standard berths:  
     ```  
     For each oversized ship s and standard berth b: assign[s, b] == 0  
     ```  
   - **Berth Makespan:** Calculate total processing time per berth:  
     ```  
     For each berth b: berth_makespan[b] == sum(assign[s, b] * process_time[ship_types[s]] for all ships s)  
     ```  
   - **Overall Makespan:** The makespan is the maximum berth workload:  
     ```  
     For each berth b: makespan >= berth_makespan[b]  
     ```  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
berths = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6']
berth_types = {'B1': 'Standard', 'B2': 'Standard', 'B3': 'Standard', 'B4': 'Oversized', 'B5': 'Standard', 'B6': 'Oversized'}
standard_berths = ['B1', 'B2', 'B3', 'B5']
oversized_berths = ['B4', 'B6']
ships = ['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8', 'S9', 'S10', 'S11', 'S12', 'S13', 'S14', 'S15', 'S16', 'S17', 'S18', 'S19', 'S20', 'S21', 'S22', 'S23', 'S24', 'S25']
ship_types = {'S1': 'Standard', 'S2': 'Oversized', 'S3': 'Standard', 'S4': 'Oversized', 'S5': 'Standard', 'S6': 'Oversized', 'S7': 'Standard', 'S8': 'Standard', 'S9': 'Standard', 'S10': 'Standard', 'S11': 'Standard', 'S12': 'Standard', 'S13': 'Standard', 'S14': 'Oversized', 'S15': 'Oversized', 'S16': 'Standard', 'S17': 'Oversized', 'S18': 'Oversized', 'S19': 'Standard', 'S20': 'Standard', 'S21': 'Oversized', 'S22': 'Oversized', 'S23': 'Oversized', 'S24': 'Oversized', 'S25': 'Standard'}
standard_ships = ['S1', 'S3', 'S5', 'S7', 'S8', 'S9', 'S10', 'S11', 'S12', 'S13', 'S16', 'S19', 'S20', 'S25']
oversized_ships = ['S2', 'S4', 'S6', 'S14', 'S15', 'S17', 'S18', 'S21', 'S22', 'S23', 'S24']
process_time = {'Standard': 50, 'Oversized': 73} # Type: Time
# --- End Parameters ---

GUROBI_TIME_LIMIT = 60

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m34 = gp.Model("PORT_BERTH_ASSIGNMENT_Makespan_MIP", env=env)

    # --- Basic Input Validation ---
    if not ships or not berths: raise ValueError("Empty ships or berths list")

    # --- Decision Variables ---
    # Binary: assign[s, b]=1 if ship s assigned to berth b
    assign_keys = [(s, b) for s in ships for b in berths]
    assign = m34.addVars(assign_keys, vtype=GRB.BINARY, name="assign")
    # Continuous: Makespan for each berth
    berth_makespan = m34.addVars(berths, name="berth_makespan", lb=0)
    # Continuous: Overall makespan (objective)
    makespan = m34.addVar(name="overall_makespan", lb=0)

    # --- Objective Function ---
    # Minimize the overall makespan
    m34.setObjective(makespan, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Assignment constraints:
    # 1. Each ship assigned to exactly one berth
    for s in ships:
        m34.addConstr(gp.quicksum(assign[s, b] for b in berths) == 1, name=f"assign_ship_{s}")

    # 2. Ships assigned only to compatible berths
    # Standard ships can use Standard or Oversized berths (as per common logic, original model disallowed Ovr)
    # Let's allow standard in oversized for flexibility (can revert if needed)
    # for s in standard_ships:
    #     for b in oversized_berths:
    #         # If standard CANNOT use oversized:
    #         # m34.addConstr(assign[s, b] == 0, name=f"std_ship_{s}_no_ovr_berth_{b}")
    #         pass # Allow standard in oversized

    # Oversized ships CANNOT use Standard berths
    for s in oversized_ships:
        for b in standard_berths:
            m34.addConstr(assign[s, b] == 0, name=f"ovr_ship_{s}_no_std_berth_{b}")

    # Makespan calculation constraints:
    # 1. Calculate makespan for each berth (sum of processing times of assigned ships)
    for b in berths:
        # Get process time based on ship type, not berth type (ship determines time)
        m34.addConstr(berth_makespan[b] == gp.quicksum(assign[s, b] * process_time.get(ship_types.get(s, 'Standard'), 0)
                                                    for s in ships), name=f"makespan_berth_{b}")

    # 2. Overall makespan is the maximum of individual berth makespans
    for b in berths:
        m34.addConstr(makespan >= berth_makespan[b], name=f"overall_makespan_ge_berth_{b}")


    # --- Optimization ---
    m34.optimize()

    # --- Store results ---
    results_dict['status'] = m34.status
    if m34.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m34.ObjVal
        # Store other results needed for the detailed output
        results_dict['makespan_sol'] = makespan.X
        results_dict['berth_makespan_sol'] = m34.getAttr('X', berth_makespan)
        results_dict['assign_sol'] = m34.getAttr('X', assign)


    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- PORT_BERTH_ASSIGNMENT: Port Berth Assignment (MIP) ---") # Problem 34 in original
    if m34.status == GRB.OPTIMAL:
        makespan_sol = results_dict.get('makespan_sol', 'N/A')
        berth_mk_sol = results_dict.get('berth_makespan_sol', {})
        assign_sol = results_dict.get('assign_sol', {})

        print(f"Optimization Status: Optimal")
        # Format makespan value
        if isinstance(makespan_sol, (int, float)):
             print(f"Minimum Makespan (Completion time of last ship): {makespan_sol:.1f} minutes")
        else:
             print(f"Minimum Makespan (Completion time of last ship): {makespan_sol}")

        print("Assignments and Berth Makespans:")
        assignments_dict = {} # Track assignments for final print
        for b in berths:
            ships_in_berth = []
            # Iterate through solution dictionary `assign_sol`
            for (s_key, b_key), assigned_val in assign_sol.items():
                if b_key == b and assigned_val > 0.5:
                    ships_in_berth.append(s_key)
                    assignments_dict[s_key] = b_key # Store assignment

            berth_type_print = berth_types.get(b, 'Unknown')
            berth_mk_print = berth_mk_sol.get(b, 'N/A')
            # Format berth makespan value
            if isinstance(berth_mk_print, (int, float)):
                 berth_mk_str = f"{berth_mk_print:.1f} min"
            else:
                 berth_mk_str = f"{berth_mk_print}"

            print(f"  Berth {b} ({berth_type_print}): Assigned Ships: {', '.join(ships_in_berth)}. Berth Makespan: {berth_mk_str}")
        # Optional: Verify assignment printout was commented out in original
        # print("Ship Assignments:")
        # for s in ships: print(f"  Ship {s} -> Berth {assignments_dict.get(s, 'Unassigned')}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m34.status}")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- PORT_BERTH_ASSIGNMENT: Port Berth Assignment (MIP) ---
Optimization Status: Optimal
Minimum Makespan (Completion time of last ship): 438.0 minutes
Assignments and Berth Makespans:
  Berth B1 (Standard): Assigned Ships: S1, S3, S5, S8, S9, S10, S16, S19. Berth Makespan: 400.0 min
  Berth B2 (Standard): Assigned Ships: S7, S11. Berth Makespan: 100.0 min
  Berth B3 (Standard): Assigned Ships: S13, S20. Berth Makespan: 100.0 min
  Berth B4 (Oversized): Assigned Ships: S6, S17, S18, S22, S23. Berth Makespan: 365.0 min
  Berth B5 (Standard): Assigned Ships: S12, S25. Berth Makespan: 100.0 min
  Berth B6 (Oversized): Assigned Ships: S2, S4, S14, S15, S21, S24. Berth Makespan: 438.0 min


```

================================================================================



--- Problem 426 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling six delivery trucks (`1` to `6`) to a single loading dock (`1`), while adhering to strict arrival times and processing requirements. Each truck arrives at a specific hour: Truck 1 at 4, Truck 2 at 9, Truck 3 at 11, Truck 4 at 14, Truck 5 at 15, and Truck 6 at 18. Loading these vehicles takes varying durations—5 hours for Trucks 1, 2, 4, 5, and 6, and 3 hours for Truck 3. Complicating matters, the loading dock undergoes mandatory maintenance from hour 24 to 34, during which no truck can be serviced. The logistics manager must decide whether to schedule each truck before or after this maintenance window, ensuring no overlaps in loading times. The primary goal is to minimize the total operational time (makespan) required to service all trucks, balancing timely arrivals, processing durations, and the inflexible maintenance block.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign[i, j]`: Binary (1 if truck `i` is assigned to dock `j`; 0 otherwise).  
     - `start_time[i]`: Continuous, the time truck `i` begins loading.  
     - `completion_time[i]`: Continuous, the time truck `i` finishes loading.  
     - `precedes[i, k, j]`: Binary (1 if truck `i` is scheduled before truck `k` on dock `j`; 0 otherwise).  
     - `b[i]`: Binary (1 if truck `i` completes before maintenance; 0 if it starts after).  
     - `makespan`: Continuous, the latest completion time across all trucks.  

   - **2. Parameters:**  
     - `arrival_times[i]`: Truck `i`'s arrival hour (e.g., `{1:4, 2:9, ...}`).  
     - `processing_times[i]`: Truck `i`'s loading duration (e.g., `{1:5, 2:5, ...}`).  
     - `maint_start=24`, `maint_end=34`: Maintenance window.  
     - `H=100`: A large constant for disjunctive constraints.  

   - **3. Objective Function:**  
     Minimize `makespan` (the latest completion time).  

   - **4. Constraints:**  
     - Each truck must be assigned to the dock: `assign[i, 1] = 1` for all `i`.  
     - Trucks cannot start before arrival: `start_time[i] >= arrival_times[i]`.  
     - Completion time logic: `completion_time[i] = start_time[i] + processing_times[i]`.  
     - Non-overlapping schedules: For trucks `i` and `k` (with `i < k`), either `start_time[k] >= completion_time[i]` or `start_time[i] >= completion_time[k]`.  
     - Maintenance disjunction:  
       - If `b[i]=1`, truck `i` must finish by `maint_start`: `completion_time[i] <= maint_start + H*(1 - b[i])`.  
       - If `b[i]=0`, truck `i` must start after `maint_end`: `start_time[i] >= maint_end - H*b[i]`.  
     - Makespan definition: `makespan >= completion_time[i]` for all `i`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
docks = [1] # Should be [1]
arrival_times = {1: 4, 2: 9, 3: 11, 4: 14, 5: 15, 6: 18}
processing_times = {1: 5, 2: 5, 3: 3, 4: 5, 5: 5, 6: 5}
maint_start = 24
maint_end = 34
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("LOADING_DOCK_PROBLEM_6_MAINTENANCE")

    if not trucks or not docks or len(docks)!=1: raise ValueError("Invalid trucks/docks")
    the_dock = docks[0]

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    b = m.addVars(trucks, vtype=GRB.BINARY, name="maint_choice") # For disjunction

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_dock] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (using Indicators)
    j = the_dock
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j])) # Link precedence if both assigned (always true here)

    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. Maintenance window constraint
    for i in trucks:
         m.addConstr(completion_time[i] <= maint_start + H * b[i], name=f"maint_before_{i}")
         m.addConstr(start_time[i] >= maint_end - H * (1 - b[i]), name=f"maint_after_{i}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    for i in trucks:
        print(f"Truck {i} start time: {start_time[i].x:.4f}, completion time: {completion_time[i].x:.4f}")
    for i in trucks:
        if b[i].x > 0.5:
            print(f"Truck {i} completes before maintenance.")
        else:
            print(f"Truck {i} starts after maintenance.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
42.0000
Truck 1 start time: 4.0000, completion time: 9.0000
Truck 2 start time: 9.0000, completion time: 14.0000
Truck 3 start time: 34.0000, completion time: 37.0000
Truck 4 start time: 14.0000, completion time: 19.0000
Truck 5 start time: 19.0000, completion time: 24.0000
Truck 6 start time: 37.0000, completion time: 42.0000
Truck 1 starts after maintenance.
Truck 2 starts after maintenance.
Truck 3 completes before maintenance.
Truck 4 starts after maintenance.
Truck 5 starts after maintenance.
Truck 6 completes before maintenance.


```

================================================================================



--- Problem 427 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently loading a shipment of 14 items into the fewest possible trucks for transport. Each item has a specific weight, ranging from 5 to 20 units, and the trucks have a strict capacity limit of 21 units. The challenge is to assign these items to trucks in such a way that no truck exceeds its capacity while minimizing the total number of trucks used. The items must be loaded carefully—each can only go into one truck, and trucks cannot be overloaded. The company aims to optimize space utilization to reduce shipping costs and improve operational efficiency. The key question is: *What is the minimum number of trucks required to load all items without violating capacity constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[i, j]`: Binary variable indicating whether item `i` is assigned to truck `j` (1 if assigned, 0 otherwise).  
     - `y[j]`: Binary variable indicating whether truck `j` is used (1 if used, 0 otherwise).  
   - **2. Parameters:**  
     - `items`: List of item weights (`[14, 9, 7, 10, 14, 8, 20, 11, 19, 15, 14, 18, 5, 5]`).  
     - `capacity`: Maximum weight each truck can hold (21).  
     - `num_items`: Total number of items (14).  
     - `num_trucks`: Maximum possible trucks (equal to `num_items`).  
   - **3. Objective Function:**  
     - Minimize the total number of trucks used: `Minimize: sum(y[j] for all j)`.  
   - **4. Constraints:**  
     - **Assignment Constraint:** Each item must be assigned to exactly one truck:  
       `For each item i: sum(x[i, j] for all j) = 1`.  
     - **Capacity Constraint:** The total weight in any truck `j` must not exceed its capacity if the truck is used:  
       `For each truck j: sum(items[i] * x[i, j] for all i) <= capacity * y[j]`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB

# --- Data Definition ---
items = [14, 9, 7, 10, 14, 8, 20, 11, 19, 15, 14, 18, 5, 5]      # Weights of items
capacity = 21           # Truck capacity
num_items = 14     # len(items)
num_trucks = num_items    # Maximum number of trucks (worst case: one item per truck)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Time limit
# env.setParam('TimeLimit', 30)
env.start()

# Create Model
model = Model("Truck Packing Problem", env=env)

# --- Decision Variables ---
# x[i,j]: item i is assigned to truck j
x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")
# y[j]: truck j is used
y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")

# --- Objective: Minimize the number of trucks used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)

# --- Constraints ---
# 1. Each item must be assigned to exactly one truck
for i in range(num_items):
    model.addConstr(x.sum(i, '*') == 1, name=f"Item_{i}_Assignment")

# 2. Truck capacity constraint: sum of weights in truck j <= capacity IF truck j is used (y[j]=1)
for j in range(num_trucks):
    model.addConstr(gp.quicksum(items[i] * x[i, j] for i in range(num_items)) <= capacity * y[j], name=f"Truck_{j}_Capacity")

# --- Solve ---
print("Solving 1DTP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_trucks = int(results_dict.get('obj_val', -1))
    print(f"\nOptimal number of trucks used: {optimal_trucks}")
    print("-" * 30)
    truck_details = []
    for j_sol in range(num_trucks): # Loop through potential trucks
        # Check if the truck variable y[j_sol] exists and is set to 1
        # Using .X requires Gurobi v9+ and that the variable is in the solution
        try:
            if y[j_sol].X > 0.5: # Check if truck j_sol is used
                # Find items assigned to this truck j_sol
                assigned_items_indices = [i for i in range(num_items) if x[i, j_sol].X > 0.5]
                assigned_items_weights = [items[i] for i in assigned_items_indices]
                truck_load = sum(assigned_items_weights)
                print(f"Truck {j_sol + 1} (Load: {truck_load}/{capacity}): Items (indices): {assigned_items_indices}")
                # Optional: Print weights too
                # print(f"  Weights: {assigned_items_weights}")
                truck_details.append({'truck_index': j_sol, 'item_indices': assigned_items_indices, 'load': truck_load})
        except AttributeError:
            # This might happen if y[j_sol] was optimized to 0 and doesn't have an .X value
            # Or if the model was infeasible/not solved optimally.
            # Since we check for OPTIMAL status first, this is less likely for y,
            # but could happen if x[i, j_sol] is 0. The check x[i,j_sol].X > 0.5 handles this.
            pass # Just skip if variable/attribute doesn't exist for unused trucks/items
    results_dict['truck_details'] = truck_details # Store details
    print("-" * 30)

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount to see if a feasible solution was found
     if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
     else: print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 1DTP instance...

Optimal number of trucks used: 9
------------------------------
Truck 1 (Load: 21/21): Items (indices): [3, 7]
Truck 2 (Load: 21/21): Items (indices): [2, 4]
Truck 3 (Load: 19/21): Items (indices): [0, 12]
Truck 4 (Load: 17/21): Items (indices): [1, 5]
Truck 6 (Load: 19/21): Items (indices): [8]
Truck 8 (Load: 14/21): Items (indices): [10]
Truck 11 (Load: 18/21): Items (indices): [11]
Truck 12 (Load: 20/21): Items (indices): [9, 13]
Truck 13 (Load: 20/21): Items (indices): [6]
------------------------------


```

================================================================================



--- Problem 428 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A port operator is tasked with efficiently managing ship berthing at two types of docks: Automated Berthing (AB) and Manual Berthing (MB). The port has **2 AB docks** and **3 MB docks**, each with distinct processing times—**14 minutes per ship for AB** and **22 minutes for MB**. Over a **584-minute period**, a total of **56 ships** arrive, with **77% (43 ships) equipped for AB** and **23% (13 ships) requiring MB**.  

The challenge lies in balancing dock utilization to minimize congestion. The operator must decide how many AB-eligible ships should be diverted to MB docks (despite slower processing) to prevent overloading either dock type. The goal is to **minimize the maximum volume-to-capacity (V/C) ratio** across all docks, ensuring neither AB nor MB docks become bottlenecks. Capacities are precomputed: **AB docks can handle 83.43 ships**, while **MB docks can manage 79.64 ships** in the given period.  

**Key Question:** *How should AB ships be distributed between AB and MB docks to achieve the most balanced load, minimizing the worst-case congestion ratio?*  
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `n_ab_ab`: Integer, number of AB ships assigned to AB docks.  
- `n_ab_mb`: Integer, number of AB ships assigned to MB docks.  
- `n_mb_mb`: Integer, fixed as 13 (MB ships must use MB docks).  
- `MaxVC`: Continuous, represents the maximum V/C ratio across docks.  

**2. Parameters:**  
- `num_ab_ships = 43`, `num_mb_ships = 13` (ship counts).  
- `cap_ab = 83.43`, `cap_mb = 79.64` (dock capacities).  
- `time_ab_m = 14`, `time_mb_m = 22` (processing times).  

**3. Objective Function:**  
- **Minimize** `MaxVC` (the highest V/C ratio among docks).  

**4. Constraints:**  
- **Ship conservation:**  
  - AB ships: `n_ab_ab + n_ab_mb = 43`.  
  - MB ships: `n_mb_mb = 13`.  
- **V/C ratio limits:**  
  - For AB docks: `MaxVC * (cap_ab + ε) ≥ n_ab_ab`.  
  - For MB docks: `MaxVC * (cap_mb + ε) ≥ n_ab_mb + n_mb_mb`.  
- **Non-negativity and integer requirements** for all variables.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
num_ab_docks = 2
num_mb_docks = 3
time_ab_m = 14
time_mb_m = 22
period_m = 584
total_arrivals = 56
pct_ab = 0.77
pct_mb = 0.23
# Calculated values
num_ab_ships = 43
num_mb_ships = 13
cap_ab = 83.43
cap_mb = 79.64
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_DOCK_BALANCING", env=env)

    # --- Decision Variables ---
    # n_ab_ab: Number of AB ships using AB docks
    n_ab_ab = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_ab_ab")
    # n_ab_mb: Number of AB ships using MB docks
    n_ab_mb = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_ab_mb")
    # n_mb_mb: Number of MB ships using MB docks (fixed by input)
    # This can be treated as data, but keep as variable for consistency if needed
    n_mb_mb = m.addVar(vtype=GRB.INTEGER, lb=0, name="n_mb_mb")
    # MaxVC: Maximum V/C ratio across dock types
    MaxVC = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="MaxVC") # V/C >= 0

    # --- Objective Function: Minimize the maximum V/C ratio ---
    m.setObjective(MaxVC, GRB.MINIMIZE)

    # --- Constraints ---
    # Conservation of AB ships
    m.addConstr(n_ab_ab + n_ab_mb == num_ab_ships, "ABConserve")

    # Fix MB ships (must use MB docks)
    m.addConstr(n_mb_mb == num_mb_ships, "MBConserve")

    # Calculate flows
    flow_ab = n_ab_ab
    flow_mb = n_ab_mb + n_mb_mb

    # Max V/C calculation (using linear form MaxVC * Capacity >= Flow)
    # Use epsilon to avoid issues if capacity is exactly zero
    epsilon = 1e-6
    if cap_ab > 0:
        m.addConstr(MaxVC * (cap_ab + epsilon) >= flow_ab, "VC_AB")
    else:
         # If AB capacity is zero, no AB ships can use AB docks
         m.addConstr(n_ab_ab == 0, "ZeroCapAB")

    if cap_mb > 0:
        m.addConstr(MaxVC * (cap_mb + epsilon) >= flow_mb, "VC_MB")
    else:
        # If MB capacity is zero, no ships can use MB docks
        m.addConstr(n_ab_mb == 0, "ZeroCapMB_AB")
        m.addConstr(n_mb_mb == 0, "ZeroCapMB_MB") # Will likely make infeasible if num_mb > 0

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_ab_ab_sol'] = n_ab_ab.X # Not needed for output
        # results_dict['n_ab_mb_sol'] = n_ab_mb.X
        # results_dict['n_mb_mb_sol'] = n_mb_mb.X

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is Max V/C ratio
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show precision
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the decision variables and their values
if m.Status == GRB.OPTIMAL:
    print(f"Optimal objective value: {obj_val_print:.4f}")
    print(f"Number of AB ships assigned to AB docks (n_ab_ab): {n_ab_ab.X}")
    print(f"Number of AB ships assigned to MB docks (n_ab_mb): {n_ab_mb.X}")
    print(f"Number of MB ships assigned to MB docks (n_mb_mb): {n_mb_mb.X}")
```
Answer:
Optimal objective value: 0.3476
Optimal objective value: 0.3476
Number of AB ships assigned to AB docks (n_ab_ab): 29.0
Number of AB ships assigned to MB docks (n_ab_mb): 14.0
Number of MB ships assigned to MB docks (n_mb_mb): 13.0


```

================================================================================



--- Problem 429 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A busy port is managing the berthing of incoming ships within a limited time window. The port has two types of berths: **General Cargo (GC) berths**, which are slower to process but more numerous, and **Container (CT) berths**, which are faster but limited in quantity. The port manager must decide how many ships of each type to berth to maximize the total number of ships served, while respecting berth availability, processing times, and actual demand.  

   The port has **4 GC berths**, each requiring **3.30 hours** to fully process a ship, and **1 CT berth**, which takes only **0.77 hours** per ship. The planning horizon is tight—just **3.7 hours**—during which the port must accommodate **6 GC berthing requests** and **12 CT requests**. The core question is: *How many GC and CT ships should the port berth to serve as many ships as possible without exceeding berth capacities or available time?*
**

Modeling Process:
**
**1. Decision Variables:**  
   - `x_gc`: Number of GC ships berthed (continuous, ≥ 0).  
   - `x_ct`: Number of CT ships berthed (continuous, ≥ 0).  

   **2. Parameters:**  
   - `num_gc_berths = 4` (available GC berths).  
   - `time_per_gc_process_hr = 3.30` (hours per GC process).  
   - `num_ct_berths = 1` (available CT berths).  
   - `time_per_ct_process_hr = 0.77` (hours per CT process).  
   - `planning_horizon_hr = 3.7` (total operating hours).  
   - `demand_gc = 6`, `demand_ct = 12` (maximum ships requesting berthing).  

   **3. Objective Function:**  
   Maximize the total number of ships berthed:  
   `Maximize: x_gc + x_ct`.  

   **4. Constraints:**  
   - **GC berth capacity:** Total GC processing time cannot exceed available berth-hours:  
     `x_gc * 3.30 ≤ 4 * 3.7`.  
   - **CT berth capacity:** Total CT processing time cannot exceed available berth-hours:  
     `x_ct * 0.77 ≤ 1 * 3.7`.  
   - **Demand limits:**  
     `x_gc ≤ 6`, `x_ct ≤ 12`.  

3.
**

Corresponding Code:
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
num_gc_berths = 4; time_per_gc_process_hr = 3.30
num_ct_berths = 1; time_per_ct_process_hr = 0.77
planning_horizon_hr = 3.7; demand_gc = 6; demand_ct = 12
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m21 = gp.Model("Port_Berthing_LP", env=env)
    # Vars
    x_gc = m21.addVar(name="gc_ships_berthed", lb=0)
    x_ct = m21.addVar(name="ct_ships_berthed", lb=0)
    # Objective
    m21.setObjective(x_gc + x_ct, sense=GRB.MAXIMIZE)
    # Constraints
    m21.addConstr(x_gc * time_per_gc_process_hr <= num_gc_berths * planning_horizon_hr, "gc_capacity")
    m21.addConstr(x_ct * time_per_ct_process_hr <= num_ct_berths * planning_horizon_hr, "ct_capacity")
    m21.addConstr(x_gc <= demand_gc, "gc_demand")
    m21.addConstr(x_ct <= demand_ct, "ct_demand")
    # Optimize
    m21.optimize()
    # Store results
    results_dict['status'] = m21.status
    if m21.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m21.objVal; results_dict['xgc_opt'] = x_gc.X; results_dict['xct_opt'] = x_ct.X
    # Output Results
    print("--- Problem 21: Port Berthing Usage (LP) ---")
    if m21.status == GRB.OPTIMAL:
        print(f"Optimization Status: Optimal")
        xgc = results_dict.get('xgc_opt', 0); xct = results_dict.get('xct_opt', 0)
        gc_cap_hours = num_gc_berths * planning_horizon_hr; ct_cap_hours = num_ct_berths * planning_horizon_hr
        gc_hours_used = xgc * time_per_gc_process_hr; ct_hours_used = xct * time_per_ct_process_hr
        gc_cap_ships = gc_cap_hours / time_per_gc_process_hr if time_per_gc_process_hr > 1e-6 else 0
        ct_cap_ships = ct_cap_hours / time_per_ct_process_hr if time_per_ct_process_hr > 1e-6 else 0
        print(f"Maximum Total Ships Berthed: {m21.objVal:.2f}")
        print(f"  General Cargo Ships Berthed: {xgc:.2f} (Demand: {demand_gc}, Capacity in ships: {gc_cap_ships:.2f})")
        print(f"  Container Ships Berthed: {xct:.2f} (Demand: {demand_ct}, Capacity in ships: {ct_cap_ships:.2f})")
        print(f"  GC Berth-Hours Used: {gc_hours_used:.1f} / {gc_cap_hours:.1f}")
        print(f"  CT Berth-Hours Used: {ct_hours_used:.1f} / {ct_cap_hours:.1f}")
    else: print(f"Optimization Status: {m21.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_BERTHING
```
Answer:
--- Problem 21: Port Berthing Usage (LP) ---
Optimization Status: Optimal
Maximum Total Ships Berthed: 9.29
  General Cargo Ships Berthed: 4.48 (Demand: 6, Capacity in ships: 4.48)
  Container Ships Berthed: 4.81 (Demand: 12, Capacity in ships: 4.81)
  GC Berth-Hours Used: 14.8 / 14.8
  CT Berth-Hours Used: 3.7 / 3.7



================================================================================



--- Problem 430 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy port experiences varying ship arrival and departure demands throughout the day, with distinct peaks during the morning, midday, and evening. The port has two berths, Berth A and Berth B, each with a fixed number of cranes—Berth A has one permanent crane, while Berth B has two. To adapt to the dynamic ship handling patterns, a single additional crane is available, which can be allocated to either berth as needed. The goal is to minimize congestion by strategically assigning this additional crane during each time period (Morning, Midday, Evening) to balance the ship-to-cranes (S/C) ratios. Ship arrivals vary significantly: in the Morning, Berth A handles 1,931 ships per hour (ships/h), while Berth B sees 1,840 ships/h; Midday flows drop to 1,497 ships/h for A and 967 ships/h for B; and in the Evening, Berth A drops sharply to 409 ships/h, while Berth B surges to 1,712 ships/h. Each crane can handle up to 807 ships/h. The challenge is to determine the optimal additional crane assignments to ensure the worst-case congestion (maximum S/C ratio across all periods and berths) is as low as possible.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `y[t]` for each time period `t` (Morning, Midday, Evening):  
       `y[t] = 1` if the additional crane is assigned to Berth A in period `t`, `0` if assigned to Berth B.  
     - Continuous variable `Max_SC_Ratio`: Represents the maximum S/C ratio across all periods and berths.  

   - **2. Parameters:**  
     - `flows[t][b]`: Ship flow (ships/h) for berth `b` (A or B) in period `t`.  
     - `crane_capacity = 807`: Capacity per crane (ships/h).  
     - `num_fixed_cranes_A = 1`, `num_fixed_cranes_B = 2`: Fixed cranes for Berths A and B.  
     - `num_additional_cranes = 1`: Additional crane count.  

   - **3. Objective Function:**  
     Minimize `Max_SC_Ratio`.  

   - **4. Constraints:**  
     - For each period `t` and berth `b`, ensure `Max_SC_Ratio` bounds the S/C ratio:  
       - Berth A: `Max_SC_Ratio * ( (num_fixed_cranes_A + y[t]) * crane_capacity + epsilon ) >= flows[t]['A']`  
       - Berth B: `Max_SC_Ratio * ( (num_fixed_cranes_B + (1 - y[t])) * crane_capacity + epsilon ) >= flows[t]['B']`  
       (where `epsilon = 1e-6` avoids division by zero).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
periods = ['Morning', 'Midday', 'Evening']
flows = {'Morning': {'A': 1931, 'B': 1840}, 'Midday': {'A': 1497, 'B': 967}, 'Evening': {'A': 409, 'B': 1712}} # Dict period: {'A': flow, 'B': flow}
crane_capacity = 807 # ships/h/crane
num_fixed_cranes_A = 1
num_fixed_cranes_B = 2
num_additional_cranes = 1
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("ADDITIONAL_CRANE_ASSIGN", env=env)

    # --- Input Validation ---
    if not periods: raise ValueError("Empty periods list")
    if crane_capacity <= 0: raise ValueError("Crane capacity must be positive")

    # --- Decision Variables ---
    # y[t] = 1 if additional crane goes to A in period t, 0 if to B
    y = m.addVars(periods, vtype=GRB.BINARY, name="AdditionalCraneToA")
    # Max_SC_Ratio: the maximum S/C ratio across all periods and berths
    Max_SC_Ratio = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name="Max_SC_Ratio") # S/C must be >= 0

    # --- Objective Function: Minimize the maximum S/C ratio ---
    m.setObjective(Max_SC_Ratio, GRB.MINIMIZE)

    # --- Constraints ---
    for t in periods:
        flow_A = flows.get(t, {}).get('A', 0)
        flow_B = flows.get(t, {}).get('B', 0)

        # Calculate capacity for each berth using linear expressions
        cap_A_expr = (num_fixed_cranes_A + y[t]) * crane_capacity
        cap_B_expr = (num_fixed_cranes_B + (num_additional_cranes - y[t])) * crane_capacity

        # Ensure capacity expressions are non-negative (should be true if inputs valid)
        # Add constraints linking Max_SC_Ratio to S/C for each berth/period
        # Max_SC_Ratio >= Flow / Capacity  <=>  Max_SC_Ratio * Capacity >= Flow
        # Use small epsilon for capacity to avoid potential division by zero if capacity=0 allowed
        epsilon = 1e-6
        m.addConstr(Max_SC_Ratio * (cap_A_expr + epsilon) >= flow_A, f"SC_A_{t}")
        m.addConstr(Max_SC_Ratio * (cap_B_expr + epsilon) >= flow_B, f"SC_B_{t}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['y_sol'] = m.getAttr('X', y) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is Max S/C ratio
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show precision
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the additional crane assignments for each period
if m.Status == GRB.OPTIMAL:
    for t in periods:
        if y[t].X > 0.5:
            print(f"Additional crane assigned to Berth A in {t}")
        else:
            print(f"Additional crane assigned to Berth B in {t}")
```
Answer:
Optimal objective value: 1.1964
Additional crane assigned to Berth A in Morning
Additional crane assigned to Berth A in Midday
Additional crane assigned to Berth B in Evening


```

================================================================================



--- Problem 431 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, two cranes are responsible for loading and unloading containers from ships. Each crane must be allocated a certain amount of time to operate, balancing efficiency and minimizing delays. The total operational cycle time is fixed at 84 minutes, and each crane’s operational time must fall between a minimum of 5 minutes and a maximum of 84 minutes. The challenge lies in distributing these operational times to minimize the total delay experienced by the ships.  

   The operational impact coefficients—626 for Crane 1 and 2620 for Crane 2—reflect the relative impact of delays on each crane. A higher coefficient means that delays in that crane contribute more significantly to the overall congestion. The core question is: *How should the 84-minute cycle be split between the two cranes to minimize the total delay across the port?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - \( t_i \): Continuous variable representing the operational time (in minutes) allocated to Crane \( i \), where \( i \in \{1, 2\} \).  
   - Bounds: \( 5 \leq t_i \leq 84 \).  

   **2. Parameters:**  
   - \( \text{impact_coeffs} = [626, 2620] \): Operational impact coefficients for Cranes 1 and 2.  
   - \( \text{cycle_time} = 84 \): Total fixed cycle time (minutes).  
   - \( \text{lb_time} = 5 \), \( \text{ub_time} = 84 \): Lower and upper bounds for operational times.  

   **3. Objective Function:**  
   Minimize the total delay:  
   \[
   \text{Minimize: } 626 \times (84 - t_1) + 2620 \times (84 - t_2)
   \]  
   (Each term represents delay for a crane, calculated as impact coefficient multiplied by non-operational time.)  

   **4. Constraints:**  
   - **Total cycle time:** The sum of operational times must equal the cycle time:  
     \[
     t_1 + t_2 = 84
     \]  
   - **Variable bounds:**  
     \[
     5 \leq t_1 \leq 84, \quad 5 \leq t_2 \leq 84
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_cranes = 2
lb_time = 5          # Lower bound for operational time
ub_time = 84         # Upper bound for operational time
cycle_time = 84      # Total cycle time (set equal to ub_time)
impact_coeffs = [626, 2620] # Operational impact coefficients per crane
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(impact_coeffs) != num_cranes:
    print("Error: impact_coeffs length mismatch with num_cranes")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: impact_coeffs length"
    # raise ValueError("impact_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_cranes}-Crane Operational Timing", env=env)

        # --- Decision variables (dynamic based on num_cranes) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_cranes, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for crane i is proportional to impact * non-operational_time = impact * (cycle_time - operational_time[i])
        model.setObjective(gp.quicksum(impact_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_cranes)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of operational times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_cranes)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_cranes)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal operational times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_cranes):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total delay: 62554.00
------------------------------
Optimal operational times (minutes):
  t1: 5.00, t2: 79.00


```

================================================================================



--- Problem 432 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling the unloading of five incoming trucks (Trucks 1–5) at three available depots (Depots 1–3). Each truck arrives at a specific time: Truck 1 at 2 hours, Truck 2 at 5, Truck 3 at 7, Truck 4 at 9, and Truck 5 at 11. The base processing time for unloading and servicing varies by truck: 8 hours for Trucks 1 and 3, 3 hours for Trucks 2 and 5, and 4 hours for Truck 4. However, Truck 3 requires an additional 1-hour security check due to its cargo type, increasing its total processing time to 9 hours.

The logistics hub aims to minimize the total operational time (makespan) — the moment the last truck departs — by strategically assigning trucks to depots while respecting arrival times and avoiding overlaps. Critical rules include: each truck must dock at exactly one depot, no truck can start processing before its arrival, and two trucks cannot occupy the same depot simultaneously. The core question is: *What is the optimal depot assignment and schedule to ensure all trucks are serviced as quickly as possible?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary (0/1) indicating if truck *i* is assigned to depot *j*.  
   - `start_time(i)`: Continuous, the time truck *i* begins processing.  
   - `completion_time(i)`: Continuous, the time truck *i* finishes (start time + processing time).  
   - `precedes(i, k, j)`: Binary (0/1) indicating if truck *i* is scheduled before truck *k* at depot *j*.  
   - `makespan`: Continuous, the latest completion time across all trucks.  

   **2. Parameters:**  
   - `arrival_times[i]`: Truck *i*'s arrival time (e.g., Truck 1: 2).  
   - `processing_times[i]`: Total service time for truck *i* (e.g., Truck 3: 9).  
   - `H=100`: A large constant for logical constraints.  

   **3. Objective Function:**  
   Minimize `makespan` (latest completion time).  

   **4. Constraints:**  
   - **Assignment:** Each truck to exactly one depot: `sum(assign(i, j) for all j) = 1` for all *i*.  
   - **Arrival Time:** `start_time[i] >= arrival_times[i]` for all *i*.  
   - **Completion Time:** `completion_time[i] = start_time[i] + processing_times[i]` for all *i*.  
   - **Non-Overlapping:** For each depot *j* and trucks *i*, *k* (*i < k*):  
     - If `precedes(i, k, j) = 1`, then `start_time[k] >= completion_time[i]`.  
     - Else, `start_time[i] >= completion_time[k]`.  
     - Logical link: `assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))`.  
   - **Makespan Definition:** `makespan >= completion_time[i]` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2, 3]
arrival_times = {1: 2, 2: 5, 3: 7, 4: 9, 5: 11}
base_processing_times = {1: 8, 2: 3, 3: 8, 4: 4, 5: 3}
type_X_trucks = [3] # Trucks needing security check
security_check_time = 1.0
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Data Prep ---
    processing_times = {}
    for i in trucks:
        if i in type_X_trucks:
            processing_times[i] = base_processing_times.get(i, 0) + security_check_time
        else:
            processing_times[i] = base_processing_times.get(i, 0)

    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_38_SECURITY_CHECK")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (using effective processing time)
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Print Missing Outputs ---

if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.4f}")
                print(f"  Completion Time: {completion_time[i].x:.4f}")
    print(f"Total Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
29.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 1
  Start Time: 2.0000
  Completion Time: 10.0000
Truck 2 is assigned to Depot 1
  Start Time: 10.0000
  Completion Time: 13.0000
Truck 3 is assigned to Depot 1
  Start Time: 13.0000
  Completion Time: 22.0000
Truck 4 is assigned to Depot 1
  Start Time: 22.0000
  Completion Time: 26.0000
Truck 5 is assigned to Depot 1
  Start Time: 26.0000
  Completion Time: 29.0000
Total Makespan: 29.0000


```

================================================================================



--- Problem 433 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A busy container terminal is facing the challenge of efficiently managing the flow of trucks while minimizing operational costs. The terminal has a total of 20 truck loading bays available, but staffing all of them would be prohibitively expensive. Trucks arrive at a steady rate of 3,215 per hour, and each open bay can process 382 trucks per hour. The cost to operate a single bay is $32 per hour.  

The critical question facing the terminal manager is: *How many bays should be opened to ensure that the total processing capacity meets or exceeds the arrival rate, while keeping staffing costs as low as possible?* The solution must balance the competing demands of service efficiency (avoiding long queues) and cost control (not overstaffing).
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x`: The number of truck loading bays to open (non-negative integer).  

   **2. Parameters:**  
   - `total_bays = 20`: Maximum number of bays available.  
   - `arrival_rate = 3,215`: Trucks arriving per hour.  
   - `service_rate_per_bay = 382`: Trucks processed per hour per bay.  
   - `cost_per_bay = 32`: Cost in dollars per hour to operate one bay.  

   **3. Objective Function:**  
   Minimize the total staffing cost:  
   \[
   \text{Minimize: } 32 \cdot x
   \]  

   **4. Constraints:**  
   - **Capacity Constraint:** The total processing capacity must meet or exceed the arrival rate:  
     \[
     382 \cdot x \geq 3,215
     \]  
   - **Availability Constraint:** The number of open bays cannot exceed the total available bays:  
     \[
     x \leq 20
     \]  
   - **Non-Negativity & Integer Constraint:** `x` must be a non-negative integer.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
total_bays = 20
arrival_rate = 3215 # trucks/hour
service_rate_per_bay = 382 # trucks/hour/bay
cost_per_bay = 32 # $/hour
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# --- Model Creation ---
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    m1 = gp.Model("Truck_Bay_Staffing", env=env)

    # --- Decision Variables ---
    # Number of bays to open (ensure non-negative integer)
    x = m1.addVar(vtype=GRB.INTEGER, name="num_open_bays", lb=0)

    # --- Objective Function ---
    # Minimize total staffing cost
    m1.setObjective(cost_per_bay * x, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraint 1: Total processing capacity must meet arrival rate
    # Ensure service rate is positive before adding constraint
    if service_rate_per_bay > 0:
        m1.addConstr(service_rate_per_bay * x >= arrival_rate, name="capacity_constraint")
    else:
        # Handle case where service rate is zero (problem likely infeasible if arrival > 0)
        if arrival_rate > 0:
            print("Warning: Service rate is zero but arrival rate is positive. Setting model infeasible.")
            # How to force infeasibility? Add contradictory constraint
            m1.addConstr(x >= 1, "ForceInfeasible1")
            m1.addConstr(x <= 0, "ForceInfeasible2")
        else:
             # If arrival is also 0, x=0 is optimal, capacity constraint is 0 >= 0
             m1.addConstr(0 * x >= 0, name="capacity_constraint_zero")

    # Constraint 2: Number of open bays cannot exceed total available bays
    m1.addConstr(x <= total_bays, name="availability_constraint")

    # --- Optimization ---
    m1.optimize()

    # --- Store results ---
    results_dict['status'] = m1.status
    if m1.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m1.objVal
        results_dict['x_optimal'] = x.X # Store optimal X value

    # --- Output Results (for capture) ---
    if m1.status == GRB.OPTIMAL:
        # Use .X attribute to get the value
        optimal_x = results_dict.get('x_optimal', 'N/A')
        if not isinstance(optimal_x, (int, float)): optimal_x = -1 # Handle case where it wasn't stored

        print(f"Optimization Status: Optimal")
        print(f"Optimal number of bays to open: {int(round(optimal_x))}") # Round before int() for safety
        print(f"Minimum total staffing cost: ${m1.objVal:.2f}/hour")
        print(f"Total processing capacity: {service_rate_per_bay * optimal_x:.0f} trucks/hour (Arrival rate: {arrival_rate})")
    elif m1.status == GRB.INFEASIBLE:
        print(f"Optimization Status: Infeasible")
    else:
        print(f"Optimization Status: {m1.status}")

except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimization Status: Optimal
Optimal number of bays to open: 9
Minimum total staffing cost: $288.00/hour
Total processing capacity: 3438 trucks/hour (Arrival rate: 3215)


```

================================================================================



--- Problem 434 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy container terminal faces the daily challenge of efficiently assigning a fleet of 11 ships (S1 to S11) to six available berths (B1 to B6). The berths are categorized by size: B1, B4, and B5 are *Oversized*, while B2, B3, and B6 are *Standard*. The ships also vary in size—S3 and S4 are *Oversized*, while the rest are *Standard*. Processing times differ significantly: *Standard* ships take 49 minutes to service, while *Oversized* ships require 79 minutes.  

   The terminal manager must assign each ship to exactly one berth, adhering to strict compatibility rules: *Oversized* ships cannot use *Standard* berths (though *Standard* ships may use any berth). The goal is to minimize the *makespan*—the total time until the last ship finishes processing—by balancing workloads across berths. This ensures no single berth becomes a bottleneck, maximizing throughput for the day’s operations.  

   **Key Question:** What is the optimal assignment of ships to berths to minimize the total completion time, and what is the resulting makespan?
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `assign[s, b]`: Equals 1 if ship `s` is assigned to berth `b`; 0 otherwise.  
   - Continuous variable `berth_makespan[b]`: Total processing time for all ships assigned to berth `b`.  
   - Continuous variable `makespan`: Maximum `berth_makespan` across all berths (the objective to minimize).  

   **2. Parameters:**  
   - `process_time[ship_type]`: 49 minutes for *Standard*, 79 for *Oversized* ships.  
   - `berths`: List of berths (B1–B6) with types (`berth_types`).  
   - `ships`: List of ships (S1–S11) with types (`ship_types`).  

   **3. Objective Function:**  
   Minimize `makespan` (the longest berth processing time).  

   **4. Constraints:**  
   - **Assignment:** Each ship `s` must be assigned to exactly one berth:  
     `sum(assign[s, b] for b in berths) == 1` for all `s`.  
   - **Compatibility:** *Oversized* ships cannot use *Standard* berths:  
     `assign[s, b] == 0` for `s` in *Oversized* and `b` in *Standard*.  
   - **Berth Makespan:** Total time per berth `b` is the sum of processing times of assigned ships:  
     `berth_makespan[b] == sum(assign[s, b] * process_time[ship_types[s]] for s in ships)`.  
   - **Overall Makespan:** `makespan` must be ≥ each `berth_makespan[b]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
berths = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6']
berth_types = {'B1': 'Oversized', 'B2': 'Standard', 'B3': 'Standard', 'B4': 'Oversized', 'B5': 'Oversized', 'B6': 'Standard'}
standard_berths = ['B2', 'B3', 'B6']
oversized_berths = ['B1', 'B4', 'B5']
ships = ['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8', 'S9', 'S10', 'S11']
ship_types = {'S1': 'Standard', 'S2': 'Standard', 'S3': 'Oversized', 'S4': 'Oversized', 'S5': 'Standard', 'S6': 'Standard', 'S7': 'Standard', 'S8': 'Standard', 'S9': 'Standard', 'S10': 'Standard', 'S11': 'Standard'}
standard_ships = ['S1', 'S2', 'S5', 'S6', 'S7', 'S8', 'S9', 'S10', 'S11']
oversized_ships = ['S3', 'S4']
process_time = {'Standard': 49, 'Oversized': 79} # Type: Time
# --- End Parameters ---

GUROBI_TIME_LIMIT = 60

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m34 = gp.Model("CONTAINER_TERMINAL_BERTH_ASSIGNMENT_Makespan_MIP", env=env)

    # --- Basic Input Validation ---
    if not ships or not berths: raise ValueError("Empty ships or berths list")

    # --- Decision Variables ---
    # Binary: assign[s, b]=1 if ship s assigned to berth b
    assign_keys = [(s, b) for s in ships for b in berths]
    assign = m34.addVars(assign_keys, vtype=GRB.BINARY, name="assign")
    # Continuous: Makespan for each berth
    berth_makespan = m34.addVars(berths, name="berth_makespan", lb=0)
    # Continuous: Overall makespan (objective)
    makespan = m34.addVar(name="overall_makespan", lb=0)

    # --- Objective Function ---
    # Minimize the overall makespan
    m34.setObjective(makespan, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Assignment constraints:
    # 1. Each ship assigned to exactly one berth
    for s in ships:
        m34.addConstr(gp.quicksum(assign[s, b] for b in berths) == 1, name=f"assign_ship_{s}")

    # 2. Ships assigned only to compatible berths
    # Standard ships can use Standard or Oversized berths (as per common logic, original model disallowed Ovr)
    # Let's allow standard in oversized for flexibility (can revert if needed)
    # for s in standard_ships:
    #     for b in oversized_berths:
    #         # If standard CANNOT use oversized:
    #         # m34.addConstr(assign[s, b] == 0, name=f"std_ship_{s}_no_ovr_berth_{b}")
    #         pass # Allow standard in oversized

    # Oversized ships CANNOT use Standard berths
    for s in oversized_ships:
        for b in standard_berths:
            m34.addConstr(assign[s, b] == 0, name=f"ovr_ship_{s}_no_std_berth_{b}")

    # Makespan calculation constraints:
    # 1. Calculate makespan for each berth (sum of processing times of assigned ships)
    for b in berths:
        # Get process time based on ship type, not berth type (ship determines time)
        m34.addConstr(berth_makespan[b] == gp.quicksum(assign[s, b] * process_time.get(ship_types.get(s, 'Standard'), 0)
                                                      for s in ships), name=f"makespan_berth_{b}")

    # 2. Overall makespan is the maximum of individual berth makespans
    for b in berths:
        m34.addConstr(makespan >= berth_makespan[b], name=f"overall_makespan_ge_berth_{b}")


    # --- Optimization ---
    m34.optimize()

    # --- Store results ---
    results_dict['status'] = m34.status
    if m34.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m34.ObjVal
        # Store other results needed for the detailed output
        results_dict['makespan_sol'] = makespan.X
        results_dict['berth_makespan_sol'] = m34.getAttr('X', berth_makespan)
        results_dict['assign_sol'] = m34.getAttr('X', assign)


    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- CONTAINER_TERMINAL_BERTH_ASSIGNMENT: Container Terminal Berth Assignment (MIP) ---") # Problem 34 in original
    if m34.status == GRB.OPTIMAL:
        makespan_sol = results_dict.get('makespan_sol', 'N/A')
        berth_mk_sol = results_dict.get('berth_makespan_sol', {})
        assign_sol = results_dict.get('assign_sol', {})

        print(f"Optimization Status: Optimal")
        # Format makespan value
        if isinstance(makespan_sol, (int, float)):
             print(f"Minimum Makespan (Completion time of last ship): {makespan_sol:.1f} minutes")
        else:
             print(f"Minimum Makespan (Completion time of last ship): {makespan_sol}")

        print("Assignments and Berth Makespans:")
        assignments_dict = {} # Track assignments for final print
        for b in berths:
            ships_in_berth = []
            # Iterate through solution dictionary `assign_sol`
            for (s_key, b_key), assigned_val in assign_sol.items():
                if b_key == b and assigned_val > 0.5:
                    ships_in_berth.append(s_key)
                    assignments_dict[s_key] = b_key # Store assignment

            berth_type_print = berth_types.get(b, 'Unknown')
            berth_mk_print = berth_mk_sol.get(b, 'N/A')
            # Format berth makespan value
            if isinstance(berth_mk_print, (int, float)):
                 berth_mk_str = f"{berth_mk_print:.1f} min"
            else:
                 berth_mk_str = f"{berth_mk_print}"

            print(f"  Berth {b} ({berth_type_print}): Assigned Ships: {', '.join(ships_in_berth)}. Berth Makespan: {berth_mk_str}")
        # Optional: Verify assignment printout was commented out in original
        # print("Ship Assignments:")
        # for s in ships: print(f"  Ship {s} -> Berth {assignments_dict.get(s, 'Unassigned')}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m34.status}")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2


```
Answer:
--- CONTAINER_TERMINAL_BERTH_ASSIGNMENT: Container Terminal Berth Assignment (MIP) ---
Optimization Status: Optimal
Minimum Makespan (Completion time of last ship): 128.0 minutes
Assignments and Berth Makespans:
  Berth B1 (Oversized): Assigned Ships: S4. Berth Makespan: 79.0 min
  Berth B2 (Standard): Assigned Ships: S5, S6. Berth Makespan: 98.0 min
  Berth B3 (Standard): Assigned Ships: S9, S11. Berth Makespan: 98.0 min
  Berth B4 (Oversized): Assigned Ships: S3, S8. Berth Makespan: 128.0 min
  Berth B5 (Oversized): Assigned Ships: S1, S2. Berth Makespan: 98.0 min
  Berth B6 (Standard): Assigned Ships: S7, S10. Berth Makespan: 98.0 min



================================================================================



--- Problem 435 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port authority is tasked with scheduling crane operations for a critical container unloading project that must be completed within a tight timeframe. The project spans approximately 2.91 days, requiring a total of 17.87 work hours to finish. The challenge lies in minimizing disruptions caused by reduced crane availability during unloading. Container arrival rates vary significantly throughout the day, divided into three distinct periods: Peak (5.43 hours/day), OffPeak (6.25 hours/day), and Night (12.77 hours/day). During Peak hours, container arrivals soar to 6,145 containers per hour, while OffPeak sees 4,372 containers, and Night drops to 1,498 containers.

The team must decide how to allocate work hours across these periods while adhering to strict constraints. Normal crane capacity is 6,850 containers per hour, but crane unavailability reduces this to 3,943 containers, potentially causing delays if demand exceeds capacity. The goal is to strategically schedule work hours to minimize the total cumulative delay over the project duration. The key question is: *How should work hours be distributed across Peak, OffPeak, and Night periods to minimize container unloading disruptions while meeting the project’s hourly requirements?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `WorkHours_p`: Hours spent working in each period `p` (Peak, OffPeak, Night) per day. Continuous, non-negative.  
   - **2. Parameters:**  
     - `T_project_days = 2.91`: Total project duration in days.  
     - `TotalWorkHoursNeeded = 17.87`: Total work hours required.  
     - `WorkHoursPerDay = 6.14`: Daily work hours (`TotalWorkHoursNeeded / T_project_days`).  
     - `Duration_p`: Duration of each period (Peak: 5.43h, OffPeak: 6.25h, Night: 12.77h).  
     - `Lambda_p`: Hourly demand (Peak: 6,145 cont/h, OffPeak: 4,372 cont/h, Night: 1,498 cont/h).  
     - `C_normal = 6,850`: Normal capacity (cont/h).  
     - `C_work = 3,943`: Reduced capacity during work (cont/h).  
     - `DelayRate_p_work`: Delay rate if working in period `p` (`max(0, Lambda_p - C_work)`).  
     - `DelayRate_p_nowork`: Delay rate if not working in period `p` (`max(0, Lambda_p - C_normal)`).  
   - **3. Objective Function:**  
     Minimize total project delay:  
     `T_project_days * sum( (DelayRate_p_work * WorkHours_p) + (DelayRate_p_nowork * (Duration_p - WorkHours_p)) for all p )`.  
   - **4. Constraints:**  
     - Total daily work hours must equal `WorkHoursPerDay`:  
       `sum(WorkHours_p for all p) = 6.14`.  
     - Work hours in each period cannot exceed its duration:  
       `WorkHours_p <= Duration_p` for all `p`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
T_project_days = 2.9096952139913306
TotalWorkHoursNeeded = 17.87047199735842
periods = ['Peak', 'OffPeak', 'Night']

# Duration per period per day (hours)
Duration_p = {'Peak': 5.425441932679208, 'OffPeak': 6.248987306789458, 'Night': 12.769258759838424}
# Hourly demand per period (cont/h)
Lambda_p = {'Peak': 6144.924720055404, 'OffPeak': 4372.1580311689295, 'Night': 1497.5001996794538}
# Capacities (cont/h)
C_normal = 6849.960438937831
C_work = 3943.454367332032  # Reduced capacity due to crane unavailability

# Calculate required work hours per day (assuming uniform distribution)
WorkHoursPerDay = TotalWorkHoursNeeded / T_project_days

# --- Calculate Delay Rates (simplified: containers queued per hour if demand > capacity) ---
DelayRate_p_work = {}
DelayRate_p_nowork = {}
print("--- Delay Rate Calculation (Containers Queued per Hour) ---")
for p in periods:
    # Delay rate if working (capacity = C_work)
    rate_work = max(0, Lambda_p[p] - C_work)
    DelayRate_p_work[p] = rate_work
    # Delay rate if not working (capacity = C_normal)
    rate_nowork = max(0, Lambda_p[p] - C_normal)
    DelayRate_p_nowork[p] = rate_nowork
    print(f" Period {p}: Work Delay Rate = {rate_work:.1f} cont/h, No Work Delay Rate = {rate_nowork:.1f} cont/h")

# --- Gurobi Model ---
model = gp.Model("CraneOperationScheduling")

# --- Decision Variables ---
# WorkHours_p: Hours spent working within period p each day
WorkHours_p = model.addVars(periods, name="WorkHours", lb=0.0)

# --- Constraints ---
# 1. Total work hours per day must match the requirement
model.addConstr(gp.quicksum(WorkHours_p[p] for p in periods) == WorkHoursPerDay,
                name="DailyWorkHours")

# 2. Work hours in a period cannot exceed the duration of that period
for p in periods:
    model.addConstr(WorkHours_p[p] <= Duration_p[p], name=f"DurationLimit_{p}")

# --- Objective Function ---
# Minimize total delay over the project duration.
daily_delay_expr = gp.quicksum(DelayRate_p_work[p] * WorkHours_p[p] +
                               DelayRate_p_nowork[p] * (Duration_p[p] - WorkHours_p[p])
                               for p in periods)
total_project_delay = T_project_days * daily_delay_expr
model.setObjective(total_project_delay, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    print(f"Minimum Total Delay Proxy (Sum of hourly queue growth * duration): {model.objVal:.2f}")
    print(f"\nOptimal Work Schedule (Hours per Day):")
    total_hours_sched = 0
    for p in periods:
        print(f"  Period {p} ({Duration_p[p]}h total): Work for {WorkHours_p[p].X:.2f} hours")
        total_hours_sched += WorkHours_p[p].X
    print(f"  Total scheduled work hours per day: {total_hours_sched:.2f} (Target={WorkHoursPerDay:.2f})")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
    model.computeIIS()
    model.write("model_iis.ilp")
    print("IIS written to model_iis.ilp")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- Delay Rate Calculation (Containers Queued per Hour) ---
 Period Peak: Work Delay Rate = 2201.5 cont/h, No Work Delay Rate = 0.0 cont/h
 Period OffPeak: Work Delay Rate = 428.7 cont/h, No Work Delay Rate = 0.0 cont/h
 Period Night: Work Delay Rate = 0.0 cont/h, No Work Delay Rate = 0.0 cont/h
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 4 rows, 3 columns and 6 nonzeros
Model fingerprint: 0x6ec3c9d8
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [1e+03, 6e+03]
  Bounds range     [0e+00, 0e+00]
  RHS range        [5e+00, 1e+01]
Presolve removed 4 rows and 3 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    0.0000000e+00   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  0.000000000e+00

--- Optimization Results ---
Optimization Status: Optimal
Minimum Total Delay Proxy (Sum of hourly queue growth * duration): 0.00

Optimal Work Schedule (Hours per Day):
  Period Peak (5.425441932679208h total): Work for 0.00 hours
  Period OffPeak (6.248987306789458h total): Work for 0.00 hours
  Period Night (12.769258759838424h total): Work for 6.14 hours
  Total scheduled work hours per day: 6.14 (Target=6.14)



================================================================================



--- Problem 436 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy trucking terminal, three trucks—Truck 1, Truck 2, and Truck 3—arrive at staggered times, each requiring immediate unloading at one of the two available depots. The terminal has two depots, Depot 1 and Depot 2, each with varying processing efficiencies. Truck 1 arrives at 4:00, Truck 2 at 5:00, and Truck 3 at 7:00. The time it takes to process each truck depends on the depot assigned: for example, Truck 1 takes 2 hours at Depot 1 but 3 hours at Depot 2, while Truck 3’s processing time jumps to 10 hours if assigned to Depot 2. The terminal manager faces a critical scheduling challenge: assign each truck to exactly one depot and determine their start times such that no two trucks overlap at the same depot, all while minimizing the total processing time across all assignments. The goal is to streamline operations, reduce idle time, and ensure swift turnover of trucks to maximize terminal efficiency. The central question is: *What is the optimal depot assignment and schedule that achieves the minimum total processing time without violating arrival times or depot capacity?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary `assign[i, j]`: 1 if truck *i* is assigned to depot *j*, else 0.  
     - Continuous `start_time[i]`: Start time of truck *i*.  
     - Continuous `completion_time[i]`: Completion time of truck *i*.  
     - Binary `precedes[i, k, j]`: 1 if truck *i* is scheduled before truck *k* at depot *j*, else 0 (for *i < k*).  

   - **2. Parameters:**  
     - `arrival_times[i]`: Arrival time of truck *i* (Truck 1: 4, Truck 2: 5, Truck 3: 7).  
     - `processing_times[i, j]`: Time to process truck *i* at depot *j* (e.g., (1,1): 2, (3,2): 10).  
     - `H = 100`: A large constant for logical constraints.  

   - **3. Objective Function:**  
     Minimize the total processing time:  
     `Minimize: sum(processing_times[i, j] * assign[i, j] for all i, j)`.  

   - **4. Constraints:**  
     - Each truck assigned to exactly one depot: `sum(assign[i, j] for j) = 1` for all *i*.  
     - Start time ≥ arrival time: `start_time[i] ≥ arrival_times[i]` for all *i*.  
     - Completion time definition: `completion_time[i] = start_time[i] + sum(processing_times[i, j] * assign[i, j] for j)`.  
     - No overlapping at depots: For each depot *j* and trucks *i < k*:  
       - If `precedes[i, k, j] = 1`, then `start_time[k] ≥ completion_time[i]`.  
       - Else, `start_time[i] ≥ completion_time[k]`.  
       - Logical link: `assign[i, j] + assign[k, j] - 1 ≤ precedes[i, k, j] + (1 - precedes[i, k, j])`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
depots = [1, 2]
arrival_times = {1: 4, 2: 5, 3: 7}
processing_times = {(1, 1): 2, (1, 2): 3, (2, 1): 8, (2, 2): 6, (3, 1): 5, (3, 2): 10} # Dict {(truck, depot): time}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_46_MIN_PROC_TIME")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    # Minimize total actual processing time used
    m.setObjective(gp.quicksum(processing_times.get((i,j), 0) * assign[i,j] for i in trucks for j in depots), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (depot dependent)
    m.addConstrs((completion_time[i] == start_time[i] + gp.quicksum(processing_times.get((i,j), 0) * assign[i,j] for j in depots)
                  for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Total proc time
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Print Missing Outputs ---

if m.status == GRB.OPTIMAL:
    print("Optimal Depot Assignments and Schedules:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
    print(f"Total Processing Time: {m.objVal:.4f}")
else:
    print(f"Optimization ended with status {m.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
13.0000
Optimal Depot Assignments and Schedules:
Truck 1 assigned to Depot 1
Start Time: 4.0000, Completion Time: 6.0000
Truck 2 assigned to Depot 2
Start Time: 6.0000, Completion Time: 12.0000
Truck 3 assigned to Depot 1
Start Time: 12.0000, Completion Time: 17.0000
Total Processing Time: 13.0000


```

================================================================================



--- Problem 437 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A busy maritime port is tasked with efficiently berthing 10 incoming ships at 5 available berths. Each ship arrives at a specific time: Ship 1 at hour 4, Ship 2 at hour 6, and so on, with Ship 10 arriving at hour 27. The processing times vary—Ship 1 requires 4 hours to unload, while Ships 6 through 10 each need 10 hours. The port manager must assign each ship to exactly one berth, ensuring no two ships at the same berth overlap in time. The primary goal is to minimize the *makespan*—the total time taken to service all ships—so that the port can free up resources as quickly as possible. Additionally, due to recent weather conditions, the port has a new requirement: no ship should start unloading before its arrival time plus a 1-hour buffer. The question is: *What is the optimal berth assignment and schedule that achieves the shortest possible makespan, considering the 1-hour buffer?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary `assign[i, j]`: 1 if ship *i* is assigned to berth *j*, else 0.  
     - Continuous `start_time[i]`: When ship *i* begins processing.  
     - Continuous `completion_time[i]`: When ship *i* finishes (`start_time[i] + processing_time[i]`).  
     - Binary `precedes[i, k, j]`: 1 if ship *i* is scheduled before ship *k* at berth *j*, else 0 (for *i < k*).  
     - Continuous `makespan`: Maximum completion time across all ships.  

   - **2. Parameters:**  
     - `arrival_times[i]`: Earliest start time for ship *i* (e.g., Ship 1: 4).  
     - `processing_times[i]`: Duration for ship *i* (e.g., Ship 1: 4).  
     - `H = 200`: A large constant for logical constraints.  

   - **3. Objective Function:**  
     Minimize `makespan`.  

   - **4. Constraints:**  
     - Each ship assigned to exactly one berth: `sum(assign[i, j] for j in berths) = 1` for all *i*.  
     - Start time ≥ arrival time plus 1-hour buffer: `start_time[i] ≥ arrival_times[i] + 1` for all *i*.  
     - Completion time definition: `completion_time[i] = start_time[i] + processing_times[i]`.  
     - Non-overlapping at berths: For each berth *j* and ships *i < k*, enforce:  
       - If `precedes[i, k, j] = 1`, then `start_time[k] ≥ completion_time[i]`.  
       - Else, `start_time[i] ≥ completion_time[k]`.  
       - Logical link: `assign[i, j] + assign[k, j] - 1 ≤ precedes[i, k, j]`.  
     - Makespan definition: `makespan ≥ completion_time[i]` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
berths = [1, 2, 3, 4, 5]
arrival_times = {1: 4, 2: 6, 3: 8, 4: 11, 5: 15, 6: 19, 7: 21, 8: 23, 9: 26, 10: 27}
processing_times = {1: 4, 2: 4, 3: 5, 4: 8, 5: 8, 6: 10, 7: 10, 8: 10, 9: 10, 10: 10}
H = 200 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_18_LARGE_MAKESPAN")

    if not ships or not berths: raise ValueError("Empty ships or berths")

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in ships for k in ships if i < k for j in berths],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in ships), name="assignment")
    # 2. Arrival time plus 1-hour buffer
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) + 1 for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in ships), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")
        if m.SolCount > 0 and abs(m.ObjVal) < GRB.INFINITY :
             print(f"{m.ObjVal:.4f}")
        elif m.status != GRB.INFEASIBLE and m.status != GRB.UNBOUNDED:
             print("No feasible solution found.")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the berth assignment and schedule
if m.status == GRB.OPTIMAL:
    for i in ships:
        for j in berths:
            if assign[i, j].x > 0.5:
                print(f"Ship {i} is assigned to Berth {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
84.0000
Ship 1 is assigned to Berth 1
Start Time: 5.0000, Completion Time: 9.0000
Ship 2 is assigned to Berth 1
Start Time: 9.0000, Completion Time: 13.0000
Ship 3 is assigned to Berth 1
Start Time: 21.0000, Completion Time: 26.0000
Ship 4 is assigned to Berth 1
Start Time: 13.0000, Completion Time: 21.0000
Ship 5 is assigned to Berth 1
Start Time: 26.0000, Completion Time: 34.0000
Ship 6 is assigned to Berth 1
Start Time: 34.0000, Completion Time: 44.0000
Ship 7 is assigned to Berth 1
Start Time: 44.0000, Completion Time: 54.0000
Ship 8 is assigned to Berth 1
Start Time: 64.0000, Completion Time: 74.0000
Ship 9 is assigned to Berth 1
Start Time: 54.0000, Completion Time: 64.0000
Ship 10 is assigned to Berth 1
Start Time: 74.0000, Completion Time: 84.0000


```

================================================================================



--- Problem 438 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
At a busy urban intersection, traffic lights operate on a fixed cycle to manage the flow of vehicles. The cycle lasts 98.0 seconds, divided into green and lost time phases for both the main and side roads. The main road enjoys 46.9 seconds of green time, while the side road gets 45.6 seconds, with a total of 10 seconds lost to transition phases (5 seconds per phase). The sequence is strict: Main Green, Main Lost Time, Side Green, Side Lost Time. 

An emergency vehicle (EV) arrives at the intersection 48.5 seconds into the cycle, just as the main road’s green phase ends. Without intervention, the EV would face a 49.5-second delay—waiting for the next main green phase—costing valuable time during an emergency. However, preempting the traffic signal to grant immediate green access to the EV could disrupt general traffic, increasing delays for other vehicles by an estimated 500 vehicle-seconds. 

The challenge is to decide whether to preempt the signal or not, weighing the EV’s urgency (weighted at 10.46 per second of delay) against the inconvenience to general traffic (weighted at 1.09 per vehicle-second). The goal is to minimize the total weighted cost of delays, balancing public safety and traffic efficiency.

Additionally, it is noted that the weather conditions are currently clear, and there are no ongoing construction activities in the vicinity. These factors do not affect the optimization model or the decision-making process.
**

2. **Modeling Process:**
**
**1. Decision Variables:**  
- `y(s)`: Binary variable indicating whether strategy `s` is chosen (`s ∈ {'NoPreemption', 'Preemption'}`).  

**2. Parameters:**  
- `C_cycle = 98.0`: Total traffic light cycle time (seconds).  
- `g_main_normal = 46.9`: Main road green time (seconds).  
- `g_side_normal = 45.6`: Side road green time (seconds).  
- `L_lost_time_total = 10.0`: Total lost time (seconds).  
- `T_ev_arrival = 48.5`: EV arrival time (seconds).  
- `T_ev_pass_duration = 11.1`: EV passage duration (seconds).  
- `W_ev = 10.46`: Weight for EV delay.  
- `W_gen = 1.09`: Weight for general traffic delay.  
- `strategy_costs`: Precomputed costs for each strategy:  
  - `NoPreemption`: EV delay cost = 517.24.  
  - `Preemption`: General traffic delay cost = 544.95.  

**3. Objective Function:**  
Minimize the total weighted cost:  
`Minimize: y('NoPreemption') * 517.24 + y('Preemption') * 544.95`.  

**4. Constraints:**  
- **Single Strategy Selection:** Exactly one strategy must be chosen:  
  `y('NoPreemption') + y('Preemption') = 1`.  

---

3. **Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
C_cycle = 98.00295380016341  # s
g_main_normal = 46.93291944094668  # s
g_side_normal = 45.59851456877819  # s
L_lost_time_total = C_cycle - g_main_normal - g_side_normal  # = 10s -> 5s per phase

# Assume phase sequence: Main Green -> Main L -> Side Green -> Side L
main_green_end = g_main_normal
main_lost_end = main_green_end + L_lost_time_total / 2.0
side_green_end = main_lost_end + g_side_normal
side_lost_end = C_cycle

# EV Arrival time
T_ev_arrival = 48.54727667793237  # seconds
T_ev_pass_duration = 11.097378590382942  # seconds
W_ev = 10.458624676524304  # Weight for EV delay
W_gen = 1.089905255493566  # Weight for general traffic delay increase

strategies = ['NoPreemption', 'Preemption']

# --- Calculate Delays for each strategy ---
strategy_costs = {}
print("--- Cost Calculation per Strategy ---")

# Strategy N: No Preemption
ev_delay_N = 0
current_time_in_cycle = T_ev_arrival % C_cycle
if not (0 <= current_time_in_cycle < main_green_end):  # Check if EV arrives during main green
    # EV arrives during red or side green. Calculate wait time till next main green.
    time_to_next_main_green = C_cycle - current_time_in_cycle
    ev_delay_N = time_to_next_main_green
gen_delay_increase_N = 0  # Baseline
total_cost_N = ev_delay_N * W_ev + gen_delay_increase_N * W_gen
strategy_costs['NoPreemption'] = total_cost_N
print(f" Strategy 'NoPreemption':")
print(f"  EV arrives at {T_ev_arrival:.1f}s. Cycle pos: {current_time_in_cycle:.1f}s.")
print(f"  EV Delay = {ev_delay_N:.1f}s")
print(f"  General Traffic Delay Increase = {gen_delay_increase_N:.1f} veh*s (Baseline)")
print(f"  Total Weighted Cost = {total_cost_N:.2f}")

# Strategy P: Preemption
ev_delay_P = 0  # Preemption ensures green on arrival
# Estimate general traffic delay increase
lost_side_green = 0
if main_lost_end <= current_time_in_cycle < side_green_end:
     lost_side_green = side_green_end - current_time_in_cycle
# Main green gained: T_ev_pass_duration
gained_main_green = T_ev_pass_duration
# Estimate of delay impact
gen_delay_increase_P = 500.0  # Placeholder veh*s
total_cost_P = ev_delay_P * W_ev + gen_delay_increase_P * W_gen
strategy_costs['Preemption'] = total_cost_P
print(f" Strategy 'Preemption':")
print(f"  EV Delay = {ev_delay_P:.1f}s")
print(f"  Estimated General Traffic Delay Increase = {gen_delay_increase_P:.1f} veh*s")
print(f"  Total Weighted Cost = {total_cost_P:.2f}")

# --- Gurobi Model (Simple selection) ---
model = gp.Model("EV_Preemption_Choice")

# --- Decision Variables ---
y = model.addVars(strategies, vtype=GRB.BINARY, name="ChooseStrategy")

# --- Constraints ---
model.addConstr(gp.quicksum(y[s] for s in strategies) == 1, name="SelectOneStrategy")

# --- Objective Function ---
# Minimize the total weighted cost
objective = gp.quicksum(y[s] * strategy_costs[s] for s in strategies)
model.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    chosen_strategy = ""
    for s in strategies:
        if y[s].X > 0.9:
            chosen_strategy = s
            break

    if chosen_strategy:
         print(f"Optimal Preemption Strategy: {chosen_strategy}")
         print(f" Minimum Total Weighted Cost: {model.objVal:.2f}")
    else:
         print("Error: No strategy selected.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- Cost Calculation per Strategy ---
 Strategy 'NoPreemption':
  EV arrives at 48.5s. Cycle pos: 48.5s.
  EV Delay = 49.5s
  General Traffic Delay Increase = 0.0 veh*s (Baseline)
  Total Weighted Cost = 517.24
 Strategy 'Preemption':
  EV Delay = 0.0s
  Estimated General Traffic Delay Increase = 500.0 veh*s
  Total Weighted Cost = 544.95
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 2 columns and 2 nonzeros
Model fingerprint: 0xc269a392
Variable types: 0 continuous, 2 integer (2 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [5e+02, 5e+02]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 517.2383651
Presolve removed 1 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 1: 517.238 

Optimal solution found (tolerance 1.00e-04)
Best objective 5.172383651448e+02, best bound 5.172383651448e+02, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Preemption Strategy: NoPreemption
 Minimum Total Weighted Cost: 517.24



================================================================================



--- Problem 439 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with loading 14 packages of varying weights onto a selection of 7 available truck types, each with distinct capacities and associated costs. The packages range from lightweight (4 units) to heavier ones (90 units), while the trucks offer different trade-offs between capacity and cost—some are spacious but expensive (e.g., 100-unit capacity at $3), while others are more constrained but cheaper (e.g., 90-unit capacity at $81). The challenge is to assign every package to exactly one truck without exceeding the truck's capacity, while minimizing the total cost of trucks used. The operational stakes are high: selecting inefficient truck combinations could inflate expenses, but underutilizing trucks wastes resources. The core question is: *What is the cheapest way to load all packages while respecting each truck's limits?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[i, j]`: Binary variable (1 if package *i* is assigned to truck *j*; 0 otherwise).  
     - `y[j]`: Binary variable (1 if truck *j* is used; 0 otherwise).  
   - **2. Parameters:**  
     - `packages[i]`: Weight of package *i* (e.g., 44, 41, ..., 76).  
     - `trucks[j]`: Tuple of (capacity, cost) for truck *j* (e.g., (99, 100), (94, 94)).  
   - **3. Objective Function:**  
     Minimize total cost:  
     `Minimize: sum(y[j] * trucks[j][1] for all j)`  
   - **4. Constraints:**  
     - **Package assignment:** Each package must be in exactly one truck:  
       `sum(x[i, j] for all j) = 1` for every package *i*.  
     - **Truck capacity:** Total weight in truck *j* cannot exceed its capacity:  
       `sum(packages[i] * x[i, j] for all i) <= trucks[j][0] * y[j]` for every truck *j*.  
     - **Linking constraint:** A package can only be placed in a truck if the truck is used:  
       `x[i, j] <= y[j]` for every package *i* and truck *j*.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys # Make sys available inside exec if needed, e.g. for print traceback
import traceback

# --- Data Definition (Embedded) ---
packages = [44, 41, 4, 40, 20, 90, 40, 12, 42, 51, 8, 76, 17, 17]      # Package weights
trucks = [(99, 100), (94, 94), (90, 81), (100, 3), (90, 53), (95, 31), (93, 65)]        # List of (Capacity, Cost) tuples
num_packages = 14       # len(packages)
num_trucks = 7         # len(trucks)
# --- End Data Definition ---

# Time limit (passed from outer scope via globals if needed, or hardcoded)
GUROBI_TIME_LIMIT = 60

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Keep output clean for saving
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Cost-Sensitive Truck Loading", env=env)

    # --- Decision Variables ---
    x = model.addVars(num_packages, num_trucks, vtype=GRB.BINARY, name="x")
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")

    # --- Objective: Minimize total cost ---
    model.setObjective(gp.quicksum(y[j] * trucks[j][1] for j in range(num_trucks)), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Each package assignment
    for i in range(num_packages):
        model.addConstr(x.sum(i, '*') == 1, name=f"Package_{i}_Assignment")

    # 2. Truck capacity
    for j in range(num_trucks):
        truck_capacity = trucks[j][0]
        if truck_capacity < 0: truck_capacity = 0
        model.addConstr(gp.quicksum(packages[i] * x[i, j] for i in range(num_packages)) <= truck_capacity * y[j], name=f"Truck_{j}_Capacity")

    # 3. Linking package to truck usage
    for i in range(num_packages):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Package_{i}_Triggers_Truck_{j}")

    # --- Solve ---
    # print("Solving CS-TL instance...") # Comment out or keep for debug inside output
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal

    # --- Output results (This will be captured) ---
    # This logic needs to be *inside* the template now
    if model.status == GRB.OPTIMAL:
        print(f"Minimum cost: ${model.objVal:.2f}") # Use model.objVal directly
        print("-" * 30) # Add separator for clarity
        printed_truck_count = 0
        for j in range(num_trucks):
            # Use try-except for safety when accessing .X
            try:
                 if y[j].x > 0.5:
                     printed_truck_count += 1
                     truck_capacity_out, truck_cost_out = trucks[j]
                     assigned_packages = [i for i in range(num_packages) if x[i, j].x > 0.5]
                     truck_load_out = sum(packages[i] for i in assigned_packages)
                     # Format output exactly as desired for the log file
                     print(f"Truck {printed_truck_count} (Type Index {j}, Capacity: {truck_capacity_out}, Cost: ${truck_cost_out:.2f}):")
                     print(f"  Load: {truck_load_out} / {truck_capacity_out}")
                     print(f"  Packages (indices): {sorted(assigned_packages)}") # Sort for consistency
                     print("-" * 10) # Separator between trucks
            except AttributeError:
                 pass # Ignore trucks not used or if .X attribute missing
    elif model.status == GRB.TIME_LIMIT:
        print("\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: ${model.ObjVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {model.status}")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}") # Print errors to captured output
    results_dict['status'] = -1 # Use dict to signal error type to main loop
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:") # Print errors
    traceback.print_exc(file=sys.stdout) # Print traceback to captured stdout
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Minimum cost: $327.00
------------------------------
Truck 1 (Type Index 1, Capacity: 94, Cost: $94.00):
  Load: 88 / 94
  Packages (indices): [7, 8, 12, 13]
----------
Truck 2 (Type Index 2, Capacity: 90, Cost: $81.00):
  Load: 90 / 90
  Packages (indices): [5]
----------
Truck 3 (Type Index 3, Capacity: 100, Cost: $3.00):
  Load: 100 / 100
  Packages (indices): [1, 9, 10]
----------
Truck 4 (Type Index 4, Capacity: 90, Cost: $53.00):
  Load: 84 / 90
  Packages (indices): [0, 3]
----------
Truck 5 (Type Index 5, Capacity: 95, Cost: $31.00):
  Load: 64 / 95
  Packages (indices): [2, 4, 6]
----------
Truck 6 (Type Index 6, Capacity: 93, Cost: $65.00):
  Load: 76 / 93
  Packages (indices): [11]
----------


```

================================================================================



--- Problem 440 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port terminal is tasked with efficiently scheduling a set of eight container ships into the smallest number of berths to minimize operational costs and optimize berth utilization. Each ship has specific dimensions: Ship 0 (24x10), Ship 1 (54x35), Ship 2 (27x53), Ship 3 (48x32), Ship 4 (29x22), Ship 5 (43x50), Ship 6 (17x53), and Ship 7 (8x47). The berths available measure 55 units in width and 65 units in length. The challenge lies not only in fitting all ships into the berths but also in ensuring that no two ships in the same berth overlap, while strategically positioning them to maximize space efficiency. The terminal manager seeks the minimal number of berths required to accommodate all ships without violating these spatial constraints, thereby reducing operational overhead and maximizing berth density.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `x[i, j]`: 1 if ship *i* is assigned to berth *j*, else 0.  
     - Binary variable `y[j]`: 1 if berth *j* is used, else 0.  
     - Continuous variables `px[i, j]` and `py[i, j]`: Bottom-left coordinates of ship *i* in berth *j*.  
     - Auxiliary binary variables (`left`, `right`, `below`, `above`): Enforce non-overlapping conditions between pairs of ships in the same berth.  

   - **2. Parameters:**  
     - `ships`: List of ship dimensions (width, length).  
     - `berth_size`: (55, 65).  
     - `num_ships = 8`, `num_berths = 8` (worst-case upper bound).  
     - Big-M values: `M_w = 55`, `M_h = 65` (berth dimensions).  

   - **3. Objective Function:**  
     Minimize the total number of berths used:  
     \[
     \text{Minimize: } \sum_{j=1}^{8} y[j]
     \]  

   - **4. Constraints:**  
     - **Assignment:** Each ship must be placed in exactly one berth:  
       \[
       \sum_{j=1}^{8} x[i, j] = 1 \quad \forall i \in \{0, \dots, 7\}
       \]  
     - **Berth Boundaries:** Ships must fit within their assigned berth:  
       \[
       px[i, j] + \text{ship}_i\text{.width} \leq 55 \quad \text{if } x[i, j] = 1 \\
       py[i, j] + \text{ship}_i\text{.length} \leq 65 \quad \text{if } x[i, j] = 1
       \]  
     - **Non-Overlapping:** For any two ships (*i*, *k*) in the same berth *j*, enforce at least one spatial separation (left/right/below/above).  
     - **Berth Activation:** If any ship is assigned to berth *j*, mark it as used:  
       \[
       x[i, j] \leq y[j] \quad \forall i, j
       \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum

# --- Data Definition ---
ships = [(24, 10), (54, 35), (27, 53), (48, 32), (29, 22), (43, 50), (17, 53), (8, 47)]  # (width, length) of ships
berth_size = (55, 65)  # (width, length) of each berth
num_ships = 8 # len(ships)
# Maximum berths needed (worst case: one ship per berth)
# Can sometimes be reduced with lower bounds, but num_ships is safe
num_berths = num_ships
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Big-M values (using berth dimensions is common and valid)
M_w = berth_size[0]
M_h = berth_size[1]

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set parameters for potentially long runs
# env.setParam('TimeLimit', 120) # e.g., 120 seconds
# env.setParam('MIPGap', 0.01)  # Stop when 1% gap reached
env.start()

# Create model
model = Model("2D Berth Packing", env=env)

# --- Decision Variables ---
# x[i,j]: ship i assigned to berth j
x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")
# y[j]: berth j is used
y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")
# px[i,j], py[i,j]: bottom-left corner position of ship i if in berth j
px = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="px")
py = model.addVars(num_ships, num_berths, vtype=GRB.CONTINUOUS, lb=0, name="py")

# --- Non-overlapping auxiliary variables ---
# These define relative positions between pairs of ships *within the same berth*
left  = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="left")
right = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="right")
below = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="below")
above = model.addVars(num_ships, num_ships, num_berths, vtype=GRB.BINARY, name="above")

# --- Objective Function: Minimize the number of berths used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE) # Same as quicksum(y[j] for j in range(num_berths))

# --- Constraints ---

# 1. Each ship must be assigned to exactly one berth
for i in range(num_ships):
    model.addConstr(x.sum(i, '*') == 1, name=f"Ship_{i}_Assignment")

# 2. Ship placement constraints within berth boundaries (Big-M formulation)
for j in range(num_berths):
    for i in range(num_ships):
        ship_w, ship_l = ships[i] # Get dimensions for ship i

        # Position variables must be 0 if ship i is not in berth j
        # (Technically redundant if objective minimizes position, but good for clarity/tightness)
        model.addConstr(px[i, j] <= M_w * x[i, j], name=f"PosX_Zero_{i}_{j}")
        model.addConstr(py[i, j] <= M_h * x[i, j], name=f"PosY_Zero_{i}_{j}")

        # Ship's right edge <= berth width IF ship is placed in berth (x[i,j]=1)
        model.addConstr(px[i, j] + ship_w <= berth_size[0] + M_w * (1 - x[i, j]), name=f"Width_Limit_{i}_{j}")
        # Ship's top edge <= berth length IF ship is placed in berth (x[i,j]=1)
        model.addConstr(py[i, j] + ship_l <= berth_size[1] + M_h * (1 - x[i, j]), name=f"Length_Limit_{i}_{j}")

# 3. Non-overlapping constraints for ships within the same berth
for j in range(num_berths):
    for i in range(num_ships):
        for k in range(i + 1, num_ships): # Iterate over distinct pairs (i < k)
            ship_i_w, ship_i_l = ships[i]
            ship_k_w, ship_k_l = ships[k]

            # Link relative position variables to coordinates (Big-M)
            # If left[i,k,j]=1 => ship i is to the left of ship k
            model.addConstr(px[i, j] + ship_i_w <= px[k, j] + M_w * (1 - left[i, k, j]), name=f"Overlap_Left_{i}_{k}_{j}")
            # If right[i,k,j]=1 => ship i is to the right of ship k (k is left of i)
            model.addConstr(px[k, j] + ship_k_w <= px[i, j] + M_w * (1 - right[i, k, j]), name=f"Overlap_Right_{i}_{k}_{j}")
            # If below[i,k,j]=1 => ship i is below ship k
            model.addConstr(py[i, j] + ship_i_l <= py[k, j] + M_h * (1 - below[i, k, j]), name=f"Overlap_Below_{i}_{k}_{j}")
            # If above[i,k,j]=1 => ship i is above ship k (k is below i)
            model.addConstr(py[k, j] + ship_k_l <= py[i, j] + M_h * (1 - above[i, k, j]), name=f"Overlap_Above_{i}_{k}_{j}")

            # Logic: If BOTH ship i and ship k are in berth j, AT LEAST ONE relative position must hold
            # M*(x[i,j] + x[k,j] - 1) <= M*(left + right + below + above)
            # Simplified: left + right + below + above >= x[i,j] + x[k,j] - 1
            model.addConstr(left[i, k, j] + right[i, k, j] + below[i, k, j] + above[i, k, j] >= x[i, j] + x[k, j] - 1, name=f"NonOverlap_Logic_{i}_{k}_{j}")

# 4. Link ship assignment to berth usage: If any ship i is in berth j, then berth j must be used (y[j]=1)
#    This can be done per ship or aggregated. Per ship is often tighter.
for j in range(num_berths):
    for i in range(num_ships):
        model.addConstr(x[i, j] <= y[j], name=f"Ship_Berth_Activation_{i}_{j}")
    # Alternative aggregated constraint (weaker):
    # model.addConstr(x.sum('*', j) <= num_ships * y[j], name=f"Berth_Activation_{j}")


# --- Solve ---
print("Solving 2DBP instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# (This part mainly runs inside exec, results checked via dict by caller)
if results_dict.get('status') == GRB.OPTIMAL:
    print(f"\nOptimal number of berths used: {int(results_dict.get('obj_val', -1))}")
    print("-" * 30)
    berth_details = [] # Store details for potential use by caller if needed
    for j_sol in range(num_berths):
        if y[j_sol].X > 0.5:  # Use .X with Gurobi v9+
            print(f"Berth {j_sol + 1} (Used):")
            ships_in_berth_info = []
            for i_sol in range(num_ships):
                if x[i_sol, j_sol].X > 0.5:
                    ship_data = {
                        "id": i_sol,
                        "dims": ships[i_sol],
                        "pos": (round(px[i_sol, j_sol].X, 2), round(py[i_sol, j_sol].X, 2))
                    }
                    ships_in_berth_info.append(ship_data)
                    print(f"  Ship {ship_data['id']} {ship_data['dims']} at {ship_data['pos']}")
            berth_details.append({'berth_index': j_sol, 'ships': ships_in_berth_info})
            print("-" * 10)
    results_dict['berth_details'] = berth_details # Store placement details

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
    # IIS computation might be desired but makes exec more complex to handle file writes
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     if model.SolCount > 0:
        print(f"Best objective found: {model.ObjVal}")
     else:
        print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    # Error occurred before status could be set
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving 2DBP instance...
Gurobi Error code 10010: Model too large for size-limited license; visit https://gurobi.com/unrestricted for more information

Optimization finished with status: -1. No optimal solution found.


```

================================================================================



--- Problem 441 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy maritime port is managing the berthing of ships at two different docks, Dock B and Dock C. Currently, there are 84 available berthing slots at the main dock, while Dock B and Dock C have a deficit of 41 and 38 slots, respectively. The port has a fleet of 5 tugboats, each with a capacity to tow 19 ships. The logistics team must decide how many tugboats to send to each dock and how many ships to tow, aiming to minimize costs. The cost of sending a tugboat to Dock B is \$126, while sending one to Dock C costs \$67. The primary challenge is to fulfill the exact demand at Docks B and C while keeping transportation costs as low as possible, ensuring no tugboat exceeds its capacity and the total number of tugboats used does not exceed the available fleet.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n_B`: Integer, number of tugboats sent to Dock B (0 ≤ `n_B` ≤ 5).  
     - `n_C`: Integer, number of tugboats sent to Dock C (0 ≤ `n_C` ≤ 5).  
     - `x_AB`: Integer, number of ships towed from the main dock to Dock B (≥ 0).  
     - `x_AC`: Integer, number of ships towed from the main dock to Dock C (≥ 0).  

   - **2. Parameters:**  
     - `surplus_A = 84`: Berthing slots available at the main dock.  
     - `deficit_B = 41`, `deficit_C = 38`: Berthing slots needed at Docks B and C.  
     - `tug_capacity = 19`: Maximum ships per tugboat.  
     - `num_tugs = 5`: Total tugboats available.  
     - `cost_AB = 126`, `cost_AC = 67`: Cost per tugboat to Docks B and C.  

   - **3. Objective Function:**  
     Minimize total cost:  
     \[
     \text{Minimize: } 126 \cdot n_B + 67 \cdot n_C
     \]  

   - **4. Constraints:**  
     - **Tug Fleet Limit:** \( n_B + n_C \leq 5 \).  
     - **Tug Capacity:**  
       - \( x_AB \leq 19 \cdot n_B \).  
       - \( x_AC \leq 19 \cdot n_C \).  
     - **Supply Limit:** \( x_AB + x_AC \leq 84 \).  
     - **Demand Fulfillment:**  
       - \( x_AB \geq 41 \).  
       - \( x_AC \geq 38 \).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
surplus_A = 84
deficit_B = 41
deficit_C = 38
tug_capacity = 19
num_tugs = 5
cost_AB = 126
cost_AC = 67
# --- End Parameters ---

GUROBI_TIME_LIMIT = 20

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("SHIP_BERTHING_COST", env=env)

    # --- Decision Variables ---
    # n_B: number of tugboats going to Dock B
    n_B = m.addVar(vtype=GRB.INTEGER, lb=0, ub=num_tugs, name="n_B")
    # n_C: number of tugboats going to Dock C
    n_C = m.addVar(vtype=GRB.INTEGER, lb=0, ub=num_tugs, name="n_C")
    # x_AB: number of ships towed from the main dock to Dock B
    x_AB = m.addVar(vtype=GRB.INTEGER, lb=0, name="x_AB")
    # x_AC: number of ships towed from the main dock to Dock C
    x_AC = m.addVar(vtype=GRB.INTEGER, lb=0, name="x_AC")

    # --- Objective Function: Minimize transportation cost ---
    m.setObjective(cost_AB * n_B + cost_AC * n_C, GRB.MINIMIZE)

    # --- Constraints ---
    # Total number of tugboats used
    m.addConstr(n_B + n_C <= num_tugs, "TotalTugs")

    # Towed amount cannot exceed tugboat capacity
    # Handle tug_capacity = 0 case
    if tug_capacity > 0:
        m.addConstr(x_AB <= tug_capacity * n_B, "CapacityB")
        m.addConstr(x_AC <= tug_capacity * n_C, "CapacityC")
    else:
        # If capacity is 0, cannot transport ships
        m.addConstr(x_AB == 0, "CapacityB_Zero")
        m.addConstr(x_AC == 0, "CapacityC_Zero")

    # Towed amount cannot exceed surplus at the main dock
    m.addConstr(x_AB + x_AC <= surplus_A, "SupplyA")

    # Towed amount must meet deficit (Original didn't require this, but realistic)
    # Making this optional based on original snippet focusing only on cost.
    # However, without a demand constraint, solution might be trivial (move 0 ships).
    # Let's assume the goal IS to meet demand if possible, while minimizing tugboat cost.
    # Add constraints to meet demand:
    m.addConstr(x_AB >= deficit_B, "MeetDemandB")
    m.addConstr(x_AC >= deficit_C, "MeetDemandC")
    # Note: The original snippet had these as upper bounds (<= deficit).
    # If the goal is just to minimize cost *given* fixed moves, the model changes.
    # Reverting to original snippet's logic (less realistic but matches code):
    # m.addConstr(x_AB <= deficit_B, "DemandB_Limit") # Limit ships moved
    # m.addConstr(x_AC <= deficit_C, "DemandC_Limit") # Limit ships moved
    # **Correction:** The goal is likely to meet demand *while* minimizing cost.
    # The model should try to fulfill demand. Keeping the >= constraints.

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['n_B_sol'] = n_B.X # Not needed for output
        # results_dict['n_C_sol'] = n_C.X
        # results_dict['x_AB_sol'] = x_AB.X
        # results_dict['x_AC_sol'] = x_AC.X

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
         print("Model is infeasible") # Matches example
    else:
        print(f"Optimization ended with status {m.Status}") # Matches example

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print missing outputs
if m.Status == GRB.OPTIMAL:
    n_B_sol = n_B.X
    n_C_sol = n_C.X
    x_AB_sol = x_AB.X
    x_AC_sol = x_AC.X
    print(f"Number of tugboats sent to Dock B: {n_B_sol}")
    print(f"Number of tugboats sent to Dock C: {n_C_sol}")
    print(f"Number of ships towed from the main dock to Dock B: {x_AB_sol}")
    print(f"Number of ships towed from the main dock to Dock C: {x_AC_sol}")
```
Answer:
Optimal objective value: 512.00
Number of tugboats sent to Dock B: 3.0
Number of tugboats sent to Dock C: 2.0
Number of ships towed from the main dock to Dock B: 41.0
Number of ships towed from the main dock to Dock C: 38.0


```

================================================================================



--- Problem 442 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port is facing the challenge of efficiently assigning a fleet of 20 ships to its limited berths to minimize the total processing time. The port has five berths: two standard berths (B1, B2) and three oversized berths (B3, B4, B5). The ships vary in size—12 are standard (e.g., S1, S3, S5) and require 24 minutes each to process, while 8 are oversized (e.g., S2, S4, S10) and take 71 minutes each. A critical rule enforces that oversized ships cannot use standard berths, though standard ships can utilize any berth. The port manager seeks an assignment strategy that balances the workload across berths, ensuring the last ship finishes as early as possible. The core question is: *How should the ships be distributed across the berths to minimize the total completion time (makespan)?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `assign[s, b]`: 1 if ship `s` is assigned to berth `b`, 0 otherwise.  
     - Continuous variable `berth_makespan[b]`: Total processing time for berth `b`.  
     - Continuous variable `makespan`: Maximum processing time across all berths (objective).  

   - **2. Parameters:**  
     - `berths`: List of berths (B1–B5).  
     - `ships`: List of ships (S1–S20).  
     - `ship_types[s]`: Type ("Standard" or "Oversized") of ship `s`.  
     - `process_time[type]`: Processing time (24 min for standard, 71 min for oversized).  

   - **3. Objective Function:**  
     Minimize `makespan` (the maximum `berth_makespan[b]` across all berths).  

   - **4. Constraints:**  
     - Each ship assigned to exactly one berth:  
       `sum(assign[s, b] for b in berths) == 1` for all `s` in `ships`.  
     - Oversized ships cannot use standard berths:  
       `assign[s, b] == 0` for oversized `s` and standard `b`.  
     - Berth makespan calculation:  
       `berth_makespan[b] = sum(assign[s, b] * process_time[ship_types[s]] for s in ships)`.  
     - Overall makespan definition:  
       `makespan >= berth_makespan[b]` for all `b` in `berths`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
berths = ['B1', 'B2', 'B3', 'B4', 'B5']
berth_types = {'B1': 'Standard', 'B2': 'Standard', 'B3': 'Oversized', 'B4': 'Oversized', 'B5': 'Oversized'}
standard_berths = ['B1', 'B2']
oversized_berths = ['B3', 'B4', 'B5']
ships = ['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8', 'S9', 'S10', 'S11', 'S12', 'S13', 'S14', 'S15', 'S16', 'S17', 'S18', 'S19', 'S20']
ship_types = {'S1': 'Standard', 'S2': 'Oversized', 'S3': 'Standard', 'S4': 'Oversized', 'S5': 'Standard', 'S6': 'Standard', 'S7': 'Standard', 'S8': 'Standard', 'S9': 'Standard', 'S10': 'Oversized', 'S11': 'Standard', 'S12': 'Standard', 'S13': 'Standard', 'S14': 'Oversized', 'S15': 'Oversized', 'S16': 'Oversized', 'S17': 'Oversized', 'S18': 'Oversized', 'S19': 'Standard', 'S20': 'Standard'}
standard_ships = ['S1', 'S3', 'S5', 'S6', 'S7', 'S8', 'S9', 'S11', 'S12', 'S13', 'S19', 'S20']
oversized_ships = ['S2', 'S4', 'S10', 'S14', 'S15', 'S16', 'S17', 'S18']
process_time = {'Standard': 24, 'Oversized': 71} # Type: Time
# --- End Parameters ---

GUROBI_TIME_LIMIT = 60

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m34 = gp.Model("PORT_BERTH_ASSIGNMENT_Makespan_MIP", env=env)

    # --- Basic Input Validation ---
    if not ships or not berths: raise ValueError("Empty ships or berths list")

    # --- Decision Variables ---
    # Binary: assign[s, b]=1 if ship s assigned to berth b
    assign_keys = [(s, b) for s in ships for b in berths]
    assign = m34.addVars(assign_keys, vtype=GRB.BINARY, name="assign")
    # Continuous: Makespan for each berth
    berth_makespan = m34.addVars(berths, name="berth_makespan", lb=0)
    # Continuous: Overall makespan (objective)
    makespan = m34.addVar(name="overall_makespan", lb=0)

    # --- Objective Function ---
    # Minimize the overall makespan
    m34.setObjective(makespan, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Assignment constraints:
    # 1. Each ship assigned to exactly one berth
    for s in ships:
        m34.addConstr(gp.quicksum(assign[s, b] for b in berths) == 1, name=f"assign_ship_{s}")

    # 2. Ships assigned only to compatible berths
    # Standard ships can use Standard or Oversized berths (as per common logic, original model disallowed Ovr)
    # Let's allow standard in oversized for flexibility (can revert if needed)
    # for s in standard_ships:
    #     for b in oversized_berths:
    #         # If standard CANNOT use oversized:
    #         # m34.addConstr(assign[s, b] == 0, name=f"std_ship_{s}_no_ovr_berth_{b}")
    #         pass # Allow standard in oversized

    # Oversized ships CANNOT use Standard berths
    for s in oversized_ships:
        for b in standard_berths:
            m34.addConstr(assign[s, b] == 0, name=f"ovr_ship_{s}_no_std_berth_{b}")

    # Makespan calculation constraints:
    # 1. Calculate makespan for each berth (sum of processing times of assigned ships)
    for b in berths:
        # Get process time based on ship type, not berth type (ship determines time)
        m34.addConstr(berth_makespan[b] == gp.quicksum(assign[s, b] * process_time.get(ship_types.get(s, 'Standard'), 0)
                                                    for s in ships), name=f"makespan_berth_{b}")

    # 2. Overall makespan is the maximum of individual berth makespans
    for b in berths:
        m34.addConstr(makespan >= berth_makespan[b], name=f"overall_makespan_ge_berth_{b}")


    # --- Optimization ---
    m34.optimize()

    # --- Store results ---
    results_dict['status'] = m34.status
    if m34.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m34.ObjVal
        # Store other results needed for the detailed output
        results_dict['makespan_sol'] = makespan.X
        results_dict['berth_makespan_sol'] = m34.getAttr('X', berth_makespan)
        results_dict['assign_sol'] = m34.getAttr('X', assign)


    # --- Output Results ---
    # IMPORTANT: Replicate the detailed output format from the original snippet
    print(f"--- PORT_BERTH_ASSIGNMENT: Port Ship Berth Assignment (MIP) ---") # Problem 34 in original
    if m34.status == GRB.OPTIMAL:
        makespan_sol = results_dict.get('makespan_sol', 'N/A')
        berth_mk_sol = results_dict.get('berth_makespan_sol', {})
        assign_sol = results_dict.get('assign_sol', {})

        print(f"Optimization Status: Optimal")
        # Format makespan value
        if isinstance(makespan_sol, (int, float)):
             print(f"Minimum Makespan (Completion time of last ship): {makespan_sol:.1f} minutes")
        else:
             print(f"Minimum Makespan (Completion time of last ship): {makespan_sol}")

        print("Assignments and Berth Makespans:")
        assignments_dict = {} # Track assignments for final print
        for b in berths:
            ships_in_berth = []
            # Iterate through solution dictionary `assign_sol`
            for (s_key, b_key), assigned_val in assign_sol.items():
                if b_key == b and assigned_val > 0.5:
                    ships_in_berth.append(s_key)
                    assignments_dict[s_key] = b_key # Store assignment

            berth_type_print = berth_types.get(b, 'Unknown')
            berth_mk_print = berth_mk_sol.get(b, 'N/A')
            # Format berth makespan value
            if isinstance(berth_mk_print, (int, float)):
                 berth_mk_str = f"{berth_mk_print:.1f} min"
            else:
                 berth_mk_str = f"{berth_mk_print}"

            print(f"  Berth {b} ({berth_type_print}): Assigned Ships: {', '.join(ships_in_berth)}. Berth Makespan: {berth_mk_str}")
        # Optional: Verify assignment printout was commented out in original
        # print("Ship Assignments:")
        # for s in ships: print(f"  Ship {s} -> Berth {assignments_dict.get(s, 'Unassigned')}")

    else:
        # Match the generic non-optimal status message
        print(f"Optimization Status: {m34.status}")


except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- PORT_BERTH_ASSIGNMENT: Port Ship Berth Assignment (MIP) ---
Optimization Status: Optimal
Minimum Makespan (Completion time of last ship): 213.0 minutes
Assignments and Berth Makespans:
  Berth B1 (Standard): Assigned Ships: S3, S5, S9, S13. Berth Makespan: 96.0 min
  Berth B2 (Standard): Assigned Ships: S6, S7, S8, S11, S12, S19, S20. Berth Makespan: 168.0 min
  Berth B3 (Oversized): Assigned Ships: S1, S10, S14. Berth Makespan: 166.0 min
  Berth B4 (Oversized): Assigned Ships: S15, S17, S18. Berth Makespan: 213.0 min
  Berth B5 (Oversized): Assigned Ships: S2, S4, S16. Berth Makespan: 213.0 min


```

================================================================================



--- Problem 443 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port with five distinct berths is experiencing recurring maintenance activities, each reducing the capacity of the main berth while leaving alternative berths unaffected. The goal is to dynamically manage ship berthing by diverting vessels between the main and alternative berths during each 30-minute time window over a 4-hour operational horizon. Each berth has unique characteristics: normal and reduced main berth capacities (e.g., Berth 1’s main berth drops from 5,758 to 3,128 TEU/h during maintenance), fixed alternative berth capacities (e.g., 1,704 TEU/h for Berth 1), and varying arrival rates (e.g., Berth 1 sees 4,766 TEU/h in Period 1). Maintenance activities last for specific durations (e.g., 1.84 hours for Berth 1), and alternative berths impose extra handling times (e.g., 0.24 hours for Berth 1). Port managers can choose from four diversion ratios (10%, 30%, 50%, or 70%) but must limit changes between consecutive periods to 20% to avoid operational confusion. The challenge is to determine, for each berth and time period, the optimal diversion strategy that minimizes total delay—balancing queue delays on the congested main berth against the extra handling times on alternative berths—while respecting capacity limits and transition smoothness rules.
**

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variables \( y(i, t, k) \): 1 if diversion option \( k \) (e.g., 30%) is selected for berth \( i \) in time period \( t \); 0 otherwise.  

**2. Parameters:**  
- \( NUM\_BERTHS = 5 \), \( NUM\_TIME\_PERIODS = 8 \), \( TIME\_PERIOD\_LENGTH = 0.5 \) hours.  
- Capacities:  
  - Main berth (normal): [5,758, 4,063, ...] TEU/h.  
  - Main berth (reduced): [3,128, 1,933, ...] TEU/h.  
  - Alternative berth: [1,704, 1,585, ...] TEU/h.  
- Arrival rates: 5x8 matrix (e.g., 4,766 TEU/h for Berth 1, Period 1).  
- Maintenance durations: [1.84, 0.58, ...] hours.  
- Extra times for alternative berths: [0.24, 0.32, ...] hours.  
- Diversion options: [0.1, 0.3, 0.5, 0.7].  
- \( MAX\_DIVERSION\_CHANGE = 0.2 \).  

**3. Objective Function:**  
Minimize total delay:  
\[ \sum_{i,t,k} y(i,t,k) \cdot \text{delay}(i,t,k) \]  
where \( \text{delay}(i,t,k) \) combines queue delay (if main berth exceeds reduced capacity) and alternative berth delay.  

**4. Constraints:**  
- **Feasibility:** For each berth \( i \) and period \( t \), exactly one feasible diversion option \( k \) is selected (if capacity allows).  
- **Smooth Transitions:** If \( |k_1 - k_2| > 0.2 \) between consecutive periods, both cannot be selected.  
- **Binary Enforcement:** \( y(i,t,k) \in \{0,1\} \).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_BERTHS = 5
NUM_TIME_PERIODS = 8
TIME_PERIOD_LENGTH = 0.5  # h
MAX_DIVERSION_CHANGE = 0.2  # Maximum allowed change in diversion ratio
capacities_main_normal = [5758, 4063, 5290, 5467, 5134]  # TEU/h
capacities_main_reduced = [3128, 1933, 3149, 3334, 2652]  # TEU/h
capacities_alt = [1704, 1585, 1335, 1812, 1335]  # TEU/h
arrival_rates = [[4766, 4318, 4659, 3543, 3703, 4767, 3078, 2324], [4580, 4312, 3939, 3111, 4305, 4635, 2184, 3759], [2935, 4298, 3002, 3174, 4085, 4281, 3207, 3204], [2684, 4532, 4460, 3247, 3909, 4640, 4212, 2946], [4481, 3353, 3155, 2135, 4662, 3444, 2794, 4626]]  # TEU/h
maintenance_durations = [1.838476299011163, 0.5799593661914788, 1.5301525528612907, 0.9952575869970746, 1.1427548190878094]  # h
alt_berth_extra_times = [0.2439563716845991, 0.31942334952005874, 0.3156427516986192, 0.13003647415169106, 0.16281685492688908]  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option, Berth and Time Period ---
berth_period_option_delays = {}
berth_period_option_feasible = {}

for i in range(NUM_BERTHS):
    berth_period_option_delays[i] = {}
    berth_period_option_feasible[i] = {}

    for t in range(NUM_TIME_PERIODS):
        berth_period_option_delays[i][t] = {}
        berth_period_option_feasible[i][t] = {}

        for k in range(num_options):
            p_k = diversion_options[k]
            flow_alt_k = arrival_rates[i][t] * p_k
            flow_main_k = arrival_rates[i][t] * (1 - p_k)

            # 1. Check Alternative Berth Capacity Feasibility
            if flow_alt_k > capacities_alt[i] + EPSILON:
                berth_period_option_feasible[i][t][k] = False
                berth_period_option_delays[i][t][k] = LARGE_DELAY
                continue

            berth_period_option_feasible[i][t][k] = True

            # 2. Calculate Alternative Berth Delay
            delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_times[i]

            # 3. Calculate Main Berth Queue Delay
            delay_queue_main_k = 0
            max_queue_main_k = 0

            if flow_main_k > capacities_main_reduced[i] + EPSILON:
                max_queue_main_k = (flow_main_k - capacities_main_reduced[i]) * TIME_PERIOD_LENGTH
                if flow_main_k >= capacities_main_normal[i] - EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_rate_k = capacities_main_normal[i] - flow_main_k
                    if dissipation_rate_k < EPSILON:
                        delay_queue_main_k = LARGE_DELAY
                    else:
                        dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                        total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                        delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

            # 4. Calculate Total Delay for this option
            total_delay_k = delay_alt_k + delay_queue_main_k
            berth_period_option_delays[i][t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("MultiBerth_Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_BERTHS, NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for i in range(NUM_BERTHS):
    for t in range(NUM_TIME_PERIODS):
        feasible_indices = [k for k in range(num_options) if berth_period_option_feasible[i][t][k]]
        if not feasible_indices:
            exit()

        m.addConstr(gp.quicksum(y[i,t,k] for k in feasible_indices) == 1, 
                   name="SelectOneFeasibleOption_Berth{0}_Period{1}".format(i,t))

        for k in range(num_options):
            if not berth_period_option_feasible[i][t][k]:
                m.addConstr(y[i,t,k] == 0, 
                          name="ForbidInfeasibleOption_Berth{0}_Period{1}_Option{2}".format(i,t,k))

        # Add smooth transition constraints between periods
        if t > 0:
            for k1 in range(num_options):
                for k2 in range(num_options):
                    if abs(diversion_options[k1] - diversion_options[k2]) > MAX_DIVERSION_CHANGE:
                        m.addConstr(y[i,t-1,k1] + y[i,t,k2] <= 1,
                                  name="SmoothTransition_Berth{0}_Period{1}_Options{2}{3}".format(i,t,k1,k2))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[i,t,k] * berth_period_option_delays[i][t][k]
        for i in range(NUM_BERTHS)
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if berth_period_option_feasible[i][t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Multi-Berth Dynamic Diversion Strategy:")
    for i in range(NUM_BERTHS):
        print("\nBerth {0}:".format(i+1))
        for t in range(NUM_TIME_PERIODS):
            for k in range(num_options):
                if y[i,t,k].X > 0.5:
                    print("  Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                        t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                    ))
                    break
```
Answer:
Optimal Multi-Berth Dynamic Diversion Strategy:

Berth 1:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 0 (10%)

Berth 2:
  Period 1 (0.0-0.5h): Option 1 (30%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 1 (30%)
  Period 5 (2.0-2.5h): Option 1 (30%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 1 (30%)

Berth 3:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 0 (10%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 0 (10%)

Berth 4:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 1 (30%)
  Period 3 (1.0-1.5h): Option 1 (30%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 1 (30%)
  Period 8 (3.5-4.0h): Option 0 (10%)

Berth 5:
  Period 1 (0.0-0.5h): Option 0 (10%)
  Period 2 (0.5-1.0h): Option 0 (10%)
  Period 3 (1.0-1.5h): Option 0 (10%)
  Period 4 (1.5-2.0h): Option 0 (10%)
  Period 5 (2.0-2.5h): Option 0 (10%)
  Period 6 (2.5-3.0h): Option 1 (30%)
  Period 7 (3.0-3.5h): Option 0 (10%)
  Period 8 (3.5-4.0h): Option 0 (10%)



================================================================================



--- Problem 444 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A maritime port is optimizing its ship berthing process to minimize the total time for ships to complete their operations. The port operates with four ships (labeled 0 to 3) that must pass through two sequential stages: **Berthing** (Stage 0) and **Loading/Unloading** (Stage 1). Each ship has specific processing times at each stage, measured in minutes. For instance, Ship 0 takes **42 minutes** to berth and **29 minutes** to complete loading/unloading, while Ship 3 requires **24 minutes** for berthing and **52 minutes** for loading/unloading.  

   The challenge lies in sequencing the ships to minimize the **total makespan**—the time when the last ship exits the final stage. The port must adhere to strict operational rules:  
   - Ships proceed in a fixed order (0 → 1 → 2 → 3) at the Berthing stage.  
   - At the Loading/Unloading stage, a ship cannot start until it finishes Berthing *and* the preceding ship has left the Loading/Unloading stage.  

   **Core Question:** What is the shortest possible time to serve all four ships while respecting these constraints?
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `C[i, j]`: Continuous variable representing the completion time of ship `i` at stage `j` (e.g., `C[2, 1]` is when Ship 2 finishes Loading/Unloading).  

   **2. Parameters:**  
   - `ships = [0, 1, 2, 3]` (ship indices).  
   - `process_times`: Processing times per ship and stage (e.g., `process_times[1][0] = 59` minutes for Ship 1’s Berthing stage).  
   - `num_stages = 2` (Berthing and Loading/Unloading).  

   **3. Objective Function:**  
   Minimize `C[3, 1]` (completion time of the last ship at the final stage).  

   **4. Constraints:**  
   - **Berthing Stage Sequencing:**  
     - Ship 0: `C[0, 0] ≥ 42`.  
     - Subsequent ships: `C[i, 0] ≥ C[i-1, 0] + process_times[i][0]` for `i = 1, 2, 3`.  
   - **Loading/Unloading Stage Dependencies:**  
     - Ship 0: `C[0, 1] ≥ C[0, 0] + 29`.  
     - Subsequent ships:  
       - Must finish Berthing: `C[i, 1] ≥ C[i, 0] + process_times[i][1]`.  
       - Must wait for prior ship: `C[i, 1] ≥ C[i-1, 1] + process_times[i][1]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3] # List of ship indices [0, 1, ...]
# process_times[ship][stage], stage 0=Berthing, stage 1=Loading/Unloading
process_times = [[42, 29], [59, 54], [17, 49], [24, 52]]
num_stages = 2 # Should be 2 based on original code
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_FLOW_SHOP", env=env)

    # --- Basic Input Validation ---
    if not ships or num_stages <= 0 or not process_times or len(process_times) != len(ships):
        raise ValueError("Invalid input data for Port Flow Shop")
    if any(len(row) != num_stages for row in process_times):
         raise ValueError("Inconsistent number of stages in process_times")

    # --- Decision Variables ---
    # C[i, j]: Completion time of ship i at stage j
    C = m.addVars(ships, range(num_stages), vtype=GRB.CONTINUOUS, lb=0, name="C")

    # --- Objective Function: Minimize the makespan ---
    # Makespan is completion time of the last ship at the last stage
    last_ship_idx = ships[-1]
    last_stage_idx = num_stages - 1
    m.setObjective(C[last_ship_idx, last_stage_idx], GRB.MINIMIZE)

    # --- Constraints ---
    # Stage 0 completion times (assuming fixed sequence 0, 1, 2...)
    # First ship at stage 0
    m.addConstr(C[0, 0] >= process_times[0][0], "C0_0")
    # Subsequent ships at stage 0
    for i in range(1, len(ships)):
        m.addConstr(C[i, 0] >= C[i-1, 0] + process_times[i][0], f"C0_{i}")

    # Completion times for subsequent stages (j > 0)
    for j in range(1, num_stages):
        # First ship at stage j
        m.addConstr(C[0, j] >= C[0, j-1] + process_times[0][j], f"C{j}_0")
        # Subsequent ships at stage j
        for i in range(1, len(ships)):
            # Must complete stage j-1 first
            m.addConstr(C[i, j] >= C[i, j-1] + process_times[i][j], f"C{j}_{i}_StagePrev")
            # Must wait for previous ship to finish stage j
            m.addConstr(C[i, j] >= C[i-1, j] + process_times[i][j], f"C{j}_{i}_ShipPrev")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['C_sol'] = m.getAttr('X', C) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}") # Makespan
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code to print the completion times for each ship at each stage
if m.Status == GRB.OPTIMAL:
    for i in ships:
        for j in range(num_stages):
            print(f"Completion time of Ship {i} at Stage {j}: {C[i, j].X:.2f}")
```
Answer:
Optimal objective value: 256.00
Completion time of Ship 0 at Stage 0: 42.00
Completion time of Ship 0 at Stage 1: 71.00
Completion time of Ship 1 at Stage 0: 101.00
Completion time of Ship 1 at Stage 1: 155.00
Completion time of Ship 2 at Stage 0: 118.00
Completion time of Ship 2 at Stage 1: 204.00
Completion time of Ship 3 at Stage 0: 142.00
Completion time of Ship 3 at Stage 1: 256.00


```

================================================================================



--- Problem 445 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling the unloading of six incoming trucks at two available depots to minimize the total time required to service all vehicles. Each truck arrives at a specific time: Truck 1 at 5 hours, Truck 2 at 10, Truck 3 at 14, Truck 4 at 17, Truck 5 at 20, and Truck 6 at 21. Once at the depot, the trucks require varying processing times: Truck 1 takes 7 hours, Truck 2 takes 3, Truck 3 takes 4, Truck 4 takes 7, Truck 5 takes 6, and Truck 6 takes 6. The logistics team must assign each truck to exactly one depot, ensuring no two trucks at the same depot overlap in service time. The goal is to determine the optimal assignment and scheduling sequence that completes all operations as early as possible, minimizing the *makespan*—the time when the last truck departs. Given the tight scheduling constraints and the high cost of delays, the central question is: *What is the earliest possible time all trucks can be serviced, and how should they be assigned to the depots to achieve this?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary `assign(i, j)`: 1 if truck `i` is assigned to depot `j`, else 0.  
   - Continuous `start_time(i)`: When truck `i` begins service.  
   - Continuous `completion_time(i)`: When truck `i` finishes (start time + processing time).  
   - Binary `precedes(i, k, j)`: 1 if truck `i` is serviced before truck `k` at depot `j`, else 0.  
   - Continuous `makespan`: Total time until the last truck departs (objective).  

   **2. Parameters:**  
   - `trucks`: [1, 2, 3, 4, 5, 6].  
   - `depots`: [1, 2].  
   - `arrival_times`: {1:5, 2:10, 3:14, 4:17, 5:20, 6:21}.  
   - `processing_times`: {1:7, 2:3, 3:4, 4:7, 5:6, 6:6}.  
   - `H` (Big-M): 100 (ensures precedence constraints are enforced).  

   **3. Objective Function:**  
   Minimize `makespan` (the latest completion time across all trucks).  

   **4. Constraints:**  
   - **Assignment:** Each truck assigned to exactly one depot:  
     `sum(assign(i, j) for j in depots) = 1` for all trucks `i`.  
   - **Arrival Time:** Trucks cannot start before arrival:  
     `start_time(i) >= arrival_times(i)` for all `i`.  
   - **Completion Time:** `completion_time(i) = start_time(i) + processing_times(i)`.  
   - **Non-Overlapping:** For each depot `j`, if trucks `i` and `k` are assigned to `j`, one must precede the other:  
     - `precedes(i,k,j) + precedes(k,i,j) >= assign(i,j) + assign(k,j) - 1`.  
     - If `precedes(i,k,j) = 1`, then `start_time(k) >= completion_time(i)`.  
   - **Makespan Definition:** `makespan >= completion_time(i)` for all `i`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
depots = [1, 2]
arrival_times = {1: 5, 2: 10, 3: 14, 4: 17, 5: 20, 6: 21}
processing_times = {1: 7, 2: 3, 3: 4, 4: 7, 5: 6, 6: 6}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_MIN_MAKESPAN")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times[i] for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times[i] for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
    print(f"Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
30.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 2
Start Time: 5.0000, Completion Time: 12.0000
Truck 2 is assigned to Depot 2
Start Time: 12.0000, Completion Time: 15.0000
Truck 3 is assigned to Depot 2
Start Time: 15.0000, Completion Time: 19.0000
Truck 4 is assigned to Depot 1
Start Time: 17.0000, Completion Time: 24.0000
Truck 5 is assigned to Depot 2
Start Time: 20.0000, Completion Time: 26.0000
Truck 6 is assigned to Depot 1
Start Time: 24.0000, Completion Time: 30.0000
Makespan: 30.0000


```

================================================================================



--- Problem 446 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
A busy port is preparing to handle the arrival of 356 containers. The port has five berths (Berth_A to Berth_E), each with distinct characteristics: capacity, handling fee, and distance from the main storage area. The goal is to allocate containers to these berths in a way that minimizes the total cost, which includes both the handling fee and a disutility cost proportional to the transport distance.  

Berth_A and Berth_B are large but expensive and far away, with capacities of 671 and 634 containers, respectively, and costs of $12 per container plus a distance penalty. Berth_C is smaller (222 containers) but much closer, making it cheaper overall ($6 per container). Berth_D is tiny (62 containers) and far, while Berth_E offers a balance with 100 spaces and moderate distance. The disutility cost is calculated as $0.007 per meter transported.  

The challenge is to assign all 356 containers to the berths without exceeding any berth's capacity while minimizing the combined handling and disutility costs. The optimal allocation must strategically balance proximity and cost, favoring cheaper or closer berths where possible.

**Modeling Process:**
- **1. Decision Variables:**  
     Let \( x_{\text{berth}} \) be the number of containers assigned to each berth (Berth_A, Berth_B, Berth_C, Berth_D, Berth_E). These are non-negative integers.  
   - **2. Parameters:**  
     - \( \text{capacity}_{\text{berth}} \): Maximum containers a berth can hold (e.g., Berth_A: 671).  
     - \( \text{cost}_{\text{berth}} \): Handling fee per container (e.g., Berth_A: $12).  
     - \( \text{distance}_{\text{berth}} \): Transport distance in meters (e.g., Berth_A: 2204).  
     - \( \alpha = 0.007 \): Disutility cost per meter transported.  
     - Total containers to handle: 356.  
   - **3. Objective Function:**  
     Minimize the total cost:  
     \[
     \sum_{\text{berth}} x_{\text{berth}} \times (\text{cost}_{\text{berth}} + \alpha \times \text{distance}_{\text{berth}}).
     \]  
   - **4. Constraints:**  
     - All containers must be handled: \( \sum_{\text{berth}} x_{\text{berth}} = 356 \).  
     - Berth capacities: \( x_{\text{berth}} \leq \text{capacity}_{\text{berth}} \) for each berth.  

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
total_containers_to_handle = 356; berths_data = {'Berth_A': {'capacity': 671, 'cost': 12, 'distance': 2204}, 'Berth_B': {'capacity': 634, 'cost': 12, 'distance': 914}, 'Berth_C': {'capacity': 222, 'cost': 6, 'distance': 105}, 'Berth_D': {'capacity': 62, 'cost': 4, 'distance': 2205}, 'Berth_E': {'capacity': 100, 'cost': 6, 'distance': 659}}
distance_disutility_per_meter = 0.0070
berth_ids = ['Berth_A', 'Berth_B', 'Berth_C', 'Berth_D', 'Berth_E']
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    total_cost_per_container = { berth: berths_data[berth]['cost'] + berths_data[berth]['distance'] * distance_disutility_per_meter for berth in berth_ids }
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m11 = gp.Model("Port_Berth_Allocation_IP", env=env)
    # Vars
    x = m11.addVars(berth_ids, vtype=GRB.INTEGER, name="containers_in_berth", lb=0)
    # Objective
    m11.setObjective(gp.quicksum(x[berth] * total_cost_per_container[berth] for berth in berth_ids), sense=GRB.MINIMIZE)
    # Constraints
    m11.addConstr(gp.quicksum(x[berth] for berth in berth_ids) == total_containers_to_handle, "handle_all_containers")
    for berth in berth_ids: m11.addConstr(x[berth] <= berths_data[berth]['capacity'], f"capacity_berth_{berth}")
    # Optimize
    m11.optimize()
    # Store results
    results_dict['status'] = m11.status
    if m11.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m11.objVal; results_dict['x_sol'] = m11.getAttr('X', x)
    # Output Results
    print("--- Problem 11: Port Berth Allocation (IP) ---")
    if m11.status == GRB.OPTIMAL:
        x_sol = results_dict.get('x_sol', {})
        print(f"Optimization Status: Optimal"); print(f"Minimum Total Cost (Handling Fee + Distance Disutility): ${m11.objVal:.2f}"); print("Container Allocation:")
        total_handled = 0
        for berth in berth_ids:
            containers_in_berth = x_sol.get(berth, 0)
            print(f"  Berth {berth}: {int(round(containers_in_berth))} containers (Capacity: {berths_data[berth]['capacity']}, Cost/Container: ${total_cost_per_container[berth]:.2f})")
            total_handled += containers_in_berth
        print(f"Total containers handled: {int(round(total_handled))} / {total_containers_to_handle}")
    else: print(f"Optimization Status: {m11.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_BERTH
```
Answer:
--- Problem 11: Port Berth Allocation (IP) ---
Optimization Status: Optimal
Minimum Total Cost (Handling Fee + Distance Disutility): $3182.00
Container Allocation:
  Berth Berth_A: 0 containers (Capacity: 671, Cost/Container: $27.43)
  Berth Berth_B: 34 containers (Capacity: 634, Cost/Container: $18.40)
  Berth Berth_C: 222 containers (Capacity: 222, Cost/Container: $6.74)
  Berth Berth_D: 0 containers (Capacity: 62, Cost/Container: $19.44)
  Berth Berth_E: 100 containers (Capacity: 100, Cost/Container: $10.61)
Total containers handled: 356 / 356



================================================================================



--- Problem 447 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy logistics hub, three delivery trucks—Truck 1, Truck 2, and Truck 3—arrive at staggered times, each requiring a depot for unloading and loading operations. The hub has only one depot available, making efficient scheduling critical to minimize delays and ensure smooth operations. Truck 1 arrives at 5 hours, Truck 2 at 8 hours, and Truck 3 at 10 hours. The processing times for the trucks are 3, 6, and 4 hours, respectively. The challenge is to assign these trucks to the single depot in such a way that the total time taken to service all trucks (the makespan) is minimized, while respecting their arrival times and avoiding overlaps in depot usage.  

   The hub manager must
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable indicating whether truck `i` is assigned to depot `j` (1 if assigned, 0 otherwise).  
   - `start_time(i)`: Continuous variable representing the time truck `i` starts processing.  
   - `completion_time(i)`: Continuous variable representing the time truck `i` finishes processing.  
   - `precedes(i, k, j)`: Binary variable indicating whether truck `i` is scheduled before truck `k` on depot `j`.  
   - `makespan`: Continuous variable representing the total time taken to complete all operations.  

   **2. Parameters:**  
   - `trucks = [1, 2, 3]`: List of trucks.  
   - `depots = [1]`: List of depots (only one in this case).  
   - `arrival_times = {1: 5, 2: 8, 3: 10}`: Arrival times for each truck.  
   - `processing_times = {1: 3, 2: 6, 3: 4}`: Processing times for each truck.  
   - `H = 100`: A large constant (Big M) used in constraints.  

   **3. Objective Function:**  
   Minimize `makespan` (the latest completion time among all trucks).  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot (here, only one depot exists).  
     `sum(assign(i, j) for j in depots) = 1` for all `i` in trucks.  
   - **Arrival Time:** A truck cannot start processing before its arrival time.  
     `start_time(i) >= arrival_times[i]` for all `i` in trucks.  
   - **Completion Time:** The completion time is the start time plus processing time.  
     `completion_time(i) = start_time(i) + processing_times[i]` for all `i` in trucks.  
   - **Non-Overlapping:** If two trucks `i` and `k` are assigned to the same depot, one must precede the other.  
     - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
     - If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.  
   - **Makespan Definition:** The makespan is the maximum completion time across all trucks.  
     `makespan >= completion_time(i)` for all `i` in trucks.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
depots = [1]
arrival_times = {1: 5, 2: 8, 3: 10}
processing_times = {1: 3, 2: 6, 3: 4} # Using base processing times
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_57_CRANE_IGNORE") # Renamed model

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (using base proc time)
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal makespan: {m.objVal:.4f}")
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
18.0000
Optimal makespan: 18.0000
Truck 1 - Start Time: 5.0000, Completion Time: 8.0000
Truck 2 - Start Time: 8.0000, Completion Time: 14.0000
Truck 3 - Start Time: 14.0000, Completion Time: 18.0000


```

================================================================================



--- Problem 448 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
A logistics company is tasked with loading a shipment of 20 valuable items onto a limited number of trucks for transport. Each item has a specific weight and value, and the trucks have a strict weight capacity of 88 units. The company can use up to 6 trucks, but their goal is not just to fit all items—they want to maximize the total value of the items loaded, even if some items must be left behind due to space constraints.  

The items vary significantly in weight and value: some are lightweight but highly valuable (like item 17, weighing just 10 units but worth 4), while others are heavy and valuable (like item 8, weighing 75 units with a value of 99). The challenge is to strategically assign items to trucks so that no truck exceeds its weight limit, no item is placed on more than one truck, and the total value of the loaded items is as high as possible.  

The central question is: **What is the optimal way to load these items onto the available trucks to maximize the total shipped value without exceeding weight limits?**  

---

**Modeling Process:**
**1. Decision Variables:**  
- `x[i, j]`: Binary variable indicating whether item `i` is placed in truck `j` (1 if placed, 0 otherwise).  
- `y[j]`: Binary variable indicating whether truck `j` is used (1 if used, 0 otherwise).  

**2. Parameters:**  
- `items`: List of tuples `(weight, value)` for each item (e.g., item 0: weight 42, value 25).  
- `truck_capacity = 88`: Maximum weight a truck can hold.  
- `num_trucks = 6`: Maximum number of trucks available.  
- `num_items = 20`: Total number of items to consider.  

**3. Objective Function:**  
Maximize the total value of loaded items:  
```
Maximize: sum(items[i][1] * x[i, j] for all i, j)
```  

**4. Constraints:**  
- **Truck weight limit:** For each truck `j`, the total weight of assigned items must not exceed its capacity:  
  ```
  sum(items[i][0] * x[i, j] for all i) <= truck_capacity * y[j]
  ```  
- **Item-truck linkage:** If an item is placed in a truck, that truck must be marked as used:  
  ```
  x[i, j] <= y[j] for all i, j
  ```  
- **Single-truck assignment:** Each item can be placed in at most one truck:  
  ```
  sum(x[i, j] for all j) <= 1 for all i
  ```  

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Data Definition (Embedded) ---
items = [(42, 25), (49, 85), (43, 35), (64, 95), (40, 9), (79, 73), (73, 57), (56, 2), (75, 99), (75, 28), (56, 74), (18, 95), (1, 81), (54, 47), (65, 56), (15, 45), (21, 65), (10, 4), (39, 15), (82, 98)]          # List of (weight, value) tuples
truck_capacity = 88      # Maximum weight per truck
num_trucks = 6          # Maximum number of available trucks (parameter)
num_items = 20          # len(items) derived correctly
# --- End Data Definition ---

GUROBI_TIME_LIMIT = 60 # Time limit parameter

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi log in captured output
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Max-Value BPP", env=env)

    # --- Decision variables ---
    x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")  # x[i, j] -> item i placed in truck j
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")  # y[j] -> truck j is used

    # --- Objective: Maximize total value of selected items ---
    # Sum over all items i and the truck j they are placed in
    model.setObjective(gp.quicksum(items[i][1] * x[i, j] for i in range(num_items) for j in range(num_trucks)), GRB.MAXIMIZE)

    # --- Constraint 1: Truck weight limit ---
    for j in range(num_trucks):
        model.addConstr(gp.quicksum(items[i][0] * x[i, j] for i in range(num_items)) <= truck_capacity * y[j], name=f"Truck_{j}_Weight")

    # --- Constraint 2: If an item is placed in a truck, that truck must be considered used ---
    # (This is often implied by C1 if capacity > 0, but good practice)
    for i in range(num_items):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Item_{i}_Triggers_Truck_{j}")

    # --- Constraint 3: Each item can be placed in at most one truck ---
    # (Items not placed contribute 0 to objective and constraints)
    for i in range(num_items):
        model.addConstr(x.sum(i, '*') <= 1, name=f"Item_{i}_AtMostOneTruck")

    # --- Solve the model ---
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal # Best solution found

    # --- Output results (for capture) ---
    if model.status == GRB.OPTIMAL:
        print(f"Optimal total value: {model.objVal:.2f}") # Format value
        print("-" * 30)
        printed_truck_count = 0
        for j in range(num_trucks):
            try:
                 if y[j].x > 0.5:  # Truck is used
                     printed_truck_count += 1
                     assigned_items = [i for i in range(num_items) if x[i, j].x > 0.5]
                     assigned_weights = [items[i][0] for i in assigned_items]
                     truck_load = sum(assigned_weights)
                     print(f"Truck {printed_truck_count} (Index {j}):")
                     print(f"  Load: {truck_load} / {truck_capacity}")
                     print(f"  Items (indices): {sorted(assigned_items)}")
                     # Optional: print item details
                     # print(f"  Items (w,v): {[items[i] for i in sorted(assigned_items)]}")
                     print("-" * 10)
            except AttributeError:
                 pass # Skip trucks not used or if .X missing
    elif model.status == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare if items fit capacity
    else:
        print(f"\nOptimization finished with status: {model.status}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total value: 814.00
------------------------------
Truck 1 (Index 0):
  Load: 66 / 88
  Items (indices): [10, 17]
----------
Truck 2 (Index 1):
  Load: 79 / 88
  Items (indices): [5]
----------
Truck 3 (Index 2):
  Load: 88 / 88
  Items (indices): [1, 11, 16]
----------
Truck 4 (Index 3):
  Load: 80 / 88
  Items (indices): [3, 12, 15]
----------
Truck 5 (Index 4):
  Load: 75 / 88
  Items (indices): [8]
----------
Truck 6 (Index 5):
  Load: 82 / 88
  Items (indices): [19]
----------


```

================================================================================



--- Problem 449 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port terminal is tasked with efficiently scheduling 22 uniquely categorized cargo containers into berths for loading, each with a specific weight. The containers, ranging from lightweight (4 units) to heavy (77 units), must be scheduled under strict constraints: each berth can handle a maximum weight of 80 units, and no berth may contain containers of more than two distinct categories. The categories—such as 'S', 'Q', 'U', and others—add complexity, as containers of the same category can be grouped, but mixing too many categories in a single berth is prohibited. The challenge is to determine the minimal number of berths required to schedule all containers while respecting these weight and category diversity limits. This problem mirrors real-world scenarios like ship berthing with compatibility rules or organizing cargo by type, where both space and grouping restrictions are critical.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `x[i, j]`: 1 if container `i` is assigned to berth `j`, else 0.  
     - Binary variable `y[j]`: 1 if berth `j` is used, else 0.  
     - Binary variable `z[c, j]`: 1 if category `c` is present in berth `j`, else 0.  
   - **2. Parameters:**  
     - `containers`: List of container weights (e.g., [77, 37, ..., 23, 29, 37]).  
     - `categories`: List of container categories (e.g., ['S', 'Q', ..., 'S', 'U']).  
     - `capacity`: Berth weight limit (80 units).  
     - `unique_categories_list`: Sorted list of distinct categories (e.g., ['A', 'B', ..., 'Z']).  
   - **3. Objective Function:**  
     Minimize the total berths used: `Minimize sum(y[j] for all j)`.  
   - **4. Constraints:**  
     - Each container in exactly one berth: `sum(x[i, j] for all j) = 1` for all containers `i`.  
     - Berth capacity: `sum(containers[i] * x[i, j] for all i) <= capacity * y[j]` for all berths `j`.  
     - Category linking: If any container of category `c` is in berth `j`, `z[c, j] = 1`.  
     - Category limit: `sum(z[c, j] for all c) <= 2 * y[j]` for all berths `j`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
containers = [77, 37, 13, 17, 21, 7, 45, 41, 35, 54, 69, 51, 34, 10, 4, 28, 32, 70, 70, 23, 29, 37]      # Weights of containers
categories = ['S', 'Q', 'U', 'V', 'U', 'S', 'T', 'G', 'G', 'H', 'N', 'Z', 'Y', 'N', 'A', 'Y', 'E', 'R', 'B', 'G', 'S', 'U']    # Categories of containers
capacity = 80         # Berth capacity
num_containers = 22       # len(containers) - derived correctly below
num_berths = num_containers      # Maximum berths (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(containers) != len(categories) or len(containers) != num_containers:
    print("Error: Data inconsistency (containers/categories/num_containers length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_categories_list = sorted(list(set(categories))) # Get unique categories deterministically
container_indices_by_category = {category: [i for i, c in enumerate(categories) if c == category] for category in unique_categories_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Category-Constrained Berth Scheduling", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_containers, num_berths, vtype=GRB.BINARY, name="x")  # x[i,j] -> container i in berth j
        y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")              # y[j] -> whether berth j is used
        # z[c,j] -> whether category c is PRESENT in berth j (Use unique_categories_list for keys)
        z = model.addVars(unique_categories_list, num_berths, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of berths used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each container must be assigned to exactly one berth ---
        for i in range(num_containers):
            model.addConstr(x.sum(i, '*') == 1, name=f"Container_{i}_Assignment")

        # --- Constraint 2: Berth capacity constraint ---
        for j in range(num_berths):
            model.addConstr(gp.quicksum(containers[i] * x[i, j] for i in range(num_containers)) <= capacity * y[j], name=f"Berth_{j}_Capacity")

        # --- Constraint 3: Category constraint (at most 2 *different* categories per berth) ---

        # Part 3a: Link x (container in berth) and z (category in berth).
        for j in range(num_berths):
            for category in unique_categories_list:
                indices_of_this_category = container_indices_by_category.get(category, []) # Use .get for safety

                if not indices_of_this_category:
                    # If no containers of this category exist, z[category, j] must be 0.
                    model.addConstr(z[category, j] == 0, name=f"NoContainers_{category}_Berth_{j}")
                    continue

                # If any container 'i' of this 'category' is placed in berth 'j' (x[i,j]=1),
                # then the presence indicator for that 'category' in berth 'j' (z[category,j]) must be 1.
                for i in indices_of_this_category:
                    model.addConstr(x[i, j] <= z[category, j], name=f"Link_x{i}_z{category}_Berth{j}")

                # Ensure z[category, j] is 0 if no containers of that category are in the berth.
                # This helps tighten the formulation.
                model.addConstr(z[category, j] <= gp.quicksum(x[i, j] for i in indices_of_this_category), name=f"Link_z{category}_SumX_Berth{j}")


        # Part 3b: Limit the number of distinct categories (sum of z[c,j] for berth j) to 2 for USED berths.
        for j in range(num_berths):
            # sum(z[c,j] for c in unique_categories_list) gives the count of distinct categories in berth j.
            # This sum must be <= 2 *IF* the berth is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Categories_Berth_{j}")

        # --- Solve ---
        print("Solving CCBS instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_berths = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of berths used: {optimal_berths}")
    print("-" * 30)

    berth_details = []
    printed_berth_count = 0
    for j_sol in range(num_berths): # Iterate through all potential berth indices
        try:
             # Check if this berth was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_berth_count += 1
                 assigned_containers_indices = [i for i in range(num_containers) if x[i, j_sol].X > 0.5]
                 assigned_containers_weights = [containers[i] for i in assigned_containers_indices]
                 assigned_containers_categories = [categories[i] for i in assigned_containers_indices]
                 distinct_categories_in_berth = sorted(list(set(assigned_containers_categories))) # Sort for consistent output
                 berth_load = sum(assigned_containers_weights)

                 print(f"Berth {printed_berth_count} (Internal Index {j_sol}):")
                 print(f"  Containers (indices): {assigned_containers_indices}")
                 # print(f"  Containers (weights): {assigned_containers_weights}") # Optional details
                 # print(f"  Containers (categories):  {assigned_containers_categories}") # Optional details
                 print(f"  Distinct Categories: {distinct_categories_in_berth} (Count: {len(distinct_categories_in_berth)})")
                 print(f"  Total weight:    {berth_load} / {capacity}")
                 print("-" * 10)

                 berth_data = {
                     'berth_index_internal': j_sol,
                     'berth_index_printed': printed_berth_count,
                     'container_indices': assigned_containers_indices,
                     'distinct_categories': distinct_categories_in_berth,
                     'load': berth_load
                 }
                 berth_details.append(berth_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for berth index {j_sol}: {e_print}")


    results_dict['berth_details'] = berth_details # Store details

    # Final sanity check
    if printed_berth_count != optimal_berths:
         print(f"Warning: Number of printed used berths ({printed_berth_count}) does not match objective value ({optimal_berths}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# The provided code already prints the optimal number of berths used and detailed information for each berth.
# No additional print statements are necessary.
```
Answer:
Solving CCBS instance...
------------------------------

Optimal solution found.
Optimal number of berths used: 11
------------------------------
Berth 1 (Internal Index 0):
  Containers (indices): [5, 6]
  Distinct Categories: ['S', 'T'] (Count: 2)
  Total weight:    52 / 80
----------
Berth 2 (Internal Index 3):
  Containers (indices): [0]
  Distinct Categories: ['S'] (Count: 1)
  Total weight:    77 / 80
----------
Berth 3 (Internal Index 4):
  Containers (indices): [14, 17]
  Distinct Categories: ['A', 'R'] (Count: 2)
  Total weight:    74 / 80
----------
Berth 4 (Internal Index 6):
  Containers (indices): [2, 12, 15]
  Distinct Categories: ['U', 'Y'] (Count: 2)
  Total weight:    75 / 80
----------
Berth 5 (Internal Index 10):
  Containers (indices): [1, 7]
  Distinct Categories: ['G', 'Q'] (Count: 2)
  Total weight:    78 / 80
----------
Berth 6 (Internal Index 11):
  Containers (indices): [11, 20]
  Distinct Categories: ['S', 'Z'] (Count: 2)
  Total weight:    80 / 80
----------
Berth 7 (Internal Index 16):
  Containers (indices): [10, 13]
  Distinct Categories: ['N'] (Count: 1)
  Total weight:    79 / 80
----------
Berth 8 (Internal Index 17):
  Containers (indices): [3, 8, 19]
  Distinct Categories: ['G', 'V'] (Count: 2)
  Total weight:    75 / 80
----------
Berth 9 (Internal Index 18):
  Containers (indices): [18]
  Distinct Categories: ['B'] (Count: 1)
  Total weight:    70 / 80
----------
Berth 10 (Internal Index 20):
  Containers (indices): [4, 9]
  Distinct Categories: ['H', 'U'] (Count: 2)
  Total weight:    75 / 80
----------
Berth 11 (Internal Index 21):
  Containers (indices): [16, 21]
  Distinct Categories: ['E', 'U'] (Count: 2)
  Total weight:    69 / 80
----------


```

================================================================================



--- Problem 450 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A major port is experiencing a sudden incident, causing a significant reduction in the main berth's capacity. To manage the resulting congestion, port authorities are considering dynamic pricing on a parallel berth to divert some ships away from the main berth. The goal is to minimize the total system delay, which includes both the queueing delay at the main berth and the additional handling time at the parallel berth. 

The main berth has a normal capacity of 5,669.79 ships per hour, but during the incident, this drops to 2,574.05 ships per hour. The initial demand at the main berth is 5,005.68 ships per hour, while the parallel berth initially attracts 466.67 ships per hour. The parallel berth has a fixed capacity of 2,940.96 ships per hour and imposes an additional handling time of 0.0875 hours per ship. The normal price for using the parallel berth is $5.21, but authorities are considering six pricing options: $0.00, $1.00, $2.00, $3.00, $4.00, and $5.00. For every dollar decrease in the price, demand on the parallel berth is expected to increase by 161.09 ships per hour. 

The critical question is: What price should be implemented during the incident to minimize the total system delay, balancing the trade-off between diverting ships to the parallel berth and the resulting delays at both berths?
**

**Modeling Process:**
**
**1. Decision Variables:**
- `y[p]`: Binary variable indicating whether price `p` is selected (1 if selected, 0 otherwise), where `p` is one of the price options [0.0, 1.0, 2.0, 3.0, 4.0, 5.0].

**2. Parameters:**
- `C_main_norm`: Normal capacity of the main berth (5,669.79 ships/hour).
- `C_main_red`: Reduced capacity of the main berth during the incident (2,574.05 ships/hour).
- `lambda_demand_main_initial`: Initial demand at the main berth (5,005.68 ships/hour).
- `C_parallel`: Capacity of the parallel berth (2,940.96 ships/hour).
- `T_extra_parallel_h`: Additional handling time at the parallel berth (0.0875 hours).
- `Price_norm`: Normal price for using the parallel berth ($5.21).
- `lambda_parallel_initial`: Initial demand at the parallel berth (466.67 ships/hour).
- `T_inc_h`: Duration of the incident (2.1225 hours).
- `Flow_increase_per_dollar`: Increase in parallel berth demand per dollar decrease in price (161.09 ships/hour/$).
- `Price_options`: List of price options [0.0, 1.0, 2.0, 3.0, 4.0, 5.0].

**3. Objective Function:**
- Minimize the total system delay, calculated as the sum of the main berth queueing delay and the parallel berth delay for the selected price.

**4. Constraints:**
- **Select One Price:** Exactly one price must be selected: `sum(y[p] for p in Price_options) == 1`.

**Delay Calculations:**
- For each price option `p`:
  - Calculate the expected parallel berth demand: `lambda_parallel_expected = lambda_parallel_initial + (Price_norm - p) * Flow_increase_per_dollar`.
  - The effective parallel berth demand is capped at its capacity: `lambda_parallel_effective = min(lambda_parallel_expected, C_parallel)`.
  - The remaining demand at the main berth: `lambda_main = Lambda_total - lambda_parallel_effective`.
  - Calculate the main berth queueing delay:
    - If `lambda_main > C_main_red`, the delay is calculated based on the queue formation and dissipation.
    - Otherwise, the delay is zero.
  - Calculate the parallel berth delay: `delay_parallel = lambda_parallel_effective * T_inc_h * T_extra_parallel_h`.
  - The total delay for the price option is the sum of the main berth and parallel berth delays.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
C_main_norm = 5669.790226081599
C_main_red = 2574.0538169965657
lambda_demand_main_initial = 5005.67657089635
C_parallel = 2940.9632109371055
T_extra_parallel_h = 0.08752997910869846
Price_norm = 5.21092216435284
lambda_parallel_initial = 466.6700182914593
T_inc_h = 2.1225039284165197
Flow_increase_per_dollar = 161.08604061372793
Price_options = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]

Lambda_total = lambda_demand_main_initial + lambda_parallel_initial

# --- Calculate total delay for each price option ---
option_delays = {}
print("--- System Delay Calculation per Price Option ---")

for p in Price_options:
    price_decrease = Price_norm - p
    flow_increase_expected = price_decrease * Flow_increase_per_dollar
    lambda_parallel_expected = lambda_parallel_initial + flow_increase_expected

    # Effective parallel flow considering capacity
    lambda_parallel_effective = min(lambda_parallel_expected, C_parallel)

    # Remaining flow at main berth
    lambda_main = Lambda_total - lambda_parallel_effective

    # Calculate delays
    # Parallel berth delay (extra handling time only)
    delay_parallel = lambda_parallel_effective * T_inc_h * T_extra_parallel_h

    # Main berth queueing delay
    delay_main = 0
    q_max = 0
    t_diss = float('nan')
    if lambda_main > C_main_red:
        q_max = (lambda_main - C_main_red) * T_inc_h
        dissipation_rate = C_main_norm - lambda_main
        if dissipation_rate > 1e-6:
            t_diss = q_max / dissipation_rate
            delay_main = 0.5 * q_max * (T_inc_h + t_diss)
        else:
            delay_main = float('inf') # Queue doesn't dissipate naturally
    else:
         delay_main = 0 # No queue forms

    total_delay = delay_main + delay_parallel if delay_main != float('inf') else float('inf')
    option_delays[p] = total_delay

    print(f" Price=${p:.2f}: ParallelFlow={lambda_parallel_effective:.0f}, MainFlow={lambda_main:.0f} -> MainDelay={delay_main:.2f}, ParallelDelay={delay_parallel:.2f} => Total={total_delay:.2f}")

# --- Gurobi Model (Select best price) ---
model = gp.Model("DynamicPricingIncident")

# --- Decision Variables ---
y = model.addVars(Price_options, vtype=GRB.BINARY, name="ChoosePrice")

# --- Constraints ---
model.addConstr(gp.quicksum(y[p] for p in Price_options) == 1, name="SelectOnePrice")

# --- Objective Function ---
# Minimize total system delay. Handle infinite delay case (e.g., assign large penalty).
objective = gp.LinExpr()
for p in Price_options:
    cost = option_delays[p]
    if cost == float('inf'):
        cost = 1e12 # Assign large finite cost for infeasible/non-dissipating scenarios
    objective += y[p] * cost

model.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    chosen_price = -1.0
    for p in Price_options:
        if y[p].X > 0.9:
            chosen_price = p
            break

    if chosen_price >= 0:
         print(f"Optimal Price: ${chosen_price:.2f}")
         # Handle displaying infinite delay if that was the "optimal" outcome
         min_delay_val = model.objVal
         if min_delay_val >= 1e11: # Check if the large penalty was chosen
              print(f" Minimum Total System Delay: Infinite (or very large due to non-dissipating queues)")
         else:
              print(f" Minimum Total System Delay: {model.objVal:.2f} ship-hours")
    else:
         print("Error: No price selected.")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- System Delay Calculation per Price Option ---
 Price=$0.00: ParallelFlow=1306, MainFlow=4166 -> MainDelay=7384.54, ParallelDelay=242.65 => Total=7627.19
 Price=$1.00: ParallelFlow=1145, MainFlow=4327 -> MainDelay=9107.40, ParallelDelay=212.72 => Total=9320.12
 Price=$2.00: ParallelFlow=984, MainFlow=4488 -> MainDelay=11300.12, ParallelDelay=182.79 => Total=11482.91
 Price=$3.00: ParallelFlow=823, MainFlow=4650 -> MainDelay=14185.23, ParallelDelay=152.87 => Total=14338.10
 Price=$4.00: ParallelFlow=662, MainFlow=4811 -> MainDelay=18152.20, ParallelDelay=122.94 => Total=18275.14
 Price=$5.00: ParallelFlow=501, MainFlow=4972 -> MainDelay=23949.94, ParallelDelay=93.01 => Total=24042.95
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 1 rows, 6 columns and 6 nonzeros
Model fingerprint: 0x6e331b65
Variable types: 0 continuous, 6 integer (6 binary)
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [8e+03, 2e+04]
  Bounds range     [1e+00, 1e+00]
  RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 7627.1891791
Presolve removed 1 rows and 6 columns
Presolve time: 0.00s
Presolve: All rows and columns removed

Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units)
Thread count was 1 (of 255 available processors)

Solution count 1: 7627.19 

Optimal solution found (tolerance 1.00e-04)
Best objective 7.627189179131e+03, best bound 7.627189179131e+03, gap 0.0000%

--- Optimization Results ---
Optimization Status: Optimal
Optimal Price: $0.00
 Minimum Total System Delay: 7627.19 ship-hours



================================================================================



--- Problem 451 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with delivering goods from a central depot (Node 0) to three customer locations (Nodes 1, 2, and 3) using a fleet of four trucks. Each truck has a distinct capacity: Truck 1 can carry up to 93 units, Trucks 2 and 3 can each carry 61 units, and Truck 4 has a smaller capacity of 11 units. The customer demands are 45, 42, and 71 units for Nodes 1, 2, and 3, respectively. The distances between locations are asymmetric, with the depot to Node 1 being 93 units, Node 1 to Node 2 at 9 units, and Node 2 back to the depot at 20 units, among others. The company aims to minimize the total distance traveled by all trucks while ensuring each customer is visited exactly once, trucks return to the depot, and no truck exceeds its capacity. The challenge is to determine the most efficient routes for the trucks to serve all customers at the lowest possible total travel distance.
**

**Modeling Process:**
**
**1. Decision Variables:**
- `x[i, j, k]`: Binary variable indicating whether truck `k` travels directly from node `i` to node `j` (1 if yes, 0 otherwise).
- `u[i]`: Continuous variable for the Miller-Tucker-Zemlin (MTZ) subtour elimination constraints, representing the position of node `i` in the route.

**2. Parameters:**
- `N = 4`: Total number of nodes (depot + 3 customers).
- `K = 4`: Number of trucks.
- `Q = [93, 61, 61, 11]`: Capacities of the trucks.
- `q = [0, 45, 42, 71]`: Demands at each node (depot has 0 demand).
- `d[i][j]`: Distance matrix representing the distance from node `i` to node `j`.

**3. Objective Function:**
Minimize the total distance traveled by all trucks:
`Minimize: sum(d[i][j] * x[i, j, k] for all k, i, j where i != j)`

**4. Constraints:**
- **Visit Once:** Each customer node (1 to 3) must be visited exactly once:
  `sum(x[i, j, k] for all k, j where i != j) == 1` for each customer `i`.
- **Flow Conservation:** The number of trucks entering a node equals the number leaving it:
  `sum(x[i, j, k] for all j where i != j) == sum(x[j, i, k] for all j where i != j)` for each node `i` and truck `k`.
- **Depot Departure/Return:** Each truck must depart from and return to the depot:
  `sum(x[0, j, k] for j in 1 to 3) <= 1` and `sum(x[0, j, k] for j in 1 to 3) == sum(x[j, 0, k] for j in 1 to 3)` for each truck `k`.
- **Capacity Constraint:** The total demand served by a truck must not exceed its capacity:
  `sum(q[j] * sum(x[i, j, k] for all i where i != j) for j in 1 to 3) <= Q[k]` for each truck `k`.
- **MTZ Subtour Elimination:** Prevents subtours by enforcing order constraints:
  `u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2` for all `i, j in 1 to 3, i != j, and all k`.

**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 4
K = 4
Q = [93, 61, 61, 11]
q = [0, 45, 42, 71]
d = [
    [0, 93, 20, 85],
    [93, 0, 9, 43],
    [20, 9, 0, 81],
    [85, 43, 81, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Truck Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for truck {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for truck {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 396.00

Route for truck 1 (Capacity: 93):
0 -> 3 -> 0
Route Load: 71 / 93

Route for truck 2 (Capacity: 61):
0 -> 1 -> 0
Route Load: 45 / 61

Route for truck 3 (Capacity: 61):
0 -> 2 -> 0
Route Load: 42 / 61


```

================================================================================



--- Problem 452 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy container port is preparing for a major influx of ships, expecting 415 vessels to arrive within a critical 100-minute window. The port has 8 berths, each capable of processing 246 vessels per hour when operational. However, opening berths incurs a cost of $29 per berth per hour. Worse, if the port’s total processing capacity falls short of demand, frustrated ship operators face delays, costing the port $0.44 per vessel per minute of waiting time—a penalty that could quickly escalate.

The operations team faces a high-stakes balancing act: minimize costs by opening as few berths as possible while ensuring sufficient capacity to avoid costly delays. The challenge is compounded by the need to account for worst-case scenarios—what if demand surges unexpectedly? The core question is clear: *How many berths should be opened to strike the perfect balance between operational costs and penalty risks, ensuring smooth entry without overspending?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x`: Integer variable (0 to 8) representing the number of berths to open.  
     - `y`: Binary variable (0 or 1) indicating whether capacity is insufficient (`y=1` if demand exceeds capacity).  
     - `wait_penalty`: Continuous variable for the total waiting penalty cost.  

   - **2. Parameters:**  
     - `total_berths = 8`: Maximum berths available.  
     - `arrival_rate_event = 415`: Vessels arriving during the event.  
     - `service_rate_per_berth = 246`: Vessels processed per berth per hour.  
     - `cost_per_berth = 29`: Hourly cost to operate one berth.  
     - `penalty_per_vessel_minute = 0.44`: Cost per minute per vessel if capacity is insufficient.  
     - `event_duration_minutes = 100`: Duration of the event in minutes.  
     - `M = 10000`: Large constant for big-M constraints.  
     - `epsilon = 0.1`: Small constant to enforce binary logic.  

   - **3. Objective Function:**  
     Minimize total cost:  
     \[
     \text{minimize} \quad (29 \cdot x) + \text{wait\_penalty}
     \]  

   - **4. Constraints:**  
     - **Capacity trigger:**  
       If demand exceeds capacity (`arrival_rate_event > service_rate_per_berth * x`), force `y=1`:  
       \[
       415 - 246x \leq 10000y
       \]  
     - **Sufficiency trigger:**  
       If capacity suffices (`arrival_rate_event <= service_rate_per_berth * x`), force `y=0`:  
       \[
       415 - 246x \geq 0.1 - 10000(1-y)
       \]  
     - **Penalty bounds:**  
       If `y=1`, penalty equals the shortfall multiplied by duration and rate:  
       \[
       \text{wait\_penalty} \geq (415 - 246x) \cdot 100 \cdot 0.44 - 10000(1-y)
       \]  
       Upper bounds ensure penalty is zero if `y=0` and tightly linked to shortfall if `y=1`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math; import numpy as np
# Params
total_berths = 8; arrival_rate_event = 415; service_rate_per_berth = 246
cost_per_berth = 29; penalty_per_vessel_minute = 0.44; event_duration_minutes = 100
M = 10000; epsilon = 0.1
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m4 = gp.Model("Port_Berth_Entry_MIP", env=env)
    # Vars
    x = m4.addVar(vtype=GRB.INTEGER, name="num_open_berths", lb=0, ub=total_berths)
    y = m4.addVar(vtype=GRB.BINARY, name="capacity_insufficient")
    wait_penalty = m4.addVar(name="total_wait_penalty", lb=0)
    # Objective
    m4.setObjective(cost_per_berth * x + wait_penalty, sense=GRB.MINIMIZE)
    # Constraints
    m4.addConstr(arrival_rate_event - service_rate_per_berth * x <= M * y, "force_y_if_insufficient")
    m4.addConstr(arrival_rate_event - service_rate_per_berth * x >= epsilon - M * (1 - y), "force_y_if_sufficient")
    penalty_expr = (arrival_rate_event - service_rate_per_berth * x) * event_duration_minutes * penalty_per_vessel_minute
    m4.addConstr(wait_penalty >= penalty_expr - M * (1 - y), "penalty_lower_bound")
    m4.addConstr(wait_penalty <= M * y, "penalty_upper_bound_y0")
    m4.addConstr(wait_penalty <= penalty_expr + M*(1-y), name="penalty_upper_bound_y1_tight")
    # Optimize
    m4.optimize()
    # Store results
    results_dict['status'] = m4.status
    if m4.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m4.objVal; results_dict['x_optimal'] = x.X
        results_dict['y_optimal'] = y.X; results_dict['wait_penalty_optimal'] = wait_penalty.X
    # Output Results
    print("--- Problem 4: Port Berth Entry Lanes (MIP) ---")
    if m4.status == GRB.OPTIMAL:
        opt_x = results_dict.get('x_optimal', -1); opt_y = results_dict.get('y_optimal', -1); opt_pen = results_dict.get('wait_penalty_optimal', -1)
        print(f"Optimization Status: Optimal"); print(f"Optimal number of berths to open: {int(round(opt_x))}")
        capacity = service_rate_per_berth * opt_x; print(f"Total processing capacity: {capacity:.0f} vessels/hour (Arrival rate: {arrival_rate_event})")
        op_cost = cost_per_berth * opt_x; print(f"Operating cost: ${op_cost:.2f}/hour"); print(f"Estimated waiting penalty: ${opt_pen:.2f}")
        print(f"Total minimized cost: ${m4.objVal:.2f}/hour"); print(f"Is capacity insufficient (y=1)? {'Yes' if opt_y > 0.5 else 'No'}")
    elif m4.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible")
    else: print(f"Optimization Status: {m4.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_BERTH
```
Answer:
--- Problem 4: Port Berth Entry Lanes (MIP) ---
Optimization Status: Optimal
Optimal number of berths to open: 2
Total processing capacity: 492 vessels/hour (Arrival rate: 415)
Operating cost: $58.00/hour
Estimated waiting penalty: $0.00
Total minimized cost: $58.00/hour
Is capacity insufficient (y=1)? No



================================================================================



--- Problem 453 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
**
A port operator faces the challenge of dynamically pricing berthing fees during different traffic periods to maximize revenue while respecting the port's capacity limits. The port experiences two distinct periods: "off-peak" with a base demand of 966 ships per hour and "peak" with a significantly higher base demand of 2893 ships per hour. The operator can adjust berthing fees up to a maximum of $6 per ship, with demand sensitivity (alpha) set at 38 ships per hour for every dollar increase in berthing fee. The port's capacity is fixed at 1638 ships per hour, meaning the number of ships that can be accommodated cannot exceed this limit regardless of demand.  

The core question is: What berthing fees should be set during off-peak and peak periods to maximize total revenue, ensuring that the resulting traffic flow does not exceed capacity and that demand responds linearly to price changes? The operator must balance higher fees (which reduce demand but increase revenue per ship) against lower fees (which attract more ships but may not fully utilize capacity).

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- `fee[p]`: Berthing fee (in $) for period `p` (where `p` is either "off" or "peak"). Bounded between 0 and `max_fee` ($6).  
- `demand[p]`: Resulting demand (ships/hr) for period `p`, calculated as `base_demand[p] - alpha * fee[p]`.  
- `flow[p]`: Actual traffic flow (ships/hr) for period `p`, constrained by both demand and capacity.  

**2. Parameters:**  
- `capacity = 1638`: Maximum flow capacity (ships/hr).  
- `base_demand = {'off': 966, 'peak': 2893}`: Base demand (ships/hr) when fees are $0.  
- `alpha = 38`: Demand sensitivity (ships/hr per $1 fee increase).  
- `max_fee = 6`: Upper bound on berthing fee ($).  

**3. Objective Function:**  
Maximize total revenue:  
`Maximize: sum(flow[p] * fee[p] for p in periods)`  

**4. Constraints:**  
- Demand calculation for each period `p`:  
  `demand[p] == base_demand[p] - alpha * fee[p]`  
- Flow cannot exceed capacity:  
  `flow[p] <= capacity`  
- Flow cannot exceed demand:  
  `flow[p] <= demand[p]`  
- Non-negativity:  
  `fee[p], demand[p], flow[p] >= 0`  

---

**

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 1638; base_demand = {'off': 966, 'peak': 2893}; alpha = 38; max_fee = 6; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berthing_Fees_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berthing Fees (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of DYNAMIC_BERTHING_FEES
```
Answer:
--- Problem 18: Dynamic Berthing Fees (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $14256.00
  Period: Off
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 738.0 ships/hr (Base: 966)
    Actual Flow (min(Demand, Capacity)): 738.0 ships/hr (Capacity: 1638)
    Revenue this period: $4428.00
  Period: Peak
    Optimal Fee: $6.00 (Max: $6)
    Resulting Demand: 2665.0 ships/hr (Base: 2893)
    Actual Flow (min(Demand, Capacity)): 1638.0 ships/hr (Capacity: 1638)
    Revenue this period: $9828.00
Total ships processed: 2376.0



================================================================================


--- Problem 454 ---
**Difficulty:** easy
**Category:** MIP

**Problem Description:**
**
A logistics company operates a single truck to serve a small network consisting of a central depot (Node 0) and one customer location (Node 1). The truck has a maximum capacity of 21.55 units, and the customer demand is 11 units. The distance from the depot to the customer is 55 units, and the return trip is equally long. The challenge is to determine the most efficient route for the truck to deliver the required goods while minimizing the total travel distance. The truck must start and end at the depot, visit the customer exactly once, and respect its capacity limit. The key question is: What is the shortest possible route that meets all operational constraints while fulfilling the customer's demand?
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `x[i, j, k]` indicates whether truck `k` travels directly from node `i` to node `j`.  
   - Continuous variable `u[i]` (for subtour elimination, though not strictly necessary here due to the small problem size).  

   **2. Parameters:**  
   - `N = 2`: Total nodes (depot + customer).  
   - `K = 1`: Number of trucks.  
   - `Q = [21.55]`: Truck capacity.  
   - `q = [0, 11]`: Demand at each node (depot has 0 demand).  
   - `d = [[0, 55], [55, 0]]`: Distance matrix between nodes.  

   **3. Objective Function:**  
   Minimize the total distance traveled:  
   \[
   \text{Minimize: } \sum_{k=0}^{K-1} \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} d[i][j] \cdot x[i, j, k]
   \]  

   **4. Constraints:**  
   - **Visit Once:** The customer (Node 1) must be visited exactly once.  
   - **Flow Conservation:** The number of incoming and outgoing edges at each node must balance.  
   - **Depot Departure/Return:** The truck must leave and return to the depot (Node 0).  
   - **Capacity:** The total demand served by the truck must not exceed its capacity.  
   - **Subtour Elimination (MTZ):** Ensures no disconnected cycles (though redundant here).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 2
K = 1
Q = [21.55]
q = [0, 11]
d = [
    [0, 55],
    [55, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Truck Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for truck {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for truck {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 110.00

Route for truck 1 (Capacity: 21.55):
0 -> 1 -> 0
Route Load: 11 / 21.55


```

================================================================================



--- Problem 455 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
A maritime logistics company is tasked with transporting goods over a long-haul route spanning 8,937 nautical miles. The fleet consists of up to 10 ships, each incurring a fixed wear-and-tear cost of $44 per trip, regardless of distance traveled. Fuel consumption is a critical factor, with each ship burning 0.212 liters of fuel per nautical mile, and fuel costs set at $2.18 per liter. The total fuel cost for the entire distance is pre-calculated at $4,130.32, a constant expense regardless of the number of ships deployed.  

   The company aims to minimize the total operational cost, which includes both the fixed costs of using the ships and the fuel expenditure. The challenge lies in determining the optimal number of ships to deploy—balancing the fixed costs against the fuel efficiency. Using too few ships might strain resources, while deploying too many would unnecessarily inflate fixed costs. The central question is: **What is the most cost-effective number of ships to assign to this route to minimize the total expense while adhering to the fleet size limits?**

**Modeling Process:**
- **1. Decision Variables:**  
     - `n`: Integer variable representing the number of ships to use, constrained between 1 and 10 (inclusive).  

   - **2. Parameters:**  
     - `total_distance_nm = 8,937`: Total distance of the route in nautical miles.  
     - `fuel_consumption_rate_L_per_nm = 0.212`: Fuel consumption rate in liters per nautical mile.  
     - `fuel_cost_per_L = 2.18`: Cost of fuel per liter in dollars.  
     - `fixed_cost_per_ship = 44`: Fixed cost per ship in dollars.  
     - `max_ships = 10`: Maximum number of ships available.  
     - `total_fuel_cost = 4,130.32`: Pre-computed total fuel cost for the entire distance.  

   - **3. Objective Function:**  
     Minimize the total cost, which is the sum of fixed costs and fuel costs:  
     \[
     \text{Minimize: } n \times 44 + 4,130.32
     \]  

   - **4. Constraints:**  
     - Bounds on the number of ships:  
       \[
       1 \leq n \leq 10
       \]  
     - No additional constraints are needed beyond the variable bounds.  

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_distance_nm = 8937
fuel_consumption_rate_L_per_nm = 0.212
fuel_cost_per_L = 2.18
fixed_cost_per_ship = 44
max_ships = 10

# Calculated total fuel cost (constant)
total_fuel_cost = 4130.32
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m30 = gp.Model("FLEET_FUEL_MINIMIZE_IP", env=env)

    # --- Decision Variables ---
    # Integer: Number of ships to use
    # Ensure lb=1 so division in output works
    n = m30.addVar(vtype=GRB.INTEGER, name="num_ships_used", lb=1, ub=max_ships)

    # --- Objective Function ---
    # Minimize total fixed cost + total fuel cost
    total_fixed_cost_expr = n * fixed_cost_per_ship
    m30.setObjective(total_fixed_cost_expr + total_fuel_cost, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraints on n are handled by variable bounds (lb=1, ub=max_ships)
    # No other constraints in this simple model

    # --- Optimization ---
    m30.optimize()

    # --- Store results ---
    results_dict['status'] = m30.status
    if m30.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m30.ObjVal
        results_dict['n_sol'] = n.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- FLEET_FUEL_MINIMIZE: Fuel Minimization for Fleet (IP) ---")
    if m30.status == GRB.OPTIMAL:
        opt_n = int(round(results_dict.get('n_sol', 1))) # Round and ensure integer >= 1
        opt_fixed_cost = opt_n * fixed_cost_per_ship
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Optimal Number of Ships to Use: {opt_n} (Max allowed: {max_ships})")
        print(f"Resulting Fixed Wear-and-Tear Cost: ${opt_fixed_cost:.2f} (Cost/Ship: ${fixed_cost_per_ship})")
        print(f"Total Fuel Cost (Constant): ${total_fuel_cost:.2f}")
        print(f"Minimum Total Cost: ${obj_val_print:.2f}")
        # Avoid division by zero if opt_n somehow becomes 0 (lb=1 should prevent)
        if opt_n > 0:
             print(f"Distance per ship: {total_distance_nm / opt_n:.1f} nm (Total: {total_distance_nm} nm)")
        else:
             print("Cannot calculate distance per ship (0 ships).")


    elif m30.status == GRB.INFEASIBLE:
         # Should not happen with lb=1 and ub >= lb
         print(f"Optimization Status: Infeasible. Check variable bounds (lb=1, ub={max_ships}).")
    elif m30.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         # Should be very fast, but include handling just in case
         if m30.ObjVal is not None and abs(m30.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m30.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m30.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Leave empty as the code is complete and prints all required outputs)
```
Answer:
--- FLEET_FUEL_MINIMIZE: Fuel Minimization for Fleet (IP) ---
Optimization Status: Optimal
Optimal Number of Ships to Use: 1 (Max allowed: 10)
Resulting Fixed Wear-and-Tear Cost: $44.00 (Cost/Ship: $44)
Total Fuel Cost (Constant): $4130.32
Minimum Total Cost: $4174.32
Distance per ship: 8937.0 nm (Total: 8937 nm)


```

================================================================================



--- Problem 456 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A busy port requires efficient scheduling of ship berthing to minimize delays for vessels. The port operates with two distinct berths, each handling a specific flow of ships. Port managers face the challenge of allocating berthing time to each berth within a strict 15-hour cycle, ensuring the total berthing time across both berths exactly matches this cycle duration. The goal is to minimize the total delay experienced by ships, which depends on both the ship arrival rates and the non-berthing time (cycle time minus berthing time) for each berth.

Ship arrival coefficients for the two berths are measured at 2279 and 1830 ships per day, respectively, reflecting the varying demand at the port. Berthing times must adhere to practical limits: no less than 6 hours and no more than 15 hours per berth. The core question is: *How should the 15-hour cycle be split between the two berths to minimize the total delay for all ships?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - \( t_i \): Continuous variable representing the berthing time (in hours) allocated to berth \( i \), where \( i \in \{1, 2\} \).  
   - Bounds: \( 6 \leq t_i \leq 15 \).  

   **2. Parameters:**  
   - \( \text{arrival_coeff}_i \): Ship arrival coefficient for berth \( i \) (2279 for berth 1, 1830 for berth 2).  
   - \( \text{cycle_time} \): Total berthing cycle time (15 hours).  
   - \( \text{lb_time} \): Minimum berthing time per berth (6 hours).  
   - \( \text{ub_time} \): Maximum berthing time per berth (15 hours).  

   **3. Objective Function:**  
   Minimize the total delay:  
   \[
   \text{Minimize: } \sum_{i=1}^{2} \text{arrival_coeff}_i \times (\text{cycle_time} - t_i)
   \]  

   **4. Constraints:**  
   - The sum of berthing times must equal the cycle time:  
     \[
     t_1 + t_2 = 15
     \]  
   - Bounds on berthing times:  
     \[
     6 \leq t_1 \leq 15, \quad 6 \leq t_2 \leq 15
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_berths = 2
lb_time = 6          # Lower bound for berthing time
ub_time = 15         # Upper bound for berthing time
cycle_time = 15      # Total cycle time (set equal to ub_time)
arrival_coeffs = [2279, 1830] # Ship arrival coefficients per berth
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_coeffs) != num_berths:
    print("Error: arrival_coeffs length mismatch with num_berths")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_coeffs length"
    # raise ValueError("arrival_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_berths}-Berth Scheduling", env=env)

        # --- Decision variables (dynamic based on num_berths) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_berths, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total delay ---
        # Delay for berth i is proportional to arrival * non-berthing_time = arrival * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_berths)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_berths)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_berths)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total delay: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_berths):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total delay: 30144.00
------------------------------
Optimal berthing times (hours):
  t1: 9.00, t2: 6.00


```

================================================================================



--- Problem 457 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
At a busy container port, the operations team needs to optimize the allocation of crane time for two major berths: Berth A and Berth B. The total available time for crane operations is 98 minutes per shift, during which each berth must account for not only the active crane time but also the lost time—3 minutes for setup and 2 minutes for maintenance, totaling 5 minutes per berth. The minimum active crane time for either berth is set to 21 minutes to ensure efficient loading and unloading and to avoid delays.

Berth A handles an arrival flow of 565 containers per hour against a maximum capacity of 1,394 containers per hour, while Berth B sees 664 containers arriving against a maximum capacity of 1,289. The goal is to allocate active crane times in a way that maximizes the *weighted sum* of active times, where the weights reflect the degree of utilization (arrival flow divided by maximum capacity) for each berth. This ensures that the berth with higher demand relative to its capacity receives proportionally more active crane time, minimizing delays and improving overall port efficiency.

The core question is: *How should the available active crane time be split between Berth A and Berth B to maximize the weighted utilization of the cranes, while respecting the shift time and minimum active time constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `t_a`: Continuous variable representing the active crane time (minutes) for Berth A.  
- `t_b`: Continuous variable representing the active crane time (minutes) for Berth B.  

**2. Parameters:**  
- `shift_time = 98`: Total duration (minutes) of the crane operation shift.  
- `lost_time_per_berth = 5`: Sum of setup (3m) and maintenance (2m) times per berth.  
- `min_active = 21`: Minimum allowable active crane time (minutes) for any berth.  
- `max_capacity_a = 1394`, `arr_flow_a = 565`: Maximum capacity and arrival flows (containers/hour) for Berth A.  
- `max_capacity_b = 1289`, `arr_flow_b = 664`: Maximum capacity and arrival flows (containers/hour) for Berth B.  
- Weights:  
  - `weight_a = arr_flow_a / max_capacity_a` (≈ 0.4053 for Berth A).  
  - `weight_b = arr_flow_b / max_capacity_b` (≈ 0.5151 for Berth B).  

**3. Objective Function:**  
Maximize the weighted sum of active crane times:  
`Maximize: weight_a * t_a + weight_b * t_b`.  

**4. Constraints:**  
- **Shift time:** Total berth times (active + lost time) must equal the shift time:  
  `t_a + lost_time_per_berth + t_b + lost_time_per_berth = shift_time`.  
- **Minimum active time:**  
  `t_a ≥ min_active`, `t_b ≥ min_active`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
shift_time = 98
setup_time = 3
maintenance_time = 2
min_active = 21
max_capacity_a = 1394
arr_flow_a = 565
max_capacity_b = 1289
arr_flow_b = 664
lost_time_per_berth = 5 # setup + maintenance
# --- End Parameters ---

GUROBI_TIME_LIMIT = 15

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("CRANE_OPERATION_TIMING", env=env)

    # --- Decision Variables ---
    # t_a: active crane time for Berth A (minutes)
    t_a = m.addVar(lb=min_active, vtype=GRB.CONTINUOUS, name="t_a")
    # t_b: active crane time for Berth B (minutes)
    t_b = m.addVar(lb=min_active, vtype=GRB.CONTINUOUS, name="t_b")

    # --- Objective Function: Maximize weighted active crane times ---
    # Weight by flow/capacity ratio (degree of utilization)
    # Avoid division by zero
    weight_a = arr_flow_a / max_capacity_a if max_capacity_a > 1e-6 else 0
    weight_b = arr_flow_b / max_capacity_b if max_capacity_b > 1e-6 else 0
    m.setObjective(weight_a * t_a + weight_b * t_b, GRB.MAXIMIZE)

    # --- Constraints ---
    # Shift time constraint: sum of berth times must equal shift time
    # Berth time = active + lost_time_per_berth
    m.addConstr(t_a + lost_time_per_berth + t_b + lost_time_per_berth == shift_time, "ShiftTimeConstraint")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['t_a_sol'] = t_a.X # Not needed for output
        # results_dict['t_b_sol'] = t_b.X # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        # Format objective value (weighted active crane time sum)
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show more decimals for weighted sum
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the active crane times for each berth
if m.Status == GRB.OPTIMAL:
    print(f"Optimal objective value: {obj_val_print:.4f}")
    print(f"Active crane time for Berth A: {t_a.X:.4f} minutes")
    print(f"Active crane time for Berth B: {t_b.X:.4f} minutes")
```
Answer:
Optimal objective value: 43.0251
Optimal objective value: 43.0251
Active crane time for Berth A: 21.0000 minutes
Active crane time for Berth B: 67.0000 minutes


```

================================================================================



--- Problem 458 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy inland logistics hub, five delivery trucks arrive at staggered times, each requiring immediate unloading at one of the available depots. The hub has three depots, but the goal is to minimize the number of depots actively used while ensuring all trucks are serviced without delays or overlaps. Truck 1 arrives at hour 3 and takes 5 hours to unload, Truck 2 arrives at hour 8 and needs 4 hours, while Trucks 3, 4, and 5 arrive at hours 12, 15, and 20 respectively, each requiring 5 hours of handling. The challenge is to assign each truck to a depot such that no two trucks scheduled on the same depot overlap in processing time, while keeping the total number of active depots as low as possible. The hub manager must
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary (1 if truck *i* is assigned to depot *j*, else 0).  
     - `start_time(i)`: Continuous, ≥0 (when truck *i* begins processing).  
     - `completion_time(i)`: Continuous, ≥0 (when truck *i* finishes).  
     - `precedes(i, k, j)`: Binary (1 if truck *i* is scheduled before truck *k* on depot *j*, else 0).  
     - `depot_used(j)`: Binary (1 if depot *j* is used, else 0).  

   - **2. Parameters:**  
     - `trucks = [1, 2, 3, 4, 5]`, `depots = [1, 2, 3]`.  
     - `arrival_times`: {1:3, 2:8, 3:12, 4:15, 5:20}.  
     - `processing_times`: {1:5, 2:4, 3:5, 4:5, 5:5}.  
     - `H = 100` (large constant for precedence constraints).  

   - **3. Objective Function:**  
     Minimize total depots used:  
     `Minimize: sum(depot_used[j] for j in depots)`.  

   - **4. Constraints:**  
     - Each truck assigned to exactly one depot:  
       `sum(assign[i, j] for j in depots) = 1` for all *i*.  
     - Start time ≥ arrival time:  
       `start_time[i] ≥ arrival_times[i]` for all *i*.  
     - Completion time = start time + processing time:  
       `completion_time[i] = start_time[i] + processing_times[i]` for all *i*.  
     - No overlapping on the same depot (if *i* precedes *k* on *j*, enforce `start_time[k] ≥ completion_time[i]`, else reverse).  
     - Link `depot_used[j]` to assignments:  
       `assign[i, j] ≤ depot_used[j]` for all *i*, *j*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2, 3]
arrival_times = {1: 3, 2: 8, 3: 12, 4: 15, 5: 20}
processing_times = {1: 5, 2: 4, 3: 5, 4: 5, 5: 5}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_52_MIN_DEPOTS")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    depot_used = m.addVars(depots, vtype=GRB.BINARY, name="DepotUsed") # Objective var

    # --- Objective Function ---
    m.setObjective(gp.quicksum(depot_used[j] for j in depots), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Link DepotUsed to assignments
    m.addConstrs((assign[i, j] <= depot_used[j] for i in trucks for j in depots), name="link_used_depot")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{int(round(obj_val_print))}") # Number of depots
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Ensure Complete Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.2f}, Completion Time: {completion_time[i].x:.2f}")
    print(f"Total number of depots used: {int(round(results_dict['obj_val']))}")
else:
    print(f"Optimization ended with status {m.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
1
Optimal Solution Found:
Truck 1 is assigned to Depot 3
  Start Time: 3.00, Completion Time: 8.00
Truck 2 is assigned to Depot 3
  Start Time: 8.00, Completion Time: 12.00
Truck 3 is assigned to Depot 3
  Start Time: 12.00, Completion Time: 17.00
Truck 4 is assigned to Depot 3
  Start Time: 17.00, Completion Time: 22.00
Truck 5 is assigned to Depot 3
  Start Time: 22.00, Completion Time: 27.00
Total number of depots used: 1


```

================================================================================



--- Problem 459 ---
**Difficulty:** medium
**Category:** QP

**Problem Description:**
A port operator faces the challenge of dynamically adjusting berthing fees across two distinct traffic periods—off-peak and peak—to maximize revenue while respecting infrastructure constraints. During off-peak hours, the base demand for berthing is 1,155 ships per hour, while peak hours see a significantly higher base demand of 3,198 ships per hour. The operator knows that demand is sensitive to fee changes: for every $1 increase in berthing fees, demand drops by 62 ships per hour. The port has a fixed capacity of 3,996 ships per hour, meaning the actual flow of ships cannot exceed this limit, regardless of demand. Additionally, the operator cannot charge more than $15 per ship in any period.

The operator’s dilemma is to determine the optimal berthing fees for each period that will maximize total revenue, balancing the trade-off between higher fees (which reduce demand but increase per-ship revenue) and lower fees (which attract more ships but yield less revenue per ship). The solution must also ensure that the actual flow of ships never surpasses the port’s capacity or the demand for that period. The core question is: *What berthing fees should be set for off-peak and peak periods to achieve the highest possible total revenue, given these constraints?*

---

**Modeling Process:**
#### 1. **Decision Variables:**
   - `fee[p]`: The berthing fee (in dollars) for period `p` (where `p` is either 'off' or 'peak'). Bounded between 0 and 15.
   - `demand[p]`: The resulting demand (in ships per hour) for period `p`, calculated as a function of the base demand and fee sensitivity.
   - `flow[p]`: The actual flow of ships (in ships per hour) for period `p`, which is the minimum of demand and capacity.

#### 2. **Parameters:**
   - `base_demand = {'off': 1155, 'peak': 3198}`: Base demand (ships/hr) for each period.
   - `alpha = 62`: Fee sensitivity coefficient (demand drops by 62 ships/hr per $1 increase).
   - `capacity = 3996`: Maximum flow capacity (ships/hr) of the port.
   - `max_fee = 15`: Upper bound on berthing fee ($).

#### 3. **Objective Function:**
   - Maximize the total revenue across both periods:
     ```
     Maximize: sum(flow[p] * fee[p] for p in periods)
     ```

#### 4. **Constraints:**
   - **Demand Calculation:** For each period `p`, demand is linearly dependent on fee:
     ```
     demand[p] = base_demand[p] - alpha * fee[p]
     ```
   - **Flow Capacity:** The actual flow cannot exceed the port’s capacity:
     ```
     flow[p] <= capacity for each p
     ```
   - **Flow Demand:** The actual flow cannot exceed the demand:
     ```
     flow[p] <= demand[p] for each p
     ```
   - **Non-Negativity:** All variables (`fee`, `demand`, `flow`) are non-negative.

---

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
capacity = 3996; base_demand = {'off': 1155, 'peak': 3198}; alpha = 62; max_fee = 15; periods = ['off', 'peak']
# End Params
GUROBI_TIME_LIMIT = 15
if 'results_dict' not in globals(): results_dict = {} # Double braces for literal dict
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m18 = gp.Model("Dynamic_Berthing_Fees_QP", env=env)
    # Vars
    fee = m18.addVars(periods, name="fee", lb=0, ub=max_fee)
    demand = m18.addVars(periods, name="demand", lb=0) # Keep demand non-negative
    flow = m18.addVars(periods, name="flow", lb=0)
    # Constraints
    for p in periods:
        # Use double braces {p} for inner f-string variable name
        m18.addConstr(demand[p] == base_demand[p] - alpha * fee[p], f"demand_calc_{p}")
        m18.addConstr(flow[p] <= capacity, f"flow_cap_{p}")
        m18.addConstr(flow[p] <= demand[p], f"flow_demand_{p}")
    # Objective - Quadratic
    m18.setObjective(gp.quicksum(flow[p] * fee[p] for p in periods), sense=GRB.MAXIMIZE)
    # Optimize
    m18.optimize()
    # Store results
    results_dict['status'] = m18.status
    if m18.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m18.objVal; results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)
    elif m18.status == GRB.TIME_LIMIT and m18.SolCount > 0:
        results_dict['obj_val'] = m18.objVal
        # Store partial solution if needed for output below
        results_dict['fee_sol'] = m18.getAttr('X', fee)
        results_dict['demand_sol'] = m18.getAttr('X', demand); results_dict['flow_sol'] = m18.getAttr('X', flow)

    # --- Output Results (Corrected Nested f-strings) ---
    print("--- Problem 18: Dynamic Berthing Fees (QP) ---")
    if m18.status == GRB.OPTIMAL:
        # Escape braces for variables used in inner f-strings: {...}
        print(f"Optimization Status: Optimal"); print(f"Maximum Total Revenue: ${m18.objVal:.2f}") # Double braces added
        fee_sol = results_dict.get('fee_sol',{}); demand_sol = results_dict.get('demand_sol',{}); flow_sol = results_dict.get('flow_sol',{}) # Double for literal dict
        total_flow = 0
        for p in periods:
            f_opt = fee_sol.get(p, 0); d_opt = demand_sol.get(p, 0); fl_opt = flow_sol.get(p, 0); rev_p = fl_opt * f_opt
            # Escape braces for variables used in inner f-strings
            print(f"  Period: {p.capitalize()}")
            print(f"    Optimal Fee: ${f_opt:.2f} (Max: ${max_fee})") # Double braces added
            print(f"    Resulting Demand: {d_opt:.1f} ships/hr (Base: {base_demand.get(p,0)})") # Double braces added
            print(f"    Actual Flow (min(Demand, Capacity)): {fl_opt:.1f} ships/hr (Capacity: {capacity})") # Double braces added
            print(f"    Revenue this period: ${rev_p:.2f}"); total_flow += fl_opt # Double braces added
        print(f"Total ships processed: {total_flow:.1f}") # Double braces added
    elif m18.status == GRB.INFEASIBLE: print(f"Optimization Status: Infeasible.")
    elif m18.status == GRB.UNBOUNDED: print(f"Optimization Status: Unbounded.")
    elif m18.status == GRB.TIME_LIMIT:
        print(f"Optimization Status: Time Limit ({GUROBI_TIME_LIMIT}s).") # Double for literal placeholder
        if m18.SolCount > 0: print(f"Best objective found: ${m18.objVal:.2f}") # Double braces added
        else: print("No feasible solution found.")
    else: print(f"Optimization Status Code: {m18.status}") # Double braces added
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1 # Double braces added
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2 # Double braces added
# End of TOLL_PRICING
```
Answer:
--- Problem 18: Dynamic Berthing Fees (QP) ---
Optimization Status: Optimal
Maximum Total Revenue: $39399.13
  Period: Off
    Optimal Fee: $9.31 (Max: $15)
    Resulting Demand: 577.5 ships/hr (Base: 1155)
    Actual Flow (min(Demand, Capacity)): 577.5 ships/hr (Capacity: 3996)
    Revenue this period: $5379.13
  Period: Peak
    Optimal Fee: $15.00 (Max: $15)
    Resulting Demand: 2268.0 ships/hr (Base: 3198)
    Actual Flow (min(Demand, Capacity)): 2268.0 ships/hr (Capacity: 3996)
    Revenue this period: $34020.00
Total ships processed: 2845.5



================================================================================



--- Problem 460 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy inland port, seven trucks arrive at varying times, each requiring a depot for unloading and processing. The port has only two depots available, and the challenge is to schedule these trucks efficiently to minimize the total time taken to service all vehicles (the *makespan*). Each truck has a specific arrival time (e.g., Truck 1 arrives at 3.9 hours, Truck 2 at 5.4 hours) and a fixed processing duration (e.g., Truck 1 takes 3 hours, Truck 2 takes 8 hours). A critical operational rule enforces a minimum gap of 0.7 hours between the start times of any two trucks, regardless of their assigned depot, to avoid logistical conflicts. The port manager must determine the optimal assignment of trucks to depots and their start times to ensure all trucks are serviced as quickly as possible while adhering to these constraints. The core question is: *What is the shortest possible time to complete all truck operations, given the arrival times, processing durations, and start-time separation rule?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to depot *j*, 0 otherwise).  
     - `start_time(i)`: Continuous variable representing the start time of truck *i*.  
     - `completion_time(i)`: Continuous variable representing the completion time of truck *i*.  
     - `precedes(i, k, j)`: Binary variable (1 if truck *i* precedes truck *k* on depot *j*, 0 otherwise).  
     - `z_start_sep(i, k)`: Binary variable enforcing the minimum start-time gap between trucks *i* and *k*.  
     - `makespan`: Continuous variable representing the total completion time of all trucks.  

   - **2. Parameters:**  
     - `trucks`: [1, 2, 3, 4, 5, 6, 7] (list of trucks).  
     - `depots`: [1, 2] (list of depots).  
     - `arrival_times`: {1: 3.9, 2: 5.4, ..., 7: 18.1} (arrival time for each truck).  
     - `processing_times`: {1: 3, 2: 8, ..., 7: 7} (processing duration for each truck).  
     - `min_start_gap`: 0.7 (minimum required gap between start times of any two trucks).  
     - `H`: 100 (a large constant for Big-M constraints).  

   - **3. Objective Function:**  
     Minimize `makespan` (the latest completion time among all trucks).  

   - **4. Constraints:**  
     1. **Assignment:** Each truck must be assigned to exactly one depot.  
        - `sum(assign(i, j) for j in depots) = 1` for all trucks *i*.  
     2. **Arrival Time:** A truck cannot start before its arrival time.  
        - `start_time(i) >= arrival_times[i]` for all trucks *i*.  
     3. **Completion Time:** Completion time is the sum of start time and processing time.  
        - `completion_time(i) = start_time(i) + processing_times[i]` for all trucks *i*.  
     4. **Non-Overlapping:** Trucks on the same depot must not overlap.  
        - If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)`.  
        - If `precedes(i, k, j) = 0`, then `start_time(i) >= completion_time(k)`.  
     5. **Makespan Definition:** The makespan is the maximum completion time.  
        - `makespan >= completion_time(i)` for all trucks *i*.  
     6. **Start-Time Separation:** Any two trucks must start at least 0.7 hours apart.  
        - `start_time(i) >= start_time(k) + min_start_gap - H * (1 - z_start_sep(i, k))`.  
        - `start_time(k) >= start_time(i) + min_start_gap - H * z_start_sep(i, k))`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7]
depots = [1, 2]
arrival_times = {1: 3.9, 2: 5.4, 3: 9.2, 4: 11.3, 5: 15.0, 6: 16.9, 7: 18.1}
processing_times = {1: 3, 2: 8, 3: 5, 4: 8, 5: 3, 6: 3, 7: 7}
min_start_gap = 0.7
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_48_START_GAP")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    # Binary var for start separation disjunction
    z_start_sep = m.addVars([(i, k) for i in trucks for k in trucks if i < k],
                            vtype=GRB.BINARY, name="z_start_sep")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. Global Start Time Separation Constraint using Big-M
    for i in trucks:
        for k in trucks:
            if i < k:
                 m.addConstr(start_time[i] >= start_time[k] + min_start_gap - H * (1-z_start_sep[i,k]), name=f"start_gap1_{i}_{k}")
                 m.addConstr(start_time[k] >= start_time[i] + min_start_gap - H * z_start_sep[i,k], name=f"start_gap2_{i}_{k}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")
        if m.SolCount > 0 and abs(m.ObjVal) < GRB.INFINITY :
             print(f"{m.ObjVal:.4f}")
        elif m.status != GRB.INFEASIBLE and m.status != GRB.UNBOUNDED:
             print("No feasible solution found.")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.4f}")
                print(f"  Completion Time: {completion_time[i].x:.4f}")
    print(f"Total Makespan: {makespan.x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
40.9000
Optimal Solution Found:
Truck 1 is assigned to Depot 2
  Start Time: 3.9000
  Completion Time: 6.9000
Truck 2 is assigned to Depot 2
  Start Time: 6.9000
  Completion Time: 14.9000
Truck 3 is assigned to Depot 2
  Start Time: 14.9000
  Completion Time: 19.9000
Truck 4 is assigned to Depot 2
  Start Time: 22.9000
  Completion Time: 30.9000
Truck 5 is assigned to Depot 2
  Start Time: 19.9000
  Completion Time: 22.9000
Truck 6 is assigned to Depot 2
  Start Time: 37.9000
  Completion Time: 40.9000
Truck 7 is assigned to Depot 2
  Start Time: 30.9000
  Completion Time: 37.9000
Total Makespan: 40.9000


```

================================================================================



--- Problem 461 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy maritime port, three cargo ships arrive at staggered times, each requiring immediate berthing to unload their goods. Ship 1 docks at 6:00, Ship 2 at 10:00, and Ship 3 at 15:00. The port has three berths available, but each ship can only occupy one berth at a time. Processing times vary: Ship 1 takes 5 hours, Ship 2 takes 7 hours, and Ship 3 takes 8 hours. The port manager faces the challenge of assigning berths to ships while minimizing the total time each ship spends in port (from arrival to departure). The key constraint is avoiding overlaps—no two ships can occupy the same berth simultaneously. The central question is: *What is the optimal berth assignment and scheduling sequence that minimizes the cumulative time all ships spend in port?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable (1 if ship *i* is assigned to berth *j*, 0 otherwise).  
   - `start_time(i)`: Continuous variable representing the time ship *i* begins processing.  
   - `completion_time(i)`: Continuous variable representing the time ship *i* finishes processing.  
   - `precedes(i, k, j)`: Binary variable (1 if ship *i* is scheduled before ship *k* on berth *j*, 0 otherwise).  

   **2. Parameters:**  
   - `ships = [1, 2, 3]`, `berths = [1, 2, 3]`.  
   - `arrival_times = {1: 6, 2: 10, 3: 15}`.  
   - `processing_times = {1: 5, 2: 7, 3: 8}`.  
   - `H = 100` (a large constant for linearization).  

   **3. Objective Function:**  
   Minimize the total time in port for all ships:  
   `Minimize: sum(completion_time[i] - arrival_times[i] for all ships i)`.  

   **4. Constraints:**  
   - **Assignment:** Each ship must be assigned to exactly one berth:  
     `sum(assign(i, j) for all j) = 1` for each ship *i*.  
   - **Arrival Time:** Ships cannot start before arrival:  
     `start_time[i] >= arrival_times[i]` for each ship *i*.  
   - **Completion Time:** Processing time must be accounted for:  
     `completion_time[i] = start_time[i] + processing_times[i]` for each ship *i*.  
   - **Non-Overlapping:** If two ships *i* and *k* share a berth *j*, one must precede the other:  
     If `precedes(i, k, j) = 1`, then `start_time[k] >= completion_time[i]`.  
     If `precedes(i, k, j) = 0`, then `start_time[i] >= completion_time[k]`.  
     Additionally, `assign(i, j) + assign(k, j) - 1 <= precedes(i, k, j) + (1 - precedes(i, k, j))`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [1, 2, 3]
berths = [1, 2, 3]
arrival_times = {1: 6, 2: 10, 3: 15}
processing_times = {1: 5, 2: 7, 3: 8}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("BERTHING_PROBLEM_11_MIN_TOTAL_TIME")

    if not ships or not berths: raise ValueError("Empty ships or berths")

    # --- Decision Variables ---
    assign = m.addVars(ships, berths, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(ships, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in ships for k in ships if i < k for j in berths],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(completion_time[i] - arrival_times.get(i, 0) for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in ships), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in ships), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in ships), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in berths:
        for i in ships:
            for k in ships:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Total time in port
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the berth assignments and start/completion times for each ship
if m.status == GRB.OPTIMAL:
    print("Optimal Berth Assignments and Schedules:")
    for i in ships:
        for j in berths:
            if assign[i, j].x > 0.5:
                print(f"Ship {i} is assigned to Berth {j}")
                print(f"  Start Time: {start_time[i].x:.2f}")
                print(f"  Completion Time: {completion_time[i].x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
24.0000
Optimal Berth Assignments and Schedules:
Ship 1 is assigned to Berth 1
  Start Time: 6.00
  Completion Time: 11.00
Ship 2 is assigned to Berth 1
  Start Time: 11.00
  Completion Time: 18.00
Ship 3 is assigned to Berth 1
  Start Time: 18.00
  Completion Time: 26.00


```

================================================================================



--- Problem 462 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A maritime logistics company is tasked with optimizing the berthing schedule for 8 distinct ships (nodes 0 to 7) at a port. The goal is to minimize the total berthing time while ensuring each ship is assigned a unique berth and returns to its starting point (node 0). The berthing times between nodes are asymmetric, meaning the berthing time from node A to node B may differ from the reverse trip. For instance, berthing from node 0 to node 1 takes 34 minutes, but the return trip also takes 34 minutes, while other pairs like (0, 2) and (2, 0) have differing times (29 and 29 minutes, respectively). The challenge is to determine the sequence of berthing that achieves the shortest possible round-trip time, adhering to the constraints that the ships must depart from and return to the initial berth (node 0) and avoid subtours—smaller loops that exclude some nodes.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `x[i, j]` for each pair of nodes `(i, j)` where `i ≠ j`:  
       - `x[i, j] = 1` if the ship berths directly from node `i` to node `j`, else `0`.  
     - Continuous variable `u[i]` for each node `i` (used for subtour elimination).  
   - **2. Parameters:**  
     - `berth_time[i, j]`: Berthing time (minutes) from node `i` to node `j` (e.g., `berth_time[0, 1] = 34`).  
     - `num_nodes = 8`: Total number of nodes.  
   - **3. Objective Function:**  
     - Minimize total berthing time:  
       `Minimize: sum(x[i, j] * berth_time[i, j] for all i, j where i ≠ j)`.  
   - **4. Constraints:**  
     - **Departure:** The ship must leave each node exactly once:  
       `sum(x[i, j] for j in nodes if i ≠ j) = 1` for each node `i`.  
     - **Arrival:** The ship must enter each node exactly once:  
       `sum(x[j, i] for j in nodes if i ≠ j) = 1` for each node `i`.  
     - **Subtour Elimination (MTZ):** For nodes `i, j ≠ 0`:  
       `u[i] - u[j] + num_nodes * x[i, j] ≤ num_nodes - 1`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import itertools; import math
# Params
num_nodes = 8; nodes = [0, 1, 2, 3, 4, 5, 6, 7]; berth_time = {(0, 1): 34, (0, 2): 29, (0, 3): 19, (0, 4): 22, (0, 5): 21, (0, 6): 10, (0, 7): 23, (1, 0): 34, (1, 2): 17, (1, 3): 22, (1, 4): 17, (1, 5): 10, (1, 6): 13, (1, 7): 33, (2, 0): 29, (2, 1): 17, (2, 3): 22, (2, 4): 22, (2, 5): 29, (2, 6): 27, (2, 7): 15, (3, 0): 19, (3, 1): 22, (3, 2): 22, (3, 4): 18, (3, 5): 9, (3, 6): 35, (3, 7): 9, (4, 0): 22, (4, 1): 17, (4, 2): 22, (4, 3): 18, (4, 5): 14, (4, 6): 22, (4, 7): 30, (5, 0): 21, (5, 1): 10, (5, 2): 29, (5, 3): 9, (5, 4): 14, (5, 6): 26, (5, 7): 8, (6, 0): 10, (6, 1): 13, (6, 2): 27, (6, 3): 35, (6, 4): 22, (6, 5): 26, (6, 7): 26, (7, 0): 23, (7, 1): 33, (7, 2): 15, (7, 3): 9, (7, 4): 30, (7, 5): 8, (7, 6): 26}
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m17 = gp.Model("Ship_Berthing_Schedule_MIP", env=env)
    # Check if berth_time keys are valid tuples
    valid_keys = [(i,j) for i in nodes for j in nodes if i != j]
    # Vars
    x = m17.addVars(valid_keys, vtype=GRB.BINARY, name="berth") # Use valid_keys
    u = m17.addVars(nodes, vtype=GRB.CONTINUOUS, name="order", lb=0.0)
    # Objective
    m17.setObjective(gp.quicksum(x[i, j] * berth_time.get((i,j), 9999) for i, j in valid_keys), sense=GRB.MINIMIZE) # Use .get
    # Constraints
    m17.addConstrs((gp.quicksum(x[i, j] for j in nodes if i != j) == 1 for i in nodes), name="leave_node")
    m17.addConstrs((gp.quicksum(x[j, i] for j in nodes if i != j) == 1 for i in nodes), name="enter_node")
    # MTZ Subtour Elimination
    for i in nodes:
        for j in nodes:
            if i != j and i != 0 and j != 0 and (i,j) in valid_keys: # Check key exists
                 m17.addConstr(u[i] - u[j] + num_nodes * x[i, j] <= num_nodes - 1, name=f"MTZ_{i}_{j}")
    # Optimize
    m17.optimize()
    # Store results
    results_dict['status'] = m17.status
    if m17.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m17.objVal; results_dict['x_sol'] = m17.getAttr('X', x)
    # Output Results
    print("--- Problem 17: Multi-Stop Ship Berthing Schedule (TSP Variation) (MIP) ---")
    if m17.status == GRB.OPTIMAL:
        print(f"Optimization Status: Optimal"); print(f"Minimum Total Berthing Time: {m17.objVal:.1f} minutes"); print("Optimal Berthing Route:")
        x_sol = results_dict.get('x_sol', {})
        current_node = 0; route = [0]; visited_count=0
        while len(route) < num_nodes and visited_count < num_nodes + 2:
            next_node = -1
            for j in nodes:
                if current_node != j and x_sol.get((current_node, j), 0) > 0.5: next_node = j; break
            if next_node != -1: route.append(next_node); current_node = next_node
            else: break # No next node found
            visited_count += 1
        if current_node != 0: route.append(0) # Add return if not already there
        if len(route) == num_nodes + 1: print(f"  {' -> '.join(map(str, route))}")
        else: print(f"  Error: Could not reconstruct full route. Found: {' -> '.join(map(str, route))}")
    else: print(f"Optimization Status: {m17.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of SHIP_BERTHING_SCHEDULE
```
Answer:
--- Problem 17: Multi-Stop Ship Berthing Schedule (TSP Variation) (MIP) ---
Optimization Status: Optimal
Minimum Total Berthing Time: 109.0 minutes
Optimal Berthing Route:
  0 -> 6 -> 1 -> 2 -> 7 -> 3 -> 5 -> 4 -> 0



================================================================================


--- Problem 463 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A busy container terminal is facing the challenge of maximizing the number of containers processed within a limited operating window. The terminal has two types of cranes: standard cranes and high-speed cranes. With 3 standard cranes and 2 high-speed cranes available, the terminal must efficiently allocate its resources to meet the incoming demand. Each standard crane takes 5.4 hours to fully process a container, while the high-speed cranes are much quicker, requiring only 0.33 hours per container. The terminal operates for a tight 4.8-hour planning horizon. On this particular day, 12 containers are waiting to be processed by standard cranes, while 13 are seeking the speedier high-speed cranes. The core challenge is clear: How can the terminal maximize the total number of containers processed without exceeding its operational limits or the available demand?
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x_std`: Number of containers processed using standard cranes (continuous, ≥ 0).  
   - `x_hs`: Number of containers processed using high-speed cranes (continuous, ≥ 0).  

   **2. Parameters:**  
   - `num_std_cranes = 3`: Available standard cranes.  
   - `time_per_std_process_hr = 5.40`: Hours per standard crane process.  
   - `num_hs_cranes = 2`: Available high-speed cranes.  
   - `time_per_hs_process_hr = 0.33`: Hours per high-speed crane process.  
   - `planning_horizon_hr = 4.8`: Total operating hours.  
   - `demand_std = 12`: Maximum standard crane processing requests.  
   - `demand_hs = 13`: Maximum high-speed crane processing requests.  

   **3. Objective Function:**  
   Maximize the total number of containers processed:  
   \[
   \text{Maximize: } x_std + x_hs
   \]  

   **4. Constraints:**  
   - Standard crane capacity: Total standard crane processing time cannot exceed available crane-hours:  
     \[
     x_std \times 5.40 \leq 3 \times 4.8
     \]  
   - High-speed crane capacity: Total high-speed crane processing time cannot exceed available crane-hours:  
     \[
     x_hs \times 0.33 \leq 2 \times 4.8
     \]  
   - Standard crane demand: Cannot exceed requested standard crane processes:  
     \[
     x_std \leq 12
     \]  
   - High-speed crane demand: Cannot exceed requested high-speed crane processes:  
     \[
     x_hs \leq 13
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
num_std_cranes = 3; time_per_std_process_hr = 5.40
num_hs_cranes = 2; time_per_hs_process_hr = 0.33
planning_horizon_hr = 4.8; demand_std = 12; demand_hs = 13
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m21 = gp.Model("Container_Terminal_LP", env=env)
    # Vars
    x_std = m21.addVar(name="std_containers_processed", lb=0)
    x_hs = m21.addVar(name="hs_containers_processed", lb=0)
    # Objective
    m21.setObjective(x_std + x_hs, sense=GRB.MAXIMIZE)
    # Constraints
    m21.addConstr(x_std * time_per_std_process_hr <= num_std_cranes * planning_horizon_hr, "std_capacity")
    m21.addConstr(x_hs * time_per_hs_process_hr <= num_hs_cranes * planning_horizon_hr, "hs_capacity")
    m21.addConstr(x_std <= demand_std, "std_demand")
    m21.addConstr(x_hs <= demand_hs, "hs_demand")
    # Optimize
    m21.optimize()
    # Store results
    results_dict['status'] = m21.status
    if m21.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m21.objVal; results_dict['xstd_opt'] = x_std.X; results_dict['xhs_opt'] = x_hs.X
    # Output Results
    print("--- Problem 21: Container Terminal Usage (LP) ---")
    if m21.status == GRB.OPTIMAL:
        print(f"Optimization Status: Optimal")
        xstd = results_dict.get('xstd_opt', 0); xhs = results_dict.get('xhs_opt', 0)
        std_cap_hours = num_std_cranes * planning_horizon_hr; hs_cap_hours = num_hs_cranes * planning_horizon_hr
        std_hours_used = xstd * time_per_std_process_hr; hs_hours_used = xhs * time_per_hs_process_hr
        std_cap_containers = std_cap_hours / time_per_std_process_hr if time_per_std_process_hr > 1e-6 else 0
        hs_cap_containers = hs_cap_hours / time_per_hs_process_hr if time_per_hs_process_hr > 1e-6 else 0
        print(f"Maximum Total Containers Processed: {m21.objVal:.2f}")
        print(f"  Standard Cranes Containers Processed: {xstd:.2f} (Demand: {demand_std}, Capacity in containers: {std_cap_containers:.2f})")
        print(f"  High-Speed Cranes Containers Processed: {xhs:.2f} (Demand: {demand_hs}, Capacity in containers: {hs_cap_containers:.2f})")
        print(f"  Standard Crane-Hours Used: {std_hours_used:.1f} / {std_cap_hours:.1f}")
        print(f"  High-Speed Crane-Hours Used: {hs_hours_used:.1f} / {hs_cap_hours:.1f}")
    else: print(f"Optimization Status: {m21.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of CONTAINER_TERMINAL
```
Answer:
--- Problem 21: Container Terminal Usage (LP) ---
Optimization Status: Optimal
Maximum Total Containers Processed: 15.67
  Standard Cranes Containers Processed: 2.67 (Demand: 12, Capacity in containers: 2.67)
  High-Speed Cranes Containers Processed: 13.00 (Demand: 13, Capacity in containers: 29.09)
  Standard Crane-Hours Used: 14.4 / 14.4
  High-Speed Crane-Hours Used: 4.3 / 9.6



================================================================================



--- Problem 464 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling the unloading of incoming trucks at a single depot to minimize their waiting times before unloading. Three trucks—Truck 1, Truck 2, and Truck 3—arrive at staggered times: Truck 1 at time 2, Truck 2 at time 6, and Truck 3 at time 7. Each truck requires a specific processing duration once at the depot: Truck 1 needs 6 units of time, Truck 2 needs 4, and Truck 3 demands the longest at 8 units. With only a single depot available, the hub must carefully sequence the trucks to avoid overlaps while ensuring no truck starts unloading before its arrival. The core challenge is to assign the trucks to the depot in an order that minimizes the total waiting time across all trucks—the gap between their arrival and the moment unloading begins.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to depot *j*, else 0).  
     - `start_time(i)`: Continuous variable for when truck *i* begins processing.  
     - `completion_time(i)`: Continuous variable for when truck *i* finishes processing.  
     - `precedes(i, k, j)`: Binary variable (1 if truck *i* is scheduled before truck *k* on depot *j*).  
   - **2. Parameters:**  
     - `arrival_times`: {1: 2, 2: 6, 3: 7} (truck arrival times).  
     - `processing_times`: {1: 6, 2: 4, 3: 8} (truck processing durations).  
     - `H = 100`: A large constant for logical constraints.  
   - **3. Objective Function:**  
     Minimize the total waiting time:  
     `sum(start_time[i] - arrival_times[i] for all trucks i)`.  
   - **4. Constraints:**  
     - Each truck is assigned to exactly one depot.  
     - Start time of a truck cannot precede its arrival time.  
     - Completion time is the sum of start time and processing time.  
     - For any two trucks assigned to the same depot, one must precede the other (no overlap).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
depots = [1]
arrival_times = {1: 2, 2: 6, 3: 7}
processing_times = {1: 6, 2: 4, 3: 8}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM_MIN_WAIT")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes") # y[i,k,j] = 1 if i before k on j

    # --- Objective Function ---
    m.setObjective(gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    # Link precedence var: if both assigned, one must precede
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]), name=f"link_prec_{i}_{k}_{j}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Wait time can have decimals
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded") # Should not happen
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    for i in trucks:
        print(f"Truck {i} start time: {start_time[i].x:.4f}")
        print(f"Truck {i} completion time: {completion_time[i].x:.4f}")
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
7.0000
Truck 1 start time: 2.0000
Truck 1 completion time: 8.0000
Truck 1 is assigned to Depot 1
Truck 2 start time: 8.0000
Truck 2 completion time: 12.0000
Truck 2 is assigned to Depot 1
Truck 3 start time: 12.0000
Truck 3 completion time: 20.0000
Truck 3 is assigned to Depot 1


```

================================================================================



--- Problem 465 ---
**Difficulty:** hard
**Category:** NLP

**Problem Description:**
**
A port is experiencing a temporary reduction in the capacity of one of its berths due to maintenance. The main berth, which typically handles 5,455 containers per hour under normal conditions, now has a reduced capacity of 3,051 containers per hour for an incident duration of approximately 1.54 hours. An alternative berth is available, but its capacity is limited to 2,116 containers per hour, and containers taking this detour face a baseline handling time of 0.35 hours (21 minutes), which increases with congestion. The total incoming container flow is 4,130 containers per hour, demanding a careful balance between rerouting containers to the alternative berth and managing congestion on the main berth.

The challenge lies in allocating flows between the two berths to minimize the cumulative delay experienced by all containers. Delays arise from two sources: (1) the increased handling time on the alternative berth due to congestion (modeled using the BPR function with parameters α=0.15 and β=3.05), and (2) potential queue formation on the main berth if demand exceeds its reduced capacity. The optimization must account for the time it takes to clear any resulting queue after the maintenance ends. The core question is: *How should containers be split between the main and alternative berths to minimize the total system delay during and after the maintenance?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `flow_alt`: Containers per hour diverted to the alternative berth (bounded by its capacity).  
   - `flow_main`: Containers per hour remaining on the main berth.  
   - Intermediate variables track handling time, queue growth, and dissipation dynamics.  

   **2. Parameters:**  
   - Capacities: `capacity_main_normal=5,455`, `capacity_main_reduced=3,051`, `capacity_alt=2,116` (containers/h).  
   - Total demand: `arrival_rate_total=4,130` containers/h.  
   - Maintenance duration: `maintenance_duration=1.54` hours.  
   - BPR function parameters: `α=0.15`, `β=3.05`.  
   - Free-flow handling time on alternative berth: `T0_alt=0.35` hours.  

   **3. Objective Function:**  
   Minimize total system delay (container-hours), calculated as:  
   - Delay on alternative berth: `maintenance_duration * flow_alt * (T_alt_actual - T0_alt)`.  
   - Delay from queuing on main berth: `0.5 * maintenance_duration * max_queue_main + 0.5 * max_queue_main * dissipation_time_main`.  

   **4. Constraints:**  
   - Flow conservation: `flow_main + flow_alt = arrival_rate_total`.  
   - Alternative berth capacity: `flow_alt ≤ capacity_alt`.  
   - BPR handling time: `T_alt_actual = T0_alt * (1 + α * (flow_alt/capacity_alt)^β)`.  
   - Queue dynamics: If `flow_main > capacity_main_reduced`, a queue grows at rate `flow_main - capacity_main_reduced` and dissipates after the maintenance at rate `capacity_main_normal - flow_main`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
capacity_main_normal = 5455.2678128462485  # containers/h
capacity_main_reduced = 3051.381200535133  # containers/h
capacity_alt = 2116.4640900495087  # containers/h
arrival_rate_total = 4129.980029123709  # containers/h
maintenance_duration = 1.5398478504693955  # h
T0_alt = 0.34919736173784643  # h
bpr_alpha = 0.15100662131151205
bpr_beta = 3.0474046492360096
EPSILON = 1e-6

# --- Gurobi Model ---
model = gp.Model("MaintenanceRerouting")

# Decision Variables
flow_alt = model.addVar(name="flow_alt", lb=0.0, ub=arrival_rate_total)
flow_main = model.addVar(name="flow_main", lb=0.0)

# Intermediate Variables
T_alt_actual = model.addVar(name="T_alt_actual", lb=T0_alt)
vol_cap_ratio = model.addVar(name="vol_cap_ratio", lb=0.0)
vol_cap_pow_beta = model.addVar(name="vol_cap_pow_beta", lb=0.0)
max_queue_main = model.addVar(name="max_queue_main", lb=0.0)
dissipation_time_main = model.addVar(name="dissipation_time_main", lb=0.0)
dissipation_rate_main = model.addVar(name="dissipation_rate_main", lb=EPSILON)

# Constraints
model.addConstr(flow_main + flow_alt == arrival_rate_total, name="FlowConservation")
model.addConstr(flow_alt <= capacity_alt, name="AltBerthCapacity")
model.addConstr(vol_cap_ratio <= 1.0, name="VolCapRatioLimit")
model.addConstr(vol_cap_ratio * capacity_alt == flow_alt, name="CalcVolCapRatio")
model.addGenConstrPow(vol_cap_ratio, vol_cap_pow_beta, bpr_beta, name="CalcPowerTerm")
model.addConstr(T_alt_actual == T0_alt * (1.0 + bpr_alpha * vol_cap_pow_beta), name="CalcActualAltTime")

# Queue calculations
queue_growth_rate = model.addVar(name="queue_growth_rate", lb=0.0)
aux_growth_input = model.addVar(name="aux_growth_input", lb=-GRB.INFINITY)
model.addConstr(aux_growth_input == flow_main - capacity_main_reduced, name="CalcAuxGrowthInput")
model.addGenConstrMax(queue_growth_rate, [aux_growth_input], 0.0, name="CalcQueueGrowthRate")
model.addConstr(max_queue_main == queue_growth_rate * maintenance_duration, name="CalcMaxQueue")

# Dissipation calculations
model.addConstr(dissipation_rate_main == capacity_main_normal - flow_main, name="CalcDissipationRate")
model.addQConstr(dissipation_time_main * dissipation_rate_main == max_queue_main, name="CalcDissipationTime")

# Objective
obj = gp.QuadExpr()
obj += maintenance_duration * flow_alt * T_alt_actual - maintenance_duration * T0_alt * flow_alt
obj += 0.5 * maintenance_duration * max_queue_main
obj += 0.5 * max_queue_main * dissipation_time_main
model.setObjective(obj, GRB.MINIMIZE)

# Optimize
model.Params.NonConvex = 2
model.optimize()

# Output
if model.status == GRB.OPTIMAL:
    print("\n--- Maintenance Rerouting Results ---")
    print(f"Optimal Total System Delay: {model.objVal:.2f} container-hours")
    print(f"Flow to Alternative Berth: {flow_alt.X:.2f} containers/h")
    print(f"Flow on Main Berth: {flow_main.X:.2f} containers/h")
    print(f"Alternative Berth Handling Time: {T_alt_actual.X * 60:.2f} min")
    print(f"Max Queue on Main Berth: {max_queue_main.X:.2f} containers")
    print(f"Queue Dissipation Time: {dissipation_time_main.X:.2f} h")
else:
    print(f"Model status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Set parameter NonConvex to value 2
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Non-default parameters:
NonConvex  2

Optimize a model with 8 rows, 10 columns and 14 nonzeros
Model fingerprint: 0xf4ed931c
Model has 2 quadratic objective terms
Model has 1 quadratic constraint
Model has 1 simple general constraint
  1 MAX
Model has 1 function constraint treated as nonlinear
  1 POW
Variable types: 10 continuous, 0 integer (0 binary)
Coefficient statistics:
  Matrix range     [5e-02, 2e+03]
  QMatrix range    [1e+00, 1e+00]
  QLMatrix range   [1e+00, 1e+00]
  Objective range  [5e-01, 8e-01]
  QObjective range [1e+00, 3e+00]
  Bounds range     [1e-06, 4e+03]
  RHS range        [3e-01, 5e+03]
Presolve removed 2 rows and 1 columns
Presolve time: 0.00s
Presolved: 20 rows, 13 columns, 45 nonzeros
Presolved model has 3 bilinear constraint(s)
Presolved model has 1 nonlinear constraint(s)

Solving non-convex MINLP

Variable types: 12 continuous, 1 integer (1 binary)
Found heuristic solution: objective 11.2272673

Root relaxation: objective 9.800182e-01, 5 iterations, 0.00 seconds (0.00 work units)

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0    0.98002    0    2   11.22727    0.98002  91.3%     -    0s
     0     0   11.22286    0    2   11.22727   11.22286  0.04%     -    0s

Explored 1 nodes (7 simplex iterations) in 0.01 seconds (0.00 work units)
Thread count was 32 (of 255 available processors)

Solution count 1: 11.2273 

Optimal solution found (tolerance 1.00e-04)
Best objective 1.122726733225e+01, best bound 1.122726733224e+01, gap 0.0000%

--- Maintenance Rerouting Results ---
Optimal Total System Delay: 11.23 container-hours
Flow to Alternative Berth: 1078.60 containers/h
Flow on Main Berth: 3051.38 containers/h
Alternative Berth Handling Time: 21.36 min
Max Queue on Main Berth: 0.00 containers
Queue Dissipation Time: 0.00 h



================================================================================



--- Problem 466 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the maritime logistics team is tasked with coordinating the berthing times for four different types of cargo ships to minimize the total waiting time. Each type of ship has a different number of arrivals: Type 1 handles 2,134 ships, Type 2 serves 2,894, Type 3 accommodates 2,557, and Type 4 manages 702 ships. The goal is to allocate berthing times within a fixed 77-hour cycle, ensuring no type receives less than 12 hours or more than 77 hours of berthing time. The critical question is: *How should the 77-hour cycle be divided among the four types of ships to minimize the total waiting time experienced by all ships, given their arrival rates and the rigid cycle constraint?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - \( t_i \): Continuous variable representing the berthing time (in hours) allocated to ship type \( i \) (\( i = 1, 2, 3, 4 \)). Bounded between 12 and 77.  
   - **2. Parameters:**  
     - \( \text{arrival_coeffs} = [2134, 2894, 2557, 702] \): Arrival rates for each ship type.  
     - \( \text{cycle_time} = 77 \): Total cycle duration (hours).  
     - \( \text{lb_time} = 12 \), \( \text{ub_time} = 77 \): Lower/upper bounds for berthing times.  
   - **3. Objective Function:**  
     Minimize total waiting time:  
     \[
     \text{Minimize: } \sum_{i=1}^4 \text{arrival_coeffs}[i] \times (\text{cycle_time} - t_i)
     \]  
   - **4. Constraints:**  
     - Total berthing times must equal the cycle:  
       \[
       t_1 + t_2 + t_3 + t_4 = 77
       \]  
     - Bounds: \( 12 \leq t_i \leq 77 \) for all \( i \).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_types = 4
lb_time = 12          # Lower bound for berthing time
ub_time = 77          # Upper bound for berthing time
cycle_time = 77   # Total cycle time (set equal to ub_time)
arrival_coeffs = [2134, 2894, 2557, 702] # Arrival rates per ship type
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_coeffs) != num_types:
    print("Error: arrival_coeffs length mismatch with num_types")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_coeffs length"
    # raise ValueError("arrival_coeffs length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_types}-Type Berthing Time Allocation", env=env)

        # --- Decision variables (dynamic based on num_types) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_types, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for type i is proportional to arrival * non-berthing time = arrival * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_coeffs[i] * (cycle_time - t_vars[i]) for i in range(num_types)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_types)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_types)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (hours):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_types):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 454729.00
------------------------------
Optimal berthing times (hours):
  t1: 12.00, t2: 41.00, t3: 12.00, t4: 12.00


```

================================================================================



--- Problem 467 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A major railway incident has reduced the capacity of a critical track segment from three tracks to two, creating a bottleneck during peak hours. Railway operators must dynamically reroute trains to an alternative route to minimize total delay while accounting for fluctuating arrival rates over four 15-minute periods. The alternative route has limited capacity and adds 15 minutes of travel time for each rerouted train. The incident lasts exactly one hour, after which the track returns to full capacity. The challenge is to determine the optimal number of trains to divert each period, balancing queue formation at the bottleneck against the added delay from rerouting. Key parameters include arrival rates of 2978, 3795, 2356, and 3605 trains per hour for each period, a reduced mainline capacity of 3770 trains per hour (2 tracks × 1885 trains/h/track), and an alternative route capacity of 2253 trains per hour. The post-incident arrival rate is 4137 trains/h, which is below the restored mainline capacity (5655 trains/h), allowing the queue to dissipate naturally after the incident clears.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `flow_alt[t]`: Trains diverted to the alternative route in period `t` (continuous, ≥ 0).  
   - `flow_main[t]`: Trains remaining on the main route in period `t` (derived from flow conservation).  
   - `queue_length[t]`: Queue length (trains) at the end of period `t` (continuous, ≥ 0).  

   **2. Parameters:**  
   - `arrival_rates[t]`: Demand (trains/h) for periods 1–4: [2978, 3795, 2356, 3605].  
   - `capacity_main_reduced`: 3770 trains/h (2 tracks × 1885).  
   - `alt_route_capacity`: 2253 trains/h.  
   - `alt_route_extra_time`: 0.25 h (15 min) per rerouted train.  
   - `dt`: 0.25 h (15 min).  

   **3. Objective Function:**  
   Minimize total delay = `delay_main_incident_total` (triangular queue delay) + `delay_alt_total` (rerouting delay) + queue dissipation penalty (if applicable).  
   - If post-incident demand < normal capacity:  
     Dissipation delay = `0.5 * (queue_at_clearance^2) / (capacity_main_normal - arrival_rate_post)`.  
   - Else: Penalize residual queue with a large multiplier (1000×).  

   **4. Constraints:**  
   - Flow conservation: `flow_main[t] + flow_alt[t] = arrival_rates[t]` for all `t`.  
   - Alternative route capacity: `flow_alt[t] ≤ 2253` for all `t`.  
   - Queue dynamics: `queue_length[t] = max(0, queue_length[t-1] + (flow_main[t] - 3770) * 0.25)`.  
   - Total rerouting delay: `delay_alt_total = sum(flow_alt[t] * 0.25 * 0.25 for all t)`.  
   - Mainline delay: `delay_main_incident_total = 0.5 * 0.25 * sum(queue_length[t-1] + queue_length[t] for all t)`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
num_periods = 4
dt = 0.25 # h (15 minutes)
incident_duration_total = num_periods * dt # Should be 1.0 h
arrival_rates = {1: 2978, 2: 3795, 3: 2356, 4: 3605} # trains/h per period
arrival_rate_post = 4137 # trains/h after incident
capacity_per_track = 1885
num_tracks_normal = 3
num_tracks_reduced = 2
alt_route_capacity = 2253
alt_route_extra_time = 0.25 # h

capacity_main_reduced = num_tracks_reduced * capacity_per_track
capacity_main_normal = num_tracks_normal * capacity_per_track

periods = range(1, num_periods + 1) # Periods 1, 2, 3, 4

# --- Gurobi Model Setup ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.setParam('TimeLimit', 30)
env.start()
m = gp.Model("DynamicRailwayRerouting_Silent", env=env)

# --- Decision Variables ---
flow_alt = m.addVars(periods, name="flow_alt", lb=0.0)

# --- Intermediate Variables ---
flow_main = m.addVars(periods, name="flow_main", lb=0.0)
queue_length = m.addVars(range(num_periods + 1), name="queue", lb=0.0)
queue_unconstrained = m.addVars(periods, name="queue_unconstrained", lb=-GRB.INFINITY)
delay_alt_total = m.addVar(name="delay_alt_total", lb=0.0)
queue_at_clearance = m.addVar(name="queue_at_clearance", lb=0.0)
delay_main_incident_total = m.addVar(name="delay_main_incident_total", lb=0.0)
dissipation_time = m.addVar(name="dissipation_time", lb=0.0)

# --- Constraints ---
m.addConstr(queue_length[0] == 0, name="InitialQueue")

for t in periods:
    m.addConstr(flow_main[t] + flow_alt[t] == arrival_rates[t], name="FlowConservation_P{0}".format(t))
    m.addConstr(flow_alt[t] <= alt_route_capacity, name="AltCapacity_P{0}".format(t))

for t in periods:
    m.addConstr(queue_unconstrained[t] == queue_length[t-1] + (flow_main[t] - capacity_main_reduced) * dt,
                name="QueueCalcUnc_P{0}".format(t))
    m.addGenConstrMax(queue_length[t], [queue_unconstrained[t]], 0.0, name="QueueEvolution_P{0}".format(t))

m.addConstr(delay_alt_total == gp.quicksum(flow_alt[t] * dt * alt_route_extra_time for t in periods),
            name="CalcAltTotalDelay")

m.addConstr(delay_main_incident_total == 0.5 * dt * gp.quicksum(queue_length[t-1] + queue_length[t] for t in periods),
            name="CalcMainIncidentDelay")

m.addConstr(queue_at_clearance == queue_length[num_periods], name="DefineQueueAtClearance")

# --- Objective Function ---
can_dissipate = arrival_rate_post < capacity_main_normal

if can_dissipate:
    dissipation_rate = capacity_main_normal - arrival_rate_post
    m.addConstr(queue_at_clearance == dissipation_rate * dissipation_time, name="CalcDissipationTime")
    obj = delay_main_incident_total + (0.5 / dissipation_rate) * queue_at_clearance * queue_at_clearance + delay_alt_total
    m.setObjective(obj, GRB.MINIMIZE)
else:
    penalty_factor_non_dissipating = 1000
    obj = delay_main_incident_total + delay_alt_total + penalty_factor_non_dissipating * queue_at_clearance
    m.setObjective(obj, GRB.MINIMIZE)
    m.addConstr(dissipation_time == 1e6, "DissipationTimePenalty")

# --- Optimize ---
m.optimize()

# --- Output Results ---
if m.status == GRB.OPTIMAL:
    for t in periods:
        print("{0:.2f}".format(flow_alt[t].X))
elif m.status == GRB.INFEASIBLE:
    print("Infeasible")
elif m.status == GRB.UNBOUNDED:
    print("Unbounded")
```
Answer:
0.00
25.00
0.00
0.00



================================================================================



--- Problem 468 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
At a busy port, the operations manager is tasked with optimizing the allocation of crane time to two berths, Berth A and Berth B. The cranes operate on a fixed 90-minute cycle, but each phase incurs a 5-minute lost time due to setup and clearance intervals, totaling 10 minutes of lost time per cycle. This leaves only 80 minutes of effective crane time to allocate between the two competing berths.  

Berth A experiences a high demand of 918.43 container moves per hour, with a saturation flow rate of 1,738.82 container moves per hour per crane. Meanwhile, Berth B sees a lower demand of 671.03 container moves per hour but must adhere to a strict service level constraint: its saturation ratio cannot exceed 0.863. Additionally, each berth must be allocated at least 5 minutes of crane time to ensure minimal operational movement.  

The core challenge is to maximize the crane time allocated to Berth A—where demand is highest—while ensuring Berth B meets its saturation limit and all operational constraints are satisfied. The question is: *How should the 80 minutes of effective crane time be split between the two berths to prioritize Berth A's flow without violating Berth B's service requirements?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `g_a`: Effective crane time (minutes) allocated to Berth A.  
   - `g_b`: Effective crane time (minutes) allocated to Berth B.  

   **2. Parameters:**  
   - `cycle_length = 90` (total cycle time in minutes).  
   - `lost_time_per_phase = 5` (lost time per phase in minutes).  
   - `total_lost_time = 10` (total lost time per cycle in minutes).  
   - `effective_green_total = 80` (total usable crane time in minutes).  
   - `demand_a = 918.434` (Berth A demand in container moves/hr).  
   - `saturation_flow_a = 1,738.816` (Berth A saturation flow in container moves/hr/crane).  
   - `demand_b = 671.033` (Berth B demand in container moves/hr).  
   - `saturation_flow_b = 1,641.382` (Berth B saturation flow in container moves/hr/crane).  
   - `max_saturation_b = 0.863` (maximum allowed Berth B saturation ratio).  
   - `min_green_time = 5` (minimum crane time per berth in minutes).  

   **3. Objective Function:**  
   Maximize the Berth A crane time:  
   \[
   \text{Maximize: } g_{a}
   \]  

   **4. Constraints:**  
   - Total crane time allocation:  
     \[
     g_{a} + g_{b} = 80
     \]  
   - Berth B saturation limit (derived from demand and flow rates):  
     \[
     g_{b} \geq \frac{\text{demand}_{b} \times \text{cycle\_length}}{\text{saturation\_flow}_{b} \times \text{max\_saturation}_{b}}
     \]  
   - Minimum crane time per berth:  
     \[
     g_{a} \geq 5, \quad g_{b} \geq 5
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
cycle_length = 90  # minutes
lost_time_per_phase = 5  # minutes
total_lost_time = 2 * lost_time_per_phase
effective_green_total = cycle_length - total_lost_time

demand_a = 918.4342696811914  # container moves/hr
saturation_flow_a = 1738.8162638085307  # container moves/hr/crane
demand_b = 671.0325162535936  # container moves/hr
saturation_flow_b = 1641.3824800331784  # container moves/hr/crane

max_saturation_b = 0.8632003401784663  # Service level constraint for Berth B
min_green_time = 5  # Minimum crane time per berth

# --- Model Creation ---
model = gp.Model("Crane_Time_Allocation_LP")

# --- Decision Variables ---
g_a = model.addVar(name="green_a", lb=min_green_time)
g_b = model.addVar(name="green_b", lb=min_green_time)

# --- Objective Function ---
model.setObjective(g_a, sense=GRB.MAXIMIZE)

# --- Constraints ---
# Total effective crane time equals available time in cycle
model.addConstr(g_a + g_b == effective_green_total, name="total_green_time")

# Berth B saturation constraint
min_g_b_for_saturation = (demand_b * cycle_length) / (saturation_flow_b * max_saturation_b)
model.addConstr(g_b >= min_g_b_for_saturation, name="b_saturation_limit")

# --- Optimization ---
model.optimize()

# --- Output Results ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    print(f"Optimal Berth A Effective Crane Time: {g_a.X:.2f} minutes")
    print(f"Optimal Berth B Effective Crane Time: {g_b.X:.2f} minutes")

    # Calculate actual saturation levels achieved
    sat_a = (demand_a * cycle_length) / (saturation_flow_a * g_a.X) if g_a.X > 0 else float('inf')
    sat_b = (demand_b * cycle_length) / (saturation_flow_b * g_b.X) if g_b.X > 0 else float('inf')

    print(f"\nSaturation Analysis:")
    print(f"  Berth A Saturation: {sat_a:.3f}")
    print(f"  Berth B Saturation: {sat_b:.3f} (Constraint <= 0.8632003401784663)")

    print(f"\nTiming Summary:")
    print(f"  Total Cycle Length: 90 minutes")
    print(f"  Total Lost Time: {total_lost_time} minutes")
    print(f"  Total Effective Crane: {effective_green_total} minutes")
    print(f"  Minimum Required Berth B Crane: {min_g_b_for_saturation:.2f} minutes")
elif model.status == GRB.INFEASIBLE:
    print(f"Optimization Status: Infeasible")
    print(f"Minimum required Berth B crane time for saturation limit: {min_g_b_for_saturation:.2f} min")
    print(f"Minimum required Berth A crane time: {min_green_time:.2f} min")
    print(f"Total required minimum crane: {min_g_b_for_saturation + min_green_time:.2f} min")
    print(f"Total available effective crane: {effective_green_total:.2f} min")
else:
    print(f"Optimization Status: {model.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 2 rows, 2 columns and 3 nonzeros
Model fingerprint: 0x1fdb4e03
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [5e+00, 5e+00]
  RHS range        [4e+01, 8e+01]
Presolve removed 2 rows and 2 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    3.7374972e+01   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  3.737497189e+01

--- Optimization Results ---
Optimization Status: Optimal
Optimal Berth A Effective Crane Time: 37.37 minutes
Optimal Berth B Effective Crane Time: 42.63 minutes

Saturation Analysis:
  Berth A Saturation: 1.272
  Berth B Saturation: 0.863 (Constraint <= 0.8632003401784663)

Timing Summary:
  Total Cycle Length: 90 minutes
  Total Lost Time: 10 minutes
  Total Effective Crane: 80 minutes
  Minimum Required Berth B Crane: 42.63 minutes



================================================================================



--- Problem 469 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling three delivery trucks (Truck 1, Truck 2, and Truck 3) to a single loading dock while adhering to strict maintenance windows that temporarily halt operations. Each truck arrives at a specific time: Truck 1 at 2 hours, Truck 2 at 6 hours, and Truck 3 at 11 hours. Processing times vary, with Truck 1 requiring 6 hours, while Trucks 2 and 3 each need 7 hours. The hub must also accommodate two critical maintenance periods: the first from 10 to 13 hours and the second from 20 to 22 hours, during which no truck can be actively loading or unloading. The primary goal is to sequence the trucks' loading times to minimize the total operational duration (makespan) while ensuring no overlap between truck processing and maintenance windows. The central question is: *What is the optimal schedule that minimizes the hub's total operational time while respecting all constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary `assign[i, j]`: 1 if truck *i* is assigned to loading dock *j* (always 1 here, since there’s only one dock).  
     - Continuous `start_time[i]`: Start time of truck *i*’s processing.  
     - Continuous `completion_time[i]`: Completion time of truck *i* (start time + processing time).  
     - Binary `precedes[i, k, j]`: 1 if truck *i* is scheduled before truck *k* on loading dock *j*.  
     - Continuous `makespan`: Total operational duration (max completion time across all trucks).  
     - Binary `maint_choice[i, w]`: 1 if truck *i* avoids maintenance window *w* by finishing before or starting after it.  

   - **2. Parameters:**  
     - `arrival_times[i]`: Truck *i*’s arrival time (e.g., Truck 1: 2).  
     - `processing_times[i]`: Truck *i*’s processing duration (e.g., Truck 1: 6).  
     - `maintenance_windows`: [(10, 13), (20, 22)].  
     - `H` (Big-M): 100 (ensures constraints activate/deactivate correctly).  

   - **3. Objective Function:**  
     Minimize `makespan` (the latest completion time among all trucks).  

   - **4. Constraints:**  
     - Each truck is assigned to the single loading dock (`assign[i, j] = 1`).  
     - Trucks cannot start before arrival (`start_time[i] ≥ arrival_times[i]`).  
     - Completion time is start time + processing time (`completion_time[i] = start_time[i] + processing_times[i]`).  
     - Non-overlapping trucks: If `precedes[i, k, j] = 1`, truck *k* starts after *i* finishes (and vice versa if 0).  
     - Maintenance avoidance: For each window *w*, truck *i* must either finish before *w* starts or start after *w* ends.  
     - `makespan` is the maximum completion time across all trucks.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
docks = [1] # Should be [1]
arrival_times = {1: 2, 2: 6, 3: 11}
processing_times = {1: 6, 2: 7, 3: 7}
maintenance_windows = [(10, 13), (20, 22)] # List of (start, end) tuples
H = 100 # Big M
max_k = 20 # Not used
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("LOADING_DOCK_PROBLEM_63_MULTI_MAINT")

    if not trucks or not docks or len(docks)!=1: raise ValueError("Invalid trucks/docks")
    the_dock = docks[0]
    # if not maintenance_windows: raise ValueError("Maintenance windows list is empty") # Allow empty list

    # --- Decision Variables ---
    assign = m.addVars(trucks, docks, vtype=GRB.BINARY, name="assign") # Trivial
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in docks],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan")
    # Binary variable for each truck and each maintenance window disjunction
    maint_choice = m.addVars(trucks, range(len(maintenance_windows)), vtype=GRB.BINARY, name="maint_choice")

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment (Fixed)
    m.addConstrs((assign[i, the_dock] == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping (on the single dock) using Indicators
    j = the_dock
    for i in trucks:
        for k in trucks:
            if i < k:
                m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")
    # 6. Maintenance window constraints (multiple windows)
    for i in trucks:
        for w_idx, (m_start, m_end) in enumerate(maintenance_windows):
             # Disjunction: c[i] <= m_start OR s[i] >= m_end
             m.addConstr(completion_time[i] <= m_start + H * maint_choice[i, w_idx], name=f"maint_before_{i}_win{w_idx}")
             m.addConstr(start_time[i] >= m_end - H * (1 - maint_choice[i, w_idx]), name=f"maint_after_{i}_win{w_idx}")


    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print(f"Optimal makespan: {results_dict['obj_val']:.4f}")
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
29.0000
Optimal makespan: 29.0000
Truck 1 - Start Time: 2.0000, Completion Time: 8.0000
Truck 2 - Start Time: 22.0000, Completion Time: 29.0000
Truck 3 - Start Time: 13.0000, Completion Time: 20.0000


```

================================================================================



--- Problem 470 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A port authority faces the critical challenge of minimizing delays caused by two separate ship berthing incidents, labeled A and B, occurring at different times. Incident A happens at the start of the simulation (time = 0 minutes), while Incident B occurs later (time = 11 minutes). Two tugboats, T1 and T2, are available to clear these incidents, each with varying travel times to the berths. For example, T1 takes 24 minutes to reach Berth A and 25 minutes to reach Berth B, while T2 is faster, requiring only 14 minutes to reach A and 18 minutes to B.

Once an incident is cleared, the team must account for the time it takes to travel between berths if the same tugboat is assigned to both. The inter-berth travel times are 18 minutes from A to B and 25 minutes from B to A. Clearing Incident A takes 35 minutes, while Incident B requires 30 minutes.

The real complexity arises from the port's operational dynamics. Each incident reduces the berth's capacity, leading to queue buildup. The normal capacity for Berth A is ~93.88 ships per minute (5633/60), dropping to ~50.93 ships per minute (3056/60) during the incident. Similarly, Berth B's normal capacity is ~55.9 ships per minute (3354/60), reduced to ~25.92 ships per minute (1555/60). Meanwhile, ships arrive at rates of ~53.18 ships per minute (3191/60) for A and ~35.92 ships per minute (2155/60) for B.

The optimization problem revolves around assigning tugboats to berths and sequencing their responses to minimize the total delay caused by queue buildup. The delay is calculated in three phases: before clearance begins (queue growth), during clearance (continued growth), and after clearance (queue dissipation, if possible). If the queue cannot dissipate naturally (due to insufficient capacity), a heavy penalty is applied. The core question is: **What is the optimal assignment and sequencing of tugboats to berths to minimize the total traffic delay?**

---

**Modeling Process:**
**
**1. Decision Variables:**  
- Binary variables:  
  - `assign_first(k, i)`: 1 if tugboat `k` is assigned to berth `i` as its first task, else 0.  
  - `sequence(k, i, j)`: 1 if tugboat `k` serves berth `j` immediately after `i`, else 0.  
- Continuous variables:  
  - `start_clear(i)`: Time when clearance of berth `i` begins.  
  - `end_clear(i)`: Time when clearance of berth `i` ends.  
  - `queue_at_start_clear(i)`: Queue size when clearance starts.  
  - `queue_at_clear_end(i)`: Queue size when clearance ends.  
  - `dissipation_time(i)`: Time to dissipate the queue after clearance.  

**2. Parameters:**  
- `time_occur(i)`: Time incident `i` occurs (A: 0, B: 11).  
- `travel_time_base(k, i)`: Travel time for tugboat `k` to berth `i` (e.g., T1 to A: 24).  
- `travel_time_inter(i, j)`: Travel time between berths (e.g., A to B: 18).  
- `clearance_time(i)`: Time to clear berth `i` (A: 35, B: 30).  
- `growth_rate_before(i)`: Queue growth rate before clearance (arrival rate - reduced capacity).  
- `dissipation_rate(i)`: Queue dissipation rate after clearance (normal capacity - arrival rate).  
- `M`: Large constant (10,000) for linearization.  

**3. Objective Function:**  
Minimize the total delay, calculated as:  
- Delay before clearance: `0.5 * growth_rate_before(i) * (start_clear(i) - time_occur(i))^2`.  
- Delay during clearance: `0.5 * (queue_at_start_clear(i) + queue_at_clear_end(i)) * clearance_time(i)`.  
- Delay after clearance (if dissipating): `0.5 * (1 / dissipation_rate(i)) * queue_at_clear_end(i)^2`.  
- Penalty (if not dissipating): `10000 * queue_at_clear_end(i)`.  

**4. Constraints:**  
- Each berth must be assigned to exactly one tugboat (either first or in sequence).  
- Each tugboat can start with at most one berth.  
- Sequencing logic: If a tugboat serves berth `j` after `i`, it must have served `i` first.  
- Start time constraints:  
  - If assigned first, start time ≥ incident time + travel time.  
  - If sequenced, start time ≥ end time of previous berth + inter-berth travel time.  
- Queue dynamics:  
  - Queue at start of clearance = growth rate × time difference.  
  - Queue at end of clearance = queue at start + growth during clearance.  
  - Dissipation time = queue at end / dissipation rate (if dissipating).  

---

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
berths = ['A', 'B']
tugboats = ['T1', 'T2']

# Times in minutes from simulation start
time_occur = {'A': 0, 'B': 11}
travel_time_base = {('T1', 'A'): 24, ('T1', 'B'): 25, ('T2', 'A'): 14, ('T2', 'B'): 18}
travel_time_inter = {('A', 'B'): 18, ('B', 'A'): 25, ('A', 'A'): 0, ('B', 'B'): 0}
clearance_time = {'A': 35, 'B': 30}

# Capacities and Arrival rates (ships per minute)
cap_normal = {'A': 5633/60, 'B': 3354/60} # ships/min
cap_reduced = {'A': 3056/60, 'B': 1555/60} # ships/min
arrival_rate = {'A': 3191/60, 'B': 2155/60} # ships/min

M = 10000
EPSILON = 1e-6

# Pre-calculate rates
growth_rate_before = {}
dissipation_rate = {}
can_dissipate = {}
inv_dissipation_rate = {}
non_dissipating_penalty = 10000

for i in berths:
    growth_rate_before[i] = max(0, arrival_rate[i] - cap_reduced[i])
    dissipation_rate[i] = cap_normal[i] - arrival_rate[i]
    can_dissipate[i] = dissipation_rate[i] > EPSILON
    if not can_dissipate[i]:
        inv_dissipation_rate[i] = 0
    else:
        inv_dissipation_rate[i] = 1.0 / dissipation_rate[i]

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("BerthResourceAllocation", env=env)

# --- Decision Variables ---
assign_first = m.addVars(tugboats, berths, vtype=GRB.BINARY, name="assign_first")
sequence = m.addVars(tugboats, berths, berths, vtype=GRB.BINARY, name="sequence")

# Timing variables
start_clear = m.addVars(berths, name="start_clear", lb=0.0)
end_clear = m.addVars(berths, name="end_clear", lb=0.0)

# Queue and Delay related variables
queue_start_clear_time_diff = m.addVars(berths, name="queue_start_clear_time_diff", lb=0.0)
queue_at_start_clear = m.addVars(berths, name="queue_at_start_clear", lb=0.0)
aux_q_start = m.addVars(berths, name="aux_q_start", lb=-GRB.INFINITY)
queue_at_clear_end = m.addVars(berths, name="queue_at_clear_end", lb=0.0)
aux_q_end = m.addVars(berths, name="aux_q_end", lb=-GRB.INFINITY)
dissipation_time = m.addVars(berths, name="dissipation_time", lb=0.0)

# --- Constraints ---
for i in berths:
    m.addConstr(gp.quicksum(assign_first[k, i] for k in tugboats) +
                gp.quicksum(sequence[k, j, i] for k in tugboats for j in berths if i != j) == 1,
                name="AssignBerth_{0}".format(i))

for k in tugboats:
    m.addConstr(gp.quicksum(assign_first[k, i] for i in berths) <= 1, name="TugboatStart_{0}".format(k))

for k in tugboats:
    for i in berths:
        tugboat_served_i = assign_first[k, i] + gp.quicksum(sequence[k, l, i] for l in berths if l != i)
        m.addConstr(gp.quicksum(sequence[k, i, j] for j in berths if i != j) <= tugboat_served_i,
                    name="SequenceLogic_{0}_{1}".format(k, i))
        m.addConstr(sequence[k,i,i] == 0, name="NoSelfLoop_{0}_{1}".format(k, i))
        for j in berths:
             if i != j:
                  m.addConstr(sequence[k,i,j] + sequence[k,j,i] <= 1, name="NoImmediateLoop_{0}_{1}_{2}".format(k, i, j))

for k in tugboats:
    for i in berths:
        m.addConstr(start_clear[i] >= time_occur[i] + travel_time_base[k, i] - M * (1 - assign_first[k, i]),
                    name="StartTimeFirst_{0}_{1}".format(k, i))
        for j in berths:
            if i != j:
                m.addConstr(start_clear[i] >= end_clear[j] + travel_time_inter[j, i] - M * (1 - sequence[k, j, i]),
                            name="StartTimeFollow_{0}_{1}_{2}".format(k, j, i))

for i in berths:
    m.addConstr(end_clear[i] == start_clear[i] + clearance_time[i], name="EndClearTime_{0}".format(i))
    m.addConstr(start_clear[i] >= time_occur[i], name="StartAfterOccur_{0}".format(i))

for i in berths:
    m.addConstr(queue_start_clear_time_diff[i] >= start_clear[i] - time_occur[i], name="CalcTimeDiff_{0}".format(i))
    m.addConstr(aux_q_start[i] == growth_rate_before[i] * queue_start_clear_time_diff[i], name="CalcAuxQStart_{0}".format(i))
    m.addGenConstrMax(queue_at_start_clear[i], [aux_q_start[i]], 0.0, name="SetQStartMax_{0}".format(i))
    queue_growth_during_clearance = growth_rate_before[i] * clearance_time[i]
    m.addConstr(aux_q_end[i] == queue_at_start_clear[i] + queue_growth_during_clearance, name="CalcAuxQEnd_{0}".format(i))
    m.addGenConstrMax(queue_at_clear_end[i], [aux_q_end[i]], 0.0, name="SetQEndMax_{0}".format(i))
    if can_dissipate[i]:
         m.addConstr(dissipation_time[i] == queue_at_clear_end[i] * inv_dissipation_rate[i], name="CalcDissipationTime_{0}".format(i))
    else:
         m.addConstr(dissipation_time[i] == 0, name="SetDissipationTimeZero_{0}".format(i))

# --- Objective Function ---
objective = gp.QuadExpr()
for i in berths:
    delay_before = 0.5 * growth_rate_before[i] * queue_start_clear_time_diff[i] * queue_start_clear_time_diff[i]
    objective += delay_before
    delay_during = 0.5 * (queue_at_start_clear[i] + queue_at_clear_end[i]) * clearance_time[i]
    objective += delay_during
    if can_dissipate[i]:
        delay_dissipation = 0.5 * inv_dissipation_rate[i] * queue_at_clear_end[i] * queue_at_clear_end[i]
        objective += delay_dissipation
    else:
        objective += non_dissipating_penalty * queue_at_clear_end[i]

m.setObjective(objective, GRB.MINIMIZE)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("{0:.2f}".format(m.objVal))
elif m.status == GRB.INFEASIBLE:
    print("Infeasible")
elif m.status == GRB.UNBOUNDED:
    print("Unbounded")
```
Answer:
21417.42



================================================================================



--- Problem 471 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
In a busy port, the harbor master is tasked with coordinating the berthing times for three different types of ships to minimize the total waiting time. Each type of ship has a specific arrival rate, quantified by flow coefficients of 641, 1988, and 949 ships per hour, respectively. The berthing cycle must adhere to strict operational limits: each ship type's berthing time cannot fall below 19 minutes or exceed 68 minutes, and the total cycle duration is fixed at 68 minutes. The core optimization task is to allocate berthing times strategically, balancing the competing demands of high-traffic ship types while ensuring the sum of all berthing times matches the cycle duration. The goal is to minimize the cumulative waiting time experienced by ships, calculated as the product of the ship arrival rate and the non-berthing time (cycle time minus berthing time) for each ship type.

**Modeling Process:**
- **1. Decision Variables:**  
     Let \( t_i \) represent the berthing time (in minutes) allocated to ship type \( i \), where \( i \in \{1, 2, 3\} \). Each \( t_i \) is a continuous variable bounded between 19 and 68 minutes.  
   - **2. Parameters:**  
     - Ship arrival rates: \( [641, 1988, 949] \) (ships/hour) for ship types 1, 2, and 3.  
     - Cycle time: \( C = 68 \) minutes.  
     - Bounds: \( 19 \leq t_i \leq 68 \) for all \( i \).  
   - **3. Objective Function:**  
     Minimize the total waiting time:  
     \[ \text{Minimize: } 641 \cdot (68 - t_1) + 1988 \cdot (68 - t_2) + 949 \cdot (68 - t_3). \]  
   - **4. Constraints:**  
     - Total berthing time must equal the cycle time:  
       \[ t_1 + t_2 + t_3 = 68. \]  
     - Variable bounds:  
       \( t_1, t_2, t_3 \geq 19 \) and \( t_1, t_2, t_3 \leq 68 \).  

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_ship_types = 3
lb_time = 19          # Lower bound for berthing time
ub_time = 68          # Upper bound for berthing time
cycle_time = 68       # Total cycle time (set equal to ub_time)
arrival_rates = [641, 1988, 949] # Ship arrival rates per type
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_rates) != num_ship_types:
    print("Error: arrival_rates length mismatch with num_ship_types")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_rates length"
    # raise ValueError("arrival_rates length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_ship_types}-Type Berthing Time", env=env)

        # --- Decision variables (dynamic based on num_ship_types) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_ship_types, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for ship type i is proportional to arrival_rate * non_berthing_time = arrival_rate * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_rates[i] * (cycle_time - t_vars[i]) for i in range(num_ship_types)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_ship_types)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_ship_types)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_ship_types):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"


```
Answer:
Optimal total waiting time: 153454.00
------------------------------
Optimal berthing times (minutes):
  t1: 19.00, t2: 30.00, t3: 19.00



================================================================================



--- Problem 472 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
A logistics company operates a fleet of 3 trucks (with capacities 45, 63, and 24 units) to deliver goods from a central depot (Node 0) to 3 customer locations (Nodes 1, 2, and 3). Each customer has a specific demand (17, 15, and 51 units, respectively), and the distances between locations are asymmetric, with the depot-to-customer distances varying significantly (e.g., 81 units from Node 0 to Node 1, 39 units to Node 2). The challenge is to assign routes to the trucks such that every customer is served exactly once, without exceeding truck capacities, while minimizing the total distance traveled. The operational constraints include ensuring trucks start and end at the depot, avoiding subtours, and balancing loads efficiently. The key question is: *What is the most efficient route assignment that meets all delivery demands while minimizing total travel distance?*

**Modeling Process:**
- **1. Decision Variables:**  
     - Binary variable `x[i, j, k]`: 1 if truck *k* travels directly from node *i* to node *j*; 0 otherwise.  
     - Continuous variable `u[i]`: Auxiliary variable for subtour elimination (MTZ constraint), tracking the order of visits to node *i*.  
   - **2. Parameters:**  
     - `N=4`: Total nodes (1 depot + 3 customers).  
     - `K=3`: Number of trucks.  
     - `Q=[45, 63, 24]`: Truck capacities.  
     - `q=[0, 17, 15, 51]`: Demands at nodes (depot has 0 demand).  
     - `d[i][j]`: Distance matrix (e.g., `d[0][1] = 81`).  
   - **3. Objective Function:**  
     Minimize total distance:  
     `Minimize: sum(d[i][j] * x[i, j, k] for all i, j, k where i ≠ j)`.  
   - **4. Constraints:**  
     - **Visit each customer once:** `sum(x[i, j, k] for all j, k where i ≠ j) = 1` for each customer *i*.  
     - **Flow conservation:** Inflow equals outflow for each node and truck.  
     - **Depot departure/return:** Each truck leaves and returns to the depot at most once.  
     - **Capacity:** Total demand on a truck’s route ≤ its capacity.  
     - **Subtour elimination (MTZ):** `u[i] - u[j] + (N-1)*x[i, j, k] ≤ N-2` for all *i, j, k* (i ≠ j).  

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 4
K = 3
Q = [45, 63, 24]
q = [0, 17, 15, 51]
d = [
    [0, 81, 39, 63],
    [81, 0, 74, 68],
    [39, 74, 0, 42],
    [63, 68, 42, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Truck Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for truck {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for truck {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 320.00

Route for truck 1 (Capacity: 45):
0 -> 2 -> 1 -> 0
Route Load: 32 / 45

Route for truck 2 (Capacity: 63):
0 -> 3 -> 0
Route Load: 51 / 63


```

================================================================================



--- Problem 473 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
In a busy port, the harbor master must decide how to allocate berths for incoming ships to minimize operational costs while ensuring that all ships can be accommodated. The port has two possible berth configurations: Option 1 allows a capacity of 1,605 ship arrivals per hour but requires $125 per hour for operational measures, while Option 2 offers a higher capacity of 2,772 ship arrivals per hour at a steeper operational cost of $320 per hour. The current demand is 1,952 ship arrivals per hour. Any unmet demand (ships exceeding capacity) incurs a delay cost of $19 per ship per hour, reflecting fuel waste, crew frustration, and potential economic impacts. The challenge is to select the berth configuration that minimizes the total cost—combining operational expenses and delay penalties—while ensuring the chosen option can handle the demand as efficiently as possible.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `y(k)` for each option `k` (1 or 2), where `y(k) = 1` if option `k` is selected, and `0` otherwise.  
     - Continuous variable `delayed_ships` representing the number of ships delayed due to insufficient capacity (must be ≥ 0).  
   - **2. Parameters:**  
     - `capacity(k)`: Capacity of option `k` (1,605 for Option 1; 2,772 for Option 2).  
     - `operational_cost(k)`: Cost per hour for operational measures under option `k` ($125 for Option 1; $320 for Option 2).  
     - `demand`: 1,952 ship arrivals per hour.  
     - `delay_cost_per_ship`: $19 per delayed ship per hour.  
   - **3. Objective Function:**  
     Minimize total cost:  
     \[
     \text{Total Cost} = \sum_{k} (y(k) \times \text{operational\_cost}(k)) + (\text{delayed\_ships} \times 19)
     \]  
   - **4. Constraints:**  
     - Exactly one option must be chosen:  
       \[
       y(1) + y(2) = 1
       \]  
     - Delayed ships are the excess of demand over capacity (if any):  
       \[
       \text{delayed\_ships} \geq \text{demand} - \sum_{k} (y(k) \times \text{capacity}(k))
       \]  
     - Non-negativity: `delayed_ships ≥ 0`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
options = {1: {'capacity': 1605, 'operational_cost': 125}, 2: {'capacity': 2772, 'operational_cost': 320}}; demand = 1952; delay_cost_per_ship = 19
# End Params
GUROBI_TIME_LIMIT = 60; M = 10000 # Big M if needed
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    option_keys = list(options.keys())
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m12 = gp.Model("Port_Berth_Allocation_IP", env=env)
    # Vars
    y = m12.addVars(option_keys, vtype=GRB.BINARY, name="berth_choice")
    delayed_ships = m12.addVar(name="delayed_ships", lb=0) # Must be non-negative
    # Intermediate Expressions (use directly in objective/constraints)
    total_capacity = gp.quicksum(y[k] * options[k]['capacity'] for k in option_keys)
    total_operational_cost = gp.quicksum(y[k] * options[k]['operational_cost'] for k in option_keys)
    # Objective
    m12.setObjective(total_operational_cost + delayed_ships * delay_cost_per_ship, sense=GRB.MINIMIZE)
    # Constraints
    m12.addConstr(gp.quicksum(y[k] for k in option_keys) == 1, "choose_one_option")
    # Delayed ships = max(0, demand - capacity)
    m12.addConstr(delayed_ships >= demand - total_capacity, "calculate_delayed_ships_lower")
    # Since delayed_ships has lb=0 and objective minimizes it, this is sufficient for LP/IP
    # No need for extra binary variable 'z' like in original example if delayed_ships is continuous/integer >= 0
    # Optimize
    m12.optimize()
    # Store results
    results_dict['status'] = m12.status
    if m12.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m12.objVal
        results_dict['y_sol'] = m12.getAttr('X', y)
        results_dict['delayed_ships_sol'] = delayed_ships.X
    # Output Results
    print("--- Problem 12: Port Berth Allocation (IP) ---")
    if m12.status == GRB.OPTIMAL:
        y_sol = results_dict.get('y_sol', {})
        delayed_ships = results_dict.get('delayed_ships_sol', 0)
        chosen_berth = -1
        for k in option_keys:
            if y_sol.get(k, 0) > 0.5: chosen_berth = k; break
        if chosen_berth != -1:
            final_capacity = options[chosen_berth]['capacity']
            final_operational_cost = options[chosen_berth]['operational_cost']
            final_delay_cost = delayed_ships * delay_cost_per_ship
            print(f"Optimization Status: Optimal")
            print(f"Optimal berth configuration: {chosen_berth}")
            print(f"  Resulting Capacity: {final_capacity} ship arrivals/hr (Demand: {demand} ship arrivals/hr)")
            print(f"  Operational Cost: ${final_operational_cost:.2f}/hr")
            print(f"  Estimated Delayed Ships: {delayed_ships:.1f}") # Can be fractional if demand/cap not integer
            print(f"  Estimated Delay Cost: ${final_delay_cost:.2f}/hr")
            print(f"Minimum Total Cost: ${m12.objVal:.2f}/hr")
        else: print("Error: Optimal status but no option chosen.")
    else: print(f"Optimization Status: {m12.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_BERTH_ALLOCATION
```
Answer:
--- Problem 12: Port Berth Allocation (IP) ---
Optimization Status: Optimal
Optimal berth configuration: 2
  Resulting Capacity: 2772 ship arrivals/hr (Demand: 1952 ship arrivals/hr)
  Operational Cost: $320.00/hr
  Estimated Delayed Ships: 0.0
  Estimated Delay Cost: $0.00/hr
Minimum Total Cost: $320.00/hr



================================================================================



--- Problem 474 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
In a busy port, the harbor master needs to coordinate the berthing times for four different types of ships to minimize the total waiting time. Each type of ship has a unique arrival rate: Type 1 sees 1,459 ships per day, Type 2 sees 1,159, Type 3 handles a heavy flow of 2,572, and Type 4 accommodates a lighter 215 ships. The berthing system must adhere to strict operational rules: berthing times for each type cannot fall below 13 minutes or exceed 81 minutes, and the total cycle time—the sum of all berthing times—must exactly match the upper limit of 81 minutes. The core optimization task is to allocate berthing times strategically across these types, ensuring that the cumulative waiting time—calculated as the product of ship arrival rate and non-berthing time (cycle time minus berthing time)—is minimized. The question at hand: *What is the optimal distribution of berthing times that achieves this goal while respecting all constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Let \( t_i \) represent the berthing time (in minutes) allocated to ship type \( i \), where \( i \in \{1, 2, 3, 4\} \). Each \( t_i \) is a continuous variable bounded between 13 and 81 minutes.  
   - **2. Parameters:**  
     - \( \text{arrival_rates} = [1459, 1159, 2572, 215] \): Ship arrival rates (ships/day) for each type.  
     - \( \text{cycle_time} = 81 \): Fixed total cycle time (minutes).  
     - \( \text{lb_time} = 13 \), \( \text{ub_time} = 81 \): Lower/upper bounds for berthing times.  
   - **3. Objective Function:**  
     - Minimize total waiting time: \( \sum_{i=1}^4 \text{arrival_rates}_i \times (\text{cycle_time} - t_i) \).  
   - **4. Constraints:**  
     - Total berthing time constraint: \( \sum_{i=1}^4 t_i = \text{cycle_time} \).  
     - Bounds on variables: \( 13 \leq t_i \leq 81 \) for all \( i \).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
num_types = 4
lb_time = 13          # Lower bound for berthing time
ub_time = 81          # Upper bound for berthing time
cycle_time = 81   # Total cycle time (set equal to ub_time)
arrival_rates = [1459, 1159, 2572, 215] # Ship arrival rates per type
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30 # Time limit

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Basic validation (optional, but good practice)
if len(arrival_rates) != num_types:
    print("Error: arrival_rates length mismatch with num_types")
    results_dict['status'] = -3 # Data error
    results_dict['error_message'] = "Data inconsistency: arrival_rates length"
    # raise ValueError("arrival_rates length mismatch") # Alternative

# Create model
try:
    # Skip model creation if data error occurred
    if results_dict.get('status') is None or results_dict['status'] >= 0:
        env = gp.Env(empty=True)
        env.setParam('OutputFlag', 0) # Suppress Gurobi log
        env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
        env.start()
        model = Model(f"{num_types}-Type Berthing Timing", env=env)

        # --- Decision variables (dynamic based on num_types) ---
        # Using a dictionary for easy access by index 0..N-1
        t_vars = model.addVars(num_types, lb=lb_time, ub=ub_time, vtype=GRB.CONTINUOUS, name="t")

        # --- Objective function: minimize total waiting time ---
        # Waiting time for type i is proportional to arrival_rate * non_berthing_time = arrival_rate * (cycle_time - berthing_time[i])
        model.setObjective(gp.quicksum(arrival_rates[i] * (cycle_time - t_vars[i]) for i in range(num_types)), GRB.MINIMIZE)

        # --- Constraints ---
        # Sum of berthing times must equal the cycle time
        model.addConstr(gp.quicksum(t_vars[i] for i in range(num_types)) == cycle_time, "TotalCycle")

        # --- Solve the model ---
        model.optimize()

        # --- Store results ---
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
            # Store optimal times for printing later
            results_dict['optimal_times'] = [t_vars[i].x for i in range(num_types)]
        elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
             # If time limit hit but solution exists, store objective
             results_dict['obj_val'] = model.objVal


    # --- Output results (for capture) ---
    # Use results_dict for status check
    current_status_for_output = results_dict.get('status') # Use the stored status

    if current_status_for_output == GRB.OPTIMAL:
        print(f"Optimal total waiting time: {results_dict.get('obj_val', 'N/A'):.2f}")
        print("-" * 30)
        print(f"Optimal berthing times (minutes):")
        optimal_times = results_dict.get('optimal_times', [])
        if optimal_times: # Check if times were stored
             times_output = []
             for i in range(num_types):
                 times_output.append(f"t{i+1}: {optimal_times[i]:.2f}")
             print("  " + ", ".join(times_output))
        else:
             print("  Optimal times not available in results dictionary.")

    elif current_status_for_output == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif current_status_for_output == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare due to generator checks
    elif current_status_for_output == -3: # Custom data error
        print(f"\nModel execution skipped due to data error: {results_dict.get('error_message', 'Unknown data error')}")
    # Add other statuses if needed
    else:
        print(f"\nOptimization finished with status: {current_status_for_output}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total waiting time: 292952.00
------------------------------
Optimal berthing times (minutes):
  t1: 13.00, t2: 13.00, t3: 42.00, t4: 13.00


```

================================================================================



--- Problem 475 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the daily challenge of efficiently scheduling incoming trucks to minimize delays and tardiness penalties. Five trucks (1 to 5) arrive at staggered times—Truck 1 at 5 hours, Truck 2 at 9, and so on, with the last arriving at 16 hours. Each truck requires a specific unloading time: for instance, Truck 1 needs 3 hours to unload, while Truck 5 demands 6 hours. The hub has three depots available, but trucks cannot overlap at the same depot. Delays are costly: if a truck finishes after its due time (e.g., Truck 1’s deadline is 12 hours), tardiness penalties kick in. The hub manager aims to assign trucks to depots and schedule their start times to minimize a weighted sum of waiting time (weight = 4) and tardiness (weight = 5). The core question: *What is the optimal depot assignment and scheduling plan to achieve the lowest total weighted cost?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary. 1 if truck *i* is assigned to depot *j*.  
     - `start_time(i)`: Continuous. Start time of truck *i*.  
     - `completion_time(i)`: Continuous. Completion time of truck *i* (start time + unloading time).  
     - `precedes(i, k, j)`: Binary. 1 if truck *i* precedes truck *k* at depot *j*.  
     - `tardiness(i)`: Continuous. Tardiness of truck *i* (max(0, completion time − due time)).  

   - **2. Parameters:**  
     - `arrival_times(i)`: Truck *i*’s arrival time (e.g., 5 for Truck 1).  
     - `unloading_times(i)`: Truck *i*’s unloading time (e.g., 3 for Truck 1).  
     - `due_times(i)`: Truck *i*’s deadline (e.g., 12 for Truck 1).  
     - `weight_wait = 4`, `weight_tardy = 5`: Weights for waiting time and tardiness in the objective.  
     - `H = 100`: A large constant ("Big M") for linearization.  

   - **3. Objective Function:**  
     Minimize:  
     ```
     4 × (sum of waiting times: start_time(i) − arrival_times(i) for all trucks)  
     + 5 × (sum of tardiness(i) for all trucks)  
     ```  

   - **4. Constraints:**  
     - Each truck assigned to exactly one depot: `sum(assign(i, j) for all j) = 1` for all *i*.  
     - Start time ≥ arrival time: `start_time(i) ≥ arrival_times(i)` for all *i*.  
     - Completion time definition: `completion_time(i) = start_time(i) + unloading_times(i)` for all *i*.  
     - No overlapping at depots: If `precedes(i, k, j) = 1`, then `start_time(k) ≥ completion_time(i)` for all *i < k* and depot *j*.  
     - Tardiness definition: `tardiness(i) ≥ completion_time(i) − due_times(i)` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2, 3]
arrival_times = {1: 5, 2: 9, 3: 12, 4: 15, 5: 16}
unloading_times = {1: 3, 2: 5, 3: 3, 4: 5, 5: 6}
due_times = {1: 12, 2: 20, 3: 22, 4: 28, 5: 40}
weight_wait = 4
weight_tardy = 5
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_7_WEIGHTED")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    tardiness = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="tardiness")

    # --- Objective Function ---
    wait_term = gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in trucks)
    tardy_term = gp.quicksum(tardiness[i] for i in trucks)
    m.setObjective(weight_wait * wait_term + weight_tardy * tardy_term, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + unloading_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Tardiness definition
    m.addConstrs((tardiness[i] >= completion_time[i] - due_times.get(i, 0) for i in trucks), name="tardiness_calc")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Weighted cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Depot Assignments and Schedules:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.2f}")
                print(f"  Completion Time: {completion_time[i].x:.2f}")
                print(f"  Tardiness: {tardiness[i].x:.2f}")
    print(f"Total Weighted Cost: {obj_val_print:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
40.0000
Optimal Depot Assignments and Schedules:
Truck 1 assigned to Depot 1
  Start Time: 5.00
  Completion Time: 8.00
  Tardiness: 0.00
Truck 2 assigned to Depot 1
  Start Time: 9.00
  Completion Time: 14.00
  Tardiness: 0.00
Truck 3 assigned to Depot 1
  Start Time: 14.00
  Completion Time: 17.00
  Tardiness: 0.00
Truck 4 assigned to Depot 1
  Start Time: 17.00
  Completion Time: 22.00
  Tardiness: 0.00
Truck 5 assigned to Depot 1
  Start Time: 22.00
  Completion Time: 28.00
  Tardiness: 0.00
Total Weighted Cost: 40.0000


```

================================================================================



--- Problem 476 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
In a busy port, 24 ships (labeled 0 to 23) need to be assigned to one of two berths: *Berth_A* or *Berth_B*. Each berth has a strict capacity limit—27 ships for *Berth_A* and 26 for *Berth_B*. The challenge arises from the preferences of the ship captains: each ship has a documented likelihood (ranging from 0.2 to 0.9) of preferring *Berth_A* over *Berth_B*, derived from historical data or captain surveys. For instance, Ship 21 strongly favors *Berth_A* with a 90% preference, while Ship 15 leans away with only a 21% preference.

Assigning a ship to its non-preferred berth incurs a *dissatisfaction cost*—$4.28 per misassigned ship in *Berth_A* and $4.39 in *Berth_B*. The system aims to minimize total dissatisfaction by strategically balancing assignments against capacity limits. The core question: *How should ships be distributed between the two berths to minimize total dissatisfaction costs while respecting berth capacities?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `x[i, j]` for each ship `i` (0 to 23) and berth `j` (*Berth_A* or *Berth_B*), where `x[i, j] = 1` if ship `i` is assigned to berth `j`, and `0` otherwise.  

   **2. Parameters:**  
   - `preferences[i]`: Probability ship `i` prefers *Berth_A* (e.g., 0.64 for Ship 0).  
   - `dissatisfaction_cost[j]`: Cost per misassignment in berth `j` ($4.28 for *Berth_A*, $4.39 for *Berth_B*).  
   - `capacity[j]`: Maximum ships allowed in berth `j` (27 for *Berth_A*, 26 for *Berth_B*).  

   **3. Objective Function:**  
   Minimize total dissatisfaction cost:  
   ```  
   Minimize: sum(  
       (dissatisfaction_cost[Berth_A] * (1 - preferences[i]) * x[i, Berth_A]) +  
       (dissatisfaction_cost[Berth_B] * preferences[i] * x[i, Berth_B])  
       for all ships i  
   )  
   ```  

   **4. Constraints:**  
   - **Single assignment:** Each ship assigned to exactly one berth:  
     `sum(x[i, j] for j in berths) = 1` for all ships `i`.  
   - **Capacity limits:** Total ships in each berth `j` cannot exceed `capacity[j]`:  
     `sum(x[i, j] for all i) <= capacity[j]` for each berth `j`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]
berths = ['Berth_A', 'Berth_B']
capacity = {'Berth_A': 27, 'Berth_B': 26}
# Preferences defined for the first berth (e.g., Berth_A)
preferences = {0: 0.64, 1: 0.34, 2: 0.62, 3: 0.29, 4: 0.2, 5: 0.25, 6: 0.49, 7: 0.58, 8: 0.74, 9: 0.38, 10: 0.38, 11: 0.89, 12: 0.39, 13: 0.56, 14: 0.29, 15: 0.21, 16: 0.6, 17: 0.8, 18: 0.31, 19: 0.5, 20: 0.24, 21: 0.9, 22: 0.22, 23: 0.26} # Dict: ship_id -> preference for first berth
dissatisfaction_cost = {'Berth_A': 4.28, 'Berth_B': 4.39} # Dict: berth -> cost if forced here when preferred elsewhere
# --- End Parameters ---

GUROBI_TIME_LIMIT = 30

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m = gp.Model("SHIP_BERTH_ASSIGNMENT", env=env)

    # --- Calculate Assignment Costs ---
    # Assumes preference is for the *first* berth in the list
    cost = {}
    if berths: # Check if berths list is not empty
        first_berth = berths[0]
        for i in ships:
            pref_first = preferences.get(i, 0.5) # Default to 0.5 if missing
            for berth_idx, berth_name in enumerate(berths):
                if berth_name == first_berth:
                    # Cost if assigned first_berth = cost_A * prob_prefers_other
                    # Assuming preference for 'other' is (1 - pref_first)
                    cost[i, berth_name] = dissatisfaction_cost.get(berth_name, 1.0) * (1.0 - pref_first)
                else:
                    # Cost if assigned other_berth = cost_other * prob_prefers_first
                    cost[i, berth_name] = dissatisfaction_cost.get(berth_name, 1.0) * pref_first
    # print(f"Calculated costs: {cost}") # Debug print

    # --- Decision Variables ---
    # x[i, j] = 1 if ship i is guided to berth j, 0 otherwise
    # Use tuplelist of valid (ship, berth) pairs
    assign_keys = [(i,j) for i in ships for j in berths]
    x = m.addVars(assign_keys, vtype=GRB.BINARY, name="x")

    # --- Objective Function: Minimize total dissatisfaction cost ---
    # Use .get() on cost dict for safety
    m.setObjective(gp.quicksum(cost.get((i, j), 0) * x[i, j] for i, j in assign_keys), GRB.MINIMIZE)

    # --- Constraints ---
    # Each ship must be guided to exactly one berth
    if ships and berths:
        m.addConstrs((gp.quicksum(x[i, j] for j in berths) == 1 for i in ships), "ShipAssignment")

        # Capacity constraint for each Berth
        for berth_name, berth_cap in capacity.items():
            if berth_name in berths: # Check if berth exists
                m.addConstr(gp.quicksum(x[i, berth_name] for i in ships) <= berth_cap, f"Capacity_{berth_name}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['x_sol'] = m.getAttr('X', x) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.4f}") # Show decimals
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status message from the original snippet
    elif m.Status in [GRB.INFEASIBLE, GRB.TIME_LIMIT]:
        print("No optimal solution found.")
    else: # Other statuses
        print("No optimal solution found.")


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the assignment of ships to berths
if m.Status == GRB.OPTIMAL:
    for i in ships:
        for j in berths:
            if x[i, j].X > 0.5:
                print(f"Ship {i} is assigned to {j}")
```
Answer:
Optimal objective value: 32.2251
Ship 0 is assigned to Berth_A
Ship 1 is assigned to Berth_B
Ship 2 is assigned to Berth_A
Ship 3 is assigned to Berth_B
Ship 4 is assigned to Berth_B
Ship 5 is assigned to Berth_B
Ship 6 is assigned to Berth_B
Ship 7 is assigned to Berth_A
Ship 8 is assigned to Berth_A
Ship 9 is assigned to Berth_B
Ship 10 is assigned to Berth_B
Ship 11 is assigned to Berth_A
Ship 12 is assigned to Berth_B
Ship 13 is assigned to Berth_A
Ship 14 is assigned to Berth_B
Ship 15 is assigned to Berth_B
Ship 16 is assigned to Berth_A
Ship 17 is assigned to Berth_A
Ship 18 is assigned to Berth_B
Ship 19 is assigned to Berth_A
Ship 20 is assigned to Berth_B
Ship 21 is assigned to Berth_A
Ship 22 is assigned to Berth_B
Ship 23 is assigned to Berth_B


```

================================================================================



--- Problem 477 ---
**Difficulty:** easy
**Category:** IP

**Problem Description:**
**
A port authority is tasked with managing the berthing of ships over a total distance of 15,318 meters of dock space. The port manager must decide how many berths to allocate to minimize costs while ensuring timely berthing. Each berth incurs a fixed maintenance cost of $25, regardless of the length of the ship. Additionally, the cost of utilities (water and electricity) is a critical factor: each meter of dock space consumes 0.240 units of utility, with the cost of utilities priced at $1.27 per unit. The total utility cost for the entire dock space is a fixed $4,668.93, but the number of berths used directly impacts the fixed costs. The port has a maximum of 29 berths available but seeks the most cost-effective allocation. The challenge is clear: **What is the optimal number of berths to minimize the total cost, balancing fixed expenses against utility consumption?**
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `n`: Integer variable representing the number of berths to use (lower bound = 1, upper bound = 29).  
   - **2. Parameters:**  
     - `fixed_cost_per_berth = 25` ($ per berth).  
     - `total_utility_cost = 4668.93` (fixed utility cost for the entire dock space, in $).  
     - `max_berths = 29` (maximum available berths).  
   - **3. Objective Function:**  
     - Minimize the total cost:  
       `Total Cost = (n * fixed_cost_per_berth) + total_utility_cost`.  
   - **4. Constraints:**  
     - `1 ≤ n ≤ 29` (berth count must be between 1 and 29).  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
total_dock_space_m = 15318
utility_consumption_rate_units_per_m = 0.240
utility_cost_per_unit = 1.27
fixed_cost_per_berth = 25
max_berths = 29

# Calculated total utility cost (constant)
total_utility_cost = 4668.93
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m30 = gp.Model("PORT_UTILITY_MINIMIZE_IP", env=env)

    # --- Decision Variables ---
    # Integer: Number of berths to use
    # Ensure lb=1 so division in output works
    n = m30.addVar(vtype=GRB.INTEGER, name="num_berths_used", lb=1, ub=max_berths)

    # --- Objective Function ---
    # Minimize total fixed cost + total utility cost
    total_fixed_cost_expr = n * fixed_cost_per_berth
    m30.setObjective(total_fixed_cost_expr + total_utility_cost, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Constraints on n are handled by variable bounds (lb=1, ub=max_berths)
    # No other constraints in this simple model

    # --- Optimization ---
    m30.optimize()

    # --- Store results ---
    results_dict['status'] = m30.status
    if m30.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m30.ObjVal
        results_dict['n_sol'] = n.X

    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print(f"--- PORT_UTILITY_MINIMIZE: Utility Minimization for Berths (IP) ---")
    if m30.status == GRB.OPTIMAL:
        opt_n = int(round(results_dict.get('n_sol', 1))) # Round and ensure integer >= 1
        opt_fixed_cost = opt_n * fixed_cost_per_berth
        obj_val_print = results_dict.get('obj_val', 0)

        print(f"Optimization Status: Optimal")
        print(f"Optimal Number of Berths to Use: {opt_n} (Max allowed: {max_berths})")
        print(f"Resulting Fixed Maintenance Cost: ${opt_fixed_cost:.2f} (Cost/Berth: ${fixed_cost_per_berth})")
        print(f"Total Utility Cost (Constant): ${total_utility_cost:.2f}")
        print(f"Minimum Total Cost: ${obj_val_print:.2f}")
        # Avoid division by zero if opt_n somehow becomes 0 (lb=1 should prevent)
        if opt_n > 0:
             print(f"Dock space per berth: {total_dock_space_m / opt_n:.1f} m (Total: {total_dock_space_m} m)")
        else:
             print("Cannot calculate dock space per berth (0 berths).")


    elif m30.status == GRB.INFEASIBLE:
         # Should not happen with lb=1 and ub >= lb
         print(f"Optimization Status: Infeasible. Check variable bounds (lb=1, ub={max_berths}).")
    elif m30.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)")
         # Should be very fast, but include handling just in case
         if m30.ObjVal is not None and abs(m30.ObjVal) < float('inf'):
              print(f"Best Objective Found: ${m30.ObjVal:.2f} (Solution may be suboptimal)")
         else:
              print("No feasible solution found within time limit.")
    else:
        print(f"Optimization Status Code: {m30.status}")

except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- PORT_UTILITY_MINIMIZE: Utility Minimization for Berths (IP) ---
Optimization Status: Optimal
Optimal Number of Berths to Use: 1 (Max allowed: 29)
Resulting Fixed Maintenance Cost: $25.00 (Cost/Berth: $25)
Total Utility Cost (Constant): $4668.93
Minimum Total Cost: $4693.93
Dock space per berth: 15318.0 m (Total: 15318 m)


```

================================================================================



--- Problem 478 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with packing a set of 10 items into bins for shipment, each with a specific weight and color. The items have weights [6, 51, 46, 10, 23, 43, 36, 21, 58, 25] and are labeled with colors ['Y', 'V', 'H', 'N', 'P', 'V', 'H', 'Q', 'B', 'Z']. The bins have a maximum capacity of 65 units, and the company aims to minimize the number of bins used while adhering to a strict color constraint: no bin can contain items with more than two distinct colors. This constraint ensures uniformity and simplifies sorting at the destination. The challenge is to assign each item to a bin such that the total weight in any bin does not exceed its capacity, and the color diversity per bin is limited. The goal is to find the smallest number of bins that can accommodate all items under these rules.
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `x[i, j]`: Binary variable indicating whether item `i` is placed in bin `j` (1 if yes, 0 otherwise).
   - `y[j]`: Binary variable indicating whether bin `j` is used (1 if yes, 0 otherwise).
   - `z[c, j]`: Binary variable indicating whether color `c` is present in bin `j` (1 if yes, 0 otherwise).

**2. Parameters:**
   - `items`: List of item weights [6, 51, 46, 10, 23, 43, 36, 21, 58, 25].
   - `colors`: List of item colors ['Y', 'V', 'H', 'N', 'P', 'V', 'H', 'Q', 'B', 'Z'].
   - `capacity`: Maximum weight per bin (65).
   - `num_items`: Number of items (10).
   - `num_bins`: Maximum number of bins (10, one per item in the worst case).
   - `unique_colors_list`: Sorted list of unique colors ['B', 'H', 'N', 'P', 'Q', 'V', 'Y', 'Z'].

**3. Objective Function:**
   - Minimize the total number of bins used: `Minimize sum(y[j] for all j)`.

**4. Constraints:**
   - **Item Assignment:** Each item must be assigned to exactly one bin: `sum(x[i, j] for all j) = 1` for each item `i`.
   - **Bin Capacity:** The total weight in any bin `j` must not exceed its capacity: `sum(items[i] * x[i, j] for all i) <= capacity * y[j]` for each bin `j`.
   - **Color Linking:** If any item of color `c` is in bin `j`, then `z[c, j]` must be 1: `x[i, j] <= z[colors[i], j]` for each item `i` and bin `j`.
   - **Color Count:** The number of distinct colors in any used bin `j` must not exceed 2: `sum(z[c, j] for all c) <= 2 * y[j]` for each bin `j`.

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
items = [6, 51, 46, 10, 23, 43, 36, 21, 58, 25]      # Weights of items
colors = ['Y', 'V', 'H', 'N', 'P', 'V', 'H', 'Q', 'B', 'Z']    # Colors of items
capacity = 65         # Bin capacity
num_items = 10       # len(items) - derived correctly below
num_bins = num_items      # Maximum bins (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(items) != len(colors) or len(items) != num_items:
    print("Error: Data inconsistency (items/colors/num_items length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_colors_list = sorted(list(set(colors))) # Get unique colors deterministically
item_indices_by_color = {color: [i for i, c in enumerate(colors) if c == color] for color in unique_colors_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Color-Constrained Bin Packing", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_items, num_bins, vtype=GRB.BINARY, name="x")  # x[i,j] -> item i in bin j
        y = model.addVars(num_bins, vtype=GRB.BINARY, name="y")              # y[j] -> whether bin j is used
        # z[c,j] -> whether color c is PRESENT in bin j (Use unique_colors_list for keys)
        z = model.addVars(unique_colors_list, num_bins, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of bins used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each item must be assigned to exactly one bin ---
        for i in range(num_items):
            model.addConstr(x.sum(i, '*') == 1, name=f"Item_{i}_Assignment")

        # --- Constraint 2: Bin capacity constraint ---
        for j in range(num_bins):
            model.addConstr(gp.quicksum(items[i] * x[i, j] for i in range(num_items)) <= capacity * y[j], name=f"Bin_{j}_Capacity")

        # --- Constraint 3: Color constraint (at most 2 *different* colors per bin) ---

        # Part 3a: Link x (item in bin) and z (color in bin).
        for j in range(num_bins):
            for color in unique_colors_list:
                indices_of_this_color = item_indices_by_color.get(color, []) # Use .get for safety

                if not indices_of_this_color:
                    # If no items of this color exist, z[color, j] must be 0.
                    model.addConstr(z[color, j] == 0, name=f"NoItems_{color}_Bin_{j}")
                    continue

                # If any item 'i' of this 'color' is placed in bin 'j' (x[i,j]=1),
                # then the presence indicator for that 'color' in bin 'j' (z[color,j]) must be 1.
                for i in indices_of_this_color:
                    model.addConstr(x[i, j] <= z[color, j], name=f"Link_x{i}_z{color}_Bin{j}")

                # Ensure z[color, j] is 0 if no items of that color are in the bin.
                # This helps tighten the formulation.
                model.addConstr(z[color, j] <= gp.quicksum(x[i, j] for i in indices_of_this_color), name=f"Link_z{color}_SumX_Bin{j}")


        # Part 3b: Limit the number of distinct colors (sum of z[c,j] for bin j) to 2 for USED bins.
        for j in range(num_bins):
            # sum(z[c,j] for c in unique_colors_list) gives the count of distinct colors in bin j.
            # This sum must be <= 2 *IF* the bin is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Colors_Bin_{j}")

        # --- Solve ---
        print("Solving CCBP instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_bins = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of bins used: {optimal_bins}")
    print("-" * 30)

    bin_details = []
    printed_bin_count = 0
    for j_sol in range(num_bins): # Iterate through all potential bin indices
        try:
             # Check if this bin was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_bin_count += 1
                 assigned_items_indices = [i for i in range(num_items) if x[i, j_sol].X > 0.5]
                 assigned_items_weights = [items[i] for i in assigned_items_indices]
                 assigned_items_colors = [colors[i] for i in assigned_items_indices]
                 distinct_colors_in_bin = sorted(list(set(assigned_items_colors))) # Sort for consistent output
                 bin_load = sum(assigned_items_weights)

                 print(f"Bin {printed_bin_count} (Internal Index {j_sol}):")
                 print(f"  Items (indices): {assigned_items_indices}")
                 # print(f"  Items (weights): {assigned_items_weights}") # Optional details
                 # print(f"  Items (colors):  {assigned_items_colors}") # Optional details
                 print(f"  Distinct Colors: {distinct_colors_in_bin} (Count: {len(distinct_colors_in_bin)})")
                 print(f"  Total weight:    {bin_load} / {capacity}")
                 print("-" * 10)

                 bin_data = {
                     'bin_index_internal': j_sol,
                     'bin_index_printed': printed_bin_count,
                     'item_indices': assigned_items_indices,
                     'distinct_colors': distinct_colors_in_bin,
                     'load': bin_load
                 }
                 bin_details.append(bin_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for bin index {j_sol}: {e_print}")


    results_dict['bin_details'] = bin_details # Store details

    # Final sanity check
    if printed_bin_count != optimal_bins:
         print(f"Warning: Number of printed used bins ({printed_bin_count}) does not match objective value ({optimal_bins}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving CCBP instance...
------------------------------

Optimal solution found.
Optimal number of bins used: 6
------------------------------
Bin 1 (Internal Index 0):
  Items (indices): [1, 3]
  Distinct Colors: ['N', 'V'] (Count: 2)
  Total weight:    61 / 65
----------
Bin 2 (Internal Index 1):
  Items (indices): [5, 7]
  Distinct Colors: ['Q', 'V'] (Count: 2)
  Total weight:    64 / 65
----------
Bin 3 (Internal Index 2):
  Items (indices): [0, 8]
  Distinct Colors: ['B', 'Y'] (Count: 2)
  Total weight:    64 / 65
----------
Bin 4 (Internal Index 5):
  Items (indices): [2]
  Distinct Colors: ['H'] (Count: 1)
  Total weight:    46 / 65
----------
Bin 5 (Internal Index 7):
  Items (indices): [4, 6]
  Distinct Colors: ['H', 'P'] (Count: 2)
  Total weight:    59 / 65
----------
Bin 6 (Internal Index 9):
  Items (indices): [9]
  Distinct Colors: ['Z'] (Count: 1)
  Total weight:    25 / 65
----------


```

================================================================================



--- Problem 479 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
In a busy distribution center, five delivery trucks arrive at varying times, each requiring unloading at one of two available depots. The logistics manager faces the challenge of scheduling these trucks to minimize the total time all trucks spend in the distribution center, accounting for their arrival times and the differing processing times at each depot. Truck 1 arrives at time 2, Truck 2 at time 6, Truck 3 at time 8, Truck 4 at time 10, and Truck 5 at time 13. The processing times vary by truck and depot: for example, Truck 1 takes 11 hours at Depot 1 but only 8 hours at Depot 2, while Truck 5 is quicker, requiring just 1 hour at Depot 1 or 3 hours at Depot 2. The key constraint is that no two trucks can occupy the same depot simultaneously—each must start unloading only after the previous truck at that depot has finished. The central question is: What is the optimal assignment of trucks to depots and their start times to minimize the total completion time for all trucks?
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign[i, j]`: Binary variable (1 if Truck *i* is assigned to Depot *j*, 0 otherwise).  
   - `start_time[i]`: Continuous variable representing the start time of Truck *i*.  
   - `completion_time[i]`: Continuous variable representing the completion time of Truck *i*.  
   - `precedes[i, k, j]`: Binary variable (1 if Truck *i* precedes Truck *k* at Depot *j*, 0 otherwise).  

   **2. Parameters:**  
   - `trucks`: [1, 2, 3, 4, 5]  
   - `depots`: [1, 2]  
   - `arrival_times`: {1: 2, 2: 6, 3: 8, 4: 10, 5: 13}  
   - `processing_times`: {(1, 1): 11, (1, 2): 8, ..., (5, 2): 3}  
   - `H`: A large constant (100) for logical constraints.  

   **3. Objective Function:**  
   Minimize the sum of completion times for all trucks:  
   `Minimize: sum(completion_time[i] for i in trucks)`  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot:  
     `For each i in trucks: sum(assign[i, j] for j in depots) = 1`  
   - **Arrival Time:** A truck cannot start unloading before its arrival time:  
     `For each i in trucks: start_time[i] >= arrival_times[i]`  
   - **Completion Time:** The completion time is the start time plus the processing time at the assigned depot:  
     `For each i in trucks: completion_time[i] = start_time[i] + sum(processing_times[i, j] * assign[i, j] for j in depots)`  
   - **Non-Overlapping:** If two trucks are assigned to the same depot, one must precede the other:  
     `For each j in depots, i < k in trucks: precedes[i, k, j] = 1 ⇒ start_time[k] >= completion_time[i]`  
     `For each j in depots, i < k in trucks: precedes[i, k, j] = 0 ⇒ start_time[i] >= completion_time[k]`  
     `For each j in depots, i < k in trucks: assign[i, j] + assign[k, j] - 1 <= precedes[i, k, j] + (1 - precedes[i, k, j])`  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2]
arrival_times = {1: 2, 2: 6, 3: 8, 4: 10, 5: 13}
processing_times = {(1, 1): 11, (1, 2): 8, (2, 1): 7, (2, 2): 6, (3, 1): 4, (3, 2): 1, (4, 1): 4, (4, 2): 5, (5, 1): 1, (5, 2): 3} # Dict {(truck, depot): time}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_8_DEPOT_PROC")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(completion_time[i] for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time (depot dependent)
    m.addConstrs((completion_time[i] == start_time[i] + gp.quicksum(processing_times.get((i,j), 0) * assign[i,j] for j in depots)
                  for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print the assignment of trucks to depots and their start and completion times
if m.status == GRB.OPTIMAL:
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}, Start Time: {start_time[i].x:.2f}, Completion Time: {completion_time[i].x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
74.0000
Truck 1 is assigned to Depot 2, Start Time: 2.00, Completion Time: 10.00
Truck 2 is assigned to Depot 2, Start Time: 16.00, Completion Time: 22.00
Truck 3 is assigned to Depot 2, Start Time: 10.00, Completion Time: 11.00
Truck 4 is assigned to Depot 1, Start Time: 11.00, Completion Time: 15.00
Truck 5 is assigned to Depot 1, Start Time: 15.00, Completion Time: 16.00


```

================================================================================



--- Problem 480 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy maritime port, a fleet of nine ships arrives at staggered times throughout the day, each requiring berthing and unloading at one of two available berths. The port manager faces the challenge of minimizing the total waiting time for all ships, ensuring efficient operations while adhering to strict scheduling constraints.  

Ships arrive at distinct times: Ship 0 at 4 minutes, Ship 1 at 12 minutes, and so on, with the latest arrival being Ship 8 at 36 minutes. Each ship has a specific unloading duration—for instance, Ship 0 takes 10 minutes, while Ship 6 requires 14 minutes. The two berths must handle these ships without overlapping assignments, meaning no two ships can occupy the same berth simultaneously unless one has finished unloading before the next begins.  

The core question is: *How should the ships be assigned to the berths, and in what order, to ensure the cumulative waiting time—the delay between a ship's arrival and the start of its unloading—is as small as possible?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether Ship `i` is assigned to Berth `j` (1 if assigned, 0 otherwise).  
   - `s[i]`: Continuous variable representing the start time of unloading for Ship `i`.  
   - `C[i]`: Continuous variable representing the completion time of unloading for Ship `i` (start time plus unloading duration).  
   - `W[i]`: Continuous variable representing the waiting time for Ship `i` (start time minus arrival time).  
   - `y[i, k]`: Binary variable indicating whether Ship `i` precedes Ship `k` on the same berth (1 if `i` is scheduled before `k`, 0 otherwise).  

   **2. Parameters:**  
   - `ships`: List of ships (0 to 8).  
   - `berths`: List of berths (0 and 1).  
   - `arrival_times[i]`: Arrival time of Ship `i` (e.g., Ship 0 arrives at 4 minutes).  
   - `unloading_times[i]`: Unloading duration of Ship `i` (e.g., Ship 0 takes 10 minutes).  
   - `M`: A large constant (133) used to enforce logical constraints.  

   **3. Objective Function:**  
   Minimize the total waiting time for all ships:  
   ```  
   Minimize: sum(W[i] for all ships i)  
   ```  

   **4. Constraints:**  
   - **Assignment:** Each ship must be assigned to exactly one berth:  
     ```  
     For each ship i: sum(x[i, j] for all berths j) = 1  
     ```  
   - **Start Time:** Unloading for a ship cannot begin before its arrival:  
     ```  
     For each ship i: s[i] >= arrival_times[i]  
     ```  
   - **Completion Time:** The completion time is the start time plus unloading duration:  
     ```  
     For each ship i: C[i] = s[i] + unloading_times[i]  
     ```  
   - **Waiting Time:** The waiting time is the difference between start time and arrival time:  
     ```  
     For each ship i: W[i] = s[i] - arrival_times[i]  
     ```  
   - **Non-Overlapping:** Ships on the same berth must not overlap in unloading times (enforced via Big-M constraints):  
     ```  
     For each berth j and ships i, k (i ≠ k):  
     s[k] >= C[i] - M*(1 - y[i,k]) - M*(2 - x[i,j] - x[k,j])  
     s[i] >= C[k] - M*y[i,k] - M*(2 - x[i,j] - x[k,j])  
     y[i,k] + y[k,i] >= x[i,j] + x[k,j] - 1  
     y[i,k] + y[k,i] <= 1  
     ```  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3, 4, 5, 6, 7, 8]
berths = [0, 1]
arrival_times = {0: 4, 1: 12, 2: 13, 3: 20, 4: 20, 5: 21, 6: 21, 7: 30, 8: 36}
unloading_times = {0: 10, 1: 12, 2: 6, 3: 8, 4: 9, 5: 5, 6: 14, 7: 14, 8: 9}
M = 133 # Big M
# --- End Parameters ---

GUROBI_TIME_LIMIT = 90

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    # env.setParam('MIPGap', 0.01) # Optional: Allow a small gap for faster solves
    env.start()

    # --- Model Creation ---
    m = gp.Model("PORT_SCHEDULING", env=env)

    # --- Decision Variables ---
    # x[i, j] = 1 if ship i assigned to berth j
    x = m.addVars(ships, berths, vtype=GRB.BINARY, name="x")
    # s[i] = start time of unloading for ship i
    s = m.addVars(ships, vtype=GRB.CONTINUOUS, lb=0, name="s") # Ensure non-negative start
    # C[i] = completion time of unloading for ship i
    C = m.addVars(ships, vtype=GRB.CONTINUOUS, lb=0, name="C") # Ensure non-negative completion
    # W[i] = waiting time for ship i
    W = m.addVars(ships, vtype=GRB.CONTINUOUS, lb=0, name="W") # Ensure non-negative wait
    # y[i, k] = 1 if ship i precedes ship k on the same berth
    y = m.addVars(ships, ships, vtype=GRB.BINARY, name="y")

    # --- Objective Function: Minimize total waiting time ---
    m.setObjective(gp.quicksum(W[i] for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    if ships and berths: # Basic checks
        # Each ship assigned to exactly one berth
        m.addConstrs((gp.quicksum(x[i, j] for j in berths) == 1 for i in ships), "Assignment")

        # Unloading start time constraint (must be >= arrival)
        m.addConstrs((s[i] >= arrival_times.get(i, 0) for i in ships), "StartTime") # Use .get for safety

        # Completion time definition
        m.addConstrs((C[i] == s[i] + unloading_times.get(i, 0) for i in ships), "CompletionTime") # Use .get

        # Waiting time definition
        m.addConstrs((W[i] == s[i] - arrival_times.get(i, 0) for i in ships), "WaitingTime") # Use .get

        # Non-overlapping constraint for ships on the same berth (Big-M)
        for j in berths:
            for i in ships:
                for k in ships:
                    if i != k:
                        # Define aliases for potentially missing keys
                        xi_j = x.get((i, j))
                        xk_j = x.get((k, j))
                        yi_k = y.get((i, k))
                        yk_i = y.get((k, i)) # Need y[k,i] as well for sum <= 1

                        if xi_j is not None and xk_j is not None and yi_k is not None and yk_i is not None:
                            # s[k] >= C[i] - M * (1 - y[i,k]) - M * (2 - x[i,j] - x[k,j])
                            m.addConstr(s[k] >= C[i] - M * (1 - yi_k) - M * (2 - xi_j - xk_j), f"NonOverlap1_{i}_{k}_{j}")
                            # s[i] >= C[k] - M * y[i,k]       - M * (2 - x[i,j] - x[k,j]) --> Should be 1-y[k,i] or y[i,k]?
                            # Original used M*y[i,k]. Let's assume y[i,k]=1 means i before k.
                            # So, s[i] >= C[k] implies k is before i (y[k,i]=1). We need -M * (1-y[k,i]) or -M*y[i,k]
                            m.addConstr(s[i] >= C[k] - M * yi_k - M * (2 - xi_j - xk_j), f"NonOverlap2_{i}_{k}_{j}")

                            # Ensure y[i,k] + y[k,i] = 1 if they are on the same berth
                            m.addConstr(yi_k + yk_i >= xi_j + xk_j - 1, f"PrecedenceSum1_{i}_{k}_{j}")
                            m.addConstr(yi_k + yk_i <= 1, f"PrecedenceSum2_{i}_{k}_{j}")

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['W_sol'] = m.getAttr('X', W) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible") # Matches example
    elif m.Status == GRB.TIME_LIMIT:
         print(f"Optimization ended with status {m.Status}") # Matches example's generic else
    else: # Other statuses
        print(f"Optimization ended with status {m.Status}") # Matches example's generic else


except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print additional outputs
if m.Status == GRB.OPTIMAL:
    # Print the assignment of ships to berths
    for i in ships:
        for j in berths:
            if x[i, j].X > 0.5:
                print(f"Ship {i} is assigned to Berth {j}")
    
    # Print the start time, completion time, and waiting time for each ship
    for i in ships:
        print(f"Ship {i}: Start Time = {s[i].X:.2f}, Completion Time = {C[i].X:.2f}, Waiting Time = {W[i].X:.2f}")
```
Answer:
Optimal objective value: 34.00
Ship 0 is assigned to Berth 1
Ship 1 is assigned to Berth 0
Ship 2 is assigned to Berth 1
Ship 3 is assigned to Berth 1
Ship 4 is assigned to Berth 1
Ship 5 is assigned to Berth 0
Ship 6 is assigned to Berth 0
Ship 7 is assigned to Berth 0
Ship 8 is assigned to Berth 1
Ship 0: Start Time = 4.00, Completion Time = 14.00, Waiting Time = 0.00
Ship 1: Start Time = 12.00, Completion Time = 24.00, Waiting Time = 0.00
Ship 2: Start Time = 14.00, Completion Time = 20.00, Waiting Time = 1.00
Ship 3: Start Time = 20.00, Completion Time = 28.00, Waiting Time = 0.00
Ship 4: Start Time = 28.00, Completion Time = 37.00, Waiting Time = 8.00
Ship 5: Start Time = 24.00, Completion Time = 29.00, Waiting Time = 3.00
Ship 6: Start Time = 29.00, Completion Time = 43.00, Waiting Time = 8.00
Ship 7: Start Time = 43.00, Completion Time = 57.00, Waiting Time = 13.00
Ship 8: Start Time = 37.00, Completion Time = 46.00, Waiting Time = 1.00


```

================================================================================



--- Problem 481 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy logistics hub, three delivery trucks—Truck 1, Truck 2, and Truck 3—arrive at staggered times, each requiring immediate unloading at one of the available depots. The hub has three depots, but the challenge lies in efficiently assigning trucks to depots while minimizing the cost of waiting time, which escalates sharply if delays exceed a critical threshold.  

Truck 1 arrives at 4 hours, Truck 2 at 9 hours, and Truck 3 at 14 hours. Processing times vary: Truck 1 takes 4 hours to unload, Truck 2 takes 7 hours, and Truck 3 takes 6 hours. The waiting cost structure is tiered: for delays up to 4 hours, the cost is $80 per hour, but beyond that, it jumps to $224 per hour—a penalty designed to reflect the severe impact of prolonged delays on hub operations.  

The hub manager must decide not only which depot each truck should use but also the exact start times to ensure no two trucks occupy the same depot simultaneously. The core question is: *How can the trucks be scheduled across the depots to minimize the total waiting cost, especially given the steep penalty for excessive delays?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
    - Binary variable `assign(i, j)`: 1 if truck *i* is assigned to depot *j*, else 0.  
    - Continuous variable `start_time(i)`: When truck *i* begins processing.  
    - Continuous variable `completion_time(i)`: When truck *i* finishes (start time + processing time).  
    - Binary variable `precedes(i, k, j)`: 1 if truck *i* is scheduled before truck *k* on depot *j*.  
    - Continuous variable `wait_part1(i)`: Waiting time for truck *i* under the first cost rate (≤4 hours).  
    - Continuous variable `wait_part2(i)`: Waiting time for truck *i* under the second cost rate (>4 hours).  

    **2. Parameters:**  
    - `arrival_times[i]`: Arrival times (Truck 1: 4, Truck 2: 9, Truck 3: 14).  
    - `processing_times[i]`: Processing durations (Truck 1: 4, Truck 2: 7, Truck 3: 6).  
    - `wait_cost_rate1`: $80/hour (for wait_part1).  
    - `wait_cost_rate2`: $224/hour (for wait_part2).  
    - `wait_threshold`: 4 hours (threshold between cost rates).  

    **3. Objective Function:**  
    Minimize the total waiting cost:  
    `sum(80 * wait_part1[i] + 224 * wait_part2[i] for all trucks i)`.  

    **4. Constraints:**  
    - **Assignment:** Each truck must be assigned to exactly one depot.  
    - **Arrival time:** Start time cannot precede a truck’s arrival.  
    - **Completion time:** Completion time = start time + processing time.  
    - **Non-overlapping:** For each depot, trucks must be sequenced (either *i* before *k* or vice versa).  
    - **Wait decomposition:** Total waiting time splits into two parts based on the threshold.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3]
depots = [1, 2, 3]
arrival_times = {1: 4, 2: 9, 3: 14}
processing_times = {1: 4, 2: 7, 3: 6}
wait_cost_rate1 = 80
wait_cost_rate2 = 224
wait_threshold = 4
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_56_PIECEWISE_COST")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")
    wait_part1 = m.addVars(trucks, lb=0.0, ub=wait_threshold, vtype=GRB.CONTINUOUS, name="WaitPart1")
    wait_part2 = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="WaitPart2")

    # --- Objective Function ---
    total_wait_cost = gp.quicksum(wait_cost_rate1 * wait_part1[i] + wait_cost_rate2 * wait_part2[i] for i in trucks)
    m.setObjective(total_wait_cost, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")
    # 5. Link waiting time parts
    m.addConstrs((start_time[i] - arrival_times.get(i, 0) == wait_part1[i] + wait_part2[i] for i in trucks), name="wait_decomposition")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED: # Should not happen
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Print Missing Outputs ---

if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
                print(f"Waiting Time (Part 1): {wait_part1[i].x:.4f}, Waiting Time (Part 2): {wait_part2[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
0.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 3
Start Time: 4.0000, Completion Time: 8.0000
Waiting Time (Part 1): 0.0000, Waiting Time (Part 2): 0.0000
Truck 2 is assigned to Depot 2
Start Time: 9.0000, Completion Time: 16.0000
Waiting Time (Part 1): 0.0000, Waiting Time (Part 2): 0.0000
Truck 3 is assigned to Depot 1
Start Time: 14.0000, Completion Time: 20.0000
Waiting Time (Part 1): 0.0000, Waiting Time (Part 2): 0.0000


```

================================================================================



--- Problem 482 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port authority is tasked with scheduling a set of 24 incoming ships to a limited number of berths. Each ship has a specific length and revenue, and the goal is to maximize the total revenue from the scheduled ships while adhering to strict length limits. The berths have a maximum capacity of 58 units each, and only 5 berths are available. The challenge is to strategically assign ships to berths such that no berth exceeds its length limit, each ship is placed in at most one berth, and the total revenue of the selected ships is as high as possible.  

   The ships vary significantly in length and revenue—for instance, one ship is 51 units long and generates $12,000 in revenue, while another is just 1 unit long but generates $69,000 in revenue. The port authority must carefully balance these trade-offs to extract the most revenue from the limited berth space. The core question is: *How should the ships be distributed across the berths to achieve the highest possible total revenue without violating any constraints?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x[i, j]`: Binary variable indicating whether ship `i` is assigned to berth `j` (1 if assigned, 0 otherwise).  
   - `y[j]`: Binary variable indicating whether berth `j` is used (1 if used, 0 otherwise).  

   **2. Parameters:**  
   - `ships`: List of tuples `(length, revenue)` for each ship (e.g., `(51, 12000)`).  
   - `berth_capacity = 58`: Maximum length a berth can accommodate.  
   - `num_berths = 5`: Total berths available.  
   - `num_ships = 24`: Total ships to schedule.  

   **3. Objective Function:**  
   Maximize the total revenue of scheduled ships:  
   \[
   \text{Maximize: } \sum_{i=1}^{24} \sum_{j=1}^{5} \text{revenue}_i \cdot x[i, j]
   \]  

   **4. Constraints:**  
   - **Berth Length Limit:** For each berth `j`, the total length of assigned ships cannot exceed its capacity:  
     \[
     \sum_{i=1}^{24} \text{length}_i \cdot x[i, j] \leq 58 \cdot y[j] \quad \forall j \in \{1, \dots, 5\}
     \]  
   - **Ship-Berth Link:** If a ship `i` is assigned to berth `j`, the berth must be marked as used:  
     \[
     x[i, j] \leq y[j] \quad \forall i \in \{1, \dots, 24\}, \forall j \in \{1, \dots, 5\}
     \]  
   - **Ship Assignment:** Each ship can be assigned to at most one berth:  
     \[
     \sum_{j=1}^{5} x[i, j] \leq 1 \quad \forall i \in \{1, \dots, 24\}
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Data Definition (Embedded) ---
ships = [(51, 12000), (19, 100000), (28, 24000), (35, 75000), (21, 82000), (39, 9000), (55, 53000), (13, 42000), (58, 68000), (16, 93000), (44, 11000), (20, 43000), (27, 18000), (1, 69000), (56, 10000), (38, 19000), (48, 26000), (18, 11000), (30, 80000), (7, 65000), (48, 8000), (57, 48000), (49, 63000), (23, 78000)]          # List of (length, revenue) tuples
berth_capacity = 58      # Maximum length per berth
num_berths = 5          # Maximum number of available berths (parameter)
num_ships = 24          # len(ships) derived correctly
# --- End Data Definition ---

GUROBI_TIME_LIMIT = 60 # Time limit parameter

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi log in captured output
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Max-Revenue BPP", env=env)

    # --- Decision variables ---
    x = model.addVars(num_ships, num_berths, vtype=GRB.BINARY, name="x")  # x[i, j] -> ship i assigned to berth j
    y = model.addVars(num_berths, vtype=GRB.BINARY, name="y")  # y[j] -> berth j is used

    # --- Objective: Maximize total revenue of selected ships ---
    # Sum over all ships i and the berth j they are assigned to
    model.setObjective(gp.quicksum(ships[i][1] * x[i, j] for i in range(num_ships) for j in range(num_berths)), GRB.MAXIMIZE)

    # --- Constraint 1: Berth length limit ---
    for j in range(num_berths):
        model.addConstr(gp.quicksum(ships[i][0] * x[i, j] for i in range(num_ships)) <= berth_capacity * y[j], name=f"Berth_{j}_Length")

    # --- Constraint 2: If a ship is assigned to a berth, that berth must be considered used ---
    # (This is often implied by C1 if capacity > 0, but good practice)
    for i in range(num_ships):
        for j in range(num_berths):
            model.addConstr(x[i, j] <= y[j], name=f"Ship_{i}_Triggers_Berth_{j}")

    # --- Constraint 3: Each ship can be assigned to at most one berth ---
    # (Ships not assigned contribute 0 to objective and constraints)
    for i in range(num_ships):
        model.addConstr(x.sum(i, '*') <= 1, name=f"Ship_{i}_AtMostOneBerth")

    # --- Solve the model ---
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal # Best solution found

    # --- Output results (for capture) ---
    if model.status == GRB.OPTIMAL:
        print(f"Optimal total revenue: {model.objVal:.2f}") # Format value
        print("-" * 30)
        printed_berth_count = 0
        for j in range(num_berths):
            try:
                 if y[j].x > 0.5:  # Berth is used
                     printed_berth_count += 1
                     assigned_ships = [i for i in range(num_ships) if x[i, j].x > 0.5]
                     assigned_lengths = [ships[i][0] for i in assigned_ships]
                     berth_load = sum(assigned_lengths)
                     print(f"Berth {printed_berth_count} (Index {j}):")
                     print(f"  Load: {berth_load} / {berth_capacity}")
                     print(f"  Ships (indices): {sorted(assigned_ships)}")
                     # Optional: print ship details
                     # print(f"  Ships (l,r): {[ships[i] for i in sorted(assigned_ships)]}")
                     print("-" * 10)
            except AttributeError:
                 pass # Skip berths not used or if .X missing
    elif model.status == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare if ships fit capacity
    else:
        print(f"\nOptimization finished with status: {model.status}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total revenue: 830000.00
------------------------------
Berth 1 (Index 0):
  Load: 58 / 58
  Ships (indices): [1, 4, 17]
----------
Berth 2 (Index 1):
  Load: 58 / 58
  Ships (indices): [8]
----------
Berth 3 (Index 2):
  Load: 57 / 58
  Ships (indices): [7, 11, 13, 23]
----------
Berth 4 (Index 3):
  Load: 58 / 58
  Ships (indices): [2, 18]
----------
Berth 5 (Index 4):
  Load: 58 / 58
  Ships (indices): [3, 9, 19]
----------


```

================================================================================



--- Problem 483 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub is tasked with efficiently scheduling the arrival and unloading of five trucks, labeled 1 through 5, to minimize operational costs while adhering to strict scheduling constraints. The trucks arrive at staggered times: Truck 1 at 2 hours, Truck 2 at 3, Truck 3 at 6, Truck 4 at 7, and Truck 5 at 9. Each truck requires a specific processing time to unload and service: 3, 6, 5, 6, and 5 hours, respectively. The hub has three depots available, each capable of handling one truck at a time.

The hub incurs two types of costs: **waiting costs** (penalties for trucks idling before unloading) and **service costs** (operational expenses during unloading). Waiting costs vary by truck: $105/hour for Truck 1, $83 for Truck 2, $125 for Truck 3, $144 for Truck 4, and $99 for Truck 5. Service costs depend on the truck-depot pairing—for example, servicing Truck 1 at Depot 1 costs $68/hour, while Truck 5 at Depot 3 costs $40/hour.

The hub manager must assign each truck to exactly one depot, ensuring no two trucks occupy the same depot simultaneously. The goal is to determine the optimal assignment and scheduling sequence to **minimize the total cost**, balancing the trade-off between waiting penalties and service expenses.

**Key Question:** *What is the optimal depot assignment and start time for each truck to achieve the lowest possible total cost?*  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- **Binary** `assign[i, j]`: 1 if Truck *i* is assigned to Depot *j*, else 0.  
- **Continuous** `start_time[i]`: Time when Truck *i* begins service.  
- **Continuous** `completion_time[i]`: Time when Truck *i* finishes (`start_time[i] + processing_time[i]`).  
- **Binary** `precedes[i, k, j]`: 1 if Truck *i* is serviced before Truck *k* on Depot *j*, else 0.  

**2. Parameters:**  
- **Trucks**: 1, 2, 3, 4, 5.  
- **Depots**: 1, 2, 3.  
- **Arrival times**: `{1: 2, 2: 3, 3: 6, 4: 7, 5: 9}`.  
- **Processing times**: `{1: 3, 2: 6, 3: 5, 4: 6, 5: 5}`.  
- **Waiting costs**: `{1: 105, 2: 83, 3: 125, 4: 144, 5: 99}`.  
- **Service costs**: `{(i, j): cost}` (e.g., `(1, 1): 68`).  
- **Big M**: `H = 100` (a large constant for precedence constraints).  

**3. Objective Function:**  
Minimize:  
```
Total Cost = Σ (waiting_costs[i] × (start_time[i] - arrival_times[i]))  
           + Σ (service_costs[i, j] × processing_times[i] × assign[i, j])
```  

**4. Constraints:**  
- **Assignment**: Each truck assigned to exactly one depot:  
  `Σ assign[i, j] = 1` for all *i*.  
- **Arrival time**: Trucks cannot start before arrival:  
  `start_time[i] ≥ arrival_times[i]` for all *i*.  
- **Completion time**: Linked to start time:  
  `completion_time[i] = start_time[i] + processing_times[i]`.  
- **Non-overlapping**: For each depot *j*, if trucks *i* and *k* are assigned, enforce precedence:  
  - `precedes[i, k, j] + precedes[k, i, j] ≥ assign[i, j] + assign[k, j] - 1`.  
  - If `precedes[i, k, j] = 1`, then `start_time[k] ≥ completion_time[i]`.  

---

**

Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2, 3]
arrival_times = {1: 2, 2: 3, 3: 6, 4: 7, 5: 9}
processing_times = {1: 3, 2: 6, 3: 5, 4: 6, 5: 5}
waiting_costs = {1: 105, 2: 83, 3: 125, 4: 144, 5: 99} # Cost per hour waiting
service_costs = {(1, 1): 68, (1, 2): 57, (1, 3): 64, (2, 1): 46, (2, 2): 54, (2, 3): 58, (3, 1): 69, (3, 2): 56, (3, 3): 52, (4, 1): 55, (4, 2): 45, (4, 3): 45, (5, 1): 63, (5, 2): 67, (5, 3): 40} # Cost rate per hour servicing {(truck, depot): cost}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_53_MIN_COST")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")

    # --- Objective Function ---
    waiting_cost_expr = gp.quicksum(waiting_costs.get(i, 0) * (start_time[i] - arrival_times.get(i, 0)) for i in trucks)
    service_cost_expr = gp.quicksum(service_costs.get((i,j), 0) * processing_times.get(i, 0) * assign[i,j]
                                   for i in trucks for j in depots)
    m.setObjective(waiting_cost_expr + service_cost_expr, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block to Ensure All Outputs are Printed ---

if m.status == GRB.OPTIMAL:
    print(f"Optimal Objective Value: {m.objVal:.4f}")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time for Truck {i}: {start_time[i].x:.4f}")
                print(f"Completion Time for Truck {i}: {completion_time[i].x:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
1292.0000
Optimal Objective Value: 1292.0000
Truck 1 is assigned to Depot 2
Start Time for Truck 1: 2.0000
Completion Time for Truck 1: 5.0000
Truck 2 is assigned to Depot 1
Start Time for Truck 2: 3.0000
Completion Time for Truck 2: 9.0000
Truck 3 is assigned to Depot 3
Start Time for Truck 3: 6.0000
Completion Time for Truck 3: 11.0000
Truck 4 is assigned to Depot 2
Start Time for Truck 4: 7.0000
Completion Time for Truck 4: 13.0000
Truck 5 is assigned to Depot 1
Start Time for Truck 5: 9.0000
Completion Time for Truck 5: 14.0000


```

================================================================================



--- Problem 484 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A busy port terminal operates with a mix of automated and manual berths to manage the daily influx of ships. The terminal handles a significant volume of 2,543 container ships and 214 bulk carriers, each requiring efficient processing to minimize delays and operational costs. A key observation reveals that 70% of container ships are equipped with automated docking systems, allowing them to use automated berths, while the remaining 30% of container ships and all bulk carriers must rely on manual berthing due to compatibility or regulatory constraints.

The challenge lies in determining the optimal number of automated and manual berths to open, balancing capacity and cost. Each automated berth can service up to 864 ships per hour at a cost of $10 per hour, while manual berths handle 303 ships per hour at a higher cost of $34 per hour. With only 4 automated and 4 manual berths available, the goal is to meet demand while minimizing the total hourly operational cost. The critical question: *How many automated and manual berths should be activated to ensure all ships are processed at the lowest possible cost?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `x_auto`: Integer number of automated berths to open (≥ 0).  
   - `x_manual`: Integer number of manual berths to open (≥ 0).  

   **2. Parameters:**  
   - `auto_ships_arrival = 2,543 * 0.70 = 1,780` (automated-compatible container ships).  
   - `non_auto_ships_manual = (2,543 * 0.30) + 214 = 977` (non-automated container ships + bulk carriers).  
   - `service_rate_auto = 864` (ships/hour per automated berth).  
   - `service_rate_manual = 303` (ships/hour per manual berth).  
   - `cost_auto = $10/hour`, `cost_manual = $34/hour`.  
   - `total_auto_berths = 4`, `total_manual_berths = 4` (maximum available).  

   **3. Objective Function:**  
   Minimize total cost:  
   `Minimize: (10 * x_auto) + (34 * x_manual)`.  

   **4. Constraints:**  
   - Automated capacity: `864 * x_auto ≥ 1,780`.  
   - Manual capacity: `303 * x_manual ≥ 977`.  
   - Berth limits: `x_auto ≤ 4`, `x_manual ≤ 4`.  
   - Non-negativity: `x_auto, x_manual ≥ 0` (integer).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Parameters (Embedded) ---
total_auto_berths = 4
total_manual_berths = 4
arrival_container_ships = 2543
arrival_bulk_carriers = 214
auto_ship_ratio = 0.70
service_rate_auto = 864
service_rate_manual = 303
cost_auto = 10
cost_manual = 34
# --- End Parameters ---

GUROBI_TIME_LIMIT = 10

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# --- Calculated Arrivals (Inside Template) ---
try:
    auto_ships_arrival = arrival_container_ships * auto_ship_ratio
    non_auto_ships_arrival = arrival_container_ships * (1.0 - auto_ship_ratio)
    non_auto_ships_manual = non_auto_ships_arrival + arrival_bulk_carriers # All bulk carriers + non-automated container ships

    # --- Model Creation ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    m2 = gp.Model("Port_Berth_Mix", env=env)

    # --- Decision Variables ---
    x_auto = m2.addVar(vtype=GRB.INTEGER, name="num_open_auto_berths", lb=0)
    x_manual = m2.addVar(vtype=GRB.INTEGER, name="num_open_manual_berths", lb=0)

    # --- Objective Function ---
    m2.setObjective(cost_auto * x_auto + cost_manual * x_manual, sense=GRB.MINIMIZE)

    # --- Constraints ---
    # 1: Automated capacity for automated ships
    m2.addConstr(service_rate_auto * x_auto >= auto_ships_arrival, name="auto_capacity")
    # 2: Manual capacity for non-automated ships and all bulk carriers
    m2.addConstr(service_rate_manual * x_manual >= non_auto_ships_manual, name="manual_capacity")
    # 3: Max available automated berths
    m2.addConstr(x_auto <= total_auto_berths, name="max_auto_berths")
    # 4: Max available Manual berths
    m2.addConstr(x_manual <= total_manual_berths, name="max_manual_berths")

    # --- Optimization ---
    m2.optimize()

    # --- Store results ---
    results_dict['status'] = m2.status
    if m2.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m2.objVal
        results_dict['x_auto_optimal'] = x_auto.X
        results_dict['x_manual_optimal'] = x_manual.X

    # --- Output Results (for capture) ---
    # Use original print format
    print("--- Problem 2: Port Berth Mix (Automated vs. Manual) ---")
    if m2.status == GRB.OPTIMAL:
        optimal_auto = results_dict.get('x_auto_optimal', 'N/A')
        optimal_manual = results_dict.get('x_manual_optimal', 'N/A')
        # Round before int() for safety
        if not isinstance(optimal_auto, (int, float)): optimal_auto = -1
        if not isinstance(optimal_manual, (int, float)): optimal_manual = -1

        print(f"Optimization Status: Optimal")
        print(f"Optimal number of Automated berths to open: {int(round(optimal_auto))}")
        print(f"Optimal number of Manual berths to open: {int(round(optimal_manual))}")
        print(f"Minimum total operational cost: ${m2.objVal:.2f}/hour")
        # Recalculate capacities for output clarity
        auto_cap_achieved = service_rate_auto * optimal_auto
        manual_cap_achieved = service_rate_manual * optimal_manual
        print(f"Automated Capacity: {auto_cap_achieved:.0f} >= {auto_ships_arrival:.0f}")
        print(f"Manual Capacity: {manual_cap_achieved:.0f} >= {non_auto_ships_manual:.0f}")
    elif m2.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible")
    else:
        print(f"Optimization Status: {m2.status}")

except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 2: Port Berth Mix (Automated vs. Manual) ---
Optimization Status: Optimal
Optimal number of Automated berths to open: 3
Optimal number of Manual berths to open: 4
Minimum total operational cost: $166.00/hour
Automated Capacity: 2592 >= 1780
Manual Capacity: 1212 >= 977


```

================================================================================



--- Problem 485 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently packing 24 uniquely colored items into bins for shipment, each with a specific weight and color. The challenge is to minimize the number of bins used while adhering to two critical constraints: each bin can hold a maximum weight of 70 units, and no bin may contain items of more than two distinct colors. The items vary widely in weight, from as light as 4 units to as heavy as 69 units, and their colors span a diverse palette, including 'K', 'T', 'G', 'E', and others. 

The operational goal is to assign each item to exactly one bin, ensuring that the total weight in any bin does not exceed its capacity. Additionally, the color constraint complicates the packing process: items in the same bin must share no more than two distinct colors. This scenario mirrors real-world packing problems where items have multiple attributes (like weight and category) that must be balanced to optimize resource usage. The central question is: *What is the minimum number of bins required to pack all items while satisfying both weight and color constraints?*

To add an extra layer of complexity, the company also needs to ensure that no bin contains more than 3 items. This additional constraint aims to balance the load and reduce the risk of damage during transportation.
**

**Modeling Process:**
**
**1. Decision Variables:**
   - `x[i, j]`: Binary variable indicating whether item `i` is placed in bin `j` (1 if yes, 0 otherwise).
   - `y[j]`: Binary variable indicating whether bin `j` is used (1 if yes, 0 otherwise).
   - `z[c, j]`: Binary variable indicating whether color `c` is present in bin `j` (1 if yes, 0 otherwise).

**2. Parameters:**
   - `items`: List of item weights (e.g., [18, 38, ..., 4]).
   - `colors`: List of item colors (e.g., ['K', 'T', ..., 'V']).
   - `capacity`: Maximum weight per bin (70 units).
   - `num_items`: Total number of items (24).
   - `num_bins`: Maximum possible bins (24, one per item in the worst case).
   - `unique_colors_list`: Sorted list of distinct colors (e.g., ['A', 'B', ..., 'Z']).

**3. Objective Function:**
   - Minimize the total number of bins used:  
     `Minimize: sum(y[j] for j in range(num_bins))`.

**4. Constraints:**
   - **Item Assignment:** Each item must be placed in exactly one bin:  
     `For each item i: sum(x[i, j] for j in range(num_bins)) == 1`.
   - **Bin Capacity:** The total weight in any bin must not exceed its capacity:  
     `For each bin j: sum(items[i] * x[i, j] for i in range(num_items)) <= capacity * y[j]`.
   - **Color Linking:** If an item of color `c` is in bin `j`, then `z[c, j]` must be 1:  
     `For each bin j and color c: x[i, j] <= z[c, j] for all items i of color c`.
   - **Color Count:** The number of distinct colors per bin is limited to 2:  
     `For each bin j: sum(z[c, j] for c in unique_colors_list) <= 2 * y[j]`.
   - **Item Limit Per Bin:** No bin may contain more than 3 items:  
     `For each bin j: sum(x[i, j] for i in range(num_items)) <= 3 * y[j]`.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError

# --- Data Definition ---
items = [18, 38, 64, 14, 41, 11, 40, 43, 20, 35, 68, 16, 61, 14, 65, 49, 41, 58, 63, 48, 45, 69, 6, 4]      # Weights of items
colors = ['K', 'T', 'G', 'E', 'H', 'D', 'E', 'A', 'X', 'Z', 'P', 'O', 'B', 'L', 'Y', 'W', 'F', 'D', 'W', 'G', 'J', 'L', 'R', 'V']    # Colors of items
capacity = 70         # Bin capacity
num_items = 24       # len(items) - derived correctly below
num_bins = num_items      # Maximum bins (worst case)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# --- Input Validation (Basic) ---
if len(items) != len(colors) or len(items) != num_items:
    print("Error: Data inconsistency (items/colors/num_items length mismatch).")
    # Set error status and exit this execution block if possible
    results_dict['status'] = -3 # Custom error code for data inconsistency
    results_dict['error_message'] = "Data inconsistency detected before model build."
    # Using 'raise' might be better if exec environment allows clean capture
    # raise ValueError("Data inconsistency detected.")
    # For simplicity with exec, we'll just set status and let it proceed (model might fail later)

# --- Preprocessing (must be inside template to use generated data) ---
unique_colors_list = sorted(list(set(colors))) # Get unique colors deterministically
item_indices_by_color = {color: [i for i, c in enumerate(colors) if c == color] for color in unique_colors_list}

# Create model
try:
    # Suppress Gurobi console output
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    # Optional: Set time limit for harder instances
    # env.setParam('TimeLimit', 60)
    env.start()

    model = Model("Color-Constrained Bin Packing", env=env)

    # Check if status was already set to error due to data inconsistency
    if results_dict.get('status') is not None and results_dict['status'] < 0:
        print("Skipping model build due to earlier data inconsistency.")
    else:
        # --- Decision Variables ---
        x = model.addVars(num_items, num_bins, vtype=GRB.BINARY, name="x")  # x[i,j] -> item i in bin j
        y = model.addVars(num_bins, vtype=GRB.BINARY, name="y")              # y[j] -> whether bin j is used
        # z[c,j] -> whether color c is PRESENT in bin j (Use unique_colors_list for keys)
        z = model.addVars(unique_colors_list, num_bins, vtype=GRB.BINARY, name="z")

        # --- Objective: Minimize the number of bins used ---
        model.setObjective(y.sum('*'), GRB.MINIMIZE)

        # --- Constraint 1: Each item must be assigned to exactly one bin ---
        for i in range(num_items):
            model.addConstr(x.sum(i, '*') == 1, name=f"Item_{i}_Assignment")

        # --- Constraint 2: Bin capacity constraint ---
        for j in range(num_bins):
            model.addConstr(gp.quicksum(items[i] * x[i, j] for i in range(num_items)) <= capacity * y[j], name=f"Bin_{j}_Capacity")

        # --- Constraint 3: Color constraint (at most 2 *different* colors per bin) ---

        # Part 3a: Link x (item in bin) and z (color in bin).
        for j in range(num_bins):
            for color in unique_colors_list:
                indices_of_this_color = item_indices_by_color.get(color, []) # Use .get for safety

                if not indices_of_this_color:
                    # If no items of this color exist, z[color, j] must be 0.
                    model.addConstr(z[color, j] == 0, name=f"NoItems_{color}_Bin_{j}")
                    continue

                # If any item 'i' of this 'color' is placed in bin 'j' (x[i,j]=1),
                # then the presence indicator for that 'color' in bin 'j' (z[color,j]) must be 1.
                for i in indices_of_this_color:
                    model.addConstr(x[i, j] <= z[color, j], name=f"Link_x{i}_z{color}_Bin{j}")

                # Ensure z[color, j] is 0 if no items of that color are in the bin.
                # This helps tighten the formulation.
                model.addConstr(z[color, j] <= gp.quicksum(x[i, j] for i in indices_of_this_color), name=f"Link_z{color}_SumX_Bin{j}")


        # Part 3b: Limit the number of distinct colors (sum of z[c,j] for bin j) to 2 for USED bins.
        for j in range(num_bins):
            # sum(z[c,j] for c in unique_colors_list) gives the count of distinct colors in bin j.
            # This sum must be <= 2 *IF* the bin is used (y[j]=1).
            model.addConstr(z.sum('*', j) <= 2 * y[j], name=f"Max2Colors_Bin_{j}")

        # --- Constraint 4: Item limit per bin (no more than 3 items per bin) ---
        for j in range(num_bins):
            model.addConstr(x.sum('*', j) <= 3 * y[j], name=f"Max3Items_Bin_{j}")

        # --- Solve ---
        print("Solving CCBP instance...")
        model.optimize() # Optimize the model

        # Store results after optimization attempt
        results_dict['status'] = model.status
        if model.status == GRB.OPTIMAL:
            results_dict['obj_val'] = model.objVal
        else:
            results_dict['obj_val'] = None

# Handle Gurobi errors during model building or optimization
except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
# Handle other Python errors
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    # If error happened before status was set, set it now
    if results_dict.get('status') is None:
         results_dict['status'] = -2 # Indicate other Python error
         results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
# Check the status stored in the dictionary
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_bins = int(results_dict.get('obj_val', -1))
    print("-" * 30)
    print(f"\nOptimal solution found.")
    print(f"Optimal number of bins used: {optimal_bins}")
    print("-" * 30)

    bin_details = []
    printed_bin_count = 0
    for j_sol in range(num_bins): # Iterate through all potential bin indices
        try:
             # Check if this bin was actually used in the optimal solution
             if y[j_sol].X > 0.5:
                 printed_bin_count += 1
                 assigned_items_indices = [i for i in range(num_items) if x[i, j_sol].X > 0.5]
                 assigned_items_weights = [items[i] for i in assigned_items_indices]
                 assigned_items_colors = [colors[i] for i in assigned_items_indices]
                 distinct_colors_in_bin = sorted(list(set(assigned_items_colors))) # Sort for consistent output
                 bin_load = sum(assigned_items_weights)

                 print(f"Bin {printed_bin_count} (Internal Index {j_sol}):")
                 print(f"  Items (indices): {assigned_items_indices}")
                 # print(f"  Items (weights): {assigned_items_weights}") # Optional details
                 # print(f"  Items (colors):  {assigned_items_colors}") # Optional details
                 print(f"  Distinct Colors: {distinct_colors_in_bin} (Count: {len(distinct_colors_in_bin)})")
                 print(f"  Total weight:    {bin_load} / {capacity}")
                 print("-" * 10)

                 bin_data = {
                     'bin_index_internal': j_sol,
                     'bin_index_printed': printed_bin_count,
                     'item_indices': assigned_items_indices,
                     'distinct_colors': distinct_colors_in_bin,
                     'load': bin_load
                 }
                 bin_details.append(bin_data)
        except AttributeError:
             # If y[j_sol].X access fails (e.g., model not optimal, variable pruned), skip
             pass
        except Exception as e_print:
             # Catch potential errors during printing results (e.g., accessing non-existent index)
             print(f"Error printing results for bin index {j_sol}: {e_print}")


    results_dict['bin_details'] = bin_details # Store details

    # Final sanity check
    if printed_bin_count != optimal_bins:
         print(f"Warning: Number of printed used bins ({printed_bin_count}) does not match objective value ({optimal_bins}). Check model or tolerances.")


elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount before accessing ObjVal if time limit reached
     try:
         if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
         else: print("No feasible solution found within time limit.")
     except NameError: # model might not be defined if error occurred early
         print("No feasible solution found (model object potentially unavailable).")
     except AttributeError: # model might exist but have no SolCount/ObjVal
         print("No feasible solution found (model attributes unavailable).")

elif results_dict.get('status') is not None and results_dict['status'] < 0:
     # Print custom error messages stored earlier
     print(f"\nOptimization failed. Status code: {results_dict['status']}. Error: {results_dict.get('error_message', 'Unknown error')}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with non-optimal status: {results_dict['status']}.")
else:
    # Fallback if status is still None (shouldn't happen with current structure)
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error; status is None')}")



# The provided code already prints the required outputs, so no additional print statements are needed.
```
Answer:
Solving CCBP instance...
------------------------------

Optimal solution found.
Optimal number of bins used: 16
------------------------------
Bin 1 (Internal Index 0):
  Items (indices): [18]
  Distinct Colors: ['W'] (Count: 1)
  Total weight:    63 / 70
----------
Bin 2 (Internal Index 2):
  Items (indices): [16]
  Distinct Colors: ['F'] (Count: 1)
  Total weight:    41 / 70
----------
Bin 3 (Internal Index 3):
  Items (indices): [14, 23]
  Distinct Colors: ['V', 'Y'] (Count: 2)
  Total weight:    69 / 70
----------
Bin 4 (Internal Index 4):
  Items (indices): [21]
  Distinct Colors: ['L'] (Count: 1)
  Total weight:    69 / 70
----------
Bin 5 (Internal Index 5):
  Items (indices): [3, 5, 6]
  Distinct Colors: ['D', 'E'] (Count: 2)
  Total weight:    65 / 70
----------
Bin 6 (Internal Index 6):
  Items (indices): [19]
  Distinct Colors: ['G'] (Count: 1)
  Total weight:    48 / 70
----------
Bin 7 (Internal Index 7):
  Items (indices): [2, 22]
  Distinct Colors: ['G', 'R'] (Count: 2)
  Total weight:    70 / 70
----------
Bin 8 (Internal Index 9):
  Items (indices): [9]
  Distinct Colors: ['Z'] (Count: 1)
  Total weight:    35 / 70
----------
Bin 9 (Internal Index 11):
  Items (indices): [8, 15]
  Distinct Colors: ['W', 'X'] (Count: 2)
  Total weight:    69 / 70
----------
Bin 10 (Internal Index 12):
  Items (indices): [17]
  Distinct Colors: ['D'] (Count: 1)
  Total weight:    58 / 70
----------
Bin 11 (Internal Index 13):
  Items (indices): [12]
  Distinct Colors: ['B'] (Count: 1)
  Total weight:    61 / 70
----------
Bin 12 (Internal Index 14):
  Items (indices): [1]
  Distinct Colors: ['T'] (Count: 1)
  Total weight:    38 / 70
----------
Bin 13 (Internal Index 16):
  Items (indices): [7, 13]
  Distinct Colors: ['A', 'L'] (Count: 2)
  Total weight:    57 / 70
----------
Bin 14 (Internal Index 17):
  Items (indices): [11, 20]
  Distinct Colors: ['J', 'O'] (Count: 2)
  Total weight:    61 / 70
----------
Bin 15 (Internal Index 21):
  Items (indices): [10]
  Distinct Colors: ['P'] (Count: 1)
  Total weight:    68 / 70
----------
Bin 16 (Internal Index 22):
  Items (indices): [0, 4]
  Distinct Colors: ['H', 'K'] (Count: 2)
  Total weight:    59 / 70
----------


```

================================================================================



--- Problem 486 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A port management team faces a critical challenge: mitigating delays caused by an unexpected incident that reduces the main berth's capacity. Over four consecutive 30-minute periods, ships arrive at fluctuating rates (3895, 3851, 2517, and 4975 ships per hour, respectively). The incident lasts approximately 1.18 hours, slashing the main berth’s capacity from 5,696 to 1,734 ships per hour. An alternative berth exists, but it has a limited capacity of 806 ships per hour and adds an extra 5.33 minutes (0.089 hours) to berthing time. To balance congestion, the team can divert fractions of ships (10%, 30%, 50%, or 70%) to the alternative berth—but only if the diverted flow doesn’t exceed the alternative’s capacity. The core question: *What diversion strategy, dynamically adjusted each period, minimizes total delay across all ships while respecting capacity constraints?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - Binary variable `y(t, k)` for each time period `t` (1 to 4) and diversion option `k` (0 to 3, representing 10%, 30%, 50%, 70%).  
     - `y(t, k) = 1` if option `k` is chosen in period `t`, else `0`.  

   - **2. Parameters:**  
     - `arrival_rates[t]`: Ship arrival rate (ships/h) for period `t`.  
     - `capacity_main_normal/reduced`: Main berth capacities (5,696/1,734 ships/h).  
     - `capacity_alt`: Alternative berth capacity (806 ships/h).  
     - `period_option_delays[t][k]`: Pre-calculated total delay (ship-hours) for choosing option `k` in period `t`.  
     - `period_option_feasible[t][k]`: Boolean indicating if option `k` is feasible (diverted flow ≤ `capacity_alt`).  

   - **3. Objective Function:**  
     - Minimize total delay:  
       `Minimize: sum( y(t,k) * period_option_delays[t][k] )` for all feasible `(t,k)`.  

   - **4. Constraints:**  
     - **Feasibility:** For each period `t`, exactly one feasible diversion option must be selected:  
       `sum( y(t,k) for feasible k ) = 1`.  
     - **Infeasible Options:** Force `y(t,k) = 0` if `period_option_feasible[t][k]` is `False`.  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB
import math

# --- Parameters ---
NUM_TIME_PERIODS = 4
TIME_PERIOD_LENGTH = 0.5  # h
capacity_main_normal = 5696  # ships/h
capacity_main_reduced = 1734  # ships/h
capacity_alt = 806  # ships/h
arrival_rates = [3895, 3851, 2517, 4975]  # ships/h
incident_duration = 1.1768649574823644  # h
alt_berth_extra_time = 0.08881702203711435  # h
diversion_options = [0.1, 0.3, 0.5, 0.7]  # Available diversion ratios
num_options = len(diversion_options)
EPSILON = 1e-6
LARGE_DELAY = 1e12

# --- Pre-calculate Delay for Each Option and Time Period ---
period_option_delays = {}
period_option_feasible = {}

for t in range(NUM_TIME_PERIODS):
    period_option_delays[t] = {}
    period_option_feasible[t] = {}

    for k in range(num_options):
        p_k = diversion_options[k]
        flow_alt_k = arrival_rates[t] * p_k
        flow_main_k = arrival_rates[t] * (1 - p_k)

        # 1. Check Alternative Berth Capacity Feasibility
        if flow_alt_k > capacity_alt + EPSILON:
            period_option_feasible[t][k] = False
            period_option_delays[t][k] = LARGE_DELAY
            continue

        period_option_feasible[t][k] = True

        # 2. Calculate Alternative Berth Delay
        delay_alt_k = flow_alt_k * TIME_PERIOD_LENGTH * alt_berth_extra_time

        # 3. Calculate Main Berth Queue Delay
        delay_queue_main_k = 0
        max_queue_main_k = 0

        if flow_main_k > capacity_main_reduced + EPSILON:
            max_queue_main_k = (flow_main_k - capacity_main_reduced) * TIME_PERIOD_LENGTH
            if flow_main_k >= capacity_main_normal - EPSILON:
                delay_queue_main_k = LARGE_DELAY
            else:
                dissipation_rate_k = capacity_main_normal - flow_main_k
                if dissipation_rate_k < EPSILON:
                    delay_queue_main_k = LARGE_DELAY
                else:
                    dissipation_time_main_k = max_queue_main_k / dissipation_rate_k
                    total_influence_time_k = TIME_PERIOD_LENGTH + dissipation_time_main_k
                    delay_queue_main_k = 0.5 * max_queue_main_k * total_influence_time_k

        # 4. Calculate Total Delay for this option
        total_delay_k = delay_alt_k + delay_queue_main_k
        period_option_delays[t][k] = total_delay_k

# --- Gurobi Model ---
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
env.start()
m = gp.Model("Dynamic_DiversionStrategy", env=env)

# --- Decision Variables ---
y = m.addVars(NUM_TIME_PERIODS, num_options, vtype=GRB.BINARY, name="ChooseOption")

# --- Constraints ---
for t in range(NUM_TIME_PERIODS):
    feasible_indices = [k for k in range(num_options) if period_option_feasible[t][k]]
    if not feasible_indices:
        exit()

    m.addConstr(gp.quicksum(y[t,k] for k in feasible_indices) == 1, name="SelectOneFeasibleOption_Period{0}".format(t))

    for k in range(num_options):
        if not period_option_feasible[t][k]:
            m.addConstr(y[t,k] == 0, name="ForbidInfeasibleOption_Period{0}_Option{1}".format(t,k))

# --- Objective Function ---
m.setObjective(
    gp.quicksum(
        y[t,k] * period_option_delays[t][k]
        for t in range(NUM_TIME_PERIODS)
        for k in range(num_options)
        if period_option_feasible[t][k]
    ),
    GRB.MINIMIZE
)

# --- Optimize ---
m.optimize()

# --- Output ---
if m.status == GRB.OPTIMAL:
    print("Optimal Dynamic Diversion Strategy:")
    for t in range(NUM_TIME_PERIODS):
        for k in range(num_options):
            if y[t,k].X > 0.5:
                print("Period {0} ({1:.1f}-{2:.1f}h): Option {3} ({4:.0f}%)".format(
                    t+1, t*TIME_PERIOD_LENGTH, (t+1)*TIME_PERIOD_LENGTH, k, diversion_options[k]*100
                ))
                break
```
Answer:
Optimal Dynamic Diversion Strategy:
Period 1 (0.0-0.5h): Option 0 (10%)
Period 2 (0.5-1.0h): Option 0 (10%)
Period 3 (1.0-1.5h): Option 1 (30%)
Period 4 (1.5-2.0h): Option 0 (10%)



================================================================================



--- Problem 487 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
A maritime logistics company operates a fleet of 5 ships with varying capacities (80, 98, 56, 90, and 100 units) to serve 8 customer locations from a central port (node 0). Each customer has a specific demand (ranging from 10 to 92 units), and the distances between every pair of locations are precisely known, forming a symmetric distance matrix. The challenge is to design routes for the ships such that:  
- Every customer is visited exactly once.  
- Each ship starts and ends at the port.  
- The total demand served by any ship does not exceed its capacity.  
- The combined travel distance across all routes is minimized.  

The operational stakes are high: inefficient routing could lead to wasted fuel, delayed deliveries, and strained resources. The company seeks the most cost-effective way to deploy its fleet while respecting all constraints, ensuring timely service without overloading any ship.  

**Core Question:** What is the optimal set of routes that minimizes total travel distance while meeting all customer demands and ship capacity limits?  

---

**

Modeling Process:**
**
**1. Decision Variables:**  
- Binary variables \(x_{i,j,k}\): Equals 1 if ship \(k\) travels directly from node \(i\) to node \(j\), and 0 otherwise.  
- Continuous variables \(u_i\) (for subtour elimination): Represent the sequence of node \(i\) in a route (Miller-Tucker-Zemlin constraints).  

**2. Parameters:**  
- \(N = 9\): Total nodes (1 port + 8 customers).  
- \(K = 5\): Number of ships.  
- \(Q = [80, 98, 56, 90, 100]\): Ship capacities.  
- \(q = [0, 92, 65, 30, 10, 58, 69, 33, 44]\): Demands at each node (port has 0).  
- \(d_{i,j}\): Distance matrix between nodes \(i\) and \(j\).  

**3. Objective Function:**  
Minimize the total distance traveled by all ships:  
\[
\text{Minimize: } \sum_{k=0}^{K-1} \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} d_{i,j} \cdot x_{i,j,k} \quad (i \neq j)
\]

**4. Constraints:**  
- **Visit each customer once:**  
  \[
  \sum_{k=0}^{K-1} \sum_{j=0}^{N-1} x_{i,j,k} = 1 \quad \forall i \in \{1, \dots, N-1\}, \quad i \neq j
  \]  
- **Flow conservation:**  
  \[
  \sum_{j=0}^{N-1} x_{i,j,k} = \sum_{j=0}^{N-1} x_{j,i,k} \quad \forall i \in \{0, \dots, N-1\}, \quad \forall k \in \{0, \dots, K-1\}, \quad i \neq j
  \]  
- **Port departure/return:**  
  \[
  \sum_{j=1}^{N-1} x_{0,j,k} \leq 1 \quad \text{and} \quad \sum_{j=1}^{N-1} x_{0,j,k} = \sum_{j=1}^{N-1} x_{j,0,k} \quad \forall k
  \]  
- **Capacity limits:**  
  \[
  \sum_{j=1}^{N-1} q_j \cdot \left( \sum_{i=0}^{N-1} x_{i,j,k} \right) \leq Q_k \quad \forall k
  \]  
- **Subtour elimination (MTZ):**  
  \[
  u_i - u_j + (N-1) \cdot x_{i,j,k} \leq N-2 \quad \forall i,j \in \{1, \dots, N-1\}, \quad i \neq j, \quad \forall k
  \]  

---

**

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 9
K = 5
Q = [80, 98, 56, 90, 100]
q = [0, 92, 65, 30, 10, 58, 69, 33, 44]
d = [
    [0, 52, 12, 72, 12, 11, 9, 76, 41],
    [52, 0, 57, 11, 64, 31, 24, 48, 65],
    [12, 57, 0, 40, 11, 73, 60, 53, 75],
    [72, 11, 40, 0, 40, 26, 63, 66, 10],
    [12, 64, 11, 40, 0, 47, 79, 42, 86],
    [11, 31, 73, 26, 47, 0, 45, 64, 99],
    [9, 24, 60, 63, 79, 45, 0, 10, 97],
    [76, 48, 53, 66, 42, 64, 10, 0, 40],
    [41, 65, 75, 10, 86, 99, 97, 40, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Ship Departure/Return from Port (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartPort_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnPort_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for ship {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for ship {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 511.00

Route for ship 1 (Capacity: 80):
0 -> 6 -> 0
Route Load: 69 / 80

Route for ship 2 (Capacity: 98):
0 -> 2 -> 7 -> 0
Route Load: 98 / 98

Route for ship 3 (Capacity: 56):
0 -> 8 -> 4 -> 0
Route Load: 54 / 56

Route for ship 4 (Capacity: 90):
0 -> 5 -> 3 -> 0
Route Load: 88 / 90

Route for ship 5 (Capacity: 100):
0 -> 1 -> 0
Route Load: 92 / 100


```

================================================================================



--- Problem 488 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
**
A logistics company is optimizing its truck loading operations at a central depot to handle peak delivery times efficiently. The management must decide between two loading configurations: a **single-dock** setup (processing 54 trucks per hour at a cost of $20/hour) or a **dual-dock** setup (processing 89 trucks per hour at a cost of $33/hour). During peak hours, trucks arrive at a rate of 64 per hour. If the chosen configuration cannot handle this demand, a penalty of $77/hour is incurred due to customer dissatisfaction and lost sales.  

The challenge is to select the configuration that minimizes total costs—balancing operational expenses against potential penalties for insufficient capacity. The decision hinges on whether the service rate of the chosen dock can meet or exceed the arrival rate.
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - Binary variable `y[c]` for each configuration `c` (where `c` is either "single" or "dual"), indicating whether the configuration is chosen.  
   - Binary variable `z`, which is 1 if the chosen configuration’s capacity is insufficient to meet demand, and 0 otherwise.  

   **2. Parameters:**  
   - `configs`: Dictionary with keys "single" and "dual", each containing:  
     - `rate`: Service rate (trucks/hour).  
     - `cost`: Operational cost ($/hour).  
   - `arrival_rate_peak = 64`: Demand during peak hours (trucks/hour).  
   - `penalty_insufficient_capacity = 77`: Penalty ($/hour) if capacity is insufficient.  
   - `M = 1000`: Large constant for constraint enforcement.  
   - `epsilon = 0.1`: Small constant to ensure strict inequality.  

   **3. Objective Function:**  
   Minimize total cost:  
   ```  
   Minimize: (Operational Cost) + (Penalty if Insufficient Capacity)  
            = sum(y[c] * configs[c]['cost'] for c in configs) + penalty_insufficient_capacity * z  
   ```  

   **4. Constraints:**  
   - **Exactly one configuration must be chosen:**  
     `sum(y[c] for c in configs) == 1`  
   - **Force `z = 1` if demand exceeds capacity:**  
     `arrival_rate_peak - sum(y[c] * configs[c]['rate'] for c in configs) <= M * z`  
   - **Force `z = 0` if capacity meets or exceeds demand:**  
     `sum(y[c] * configs[c]['rate'] for c in configs) - arrival_rate_peak >= epsilon - M * z`  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
configs = {'single': {'rate': 54, 'cost': 20}, 'dual': {'rate': 89, 'cost': 33}}
arrival_rate_peak = 64; penalty_insufficient_capacity = 77
M = 1000; epsilon = 0.1
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    config_keys = list(configs.keys())
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m10 = gp.Model("Truck_Loading_Optimization_IP", env=env)
    # Vars
    y = m10.addVars(config_keys, vtype=GRB.BINARY, name="config_choice")
    z = m10.addVar(vtype=GRB.BINARY, name="is_capacity_insufficient")
    # Intermediate Expressions
    capacity = gp.quicksum(y[c] * configs[c]['rate'] for c in config_keys)
    op_cost = gp.quicksum(y[c] * configs[c]['cost'] for c in config_keys)
    # Objective
    m10.setObjective(op_cost + penalty_insufficient_capacity * z, sense=GRB.MINIMIZE)
    # Constraints
    m10.addConstr(gp.quicksum(y[c] for c in config_keys) == 1, "choose_one_config")
    m10.addConstr(arrival_rate_peak - capacity <= M * z, "force_z_if_insufficient")
    m10.addConstr(capacity - arrival_rate_peak >= epsilon - M * z, "force_z_if_sufficient")
    # Optimize
    m10.optimize()
    # Store results
    results_dict['status'] = m10.status
    if m10.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m10.objVal; results_dict['y_sol'] = m10.getAttr('X', y); results_dict['z_sol'] = z.X
    # Output Results
    print("--- Problem 10: Truck Loading Optimization (IP) ---")
    if m10.status == GRB.OPTIMAL:
        y_sol = results_dict.get('y_sol', {}); z_sol = results_dict.get('z_sol', -1)
        chosen_config = "";
        for c in config_keys:
             if y_sol.get(c, 0) > 0.5: chosen_config = c; break
        if chosen_config:
            final_capacity = configs[chosen_config]['rate']; final_op_cost = configs[chosen_config]['cost']
            final_penalty = penalty_insufficient_capacity * z_sol
            print(f"Optimization Status: Optimal"); print(f"Optimal configuration: {chosen_config.capitalize()}")
            print(f"  Service Rate: {final_capacity} trucks/hr (Arrival: {arrival_rate_peak} trucks/hr)"); print(f"  Operational Cost: ${final_op_cost:.2f}/hr")
            print(f"  Insufficient Capacity Penalty Applied: ${final_penalty:.2f}/hr (z={int(round(z_sol))})"); print(f"Minimum Total Cost: ${m10.objVal:.2f}/hr")
        else: print("Error: Optimal status but no config chosen.")
    else: print(f"Optimization Status: {m10.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of TRUCK_LOADING
```
Answer:
--- Problem 10: Truck Loading Optimization (IP) ---
Optimization Status: Optimal
Optimal configuration: Dual
  Service Rate: 89 trucks/hr (Arrival: 64 trucks/hr)
  Operational Cost: $33.00/hr
  Insufficient Capacity Penalty Applied: $0.00/hr (z=0)
Minimum Total Cost: $33.00/hr



================================================================================



--- Problem 489 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
At a busy maritime port, four ships—labeled 0 through 3—arrive at a facility with two berths (0 and 1). Each ship can only be serviced at specific berths, with service times varying significantly depending on the pairing. For instance, Ship 0 takes 66 minutes at Berth 0 but 108 minutes at Berth 1, while Ship 3 is far more efficient at Berth 1 (64 minutes) compared to Berth 0 (106 minutes). The port manager faces a critical scheduling challenge: assign each ship to exactly one available berth and sequence their service times to minimize the total completion time across all ships. This objective ensures ships are serviced as quickly as possible, reducing idle time and improving overall throughput. The problem is complicated by the need to avoid overlapping assignments on the same berth—no two ships can occupy a berth simultaneously. The core question is: *What is the optimal assignment and sequencing of ships to berths that minimizes the sum of all completion times?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
- `x[i, j]`: Binary variable (1 if Ship *i* is assigned to Berth *j*, 0 otherwise).  
- `s[i]`: Continuous variable representing the start time of Ship *i*.  
- `C[i]`: Continuous variable representing the completion time of Ship *i*.  
- `y[i, k]`: Binary precedence variable (1 if Ship *i* starts before Ship *k* on the same berth, 0 otherwise).  

**2. Parameters:**  
- `ships = [0, 1, 2, 3]`: List of ships.  
- `berths = [0, 1]`: List of berths.  
- `service_times[i][j]`: Service time of Ship *i* at Berth *j* (e.g., Ship 0 at Berth 0 takes 66 units).  
- `M = 1689`: A sufficiently large constant ("Big M") for linearizing constraints.  

**3. Objective Function:**  
Minimize the sum of completion times:  
`Minimize: sum(C[i] for all ships i)`  

**4. Constraints:**  
- **Assignment**: Each ship must be assigned to exactly one available berth:  
  `For each ship i: sum(x[i, j] for all berths j where service_times[i][j] != -1) = 1`.  
- **Unavailable Berths**: Ships cannot be assigned to berths with `service_times[i][j] = -1`:  
  `For each ship i and berth j where service_times[i][j] = -1: x[i, j] = 0`.  
- **Completion Time Definition**: `C[i] = s[i] + sum(service_times[i][j] * x[i, j] for all berths j)`.  
- **Non-Overlapping**: For any two ships *i* and *k* on the same berth *j*, enforce sequencing:  
  - If `y[i, k] = 1` (i precedes k), then `s[k] >= C[i]`.  
  - If `y[k, i] = 1` (k precedes i), then `s[i] >= C[k]`.  
  - Precedence relationship: `y[i, k] + y[k, i] = 1` for all distinct ship pairs (i, k).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
ships = [0, 1, 2, 3]
berths = [0, 1]
# service_times[ship][berth], -1 means unavailable
service_times = [[66, 108], [61, 112], [48, 96], [106, 64]]
M = 1689 # Big M
# --- End Parameters ---

GUROBI_TIME_LIMIT = 120

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0)
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    # env.setParam('MIPFocus', 1) # Optional: Focus on finding feasible solutions quickly
    env.start()

    # --- Model Creation ---
    m = gp.Model("SHIP_BERTH_SCHEDULING", env=env)

    # --- Basic Input Validation ---
    if not ships or not berths:
        raise ValueError("Empty ships or berths list")
    if len(service_times) != len(ships) or any(len(row) != len(berths) for row in service_times):
         raise ValueError("Service times dimensions mismatch ships/berths")

    # --- Decision Variables ---
    # x[i, j] = 1 if ship i assigned to berth j
    x = m.addVars(ships, berths, vtype=GRB.BINARY, name="x")
    # s[i] = start time for ship i
    s = m.addVars(ships, vtype=GRB.CONTINUOUS, lb=0, name="s")
    # C[i] = completion time for ship i
    C = m.addVars(ships, vtype=GRB.CONTINUOUS, lb=0, name="C")
    # y[i, k] = 1 if ship i precedes ship k on the same berth
    # Define y only for i < k to avoid redundancy? No, original used i,k and k,i implicitly. Let's stick to original structure.
    y = m.addVars(ships, ships, vtype=GRB.BINARY, name="y")

    # --- Objective Function: Minimize the sum of completion times ---
    m.setObjective(gp.quicksum(C[i] for i in ships), GRB.MINIMIZE)

    # --- Constraints ---
    # Each ship assigned to exactly one *available* berth
    for i in ships:
        m.addConstr(gp.quicksum(x[i, j] for j in berths if service_times[i][j] != -1) == 1, f"Assignment_{i}")

    # Ensure assignment is 0 if berth is unavailable
    for i in ships:
        for j in berths:
            if service_times[i][j] == -1:
                m.addConstr(x[i, j] == 0, f"Unavailable_{i}_{j}")

    # Completion time definition (C[i] = s[i] + ActualServiceTime[i])
    m.addConstrs((C[i] == s[i] + gp.quicksum(service_times[i][j] * x[i, j]
                                            for j in berths if service_times[i][j] != -1)
                 for i in ships), "CompletionTime")


    # Non-overlapping constraint (Big-M) for pairs on the same berth
    for j in berths:
        for i in ships:
            for k in ships:
                # Original used i < k. Let's refine to avoid redundancy and simplify precedence.
                # New precedence var: y[i,k,j] = 1 if i precedes k on berth j
                # We still need the original y[i,k] to link precedence across all berths.
                # Sticking to original formulation for now. Check logic carefully.
                if i != k: # Consider distinct pairs
                    xi_j = x.get((i, j))
                    xk_j = x.get((k, j))
                    yi_k = y.get((i, k))
                    yk_i = y.get((k, i)) # Need both y[i,k] and y[k,i]

                    if xi_j is not None and xk_j is not None and yi_k is not None and yk_i is not None:
                        # If i before k (y[i,k]=1), then s[k] >= C[i]. Enforced by:
                        m.addConstr(s[k] >= C[i] - M * (1 - yi_k) - M * (2 - xi_j - xk_j), f"NonOverlap1_{i}_{k}_{j}")
                        # If k before i (y[k,i]=1, so yi_k=0), then s[i] >= C[k]. Enforced by:
                        m.addConstr(s[i] >= C[k] - M * yi_k - M * (2 - xi_j - xk_j), f"NonOverlap2_{i}_{k}_{j}")

                        # Ensure y[i,k] + y[k,i] = 1 if they are on the same berth j
                        # This is tricky because y is not berth specific.
                        # Let's use the simpler i < k iteration to avoid redundant constraints
                        if i < k:
                             # Need to ensure EITHER s[k] >= C[i] OR s[i] >= C[k] if x[i,j]=1 and x[k,j]=1
                             # Introduce berth specific precedence? Or rely on the existing y[i,k] logic?
                             # The original constraints might be sufficient IF coupled with y[i,k]+y[k,i]=1 globally?
                             m.addConstr(yi_k + yk_i == 1, f"PrecRel_{i}_{k}") # Assume one must precede the other globally
                             # If this global precedence holds, the non-overlap constraints should work.

    # --- Optimization ---
    m.optimize()

    # --- Store results ---
    results_dict['status'] = m.Status
    if m.Status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.ObjVal
        # results_dict['C_sol'] = m.getAttr('X', C) # Not needed for output

    # --- Output Results ---
    # IMPORTANT: Output only the objective value line for optimal, as per example
    if m.Status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"Optimal objective value: {obj_val_print:.2f}")
        else:
             print(f"Optimal objective value: {obj_val_print}")

    # Match the non-optimal status messages from the original snippet
    elif m.Status == GRB.INFEASIBLE:
        print("Model is infeasible") # Matches example
    elif m.Status == GRB.TIME_LIMIT:
         print(f"Optimization ended with status {m.Status}") # Matches example's generic else
    else: # Other statuses
        print(f"Optimization ended with status {m.Status}") # Matches example's generic else


except ValueError as ve: # Catch specific input validation error
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3 # Custom code for data error
except GurobiError as e:
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -2



# Supplemental code block to print the assignment and sequencing of ships to berths
if m.Status == GRB.OPTIMAL:
    for i in ships:
        for j in berths:
            if x[i, j].X > 0.5:
                print(f"Ship {i} is assigned to Berth {j} with start time: {s[i].X:.2f} and completion time: {C[i].X:.2f}")
```
Answer:
Optimal objective value: 393.00
Ship 0 is assigned to Berth 1 with start time: 64.00 and completion time: 172.00
Ship 1 is assigned to Berth 0 with start time: 48.00 and completion time: 109.00
Ship 2 is assigned to Berth 0 with start time: 0.00 and completion time: 48.00
Ship 3 is assigned to Berth 1 with start time: 0.00 and completion time: 64.00


```

================================================================================



--- Problem 490 ---
**Difficulty:** very hard
**Category:** MIP

**Problem Description:**
**
In a busy logistics hub, six trucks arrive at varying times, each requiring a depot for unloading or loading operations. The hub has only two depots available, creating a complex scheduling challenge. Trucks 1 through 6 arrive at hours 5, 7, 9, 12, 15, and 19, respectively, and their processing times range from 3 to 7 hours. The hub management faces a critical trade-off: minimizing the total waiting cost for trucks, which is calculated in two tiers. For the first hour of waiting, the cost is \$47 per hour, but any additional waiting time beyond that incurs a steeper cost of \$112 per hour. The goal is to assign each truck to a depot and schedule their start times such that no two trucks occupy the same depot simultaneously, while ensuring trucks cannot start before their arrival. The central question is: **What is the optimal depot assignment and scheduling sequence that minimizes the total waiting cost, given the tiered cost structure?**
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable indicating whether truck `i` is assigned to depot `j`.  
   - `start_time(i)`: Continuous variable representing the start time of truck `i`.  
   - `completion_time(i)`: Continuous variable representing the completion time of truck `i`.  
   - `precedes(i, k, j)`: Binary variable indicating whether truck `i` precedes truck `k` on depot `j`.  
   - `wait_part1(i)`: Continuous variable representing the waiting time of truck `i` up to the threshold (1 hour).  
   - `wait_part2(i)`: Continuous variable representing the waiting time of truck `i` beyond the threshold.  

   **2. Parameters:**  
   - `arrival_times[i]`: Arrival time of truck `i` (e.g., truck 1 arrives at hour 5).  
   - `processing_times[i]`: Processing time of truck `i` (e.g., truck 1 takes 7 hours).  
   - `wait_cost_rate1`: \$47/hour for the first hour of waiting.  
   - `wait_cost_rate2`: \$112/hour for waiting beyond the first hour.  
   - `wait_threshold`: 1 hour (the threshold for tiered waiting costs).  
   - `H`: A large constant (100) used for logical constraints.  

   **3. Objective Function:**  
   Minimize the total waiting cost:  
   \[
   \text{Minimize: } \sum_{i \in \text{trucks}} (47 \cdot \text{wait\_part1}(i) + 112 \cdot \text{wait\_part2}(i))
   \]  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot.  
     \[
     \sum_{j \in \text{depots}} \text{assign}(i, j) = 1 \quad \forall i \in \text{trucks}
     \]  
   - **Arrival Time:** Trucks cannot start before their arrival time.  
     \[
     \text{start\_time}(i) \geq \text{arrival\_times}[i] \quad \forall i \in \text{trucks}
     \]  
   - **Completion Time:** Completion time is the start time plus processing time.  
     \[
     \text{completion\_time}(i) = \text{start\_time}(i) + \text{processing\_times}[i] \quad \forall i \in \text{trucks}
     \]  
   - **Non-Overlapping:** Trucks assigned to the same depot must not overlap.  
     \[
     \text{If } \text{precedes}(i, k, j) = 1, \text{ then } \text{start\_time}(k) \geq \text{completion\_time}(i) \quad \forall i < k, j \in \text{depots}
     \]  
     \[
     \text{If } \text{precedes}(i, k, j) = 0, \text{ then } \text{start\_time}(i) \geq \text{completion\_time}(k) \quad \forall i < k, j \in \text{depots}
     \]  
   - **Waiting Time Decomposition:** Total waiting time is split into tiered parts.  
     \[
     \text{start\_time}(i) - \text{arrival\_times}[i] = \text{wait\_part1}(i) + \text{wait\_part2}(i) \quad \forall i \in \text{trucks}
     \]  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6]
depots = [1, 2]
arrival_times = {1: 5, 2: 7, 3: 9, 4: 12, 5: 15, 6: 19}
processing_times = {1: 7, 2: 6, 3: 6, 4: 3, 5: 5, 6: 3}
wait_cost_rate1 = 47
wait_cost_rate2 = 112
wait_threshold = 1
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_56_PIECEWISE_COST")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    wait_part1 = m.addVars(trucks, lb=0.0, ub=wait_threshold, vtype=GRB.CONTINUOUS, name="WaitPart1")
    wait_part2 = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="WaitPart2")

    # --- Objective Function ---
    total_wait_cost = gp.quicksum(wait_cost_rate1 * wait_part1[i] + wait_cost_rate2 * wait_part2[i] for i in trucks)
    m.setObjective(total_wait_cost, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Link waiting time parts
    m.addConstrs((start_time[i] - arrival_times.get(i, 0) == wait_part1[i] + wait_part2[i] for i in trucks), name="wait_decomposition")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}") # Cost
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    print("Optimal Depot Assignments and Schedules:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} assigned to Depot {j}")
                print(f"  Start Time: {start_time[i].x:.2f}")
                print(f"  Completion Time: {completion_time[i].x:.2f}")
                print(f"  Waiting Time (Part 1): {wait_part1[i].x:.2f}")
                print(f"  Waiting Time (Part 2): {wait_part2[i].x:.2f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
3949.0000
Optimal Depot Assignments and Schedules:
Truck 1 assigned to Depot 2
  Start Time: 5.00
  Completion Time: 12.00
  Waiting Time (Part 1): 0.00
  Waiting Time (Part 2): 0.00
Truck 2 assigned to Depot 2
  Start Time: 23.00
  Completion Time: 29.00
  Waiting Time (Part 1): 1.00
  Waiting Time (Part 2): 15.00
Truck 3 assigned to Depot 2
  Start Time: 29.00
  Completion Time: 35.00
  Waiting Time (Part 1): 1.00
  Waiting Time (Part 2): 19.00
Truck 4 assigned to Depot 2
  Start Time: 12.00
  Completion Time: 15.00
  Waiting Time (Part 1): 0.00
  Waiting Time (Part 2): 0.00
Truck 5 assigned to Depot 2
  Start Time: 15.00
  Completion Time: 20.00
  Waiting Time (Part 1): 0.00
  Waiting Time (Part 2): 0.00
Truck 6 assigned to Depot 2
  Start Time: 20.00
  Completion Time: 23.00
  Waiting Time (Part 1): 1.00
  Waiting Time (Part 2): 0.00


```

================================================================================



--- Problem 491 ---
**Difficulty:** medium
**Category:** LP

**Problem Description:**
**
A regional logistics company operates a central hub that coordinates shipments between five production facilities (Src_A to Src_E) and four distribution centers (Dst_X to Dst_[). Each source has a fixed supply capacity, ranging from 154 to 497 units, while each destination has specific demand requirements, totaling 1,245 units across all locations. The hub acts as an intermediary, where goods are consolidated before being dispatched. Transportation costs vary significantly depending on the route: moving goods from Src_C to the hub is the cheapest ($1/unit), while Src_D incurs the highest cost ($15/unit). Similarly, delivering from the hub to Dst_Z costs $5/unit, whereas Dst_Y demands $13/unit.  

The company faces a critical challenge: How should they route shipments through the hub to meet all demand while minimizing total transportation costs? The solution must balance supply limits (e.g., Src_E can provide up to 422 units but may not need to exhaust its capacity) and ensure strict demand fulfillment (e.g., Dst_X requires exactly 367 units). Additionally, the hub must maintain perfect flow equilibrium—every unit arriving must depart—to avoid inefficiencies. Furthermore, due to recent weather conditions, the company must also consider a 10% increase in the transportation cost for all routes.
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `flow[(i, j)]`: Continuous non-negative variable representing the number of units transported from location `i` to `j`, where `i` is either a source or the hub, and `j` is either the hub or a destination.  
   - **2. Parameters:**  
     - `supply[s]`: Maximum units available at source `s` (e.g., `supply['Src_A'] = 154`).  
     - `demand[d]`: Units required at destination `d` (e.g., `demand['Dst_X'] = 367`).  
     - `costs[(i, j)]`: Cost per unit shipped (e.g., `costs[('Src_A', 'Hub')] = 8.8`).  
   - **3. Objective Function:**  
     - Minimize total cost:  
       `Minimize: sum(flow[(i, j)] * costs[(i, j)] for all (i, j) in routes)`.  
   - **4. Constraints:**  
     - **Supply limits:** For each source `s`, `flow[(s, hub)] <= supply[s]`.  
     - **Demand fulfillment:** For each destination `d`, `flow[(hub, d)] >= demand[d]`.  
     - **Hub balance:** Total inflow to hub (`sum(flow[(s, hub)] for all s)`) equals total outflow (`sum(flow[(hub, d)] for all d)`).  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
sources = ['Src_A', 'Src_B', 'Src_C', 'Src_D', 'Src_E']
destinations = ['Dst_X', 'Dst_Y', 'Dst_Z', 'Dst_[']
hub = 'Hub' # Use !r for repr() to keep quotes for the string
supply = {'Src_A': 154, 'Src_B': 487, 'Src_C': 497, 'Src_D': 344, 'Src_E': 422}
demand = {'Dst_X': 367, 'Dst_Y': 325, 'Dst_Z': 380, 'Dst_[': 173}
costs = {('Src_A', 'Hub'): 8.8, ('Src_B', 'Hub'): 12.1, ('Src_C', 'Hub'): 1.1, ('Src_D', 'Hub'): 16.5, ('Src_E', 'Hub'): 13.2, ('Hub', 'Dst_X'): 7.7, ('Hub', 'Dst_Y'): 14.3, ('Hub', 'Dst_Z'): 5.5, ('Hub', 'Dst_['): 9.9}
# --- End Parameters ---

GUROBI_TIME_LIMIT = 60

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi console output within exec
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m25 = gp.Model("Logistics_Hub_Flow_LP", env=env)

    # --- Decision Variables ---
    # Flow variables for each arc
    flow_keys = list(costs.keys()) # Explicitly get keys for var creation
    flow = m25.addVars(flow_keys, name="flow", lb=0) # LP variables default to continuous

    # --- Objective Function ---
    # Minimize total transportation cost
    m25.setObjective(gp.quicksum(flow[i, j] * costs[i, j] for i, j in flow_keys), sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Supply constraints at sources
    for s in sources:
        # Ensure the key exists before adding constraint
        arc_key = (s, hub)
        if arc_key in flow:
            # Use string concatenation for name to avoid f-string formatting issues here
            m25.addConstr(flow[arc_key] <= supply[s], name="supply_" + s)
        # No else needed, if arc doesn't exist, can't use it

    # Demand constraints at destinations
    for d in destinations:
         # Ensure the key exists before adding constraint
         arc_key = (hub, d)
         if arc_key in flow:
            # Use string concatenation for name
            m25.addConstr(flow[arc_key] >= demand[d], name="demand_" + d)
         # No else needed

    # Flow balance at the Hub (Inflow = Outflow)
    # Check if keys exist before summing
    inflow_keys_hub = [k for k in flow_keys if k[1] == hub and k[0] in sources]
    outflow_keys_hub = [k for k in flow_keys if k[0] == hub and k[1] in destinations]

    # Check if lists are non-empty before creating expressions that might be empty
    inflow_hub_expr = gp.quicksum(flow[k] for k in inflow_keys_hub) if inflow_keys_hub else 0
    outflow_hub_expr = gp.quicksum(flow[k] for k in outflow_keys_hub) if outflow_keys_hub else 0
    m25.addConstr(inflow_hub_expr == outflow_hub_expr, name="hub_balance")

    # --- Optimization ---
    m25.optimize()

    # --- Store results ---
    results_dict['status'] = m25.status
    if m25.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m25.objVal
        # Store flow values, converting keys back to tuples if needed
        results_dict['flow_sol'] = {k: v for k, v in m25.getAttr('X', flow).items()}
        # Store expression values IF they are LinExpr (might be 0 if no flows)
        results_dict['inflow_val'] = inflow_hub_expr.getValue() if isinstance(inflow_hub_expr, gp.LinExpr) else inflow_hub_expr
        results_dict['outflow_val'] = outflow_hub_expr.getValue() if isinstance(outflow_hub_expr, gp.LinExpr) else outflow_hub_expr


    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print("--- Problem 25: Logistics Hub Truck Flow (LP) ---")
    if m25.status == GRB.OPTIMAL:
        flow_sol = results_dict.get('flow_sol', {}) # Get solution from dict
        print(f"Optimization Status: Optimal")
        # Use .get with a default for obj_val before formatting
        obj_val_print = results_dict.get('obj_val', 0) # Default to 0 if not found
        print(f"Minimum Total Transportation Cost: ${obj_val_print:.2f}")
        print("Optimal Flows:")
        total_supply_used_calc = 0
        total_demand_met_calc = 0
        # Use .items() for iterating through solution dictionary
        for (i, j), flow_val in flow_sol.items():
            if flow_val > 1e-6: # Print only non-negligible flows
                # Escape i, j, flow_val and braces for costs.get()
                print(f"  Flow from {i} to {j}: {flow_val:.1f} units (Cost/Unit: ${costs.get((i,j), 'N/A')})")
                if i in sources: total_supply_used_calc += flow_val
                if j in destinations: total_demand_met_calc += flow_val

        print("\nSummary:")
        # Use .get with defaults for calculated values before formatting
        inflow_print = results_dict.get('inflow_val', 0)
        outflow_print = results_dict.get('outflow_val', 0)
        # Ensure inflow/outflow values are numbers before formatting
        print(f"Total Flow In Hub: {float(inflow_print):.1f}")
        print(f"Total Flow Out Hub: {float(outflow_print):.1f}")
        # Re-calculate supply/demand usage from solution dict for detailed output
        for s in sources:
             flow_out = flow_sol.get((s, hub), 0)
             # Escape s, flow_out and braces for supply.get()
             print(f"  Supply from {s}: {flow_out:.1f} / {supply.get(s, 'N/A')}")
        for d in destinations:
             flow_in = flow_sol.get((hub, d), 0)
             # Escape d, flow_in and braces for demand.get()
             print(f"  Demand met for {d}: {flow_in:.1f} / {demand.get(d, 'N/A')}")

    elif m25.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible. Check if total supply >= total demand.")
         # Calculate totals directly from input params for this message
         # Escape braces for sum() values
         print(f"Total Supply Available: {sum(supply.values())}")
         print(f"Total Demand Required: {sum(demand.values())}")
    elif m25.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)") # Escape limit
         # If objective value exists (feasible solution found before limit), print it
         if m25.ObjVal is not None and abs(m25.ObjVal) < float('inf'):
              # Escape objval
              print(f"Best Objective Found: ${m25.ObjVal:.2f}")
         else:
              print("No feasible solution found within time limit.")
    else:
        # Handle other statuses like UNBOUNDED, INF_OR_UNBD etc.
        print(f"Optimization Status Code: {m25.status}") # Escape status

except GurobiError as e:
    # Escape errno and e message
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
except Exception as e:
    print(f"Python Error: {e}") # Escape error message
    print("--- Traceback ---")
    traceback.print_exc(file=sys.stdout)
    print("--- End Traceback ---")
    results_dict['status'] = -2 # Indicate Python execution error



# The code provided already prints all the necessary outputs, so no additional print statements are needed.
```
Answer:
--- Problem 25: Logistics Hub Truck Flow (LP) ---
Optimization Status: Optimal
Minimum Total Transportation Cost: $20483.10
Optimal Flows:
  Flow from Src_A to Hub: 154.0 units (Cost/Unit: $8.8)
  Flow from Src_B to Hub: 487.0 units (Cost/Unit: $12.1)
  Flow from Src_C to Hub: 497.0 units (Cost/Unit: $1.1)
  Flow from Src_E to Hub: 107.0 units (Cost/Unit: $13.2)
  Flow from Hub to Dst_X: 367.0 units (Cost/Unit: $7.7)
  Flow from Hub to Dst_Y: 325.0 units (Cost/Unit: $14.3)
  Flow from Hub to Dst_Z: 380.0 units (Cost/Unit: $5.5)
  Flow from Hub to Dst_[: 173.0 units (Cost/Unit: $9.9)

Summary:
Total Flow In Hub: 1245.0
Total Flow Out Hub: 1245.0
  Supply from Src_A: 154.0 / 154
  Supply from Src_B: 487.0 / 487
  Supply from Src_C: 497.0 / 497
  Supply from Src_D: 0.0 / 344
  Supply from Src_E: 107.0 / 422
  Demand met for Dst_X: 367.0 / 367
  Demand met for Dst_Y: 325.0 / 325
  Demand met for Dst_Z: 380.0 / 380
  Demand met for Dst_[: 173.0 / 173


```

================================================================================



--- Problem 492 ---
**Difficulty:** medium
**Category:** IP

**Problem Description:**
A busy port terminal is tasked with maximizing revenue while efficiently using limited space and adhering to strict operational constraints. The terminal has a finite capacity measured in Container Equivalent Units (CEUs), where each 20-foot container occupies 1 CEU and each 40-foot container consumes 2 CEUs. With a maximum capacity of 88 CEUs and a hard limit of 79 total containers (20-foot and 40-foot combined), the loading team must strategically decide how many of each container type to load.

Currently, 98 20-foot containers and 25 40-foot containers are waiting to be loaded. Each 20-foot container contributes $77 to profit, while 40-foot containers—despite their larger footprint—yield a significantly higher $398 per container. The terminal manager must

**Modeling Process:**
- **1. Decision Variables:**  
     - `x_20ft`: Integer number of 20-foot containers loaded (≥ 0).  
     - `x_40ft`: Integer number of 40-foot containers loaded (≥ 0).  
   - **2. Parameters:**  
     - `ceu_capacity = 88` (total CEU capacity).  
     - `ceu_per_20ft = 1`, `ceu_per_40ft = 2` (CEU consumption per container).  
     - `max_containers = 79` (total container limit).  
     - `profit_per_20ft = 77`, `profit_per_40ft = 398` (profit per container).  
     - `waiting_20ft = 98`, `waiting_40ft = 25` (queue limits).  
   - **3. Objective Function:**  
     Maximize total profit:  
     `Maximize: 77 * x_20ft + 398 * x_40ft`.  
   - **4. Constraints:**  
     - CEU limit: `1 * x_20ft + 2 * x_40ft ≤ 88`.  
     - Container limit: `x_20ft + x_40ft ≤ 79`.  
     - Queue limits: `x_20ft ≤ 98`, `x_40ft ≤ 25`.  
     - Non-negativity: `x_20ft, x_40ft ≥ 0` (integer).  

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math
# Params
ceu_capacity = 88; ceu_per_20ft = 1; ceu_per_40ft = 2
max_containers = 79; profit_per_20ft = 77; profit_per_40ft = 398
waiting_20ft = 98; waiting_40ft = 25
# End Params
GUROBI_TIME_LIMIT = 60
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None
# Model
try:
    env = gp.Env(empty=True); env.setParam('OutputFlag', 0); env.setParam('TimeLimit', GUROBI_TIME_LIMIT); env.start()
    m7 = gp.Model("Port_Loading_IP", env=env)
    # Vars
    x_20ft = m7.addVar(vtype=GRB.INTEGER, name="num_20ft_loaded", lb=0)
    x_40ft = m7.addVar(vtype=GRB.INTEGER, name="num_40ft_loaded", lb=0)
    # Objective
    m7.setObjective(profit_per_20ft * x_20ft + profit_per_40ft * x_40ft, sense=GRB.MAXIMIZE)
    # Constraints
    m7.addConstr(ceu_per_20ft * x_20ft + ceu_per_40ft * x_40ft <= ceu_capacity, "ceu_capacity")
    m7.addConstr(x_20ft + x_40ft <= max_containers, "total_container_limit")
    m7.addConstr(x_20ft <= waiting_20ft, "20ft_availability")
    m7.addConstr(x_40ft <= waiting_40ft, "40ft_availability")
    # Optimize
    m7.optimize()
    # Store results
    results_dict['status'] = m7.status
    if m7.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m7.objVal; results_dict['x_20ft_opt'] = x_20ft.X; results_dict['x_40ft_opt'] = x_40ft.X
    # Output Results
    print("--- Problem 7: Port Loading (40ft vs. 20ft) (IP) ---")
    if m7.status == GRB.OPTIMAL:
        x20 = results_dict.get('x_20ft_opt', 0); x40 = results_dict.get('x_40ft_opt', 0)
        print(f"Optimization Status: Optimal"); print(f"Optimal number of 20-foot containers to load: {int(round(x20))}")
        print(f"Optimal number of 40-foot containers to load: {int(round(x40))}"); print(f"Total CEU used: {ceu_per_20ft * x20 + ceu_per_40ft * x40:.1f} / {ceu_capacity}")
        print(f"Total containers loaded: {int(round(x20 + x40))} / {max_containers}"); print(f"Maximum total profit: ${m7.objVal:.2f}")
    else: print(f"Optimization Status: {m7.status}")
except GurobiError as e: print(f"Gurobi Error {e.errno}: {e}"); results_dict['status']=-1
except Exception as e: print(f"Python Error: {e}"); traceback.print_exc(file=sys.stdout); results_dict['status']=-2
# End of PORT_LOADING
```
Answer:
--- Problem 7: Port Loading (40ft vs. 20ft) (IP) ---
Optimization Status: Optimal
Optimal number of 20-foot containers to load: 38
Optimal number of 40-foot containers to load: 25
Total CEU used: 88.0 / 88
Total containers loaded: 63 / 79
Maximum total profit: $12876.00



================================================================================



--- Problem 493 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy trucking terminal needs to efficiently schedule incoming trucks to minimize the total time required to service all vehicles. Five trucks, labeled 1 through 5, arrive at staggered times: Truck 1 at time 1, Truck 2 at time 2, Truck 3 at time 5, Truck 4 at time 9, and Truck 5 at time 11. Each truck requires a specific processing duration: 5 units for Trucks 1 and 2, 4 for Truck 3, 8 for Truck 4, and 3 for Truck 5. The terminal has three depots available, but only one truck can occupy a depot at any given time. The critical question is: *How can the terminal assign trucks to depots and schedule their start times to ensure all trucks are serviced as quickly as possible, minimizing the total completion time (makespan)?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to depot *j*, else 0).  
     - `start_time(i)`: Continuous variable for the start time of truck *i*.  
     - `completion_time(i)`: Continuous variable for the completion time of truck *i* (start time + processing time).  
     - `precedes(i, k, j)`: Binary variable (1 if truck *i* precedes truck *k* on depot *j*, else 0).  
     - `makespan`: Continuous variable representing the latest completion time across all trucks.  

   - **2. Parameters:**  
     - `arrival_times(i)`: Arrival time of truck *i* (e.g., Truck 1 arrives at time 1).  
     - `processing_times(i)`: Processing duration of truck *i* (e.g., Truck 1 requires 5 units).  
     - `H = 100`: A large constant ("Big M") for linearization.  

   - **3. Objective Function:**  
     - Minimize `makespan` (the latest completion time).  

   - **4. Constraints:**  
     - Each truck is assigned to exactly one depot: `sum(assign(i, j) for j in depots) = 1` for all *i*.  
     - Start time cannot precede arrival time: `start_time(i) >= arrival_times(i)` for all *i*.  
     - Completion time definition: `completion_time(i) = start_time(i) + processing_times(i)` for all *i*.  
     - Non-overlapping on depots: If `precedes(i, k, j) = 1`, then `start_time(k) >= completion_time(i)` for all *i < k* and *j*.  
     - Makespan definition: `makespan >= completion_time(i)` for all *i*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5]
depots = [1, 2, 3]
arrival_times = {1: 1, 2: 2, 3: 5, 4: 9, 5: 11}
processing_times = {1: 5, 2: 5, 3: 4, 4: 8, 5: 3}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_PROBLEM_51_MIN_MAKESPAN")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    makespan = m.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Makespan") # Cmax

    # --- Objective Function ---
    m.setObjective(makespan, GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Makespan definition
    m.addConstrs((makespan >= completion_time[i] for i in trucks), name="makespan_def")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# Supplemental code block to print additional outputs
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
                print(f"Start Time: {start_time[i].x:.4f}, Completion Time: {completion_time[i].x:.4f}")
    print(f"Total Makespan: {makespan.x:.4f}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
26.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 1
Start Time: 1.0000, Completion Time: 6.0000
Truck 2 is assigned to Depot 1
Start Time: 6.0000, Completion Time: 11.0000
Truck 3 is assigned to Depot 1
Start Time: 11.0000, Completion Time: 15.0000
Truck 4 is assigned to Depot 1
Start Time: 15.0000, Completion Time: 23.0000
Truck 5 is assigned to Depot 1
Start Time: 23.0000, Completion Time: 26.0000
Total Makespan: 26.0000


```

================================================================================



--- Problem 494 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with efficiently packing a shipment of 15 items with varying weights into the fewest possible trucks, each with a maximum capacity of 60 units. The items weigh 35, 42, 14, 3, 39, 19, 10, 23, 35, 54, 17, 10, 34, 7, and 16 units respectively. The challenge lies in strategically grouping these items to minimize the number of trucks used while ensuring no truck exceeds its capacity. This problem mirrors real-world scenarios in transportation, where optimizing space utilization directly reduces costs and improves operational efficiency. The key question is: *What is the most efficient way to pack these items to minimize the total number of trucks required?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `x[i, j]`: Binary variable indicating whether item `i` is assigned to truck `j` (1 if assigned, 0 otherwise).  
     - `y[j]`: Binary variable indicating whether truck `j` is used (1 if used, 0 otherwise).  
   - **2. Parameters:**  
     - `items[i]`: Weight of item `i` (given as a list of 15 values).  
     - `capacity`: Maximum weight per truck (60 units).  
     - `num_items`: Total number of items (15).  
     - `num_trucks`: Maximum possible trucks (15, one per item in the worst case).  
   - **3. Objective Function:**  
     - Minimize the total number of trucks used: `Minimize: sum(y[j] for all j)`.  
   - **4. Constraints:**  
     - **Item Assignment:** Each item must be assigned to exactly one truck:  
       `For each item i: sum(x[i, j] for all j) = 1`.  
     - **Truck Capacity:** The total weight in any used truck `j` must not exceed its capacity:  
       `For each truck j: sum(items[i] * x[i, j] for all i) <= capacity * y[j]`.  

3.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB

# --- Data Definition ---
items = [35, 42, 14, 3, 39, 19, 10, 23, 35, 54, 17, 10, 34, 7, 16]      # Weights of items
capacity = 60           # Truck capacity
num_items = 15          # len(items)
num_trucks = num_items  # Maximum number of trucks (worst case: one item per truck)
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed

results_dict['status'] = None # Default status

# Suppress Gurobi console output
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Time limit
# env.setParam('TimeLimit', 30)
env.start()

# Create Model
model = Model("Truck Packing Problem", env=env)

# --- Decision Variables ---
# x[i,j]: item i is assigned to truck j
x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")
# y[j]: truck j is used
y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")

# --- Objective: Minimize the number of trucks used ---
model.setObjective(y.sum('*'), GRB.MINIMIZE)

# --- Constraints ---
# 1. Each item must be assigned to exactly one truck
for i in range(num_items):
    model.addConstr(x.sum(i, '*') == 1, name=f"Item_{i}_Assignment")

# 2. Truck capacity constraint: sum of weights in truck j <= capacity IF truck j is used (y[j]=1)
for j in range(num_trucks):
    model.addConstr(gp.quicksum(items[i] * x[i, j] for i in range(num_items)) <= capacity * y[j], name=f"Truck_{j}_Capacity")

# --- Solve ---
print("Solving Truck Packing instance...")
try:
    model.optimize()
    # Store results
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results ---
if results_dict.get('status') == GRB.OPTIMAL:
    optimal_trucks = int(results_dict.get('obj_val', -1))
    print(f"\nOptimal number of trucks used: {optimal_trucks}")
    print("-" * 30)
    truck_details = []
    for j_sol in range(num_trucks): # Loop through potential trucks
        # Check if the truck variable y[j_sol] exists and is set to 1
        # Using .X requires Gurobi v9+ and that the variable is in the solution
        try:
            if y[j_sol].X > 0.5: # Check if truck j_sol is used
                # Find items assigned to this truck j_sol
                assigned_items_indices = [i for i in range(num_items) if x[i, j_sol].X > 0.5]
                assigned_items_weights = [items[i] for i in assigned_items_indices]
                truck_load = sum(assigned_items_weights)
                print(f"Truck {j_sol + 1} (Load: {truck_load}/{capacity}): Items (indices): {assigned_items_indices}")
                # Optional: Print weights too
                # print(f"  Weights: {assigned_items_weights}")
                truck_details.append({'truck_index': j_sol, 'item_indices': assigned_items_indices, 'load': truck_load})
        except AttributeError:
            # This might happen if y[j_sol] was optimized to 0 and doesn't have an .X value
            # Or if the model was infeasible/not solved optimally.
            # Since we check for OPTIMAL status first, this is less likely for y,
            # but could happen if x[i, j_sol] is 0. The check x[i,j_sol].X > 0.5 handles this.
            pass # Just skip if variable/attribute doesn't exist for unused trucks/items
    results_dict['truck_details'] = truck_details # Store details
    print("-" * 30)

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.INF_OR_UNBD:
     print("\nModel is infeasible or unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit.")
     # Check SolCount to see if a feasible solution was found
     if model.SolCount > 0: print(f"Best objective found: {model.ObjVal}")
     else: print("No feasible solution found within time limit.")
elif results_dict.get('status') is not None:
    print(f"\nOptimization finished with status: {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving Truck Packing instance...

Optimal number of trucks used: 7
------------------------------
Truck 1 (Load: 35/60): Items (indices): [8]
Truck 2 (Load: 59/60): Items (indices): [1, 2, 3]
Truck 3 (Load: 60/60): Items (indices): [6, 12, 14]
Truck 4 (Load: 54/60): Items (indices): [0, 5]
Truck 12 (Load: 57/60): Items (indices): [7, 10, 11, 13]
Truck 14 (Load: 39/60): Items (indices): [4]
Truck 15 (Load: 54/60): Items (indices): [9]
------------------------------


```

================================================================================



--- Problem 495 ---
**Difficulty:** medium
**Category:** NLP

**Problem Description:**
**
A port authority is tasked with scheduling ship berthing for a critical maintenance project that must be completed within approximately 2.88 days. The project requires a total of 19.36 work hours, distributed across three distinct time periods each day: Morning, Afternoon, and Night. Each period has a specific duration—Morning lasts 5.42 hours, Afternoon 6.07 hours, and Night 11.02 hours—and experiences varying ship traffic demands. During Morning hours, the traffic surges to 5,793.7 ships per hour, while Afternoon and Night see 3,627.9 and 1,548.1 ships per hour, respectively.

The challenge lies in minimizing ship traffic disruption. When berths are closed for work, capacity drops to 3,427.3 ships per hour, causing delays if demand exceeds this reduced capacity. Notably, Morning and Afternoon periods face potential delays of 2,366.4 and 200.6 ships per hour during work, while Night operations avoid delays entirely. The team must strategically allocate work hours across these periods to meet the daily requirement of 6.71 hours while minimizing the cumulative delay over the project’s duration.

**Core Question:** How should work hours be distributed across Morning, Afternoon, and Night periods to minimize total ship traffic delays while completing the project on time?
**

**Modeling Process:**
**
**1. Decision Variables:**
- `WorkHours_p`: Hours spent working in each period `p` (Morning, Afternoon, Night) per day. Continuous and non-negative.

**2. Parameters:**
- `T_project_days = 2.88`: Total project duration (days).
- `WorkHoursPerDay = 6.71`: Required work hours per day.
- `Duration_p`: Duration of each period (Morning: 5.42h, Afternoon: 6.07h, Night: 11.02h).
- `DelayRate_p_work`: Delay rates during work (Morning: 2,366.4 ships/h, Afternoon: 200.6 ships/h, Night: 0 ships/h).
- `DelayRate_p_nowork`: Delay rates without work (all 0 ships/h).

**3. Objective Function:**
Minimize the total delay proxy over the project:
```
Minimize: T_project_days * sum( (DelayRate_p_work[p] * WorkHours_p[p]) + (DelayRate_p_nowork[p] * (Duration_p[p] - WorkHours_p[p])) for all p )
```  

**4. Constraints:**
- **Daily Work Hours:** Total work hours per day must equal 6.71:
  `sum(WorkHours_p[p] for all p) = WorkHoursPerDay`.
- **Period Duration Limits:** Work hours in each period cannot exceed its duration:
  `WorkHours_p[p] <= Duration_p[p]` for all `p`.
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import GRB

# --- Parameters ---
T_project_days = 2.8846487504395353
TotalWorkHoursNeeded = 19.35773602924041
periods = ['Morning', 'Afternoon', 'Night']

# Duration per period per day (hours)
Duration_p = {'Morning': 5.424346854019509, 'Afternoon': 6.067327360078881, 'Night': 11.016836862882794}
# Hourly demand per period (ships/h)
Lambda_p = {'Morning': 5793.701809085762, 'Afternoon': 3627.9404531466107, 'Night': 1548.0813704194995}
# Capacities (ships/h)
C_normal = 7695.139764505839
C_work = 3427.3131166337225  # 2 berths closed

# Calculate required work hours per day (assuming uniform distribution)
WorkHoursPerDay = TotalWorkHoursNeeded / T_project_days

# --- Calculate Delay Rates (simplified: ships queued per hour if demand > capacity) ---
DelayRate_p_work = {}
DelayRate_p_nowork = {}
print("--- Delay Rate Calculation (Ships Queued per Hour) ---")
for p in periods:
    # Delay rate if working (capacity = C_work)
    rate_work = max(0, Lambda_p[p] - C_work)
    DelayRate_p_work[p] = rate_work
    # Delay rate if not working (capacity = C_normal)
    rate_nowork = max(0, Lambda_p[p] - C_normal)
    DelayRate_p_nowork[p] = rate_nowork
    print(f" Period {p}: Work Delay Rate = {rate_work:.1f} ships/h, No Work Delay Rate = {rate_nowork:.1f} ships/h")

# --- Gurobi Model ---
model = gp.Model("BerthTimeOfDayScheduling")

# --- Decision Variables ---
# WorkHours_p: Hours spent working within period p each day
WorkHours_p = model.addVars(periods, name="WorkHours", lb=0.0)

# --- Constraints ---
# 1. Total work hours per day must match the requirement
model.addConstr(gp.quicksum(WorkHours_p[p] for p in periods) == WorkHoursPerDay,
                name="DailyWorkHours")

# 2. Work hours in a period cannot exceed the duration of that period
for p in periods:
    model.addConstr(WorkHours_p[p] <= Duration_p[p], name=f"DurationLimit_{p}")

# --- Objective Function ---
# Minimize total delay over the project duration.
daily_delay_expr = gp.quicksum(DelayRate_p_work[p] * WorkHours_p[p] +
                                DelayRate_p_nowork[p] * (Duration_p[p] - WorkHours_p[p])
                                for p in periods)
total_project_delay = T_project_days * daily_delay_expr
model.setObjective(total_project_delay, GRB.MINIMIZE)

# --- Optimize ---
model.optimize()

# --- Output ---
print("\n--- Optimization Results ---")
if model.status == GRB.OPTIMAL:
    print(f"Optimization Status: Optimal")
    print(f"Minimum Total Delay Proxy (Sum of hourly queue growth * duration): {model.objVal:.2f}")
    print(f"\nOptimal Work Schedule (Hours per Day):")
    total_hours_sched = 0
    for p in periods:
        print(f"  Period {p} ({Duration_p[p]}h total): Work for {WorkHours_p[p].X:.2f} hours")
        total_hours_sched += WorkHours_p[p].X
    print(f"  Total scheduled work hours per day: {total_hours_sched:.2f} (Target={WorkHoursPerDay:.2f})")

elif model.status == GRB.INFEASIBLE:
    print("Optimization Status: Model is infeasible")
    model.computeIIS()
    model.write("model_iis.ilp")
    print("IIS written to model_iis.ilp")
else:
    print(f"Optimization Status Code: {model.status}")
```
Answer:
--- Delay Rate Calculation (Ships Queued per Hour) ---
 Period Morning: Work Delay Rate = 2366.4 ships/h, No Work Delay Rate = 0.0 ships/h
 Period Afternoon: Work Delay Rate = 200.6 ships/h, No Work Delay Rate = 0.0 ships/h
 Period Night: Work Delay Rate = 0.0 ships/h, No Work Delay Rate = 0.0 ships/h
Restricted license - for non-production use only - expires 2026-11-23
Gurobi Optimizer version 12.0.1 build v12.0.1rc0 (linux64 - "Ubuntu 20.04.4 LTS")

CPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]
Thread count: 255 physical cores, 255 logical processors, using up to 32 threads

Optimize a model with 4 rows, 3 columns and 6 nonzeros
Model fingerprint: 0xbf94975d
Coefficient statistics:
  Matrix range     [1e+00, 1e+00]
  Objective range  [6e+02, 7e+03]
  Bounds range     [0e+00, 0e+00]
  RHS range        [5e+00, 1e+01]
Presolve removed 4 rows and 3 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    0.0000000e+00   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds (0.00 work units)
Optimal objective  0.000000000e+00

--- Optimization Results ---
Optimization Status: Optimal
Minimum Total Delay Proxy (Sum of hourly queue growth * duration): 0.00

Optimal Work Schedule (Hours per Day):
  Period Morning (5.424346854019509h total): Work for 0.00 hours
  Period Afternoon (6.067327360078881h total): Work for 0.00 hours
  Period Night (11.016836862882794h total): Work for 6.71 hours
  Total scheduled work hours per day: 6.71 (Target=6.71)



================================================================================



--- Problem 496 ---
**Difficulty:** hard
**Category:** LP

**Problem Description:**
**
A regional logistics company operates a centralized hub that coordinates shipments between five production facilities (Src_A to Src_E) and three retail distribution centers (Dst_X to Dst_Z). Each production facility has a fixed supply capacity, ranging from 104 units at Src_D to 490 units at Src_C, while the distribution centers have strict demand requirements (82, 181, and 337 units, respectively). Transportation costs vary significantly: moving goods to the hub costs between $5 (Src_D) and $14 (Src_B) per unit, while hub-to-destination costs are cheaper but uneven ($1 to Dst_X, $2 to Dst_Y, and $8 to Dst_Z). Additionally, due to recent weather conditions, the company must ensure that all shipments are completed within a 48-hour window. The hub acts as a consolidation point, requiring all inbound shipments from sources to exactly match outbound flows to destinations—no storage is allowed. With tight margins, the company must determine the most cost-effective flow of goods that respects supply limits, meets all demand, and balances hub throughput. The critical question: *How should shipments be routed through the hub to minimize total transportation costs while satisfying all operational constraints?*  

---

**

**Modeling Process:**
**
**1. Decision Variables:**  
- `flow[(i, j)]`: Continuous non-negative variable representing units shipped from location `i` to `j`, where `i` is either a source or the hub, and `j` is either the hub or a destination.  

**2. Parameters:**  
- **Supply:** `supply[s]` for each source `s` (e.g., `supply['Src_A'] = 162`).  
- **Demand:** `demand[d]` for each destination `d` (e.g., `demand['Dst_X'] = 82`).  
- **Costs:** `costs[(i, j)]` (e.g., `costs[('Src_C', 'Hub')] = 9`).  

**3. Objective Function:**  
Minimize total cost:  
```
Minimize: sum(flow[(i, j)] * costs[(i, j)] for all (i, j) in routes)
```

**4. Constraints:**  
- **Supply limits:** For each source `s`, `flow[(s, 'Hub')] <= supply[s]`.  
- **Demand satisfaction:** For each destination `d`, `flow[('Hub', d)] >= demand[d]`.  
- **Hub balance:** Total inflow to hub = total outflow:  
  `sum(flow[(s, 'Hub')] for all sources s) = sum(flow[('Hub', d)] for all destinations d)`.  
- **Time constraint:** All shipments must be completed within a 48-hour window. This constraint does not affect the optimization model and is only for context.

---

**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
sources = ['Src_A', 'Src_B', 'Src_C', 'Src_D', 'Src_E']
destinations = ['Dst_X', 'Dst_Y', 'Dst_Z']
hub = 'Hub' # Use !r for repr() to keep quotes for the string
supply = {'Src_A': 162, 'Src_B': 450, 'Src_C': 490, 'Src_D': 104, 'Src_E': 197}
demand = {'Dst_X': 82, 'Dst_Y': 181, 'Dst_Z': 337}
costs = {('Src_A', 'Hub'): 11, ('Src_B', 'Hub'): 14, ('Src_C', 'Hub'): 9, ('Src_D', 'Hub'): 5, ('Src_E', 'Hub'): 11, ('Hub', 'Dst_X'): 1, ('Hub', 'Dst_Y'): 2, ('Hub', 'Dst_Z'): 8}
# --- End Parameters ---

GUROBI_TIME_LIMIT = 60

# --- Global Results Dictionary ---
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None # Default status

# --- Model ---
try:
    # --- Environment Setup ---
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi console output within exec
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()

    # --- Model Creation ---
    m25 = gp.Model("Logistics_Hub_Flow_LP", env=env)

    # --- Decision Variables ---
    # Flow variables for each arc
    flow_keys = list(costs.keys()) # Explicitly get keys for var creation
    flow = m25.addVars(flow_keys, name="flow", lb=0) # LP variables default to continuous

    # --- Objective Function ---
    # Minimize total transportation cost
    m25.setObjective(gp.quicksum(flow[i, j] * costs[i, j] for i, j in flow_keys), sense=GRB.MINIMIZE)

    # --- Constraints ---
    # Supply constraints at sources
    for s in sources:
        # Ensure the key exists before adding constraint
        arc_key = (s, hub)
        if arc_key in flow:
            # Use string concatenation for name to avoid f-string formatting issues here
            m25.addConstr(flow[arc_key] <= supply[s], name="supply_" + s)
        # No else needed, if arc doesn't exist, can't use it

    # Demand constraints at destinations
    for d in destinations:
         # Ensure the key exists before adding constraint
         arc_key = (hub, d)
         if arc_key in flow:
            # Use string concatenation for name
            m25.addConstr(flow[arc_key] >= demand[d], name="demand_" + d)
         # No else needed

    # Flow balance at the Hub (Inflow = Outflow)
    # Check if keys exist before summing
    inflow_keys_hub = [k for k in flow_keys if k[1] == hub and k[0] in sources]
    outflow_keys_hub = [k for k in flow_keys if k[0] == hub and k[1] in destinations]

    # Check if lists are non-empty before creating expressions that might be empty
    inflow_hub_expr = gp.quicksum(flow[k] for k in inflow_keys_hub) if inflow_keys_hub else 0
    outflow_hub_expr = gp.quicksum(flow[k] for k in outflow_keys_hub) if outflow_keys_hub else 0
    m25.addConstr(inflow_hub_expr == outflow_hub_expr, name="hub_balance")

    # --- Optimization ---
    m25.optimize()

    # --- Store results ---
    results_dict['status'] = m25.status
    if m25.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m25.objVal
        # Store flow values, converting keys back to tuples if needed
        results_dict['flow_sol'] = {k: v for k, v in m25.getAttr('X', flow).items()}
        # Store expression values IF they are LinExpr (might be 0 if no flows)
        results_dict['inflow_val'] = inflow_hub_expr.getValue() if isinstance(inflow_hub_expr, gp.LinExpr) else inflow_hub_expr
        results_dict['outflow_val'] = outflow_hub_expr.getValue() if isinstance(outflow_hub_expr, gp.LinExpr) else outflow_hub_expr


    # --- Output Results ---
    # IMPORTANT: Escape all { } intended for the final print f-strings!
    print("--- Problem 25: Logistics Hub Truck Flow (LP) ---")
    if m25.status == GRB.OPTIMAL:
        flow_sol = results_dict.get('flow_sol', {}) # Get solution from dict
        print(f"Optimization Status: Optimal")
        # Use .get with a default for obj_val before formatting
        obj_val_print = results_dict.get('obj_val', 0) # Default to 0 if not found
        print(f"Minimum Total Transportation Cost: ${obj_val_print:.2f}")
        print("Optimal Flows:")
        total_supply_used_calc = 0
        total_demand_met_calc = 0
        # Use .items() for iterating through solution dictionary
        for (i, j), flow_val in flow_sol.items():
            if flow_val > 1e-6: # Print only non-negligible flows
                # Escape i, j, flow_val and braces for costs.get()
                print(f"  Flow from {i} to {j}: {flow_val:.1f} units (Cost/Unit: ${costs.get((i,j), 'N/A')})")
                if i in sources: total_supply_used_calc += flow_val
                if j in destinations: total_demand_met_calc += flow_val

        print("\nSummary:")
        # Use .get with defaults for calculated values before formatting
        inflow_print = results_dict.get('inflow_val', 0)
        outflow_print = results_dict.get('outflow_val', 0)
        # Ensure inflow/outflow values are numbers before formatting
        print(f"Total Flow In Hub: {float(inflow_print):.1f}")
        print(f"Total Flow Out Hub: {float(outflow_print):.1f}")
        # Re-calculate supply/demand usage from solution dict for detailed output
        for s in sources:
             flow_out = flow_sol.get((s, hub), 0)
             # Escape s, flow_out and braces for supply.get()
             print(f"  Supply from {s}: {flow_out:.1f} / {supply.get(s, 'N/A')}")
        for d in destinations:
             flow_in = flow_sol.get((hub, d), 0)
             # Escape d, flow_in and braces for demand.get()
             print(f"  Demand met for {d}: {flow_in:.1f} / {demand.get(d, 'N/A')}")

    elif m25.status == GRB.INFEASIBLE:
         print(f"Optimization Status: Infeasible. Check if total supply >= total demand.")
         # Calculate totals directly from input params for this message
         # Escape braces for sum() values
         print(f"Total Supply Available: {sum(supply.values())}")
         print(f"Total Demand Required: {sum(demand.values())}")
    elif m25.status == GRB.TIME_LIMIT:
         print(f"Optimization Status: Time Limit Reached ({GUROBI_TIME_LIMIT}s)") # Escape limit
         # If objective value exists (feasible solution found before limit), print it
         if m25.ObjVal is not None and abs(m25.ObjVal) < float('inf'):
              # Escape objval
              print(f"Best Objective Found: ${m25.ObjVal:.2f}")
         else:
              print("No feasible solution found within time limit.")
    else:
        # Handle other statuses like UNBOUNDED, INF_OR_UNBD etc.
        print(f"Optimization Status Code: {m25.status}") # Escape status

except GurobiError as e:
    # Escape errno and e message
    print(f"Gurobi Error {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
except Exception as e:
    print(f"Python Error: {e}") # Escape error message
    print("--- Traceback ---")
    traceback.print_exc(file=sys.stdout)
    print("--- End Traceback ---")
    results_dict['status'] = -2 # Indicate Python execution error



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
--- Problem 25: Logistics Hub Truck Flow (LP) ---
Optimization Status: Optimal
Minimum Total Transportation Cost: $8136.00
Optimal Flows:
  Flow from Src_C to Hub: 490.0 units (Cost/Unit: $9)
  Flow from Src_D to Hub: 104.0 units (Cost/Unit: $5)
  Flow from Src_E to Hub: 6.0 units (Cost/Unit: $11)
  Flow from Hub to Dst_X: 82.0 units (Cost/Unit: $1)
  Flow from Hub to Dst_Y: 181.0 units (Cost/Unit: $2)
  Flow from Hub to Dst_Z: 337.0 units (Cost/Unit: $8)

Summary:
Total Flow In Hub: 600.0
Total Flow Out Hub: 600.0
  Supply from Src_A: 0.0 / 162
  Supply from Src_B: 0.0 / 450
  Supply from Src_C: 490.0 / 490
  Supply from Src_D: 104.0 / 104
  Supply from Src_E: 6.0 / 197
  Demand met for Dst_X: 82.0 / 82
  Demand met for Dst_Y: 181.0 / 181
  Demand met for Dst_Z: 337.0 / 337


```

================================================================================



--- Problem 497 ---
**Difficulty:** medium
**Category:** MIP

**Problem Description:**
A logistics company operates a fleet of two trucks to serve three locations: a central depot (Node 0) and two customer sites (Nodes 1 and 2). The depot acts as the starting and ending point for all routes. Each truck has a limited capacity—Truck 1 can carry up to 30 units, while Truck 2 can handle 80 units. The customer demands are specific: Node 1 requires 15 units, and Node 2 demands 75 units. Travel distances between nodes are asymmetric; for instance, the trip from the depot to Node 1 spans 25 units, while the return journey covers the same distance. The challenge is to assign routes to the trucks such that every customer is visited exactly once, capacities are respected, and the total distance traveled is minimized. The stakes are high—efficient routing reduces fuel costs and ensures timely deliveries. The core question: *What is the optimal assignment of routes to trucks to achieve the shortest total travel distance while meeting all operational constraints?*

**Modeling Process:**
**
**1. Decision Variables:**  
    - Binary variable \(x_{ijk}\): Equals 1 if truck \(k\) travels directly from node \(i\) to node \(j\); 0 otherwise.  
    - Continuous variable \(u_i\) (for subtour elimination): Represents the position of node \(i\) in the route (MTZ formulation).  

    **2. Parameters:**  
    - \(N = 3\): Total nodes (depot + 2 customers).  
    - \(K = 2\): Number of trucks.  
    - \(Q = [30, 80]\): Truck capacities.  
    - \(q = [0, 15, 75]\): Demand at each node (depot has 0 demand).  
    - \(d\): Distance matrix (e.g., \(d_{01} = 25\)).  

    **3. Objective Function:**  
    Minimize the total distance traveled by all trucks:  
    \[
    \text{Minimize: } \sum_{k=0}^{1} \sum_{i=0}^{2} \sum_{j=0}^{2} d_{ij} \cdot x_{ijk} \quad (i \neq j)
    \]  

    **4. Constraints:**  
    - **Visit each customer once:** \(\sum_{k=0}^{1} \sum_{j=0}^{2} x_{ijk} = 1\) for \(i = 1, 2\).  
    - **Flow conservation:** \(\sum_{j=0}^{2} x_{ijk} = \sum_{j=0}^{2} x_{jik}\) for all \(i, k\).  
    - **Depot departure/return:** Each truck leaves and returns to the depot at most once.  
    - **Capacity:** \(\sum_{j=1}^{2} q_j \cdot \sum_{i=0}^{2} x_{ijk} \leq Q_k\) for each truck \(k\).  
    - **Subtour elimination (MTZ):** \(u_i - u_j + (N-1) \cdot x_{ijk} \leq N-2\) for \(i, j \geq 1, i \neq j\).  
**

**Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, quicksum
import sys

# --- Data Definition ---
N = 3
K = 2
Q = [30, 80]
q = [0, 15, 75]
d = [
    [0, 25, 18],
    [25, 0, 57],
    [18, 57, 0]
]
# --- End Data Definition ---

# Dictionary to store results (passed from calling script)
if 'results_dict' not in globals():
    results_dict = {} # Define if not passed (fallback)

results_dict['status'] = None # Default status

# Suppress Gurobi console output for cleaner logs
env = gp.Env(empty=True)
env.setParam('OutputFlag', 0)
# Optional: Set time limit if some instances take too long
# env.setParam('TimeLimit', 60) # e.g., 60 seconds
env.start()

# Create model using the environment
model = Model("VRP", env=env)

# --- Decision Variables ---
x = {}
for k in range(K):
    for i in range(N):
        for j in range(N):
            if i != j:
                x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f"x_{i}_{j}_{k}")

u = {}
# Define u only if N > 1 (MTZ requires customer nodes)
if N > 1:
    for i in range(1, N):
        u[i] = model.addVar(vtype=GRB.CONTINUOUS, lb=1, ub=N-1, name=f"u_{i}")
else:
    pass

model.update()

# --- Objective Function: Minimize Total Distance ---
if N > 1:
    model.setObjective(
        quicksum(d[i][j] * x[i, j, k] for k in range(K) for i in range(N) for j in range(N) if i != j),
        GRB.MINIMIZE
    )
else:
     model.setObjective(0, GRB.MINIMIZE) # Trivial objective

# --- Constraints ---
if N >= 2 and K >= 1:
    # 1. Each customer (nodes 1 to N-1) is visited exactly once
    for i in range(1, N):
        model.addConstr(
            quicksum(x[i, j, k] for k in range(K) for j in range(N) if i != j) == 1,
            name=f"VisitOnce_{i}"
        )

    # 2. Flow Conservation
    for k in range(K):
        for i in range(N):
            model.addConstr(
                quicksum(x[i, j, k] for j in range(N) if i != j) ==
                quicksum(x[j, i, k] for j in range(N) if i != j),
                name=f"FlowCons_{i}_{k}"
            )

    # 3. Vehicle Departure/Return from Depot (Node 0)
    for k in range(K):
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) <= 1, name=f"DepartDepot_{k}")
        model.addConstr(quicksum(x[0, j, k] for j in range(1, N)) == quicksum(x[j, 0, k] for j in range(1, N)), name=f"ReturnDepot_{k}")

    # 4. Capacity Constraint
    for k in range(K):
        model.addConstr(
            quicksum(q[j] * quicksum(x[i, j, k] for i in range(N) if i != j) for j in range(1, N)) <= Q[k],
            name=f"Capacity_{k}"
        )

    # 5. MTZ Subtour Elimination (only needed if N > 2)
    if N > 2:
        for k in range(K):
            for i in range(1, N):
                for j in range(1, N):
                    if i != j:
                         model.addConstr(u[i] - u[j] + (N - 1) * x[i, j, k] <= N - 2, name=f"MTZ_{i}_{j}_{k}")

# --- Solve ---
print("Solving VRP instance...")
try:
    model.optimize()
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.ObjVal
    else:
        results_dict['obj_val'] = None

except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1 # Indicate Gurobi error
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected error occurred during optimization: {e}")
    results_dict['status'] = -2 # Indicate other Python error
    results_dict['error_message'] = f"Optimization Error: {e}"

# --- Output Results (if optimal) ---
if results_dict.get('status') == GRB.OPTIMAL:
    print("\nOptimal solution found!")
    print(f"Total distance: {results_dict.get('obj_val', 'N/A'):.2f}")
    routes = {}
    for k_sol in range(K):
        depart_sum = sum(x[0, j, k_sol].X for j in range(1, N) if (0, j, k_sol) in x and x[0, j, k_sol].X > 0.5)
        if depart_sum > 0.5:
            route_edges = []
            current_node = 0
            path_str = "0"
            visited_count = 0
            max_visits = N + 1

            while visited_count < max_visits:
                found_next = False
                for j_sol in range(N):
                    if current_node != j_sol and (current_node, j_sol, k_sol) in x and x[current_node, j_sol, k_sol].X > 0.5:
                       route_edges.append((current_node, j_sol))
                       path_str += f" -> {j_sol}"
                       current_node = j_sol
                       found_next = True
                       break
                visited_count += 1
                if not found_next or current_node == 0 or visited_count >= max_visits :
                    break

            if visited_count >= max_visits and current_node != 0:
                 print(f"\nWarning: Route reconstruction for truck {k_sol+1} might be incomplete. Edges found:")
                 print(route_edges)
            elif route_edges:
                 print(f"\nRoute for truck {k_sol+1} (Capacity: {Q[k_sol]}):")
                 print(path_str)
                 load = sum(q[node_idx] for _, node_idx in route_edges if node_idx != 0)
                 print(f"Route Load: {load} / {Q[k_sol]}")

elif results_dict.get('status') == GRB.INFEASIBLE:
    print("\nModel is infeasible. No solution found.")
elif results_dict.get('status') == GRB.UNBOUNDED:
    print("\nModel is unbounded.")
elif results_dict.get('status') == GRB.TIME_LIMIT:
     print("\nOptimization stopped due to time limit. Best objective found: {model.ObjVal if model.SolCount > 0 else 'N/A'}")
elif results_dict.get('status') is not None:
    print(f"\nOptimization ended with status code {results_dict['status']}. No optimal solution found.")
else:
    print(f"\nOptimization did not complete successfully. Error: {results_dict.get('error_message', 'Unknown error')}")



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Solving VRP instance...

Optimal solution found!
Total distance: 86.00

Route for truck 1 (Capacity: 30):
0 -> 1 -> 0
Route Load: 15 / 30

Route for truck 2 (Capacity: 80):
0 -> 2 -> 0
Route Load: 75 / 80


```

================================================================================



--- Problem 498 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling incoming trucks to minimize the number of depots used while adhering to strict scheduling constraints. Seven trucks, labeled 1 through 7, arrive at staggered times: Truck 1 at time 3, Truck 2 at time 6, and so on, with the latest arrival being Truck 7 at time 23. Each truck requires a specific processing time for unloading and loading, ranging from 3 to 7 time units. The hub has five potential depots available, but activating each one incurs operational costs. The central question is: *What is the minimum number of depots needed to service all trucks without overlaps, ensuring no truck starts before its arrival time and all processing times are respected?*
**

**Modeling Process:**
**
- **1. Decision Variables:**  
     - `assign(i, j)`: Binary (0 or 1) indicating whether truck *i* is assigned to depot *j*.  
     - `start_time(i)`: Continuous variable for the time truck *i* begins service.  
     - `completion_time(i)`: Continuous variable for the time truck *i* finishes (start_time + processing_time).  
     - `precedes(i, k, j)`: Binary (0 or 1) indicating if truck *i* is scheduled before truck *k* on depot *j*.  
     - `depot_used(j)`: Binary (0 or 1) indicating whether depot *j* is activated.  

   - **2. Parameters:**  
     - `arrival_times[i]`: Time truck *i* arrives (e.g., Truck 1 arrives at 3).  
     - `processing_times[i]`: Time required to service truck *i* (e.g., Truck 1 needs 5 units).  
     - `H = 100`: A large constant ("Big M") for precedence constraints.  

   - **3. Objective Function:**  
     Minimize the total number of depots used:  
     `Minimize: sum(depot_used[j] for all depots j)`.  

   - **4. Constraints:**  
     - Each truck is assigned to exactly one depot: `sum(assign[i, j] for all j) = 1` for all trucks *i*.  
     - Trucks cannot start before arrival: `start_time[i] >= arrival_times[i]` for all *i*.  
     - Completion time definition: `completion_time[i] = start_time[i] + processing_times[i]` for all *i*.  
     - Non-overlapping on the same depot: For each depot *j* and trucks *i*, *k* (*i < k*), enforce either `precedes[i, k, j]` (truck *i* before *k*) or `precedes[k, i, j]` (truck *k* before *i*), with corresponding start time constraints.  
     - Link depot usage: `assign[i, j] <= depot_used[j]` for all *i*, *j*.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7]
depots = [1, 2, 3, 4, 5]
arrival_times = {1: 3, 2: 6, 3: 10, 4: 11, 5: 16, 6: 19, 7: 23}
processing_times = {1: 5, 2: 7, 3: 7, 4: 5, 5: 3, 6: 5, 7: 3}
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM_52_MIN_DEPOTS")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars(trucks, trucks, depots, vtype=GRB.BINARY, name="precedes")
    depot_used = m.addVars(depots, vtype=GRB.BINARY, name="DepotUsed") # Objective var

    # --- Objective Function ---
    m.setObjective(gp.quicksum(depot_used[j] for j in depots), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] >= assign[i,j] + assign[k,j] - 1, name=f"force_precedence_{i}_{k}_{j}")
                    m.addConstr(precedes[i,k,j] + precedes[k,i,j] <= 1, name=f"mutual_exclusion_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[i,k,j], True, start_time[k] >= completion_time[i], name=f"overlap_{i}_{k}_{j}")
                    m.addGenConstrIndicator(precedes[k,i,j], True, start_time[i] >= completion_time[k], name=f"overlap_{k}_{i}_{j}")

    # 5. Link DepotUsed to assignments
    m.addConstrs((assign[i, j] <= depot_used[j] for i in trucks for j in depots), name="link_used_depot")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             # Objective is number of depots, should be integer
             print(f"{int(round(obj_val_print))}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    print(f"Minimum number of depots used: {int(round(results_dict['obj_val']))}")
    
    # Print the assignment of trucks to depots
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
    
    # Print start and completion times for each truck
    for i in trucks:
        print(f"Truck {i} - Start Time: {start_time[i].x}, Completion Time: {completion_time[i].x}")
    
    # Print which depots are used
    for j in depots:
        if depot_used[j].x > 0.5:
            print(f"Depot {j} is used")
else:
    print(f"Optimization ended with status {m.status}")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
1
Optimal Solution Found:
Minimum number of depots used: 1
Truck 1 is assigned to Depot 5
Truck 2 is assigned to Depot 5
Truck 3 is assigned to Depot 5
Truck 4 is assigned to Depot 5
Truck 5 is assigned to Depot 5
Truck 6 is assigned to Depot 5
Truck 7 is assigned to Depot 5
Truck 1 - Start Time: 53.0, Completion Time: 58.0
Truck 2 - Start Time: 46.0, Completion Time: 53.0
Truck 3 - Start Time: 39.0, Completion Time: 46.0
Truck 4 - Start Time: 34.0, Completion Time: 39.0
Truck 5 - Start Time: 31.0, Completion Time: 34.0
Truck 6 - Start Time: 26.0, Completion Time: 31.0
Truck 7 - Start Time: 23.0, Completion Time: 26.0
Depot 5 is used


```

================================================================================



--- Problem 499 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A busy logistics hub faces the challenge of efficiently scheduling seven incoming trucks across three available depots. Each truck arrives at a specific time: Truck 1 at time 2, Truck 2 at time 6, Truck 3 at time 9, and so on, with Truck 7 arriving at time 13. The processing times vary significantly—Truck 4 and Truck 7 require 8 hours each, while Truck 2 and Truck 6 need only 3 hours. A critical operational rule mandates that Trucks 1, 3, and 5 must all be processed at the *same* depot, adding a layer of complexity to the scheduling puzzle. The logistics hub aims to minimize the total waiting time—the delay between a truck's arrival and when it actually starts being processed—across all trucks. Given the tight depot availability and the group constraint, the central question is: *How can the trucks be assigned to depots to ensure the smallest possible cumulative waiting time while respecting all operational rules?*
**

**Modeling Process:**
**
**1. Decision Variables:**  
   - `assign(i, j)`: Binary variable (1 if truck *i* is assigned to depot *j*, 0 otherwise).  
   - `start_time(i)`: Continuous variable representing when truck *i* begins processing.  
   - `completion_time(i)`: Continuous variable representing when truck *i* finishes processing.  
   - `precedes(i, k, j)`: Binary variable (1 if truck *i* is processed before truck *k* on depot *j*, 0 otherwise).  
   - `group_depot(j)`: Binary variable (1 if depot *j* is selected for the group of trucks [1, 3, 5], 0 otherwise).  

   **2. Parameters:**  
   - `trucks = [1, 2, 3, 4, 5, 6, 7]`, `depots = [1, 2, 3]`.  
   - `arrival_times`: {1: 2, 2: 6, ..., 7: 13}.  
   - `processing_times`: {1: 4, 2: 3, ..., 7: 8}.  
   - `group_A_trucks = [1, 3, 5]`.  
   - `H = 100` (a large constant for logical constraints).  

   **3. Objective Function:**  
   Minimize the total waiting time:  
   `Minimize: sum(start_time[i] - arrival_times[i] for all trucks i)`.  

   **4. Constraints:**  
   - **Assignment:** Each truck must be assigned to exactly one depot:  
     `sum(assign(i, j) for all j) = 1` for each truck *i*.  
   - **Arrival Time:** A truck cannot start before it arrives:  
     `start_time[i] >= arrival_times[i]` for each truck *i*.  
   - **Completion Time:** Processing ends at start time plus processing time:  
     `completion_time[i] = start_time[i] + processing_times[i]` for each truck *i*.  
   - **Non-Overlapping:** If two trucks *i* and *k* share a depot *j*, one must precede the other:  
     If `precedes(i, k, j) = 1`, then `start_time[k] >= completion_time[i]`.  
     If `precedes(i, k, j) = 0`, then `start_time[i] >= completion_time[k]`.  
   - **Group Constraint:** Trucks 1, 3, and 5 must share a single depot:  
     `sum(group_depot[j] for all j) = 1`, and for each truck *i* in the group, `assign(i, j) <= group_depot[j]`.  
**

**Corresponding Code:**
```python
import gurobipy as gp; from gurobipy import Model, GRB, GurobiError; import sys; import traceback; import math

# --- Parameters ---
trucks = [1, 2, 3, 4, 5, 6, 7]
depots = [1, 2, 3]
arrival_times = {1: 2, 2: 6, 3: 9, 4: 10, 5: 11, 6: 12, 7: 13}
processing_times = {1: 4, 2: 3, 3: 4, 4: 8, 5: 6, 6: 3, 7: 8}
group_A_trucks = [3, 5, 1] # Trucks that must use the same depot
H = 100 # Big M
# --- End Parameters ---

global results_dict
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

try:
    # --- Model Creation ---
    m = gp.Model("DEPOT_SCHEDULING_PROBLEM")

    if not trucks or not depots: raise ValueError("Empty trucks or depots")
    # if not group_A_trucks: print("Warning: group_A_trucks is empty") # Allow empty group

    # --- Decision Variables ---
    assign = m.addVars(trucks, depots, vtype=GRB.BINARY, name="assign")
    start_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="start")
    completion_time = m.addVars(trucks, lb=0.0, vtype=GRB.CONTINUOUS, name="completion")
    precedes = m.addVars([(i, k, j) for i in trucks for k in trucks if i < k for j in depots],
                         vtype=GRB.BINARY, name="precedes")
    group_depot = m.addVars(depots, vtype=GRB.BINARY, name="group_depot")

    # --- Objective Function ---
    m.setObjective(gp.quicksum(start_time[i] - arrival_times.get(i, 0) for i in trucks), GRB.MINIMIZE)

    # --- Constraints ---
    # 1. Assignment
    m.addConstrs((assign.sum(i, '*') == 1 for i in trucks), name="assignment")
    # 2. Arrival time
    m.addConstrs((start_time[i] >= arrival_times.get(i, 0) for i in trucks), name="arrival_time")
    # 3. Completion time
    m.addConstrs((completion_time[i] == start_time[i] + processing_times.get(i, 0) for i in trucks), name="completion_time")
    # 4. Non-overlapping using Indicator constraints
    for j in depots:
        for i in trucks:
            for k in trucks:
                if i < k:
                    m.addConstr( (precedes[i,k,j] == 1) >> (start_time[k] >= completion_time[i]), name=f"overlap_{i}_{k}_{j}" )
                    m.addConstr( (precedes[i,k,j] == 0) >> (start_time[i] >= completion_time[k]), name=f"overlap_{k}_{i}_{j}" )
                    m.addConstr(assign[i,j] + assign[k,j] - 1 <= precedes[i,k,j] + (1 - precedes[i,k,j]))
    # 5. Group Constraint
    if group_A_trucks:
        m.addConstr(group_depot.sum('*') == 1, name="one_group_depot")
        for i in group_A_trucks:
            for j in depots:
                m.addConstr(assign[i, j] <= group_depot[j], name=f"group_A_assign_{i}_{j}")

    # --- Optimization ---
    m.Params.OutputFlag = 0
    m.optimize()

    results_dict['status'] = m.status
    if m.status == GRB.OPTIMAL:
        results_dict['obj_val'] = m.objVal

    # --- Output ---
    if m.status == GRB.OPTIMAL:
        obj_val_print = results_dict.get('obj_val', 'N/A')
        if isinstance(obj_val_print, (int, float)):
             print(f"{obj_val_print:.4f}")
        else:
             print(f"{obj_val_print}")
    elif m.status == GRB.INFEASIBLE:
        print("Infeasible")
    elif m.status == GRB.UNBOUNDED:
        print("Unbounded")
    else:
        print(f"Optimization ended with status {m.status}")

except ValueError as ve:
    print(f"Input Data Error: {ve}")
    results_dict['status'] = -3
except gp.GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
except Exception as e:
    print(f"Python Error: {e}")
    traceback.print_exc(file=sys.stdout)
    results_dict['status'] = -4



# --- Supplemental Code Block ---
if m.status == GRB.OPTIMAL:
    print("Optimal Solution Found:")
    for i in trucks:
        for j in depots:
            if assign[i, j].x > 0.5:
                print(f"Truck {i} is assigned to Depot {j}")
    for i in trucks:
        print(f"Truck {i} start time: {start_time[i].x:.4f}, completion time: {completion_time[i].x:.4f}")
    print(f"Total waiting time: {results_dict['obj_val']:.4f}")
else:
    print("No optimal solution found.")
```
Answer:
Restricted license - for non-production use only - expires 2026-11-23
35.0000
Optimal Solution Found:
Truck 1 is assigned to Depot 1
Truck 2 is assigned to Depot 1
Truck 3 is assigned to Depot 1
Truck 4 is assigned to Depot 1
Truck 5 is assigned to Depot 1
Truck 6 is assigned to Depot 1
Truck 7 is assigned to Depot 1
Truck 1 start time: 2.0000, completion time: 6.0000
Truck 2 start time: 6.0000, completion time: 9.0000
Truck 3 start time: 9.0000, completion time: 13.0000
Truck 4 start time: 22.0000, completion time: 30.0000
Truck 5 start time: 16.0000, completion time: 22.0000
Truck 6 start time: 13.0000, completion time: 16.0000
Truck 7 start time: 30.0000, completion time: 38.0000
Total waiting time: 35.0000


```

================================================================================



--- Problem 500 ---
**Difficulty:** hard
**Category:** MIP

**Problem Description:**
**
A logistics company is tasked with loading a collection of 24 valuable items into a limited number of trucks for delivery. Each item has a specific weight and value, and the trucks have a strict weight capacity of 44 units. The company can use up to 7 trucks, and the goal is to maximize the total value of the items loaded while ensuring no truck exceeds its weight limit.  

The items vary significantly in weight and value—some are heavy but highly valuable (like item 2 at 38 weight and 40 value), while others are lightweight but extremely valuable (like item 13 at 7 weight and 58 value). The challenge is to strategically assign items to trucks so that the sum of their values is as high as possible, without overloading any truck or exceeding the truck limit.  

The central question is: **What is the optimal way to load these items to achieve the highest possible total value while respecting all constraints?**  

---
**

Modeling Process:**
**
**1. Decision Variables:**  
- Binary variable \(x_{i,j}\): Equals 1 if item \(i\) is placed in truck \(j\), and 0 otherwise.  
- Binary variable \(y_j\): Equals 1 if truck \(j\) is used (contains at least one item), and 0 otherwise.  

**2. Parameters:**  
- \(w_i\): Weight of item \(i\) (e.g., \(w_0 = 16\), \(w_1 = 38\), etc.).  
- \(v_i\): Value of item \(i\) (e.g., \(v_0 = 99\), \(v_1 = 40\), etc.).  
- \(C = 44\): Maximum weight capacity per truck.  
- \(N = 7\): Maximum number of available trucks.  

**3. Objective Function:**  
Maximize the total value of loaded items:  
\[
\text{Maximize: } \sum_{i=0}^{23} \sum_{j=0}^{6} v_i \cdot x_{i,j}
\]

**4. Constraints:**  
- **Truck Weight Limit:** For each truck \(j\), the total weight of items assigned must not exceed its capacity:  
  \[
  \sum_{i=0}^{23} w_i \cdot x_{i,j} \leq C \cdot y_j \quad \forall j \in \{0, 1, \dots, 6\}
  \]  
- **Item-Truck Link:** If an item is placed in a truck, that truck must be marked as used:  
  \[
  x_{i,j} \leq y_j \quad \forall i \in \{0, 1, \dots, 23\}, \forall j \in \{0, 1, \dots, 6\}
  \]  
- **Item Assignment:** Each item can be placed in at most one truck:  
  \[
  \sum_{j=0}^{6} x_{i,j} \leq 1 \quad \forall i \in \{0, 1, \dots, 23\}
  \]  

---

Corresponding Code:**
```python
import gurobipy as gp
from gurobipy import Model, GRB, GurobiError
import sys
import traceback

# --- Data Definition (Embedded) ---
items = [(16, 99), (38, 40), (39, 100), (30, 1), (33, 35), (30, 30), (15, 98), (41, 29), (26, 16), (19, 47), (30, 55), (28, 21), (7, 58), (6, 74), (12, 23), (28, 88), (35, 35), (16, 3), (31, 31), (14, 76), (41, 98), (43, 62), (11, 4), (17, 51)]          # List of (weight, value) tuples
truck_capacity = 44      # Maximum weight per truck
num_trucks = 7          # Maximum number of available trucks (parameter)
num_items = 24          # len(items) derived correctly
# --- End Data Definition ---

GUROBI_TIME_LIMIT = 60 # Time limit parameter

# Dictionary for results
if 'results_dict' not in globals(): results_dict = {}
results_dict['status'] = None

# Create model
try:
    env = gp.Env(empty=True)
    env.setParam('OutputFlag', 0) # Suppress Gurobi log in captured output
    env.setParam('TimeLimit', GUROBI_TIME_LIMIT)
    env.start()
    model = Model("Max-Value TLP", env=env)

    # --- Decision variables ---
    x = model.addVars(num_items, num_trucks, vtype=GRB.BINARY, name="x")  # x[i, j] -> item i placed in truck j
    y = model.addVars(num_trucks, vtype=GRB.BINARY, name="y")  # y[j] -> truck j is used

    # --- Objective: Maximize total value of selected items ---
    # Sum over all items i and the truck j they are placed in
    model.setObjective(gp.quicksum(items[i][1] * x[i, j] for i in range(num_items) for j in range(num_trucks)), GRB.MAXIMIZE)

    # --- Constraint 1: Truck weight limit ---
    for j in range(num_trucks):
        model.addConstr(gp.quicksum(items[i][0] * x[i, j] for i in range(num_items)) <= truck_capacity * y[j], name=f"Truck_{j}_Weight")

    # --- Constraint 2: If an item is placed in a truck, that truck must be considered used ---
    # (This is often implied by C1 if capacity > 0, but good practice)
    for i in range(num_items):
        for j in range(num_trucks):
            model.addConstr(x[i, j] <= y[j], name=f"Item_{i}_Triggers_Truck_{j}")

    # --- Constraint 3: Each item can be placed in at most one truck ---
    # (Items not placed contribute 0 to objective and constraints)
    for i in range(num_items):
        model.addConstr(x.sum(i, '*') <= 1, name=f"Item_{i}_AtMostOneTruck")

    # --- Solve the model ---
    model.optimize()

    # --- Store results ---
    results_dict['status'] = model.status
    if model.status == GRB.OPTIMAL:
        results_dict['obj_val'] = model.objVal
    elif model.status == GRB.TIME_LIMIT and model.SolCount > 0:
         results_dict['obj_val'] = model.objVal # Best solution found

    # --- Output results (for capture) ---
    if model.status == GRB.OPTIMAL:
        print(f"Optimal total value: {model.objVal:.2f}") # Format value
        print("-" * 30)
        printed_truck_count = 0
        for j in range(num_trucks):
            try:
                 if y[j].x > 0.5:  # Truck is used
                     printed_truck_count += 1
                     assigned_items = [i for i in range(num_items) if x[i, j].x > 0.5]
                     assigned_weights = [items[i][0] for i in assigned_items]
                     truck_load = sum(assigned_weights)
                     print(f"Truck {printed_truck_count} (Index {j}):")
                     print(f"  Load: {truck_load} / {truck_capacity}")
                     print(f"  Items (indices): {sorted(assigned_items)}")
                     # Optional: print item details
                     # print(f"  Items (w,v): {[items[i] for i in sorted(assigned_items)]}")
                     print("-" * 10)
            except AttributeError:
                 pass # Skip trucks not used or if .X missing
    elif model.status == GRB.TIME_LIMIT:
        print(f"\nOptimization stopped due to time limit ({GUROBI_TIME_LIMIT}s).")
        if model.SolCount > 0: print(f"Best objective found: {model.objVal:.2f}")
        else: print("No feasible solution found.")
    elif model.status == GRB.INFEASIBLE:
        print("\nModel is infeasible.") # Should be rare if items fit capacity
    else:
        print(f"\nOptimization finished with status: {model.status}.")


except GurobiError as e:
    print(f"Gurobi Error code {e.errno}: {e}")
    results_dict['status'] = -1
    results_dict['error_message'] = f"Gurobi Error code {e.errno}: {e}"
except Exception as e:
    print(f"An unexpected Python error occurred within model execution:")
    traceback.print_exc(file=sys.stdout)
    if results_dict.get('status') is None: results_dict['status'] = -2
    results_dict['error_message'] = f"Python Error: {e}"



# (Supplemental code block if needed)
# (Leave empty if no additional code is needed)
```
Answer:
Optimal total value: 933.00
------------------------------
Truck 1 (Index 0):
  Load: 44 / 44
  Items (indices): [0, 15]
----------
Truck 2 (Index 1):
  Load: 39 / 44
  Items (indices): [2]
----------
Truck 3 (Index 2):
  Load: 43 / 44
  Items (indices): [21]
----------
Truck 4 (Index 3):
  Load: 44 / 44
  Items (indices): [9, 19, 22]
----------
Truck 5 (Index 4):
  Load: 43 / 44
  Items (indices): [10, 12, 13]
----------
Truck 6 (Index 5):
  Load: 44 / 44
  Items (indices): [6, 14, 23]
----------
Truck 7 (Index 6):
  Load: 41 / 44
  Items (indices): [20]
----------


```

================================================================================


